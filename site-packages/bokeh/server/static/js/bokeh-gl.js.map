{"version":3,"sources":["src/js/plugin-prelude.js","build/js/tree/models/glyphs/webgl/base.js","build/js/tree/models/glyphs/webgl/index.js","build/js/tree/models/glyphs/webgl/line.js","build/js/tree/models/glyphs/webgl/main.js","build/js/tree/models/glyphs/webgl/markers.js","src/vendor/gloo/gloo2.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClWA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bokeh-gl.js","sourcesContent":["(function outer(modules, cache, entry) {\n  if (Bokeh != null) {\n    for (var name in modules) {\n      Bokeh.require.modules[name] = modules[name];\n    }\n\n    for (var i = 0; i < entry.length; i++) {\n      var plugin = Bokeh.require(entry[0]);\n      Bokeh.Models.register_models(plugin.models);\n\n      for (var name in plugin) {\n        if (name !== \"models\") {\n          Bokeh[name] = plugin[name];\n        }\n      }\n    }\n  } else {\n    throw new Error(\"Cannot find Bokeh. You have to load it prior to loading plugins.\");\n  }\n})\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar color_1 = require(\"core/util/color\");\nexports.BaseGLGlyph = (function () {\n    BaseGLGlyph.prototype.GLYPH = '';\n    BaseGLGlyph.prototype.VERT = '';\n    BaseGLGlyph.prototype.FRAG = '';\n    function BaseGLGlyph(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    BaseGLGlyph.prototype.set_data_changed = function (n) {\n        if (n !== this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        return this.data_changed = true;\n    };\n    BaseGLGlyph.prototype.set_visuals_changed = function () {\n        return this.visuals_changed = true;\n    };\n    BaseGLGlyph.prototype.render = function (ctx, indices, mainglyph) {\n        var dx, dy, ref, ref1, ref2, sx, sy, trans, wx, wy;\n        wx = wy = 1;\n        ref = this.glyph.renderer.map_to_screen([0 * wx, 1 * wx, 2 * wx], [0 * wy, 1 * wy, 2 * wy]), dx = ref[0], dy = ref[1];\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12);\n        ref1 = this.glyph.renderer.map_to_screen([0 * wx, 1 * wx, 2 * wx], [0 * wy, 1 * wy, 2 * wy]), dx = ref1[0], dy = ref1[1];\n        if (Math.abs((dx[1] - dx[0]) - (dx[2] - dx[1])) > 1e-6 || Math.abs((dy[1] - dy[0]) - (dy[2] - dy[1])) > 1e-6) {\n            return false;\n        }\n        ref2 = [(dx[1] - dx[0]) / wx, (dy[1] - dy[0]) / wy], sx = ref2[0], sy = ref2[1];\n        trans = {\n            pixel_ratio: ctx.pixel_ratio,\n            width: ctx.glcanvas.width,\n            height: ctx.glcanvas.height,\n            dx: dx[0] / sx,\n            dy: dy[0] / sy,\n            sx: sx,\n            sy: sy\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n    };\n    return BaseGLGlyph;\n})();\nexports.line_width = function (width) {\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n};\nexports.fill_array_with_float = function (n, val) {\n    var a, i, k, ref;\n    a = new Float32Array(n);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        a[i] = val;\n    }\n    return a;\n};\nexports.fill_array_with_vec = function (n, m, val) {\n    var a, i, j, k, l, ref, ref1;\n    a = new Float32Array(n * m);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n};\nexports.visual_prop_is_singular = function (visual, propname) {\n    return visual[propname].spec.value !== void 0;\n};\nexports.attach_float = function (prog, vbo, att_name, n, visual, name) {\n    var a;\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', [0]);\n    }\n    else if (exports.visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', visual[name].value());\n    }\n    else {\n        vbo.used = true;\n        a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'float', vbo);\n    }\n};\nexports.attach_color = function (prog, vbo, att_name, n, visual, prefix) {\n    var a, alphaname, alphas, colorname, colors, i, j, k, l, m, ref, ref1, rgba;\n    m = 4;\n    colorname = prefix + '_color';\n    alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\n    }\n    else if (exports.visual_prop_is_singular(visual, colorname) && exports.visual_prop_is_singular(visual, alphaname)) {\n        vbo.used = false;\n        rgba = color_1.color2rgba(visual[colorname].value(), visual[alphaname].value());\n        return prog.set_attribute(att_name, 'vec4', rgba);\n    }\n    else {\n        vbo.used = true;\n        if (exports.visual_prop_is_singular(visual, colorname)) {\n            colors = (function () {\n                var k, ref, results;\n                results = [];\n                for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    results.push(visual[colorname].value());\n                }\n                return results;\n            })();\n        }\n        else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        if (exports.visual_prop_is_singular(visual, alphaname)) {\n            alphas = exports.fill_array_with_float(n, visual[alphaname].value());\n        }\n        else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        a = new Float32Array(n * m);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            rgba = color_1.color2rgba(colors[i], alphas[i]);\n            for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                a[i * m + j] = rgba[j];\n            }\n        }\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'vec4', vbo);\n    }\n};\n","/*\nCopyright notice: many of the awesome techniques and  GLSL code contained in\nthis module are based on work by Nicolas Rougier as part of the Glumpy and\nVispy projects. The algorithms are published in\nhttp://jcgt.org/published/0003/04/01/ and http://jcgt.org/published/0002/02/08/\n\nThis module contains all gl-specific code to add gl support for the glyphs.\nBy implementing it separetely, the GL functionality can be spun off in a\nseparate library.\nOther locations where we work with GL, or prepare for GL-rendering:\n- canvas.coffee\n- plot.coffee\n- glyph.coffee\n- glyph_renderer.coffee\n*/\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./line\"));\n__export(require(\"./markers\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DashAtlas, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gloo2 = require(\"gloo2\");\nvar color_1 = require(\"core/util/color\");\nvar base_1 = require(\"./base\");\nDashAtlas = (function () {\n    function DashAtlas(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        this.tex = new gloo2.Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([this._height, this._width], gl.RGBA);\n        this.tex.set_data([0, 0], [this._height, this._width], new Uint8Array(this._height * this._width * 4));\n        this.get_atlas_data([1]);\n    }\n    DashAtlas.prototype.get_atlas_data = function (pattern) {\n        var data, findex_period, key, period, ref, x;\n        key = pattern.join('-');\n        findex_period = this._atlas[key];\n        if (findex_period === void 0) {\n            ref = this.make_pattern(pattern), data = ref[0], period = ref[1];\n            this.tex.set_data([this._index, 0], [1, this._width], new Uint8Array((function () {\n                var l, len, results;\n                results = [];\n                for (l = 0, len = data.length; l < len; l++) {\n                    x = data[l];\n                    results.push(x + 10);\n                }\n                return results;\n            })()));\n            this._atlas[key] = [this._index / this._height, period];\n            this._index += 1;\n        }\n        return this._atlas[key];\n    };\n    DashAtlas.prototype.make_pattern = function (pattern) {\n        var C, Z, a, b, c, dash_end, dash_start, dash_type, i, index, j, l, len, n, p, period, q, r, ref, ref1, ref2, v, val, val_at_index, x;\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        period = 0;\n        for (l = 0, len = pattern.length; l < len; l++) {\n            v = pattern[l];\n            period += v;\n        }\n        C = [];\n        c = 0;\n        for (i = p = 0, ref = pattern.length + 2; p < ref; i = p += 2) {\n            a = Math.max(0.0001, pattern[i % pattern.length]);\n            b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push.apply(C, [c, c + a]);\n            c += a + b;\n        }\n        n = this._width;\n        Z = new Float32Array(n * 4);\n        for (i = q = 0, ref1 = n; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            x = period * i / (n - 1);\n            index = 0;\n            val_at_index = 1e16;\n            for (j = r = 0, ref2 = C.length; 0 <= ref2 ? r < ref2 : r > ref2; j = 0 <= ref2 ? ++r : --r) {\n                val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if (index % 2 === 0) {\n                dash_type = x <= C[index] ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            }\n            else {\n                dash_type = x > C[index] ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[i * 4 + 0] = C[index];\n            Z[i * 4 + 1] = dash_type;\n            Z[i * 4 + 2] = dash_start;\n            Z[i * 4 + 3] = dash_end;\n        }\n        return [Z, period];\n    };\n    return DashAtlas;\n})();\nexports.LineGLGlyph = (function (superClass) {\n    extend(LineGLGlyph, superClass);\n    function LineGLGlyph() {\n        return LineGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    LineGLGlyph.prototype.GLYPH = 'line';\n    LineGLGlyph.prototype.JOINS = {\n        'miter': 0,\n        'round': 1,\n        'bevel': 2\n    };\n    LineGLGlyph.prototype.CAPS = {\n        '': 0,\n        'none': 0,\n        '.': 0,\n        'round': 1,\n        ')': 1,\n        '(': 1,\n        'o': 1,\n        'triangle in': 2,\n        '<': 2,\n        'triangle out': 3,\n        '>': 3,\n        'square': 4,\n        '[': 4,\n        ']': 4,\n        '=': 4,\n        'butt': 5,\n        '|': 5\n    };\n    LineGLGlyph.prototype.VERT = \"precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size, u_offset;\\nuniform vec2 u_scale_aspect;\\nuniform float u_scale_length;\\n\\nuniform vec4 u_color;\\nuniform float u_antialias;\\nuniform float u_length;\\nuniform float u_linewidth;\\nuniform float u_dash_index;\\nuniform float u_closed;\\n\\nattribute vec2 a_position;\\nattribute vec4 a_tangents;\\nattribute vec2 a_segment;\\nattribute vec2 a_angles;\\nattribute vec2 a_texcoord;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\nfloat cross(in vec2 v1, in vec2 v2)\\n{\\n    return v1.x*v2.y - v1.y*v2.x;\\n}\\n\\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\\n{\\n    return cross(v2-v1,v1-v3) / length(v2-v1);\\n}\\n\\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\\n{\\n    float c = cos(alpha);\\n    float s = sin(alpha);\\n    result = vec2( c*v.x - s*v.y,\\n                   s*v.x + c*v.y );\\n}\\n\\nvoid main()\\n{\\n    bool closed = (u_closed > 0.0);\\n\\n    // Attributes and uniforms to varyings\\n    v_color = u_color;\\n    v_linewidth = u_linewidth;\\n    v_segment = a_segment * u_scale_length;\\n    v_length = u_length * u_scale_length;\\n\\n    // Scale to map to pixel coordinates. The original algorithm from the paper\\n    // assumed isotropic scale. We obviously do not have this.\\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\\n\\n    // Correct angles for aspect ratio\\n    vec2 av;\\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\\n    v_angles.x = atan(av.y, av.x);\\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\\n    v_angles.y = atan(av.y, av.x);\\n\\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\\n    // and a modified alpha\\n    v_color.a = min(v_linewidth, v_color.a);\\n    v_linewidth = max(v_linewidth, 1.0);\\n\\n    // If color is fully transparent we just will discard the fragment anyway\\n    if( v_color.a <= 0.0 ) {\\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\\n        return;\\n    }\\n\\n    // This is the actual half width of the line\\n    float w = ceil(u_antialias+v_linewidth)/2.0;\\n\\n    vec2 position = (a_position + u_offset) * abs_scale;\\n\\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\\n    float u = a_texcoord.x;\\n    float v = a_texcoord.y;\\n    vec2 o1 = vec2( +t1.y, -t1.x);\\n    vec2 o2 = vec2( +t2.y, -t2.x);\\n\\n    // This is a join\\n    // ----------------------------------------------------------------\\n    if( t1 != t2 ) {\\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\\n        vec2 t  = normalize(t1+t2);\\n        vec2 o  = vec2( + t.y, - t.x);\\n\\n        if ( u_dash_index > 0.0 )\\n        {\\n            // Broken angle\\n            // ----------------------------------------------------------------\\n            if( (abs(angle) > THETA) ) {\\n                position += v * w * o / cos(angle/2.0);\\n                float s = sign(angle);\\n                if( angle < 0.0 ) {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position -= 2.0 * w * t1 / sin(angle);\\n                            u -= 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position += 2.0 * w * t2 / sin(angle);\\n                            u += 2.0*w / sin(angle);\\n                        }\\n                    }\\n                } else {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position += 2.0 * w * t1 / sin(angle);\\n                            u += 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position -= 2.0 * w * t2 / sin(angle);\\n                            u -= 2.0*w / sin(angle);\\n                        }\\n                    }\\n                }\\n                // Continuous angle\\n                // ------------------------------------------------------------\\n            } else {\\n                position += v * w * o / cos(angle/2.0);\\n                if( u == +1.0 ) u = v_segment.y;\\n                else            u = v_segment.x;\\n            }\\n        }\\n\\n        // Solid line\\n        // --------------------------------------------------------------------\\n        else\\n        {\\n            position.xy += v * w * o / cos(angle/2.0);\\n            if( angle < 0.0 ) {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            } else {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            }\\n        }\\n\\n    // This is a line start or end (t1 == t2)\\n    // ------------------------------------------------------------------------\\n    } else {\\n        position += v * w * o1;\\n        if( u == -1.0 ) {\\n            u = v_segment.x - w;\\n            position -= w * t1;\\n        } else {\\n            u = v_segment.y + w;\\n            position += w * t2;\\n        }\\n    }\\n\\n    // Miter distance\\n    // ------------------------------------------------------------------------\\n    vec2 t;\\n    vec2 curr = a_position * abs_scale;\\n    if( a_texcoord.x < 0.0 ) {\\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, +v_angles.x/2.0, t);\\n        v_miter.x = signed_distance(curr, curr+t, position);\\n\\n        rotate( t2, +v_angles.y/2.0, t);\\n        v_miter.y = signed_distance(next, next+t, position);\\n    } else {\\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, -v_angles.x/2.0,t);\\n        v_miter.x = signed_distance(prev, prev+t, position);\\n\\n        rotate( t2, -v_angles.y/2.0,t);\\n        v_miter.y = signed_distance(curr, curr+t, position);\\n    }\\n\\n    if (!closed && v_segment.x <= 0.0) {\\n        v_miter.x = 1e10;\\n    }\\n    if (!closed && v_segment.y >= v_length)\\n    {\\n        v_miter.y = 1e10;\\n    }\\n\\n    v_texcoord = vec2( u, v*w );\\n\\n    // Calculate position in device coordinates. Note that we\\n    // already scaled with abs scale above.\\n    vec2 normpos = position * sign(u_scale_aspect);\\n    normpos += 0.5;  // make up for Bokeh's offset\\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n}\\n\";\n    LineGLGlyph.prototype.FRAG_ = \"// Fragment shader that can be convenient during debugging to show the line skeleton.\\nprecision mediump float;\\nuniform vec4  u_color;\\nvoid main () {\\n  gl_FragColor = u_color;\\n}\";\n    LineGLGlyph.prototype.FRAG = \"precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform sampler2D u_dash_atlas;\\n\\nuniform vec2 u_linecaps;\\nuniform float u_miter_limit;\\nuniform float u_linejoin;\\nuniform float u_antialias;\\nuniform float u_dash_phase;\\nuniform float u_dash_period;\\nuniform float u_dash_index;\\nuniform vec2 u_dash_caps;\\nuniform float u_closed;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\n// Compute distance to cap ----------------------------------------------------\\nfloat cap( int type, float dx, float dy, float t, float linewidth )\\n{\\n    float d = 0.0;\\n    dx = abs(dx);\\n    dy = abs(dy);\\n    if      (type == 0)  discard;  // None\\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\\n    else if (type == 4)  d = max(dx,dy);  // Square\\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\\n    return d;\\n}\\n\\n// Compute distance to join -------------------------------------------------\\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\\n           in float linewidth )\\n{\\n    // texcoord.x is distance from start\\n    // texcoord.y is distance from centerline\\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\\n\\n    float dx = texcoord.x;\\n\\n    // Round join\\n    if( type == 1 ) {\\n        if (dx < segment.x) {\\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\\n            //d = length( texcoord - vec2(segment.x,0.0));\\n        } else if (dx > segment.y) {\\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\\n            //d = length( texcoord - vec2(segment.y,0.0));\\n        }\\n    }\\n    // Bevel join\\n    else if ( type == 2 ) {\\n        if (dx < segment.x) {\\n            vec2 x = texcoord - vec2(segment.x,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n\\n        } else if (dx > segment.y) {\\n            vec2 x = texcoord - vec2(segment.y,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n        }\\n        /*  Original code for bevel which does not work for us\\n        if( (dx < segment.x) ||  (dx > segment.y) )\\n            d = max(d, min(abs(x.x),abs(x.y)));\\n        */\\n    }\\n\\n    return d;\\n}\\n\\nvoid main()\\n{\\n    // If color is fully transparent we just discard the fragment\\n    if( v_color.a <= 0.0 ) {\\n        discard;\\n    }\\n\\n    // Test if dash pattern is the solid one (0)\\n    bool solid =  (u_dash_index == 0.0);\\n\\n    // Test if path is closed\\n    bool closed = (u_closed > 0.0);\\n\\n    vec4 color = v_color;\\n    float dx = v_texcoord.x;\\n    float dy = v_texcoord.y;\\n    float t = v_linewidth/2.0-u_antialias;\\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\\n    float d = 0.0;\\n\\n    vec2 linecaps = u_linecaps;\\n    vec2 dash_caps = u_dash_caps;\\n    float line_start = 0.0;\\n    float line_stop = v_length;\\n\\n    // Apply miter limit; fragments too far into the miter are simply discarded\\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\\n          discard;\\n    }\\n\\n    // Solid line --------------------------------------------------------------\\n    if( solid ) {\\n        d = abs(dy);\\n        if( (!closed) && (dx < line_start) ) {\\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\\n        }\\n        else if( (!closed) &&  (dx > line_stop) ) {\\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\\n        }\\n        else {\\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\\n        }\\n\\n    // Dash line --------------------------------------------------------------\\n    } else {\\n        float segment_start = v_segment.x;\\n        float segment_stop  = v_segment.y;\\n        float segment_center= (segment_start+segment_stop)/2.0;\\n        float freq          = u_dash_period*width;\\n        float u = mod( dx + u_dash_phase*width, freq);\\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n        float dash_center= tex.x * width;\\n        float dash_type  = tex.y;\\n        float _start = tex.z * width;\\n        float _stop  = tex.a * width;\\n        float dash_start = dx - u + _start;\\n        float dash_stop  = dx - u + _stop;\\n\\n        // Compute extents of the first dash (the one relative to v_segment.x)\\n        // Note: this could be computed in the vertex shader\\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\\n            float u = mod(segment_start + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_start - u + _start;\\n            dash_stop = segment_start - u + _stop;\\n        }\\n\\n        // Compute extents of the last dash (the one relatives to v_segment.y)\\n        // Note: This could be computed in the vertex shader\\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\\n            float u = mod(segment_stop + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_stop - u + _start;\\n            dash_stop  = segment_stop - u + _stop;\\n        }\\n\\n        // This test if the we are dealing with a discontinuous angle\\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\\n        //if( dx < line_start) discontinuous = false;\\n        //if( dx > line_stop)  discontinuous = false;\\n\\n        float d_join = join( int(u_linejoin), abs(dy),\\n                            v_segment, v_texcoord, v_miter, v_linewidth );\\n\\n        // When path is closed, we do not have room for linecaps, so we make room\\n        // by shortening the total length\\n        if (closed) {\\n             line_start += v_linewidth/2.0;\\n             line_stop  -= v_linewidth/2.0;\\n        }\\n\\n        // We also need to take antialias area into account\\n        //line_start += u_antialias;\\n        //line_stop  -= u_antialias;\\n\\n        // Check is dash stop is before line start\\n        if( dash_stop <= line_start ) {\\n            discard;\\n        }\\n        // Check is dash start is beyond line stop\\n        if( dash_start >= line_stop ) {\\n            discard;\\n        }\\n\\n        // Check if current dash start is beyond segment stop\\n        if( discontinuous ) {\\n            // Dash start is beyond segment, we discard\\n            if( (dash_start > segment_stop) ) {\\n                discard;\\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\\n            }\\n\\n            // Dash stop is before segment, we discard\\n            if( (dash_stop < segment_start) ) {\\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\\n            }\\n\\n            // Special case for round caps (nicer with this)\\n            if( dash_caps.x == 1.0 ) {\\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for round caps  (nicer with this)\\n            if( dash_caps.y == 1.0 ) {\\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\\n                    float a = v_angles.x/2.0;\\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the cap into square to avoid holes\\n                    dash_caps.x = 4.0;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\\n                    float a = v_angles.y/2.0;\\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the caps into square to avoid holes\\n                    dash_caps.y = 4.0;\\n                }\\n            }\\n        }\\n\\n        // Line cap at start\\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\\n        }\\n        // Line cap at stop\\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\\n        }\\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\\n        else if( dash_type < -0.5 ) {\\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash cap right\\n        else if( dash_type > 0.5 ) {\\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash body (plain)\\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\\n            d = abs(dy);\\n        }\\n\\n        // Line join\\n        if( (dx > line_start) && (dx < line_stop)) {\\n            if( (dx <= segment_start) && (dash_start <= segment_start)\\n                && (dash_stop >= segment_start) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.x;\\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\\n                     && (dash_stop >= segment_stop) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.y;\\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( dx < (segment_start - v_linewidth/2.)) {\\n                discard;\\n            }\\n            else if( dx > (segment_stop + v_linewidth/2.)) {\\n                discard;\\n            }\\n        }\\n        else if( dx < (segment_start - v_linewidth/2.)) {\\n            discard;\\n        }\\n        else if( dx > (segment_stop + v_linewidth/2.)) {\\n            discard;\\n        }\\n    }\\n\\n    // Distance to border ------------------------------------------------------\\n    d = d - t;\\n    if( d < 0.0 ) {\\n        gl_FragColor = color;\\n    } else {\\n        d /= u_antialias;\\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\\n    }\\n}\";\n    LineGLGlyph.prototype.init = function () {\n        var gl;\n        gl = this.gl;\n        this._scale_aspect = 0;\n        this.prog = new gloo2.Program(gl);\n        this.prog.set_shaders(this.VERT, this.FRAG);\n        this.index_buffer = new gloo2.IndexBuffer(gl);\n        this.vbo_position = new gloo2.VertexBuffer(gl);\n        this.vbo_tangents = new gloo2.VertexBuffer(gl);\n        this.vbo_segment = new gloo2.VertexBuffer(gl);\n        this.vbo_angles = new gloo2.VertexBuffer(gl);\n        this.vbo_texcoord = new gloo2.VertexBuffer(gl);\n        return this.dash_atlas = new DashAtlas(gl);\n    };\n    LineGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, l, mainGlGlyph, nvertices, offset, p, q, ref, ref1, ref2, results, scale_length, sx, sy, these_indices, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy];\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        sx = trans.sx;\n        sy = trans.sy;\n        scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        if (Math.abs(this._scale_aspect - (sy / sx)) > Math.abs(1e-3 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [sx, sy]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            return this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n        }\n        else {\n            indices = this.I_triangles;\n            nvertices = this.I_triangles.length;\n            chunksize = 64008;\n            chunks = [];\n            for (i = l = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                chunks.push([]);\n            }\n            for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            for (chunk = q = 0, ref2 = chunks.length; 0 <= ref2 ? q < ref2 : q > ref2; chunk = 0 <= ref2 ? ++q : --q) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.TRIANGLES, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    LineGLGlyph.prototype._set_data = function () {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        return this.vbo_texcoord.set_data(0, this.V_texcoord);\n    };\n    LineGLGlyph.prototype._set_visuals = function () {\n        var cap, color, dash_index, dash_pattern, dash_period, join, ref;\n        color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        cap = this.CAPS[this.glyph.visuals.line.line_cap.value()];\n        join = this.JOINS[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]);\n        this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10.0]);\n        dash_pattern = this.glyph.visuals.line.line_dash.value();\n        dash_index = 0;\n        dash_period = 1;\n        if (dash_pattern.length) {\n            ref = this.dash_atlas.get_atlas_data(dash_pattern), dash_index = ref[0], dash_period = ref[1];\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]);\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\n        return this.prog.set_uniform('u_closed', 'float', [0]);\n    };\n    LineGLGlyph.prototype._bake = function () {\n        var A, I, T, V_angles, V_angles2, V_position, V_position2, V_tangents, V_tangents2, V_texcoord, V_texcoord2, Vp, Vt, _x, _y, i, i1, j, k, l, m, n, ni, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, s, t, u, w, y, z;\n        n = this.nvertices;\n        _x = new Float64Array(this.glyph._x);\n        _y = new Float64Array(this.glyph._y);\n        V_position = Vp = new Float32Array(n * 2);\n        V_angles = new Float32Array(n * 2);\n        V_tangents = Vt = new Float32Array(n * 4);\n        V_texcoord = new Float32Array(n * 2);\n        for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n            V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n        }\n        this.tangents = T = new Float32Array(n * 2 - 2);\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n            T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n        }\n        for (i = q = 0, ref2 = n - 1; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n            V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1];\n            V_tangents[i * 4 + 2] = T[i * 2 + 0];\n            V_tangents[i * 4 + 3] = T[i * 2 + 1];\n        }\n        V_tangents[0 * 4 + 0] = T[0];\n        V_tangents[0 * 4 + 1] = T[1];\n        V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n        V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1];\n        A = new Float32Array(n);\n        for (i = r = 0, ref3 = n; 0 <= ref3 ? r < ref3 : r > ref3; i = 0 <= ref3 ? ++r : --r) {\n            A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n        }\n        for (i = s = 0, ref4 = n - 1; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {\n            V_angles[i * 2 + 0] = A[i];\n            V_angles[i * 2 + 1] = A[i + 1];\n        }\n        m = 4 * n - 4;\n        this.V_position = V_position2 = new Float32Array(m * 2);\n        this.V_angles = V_angles2 = new Float32Array(m * 2);\n        this.V_tangents = V_tangents2 = new Float32Array(m * 4);\n        this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n        o = 2;\n        for (i = t = 0, ref5 = n; 0 <= ref5 ? t < ref5 : t > ref5; i = 0 <= ref5 ? ++t : --t) {\n            for (j = u = 0; u < 4; j = ++u) {\n                for (k = w = 0; w < 2; k = ++w) {\n                    V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n                    V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n                }\n                for (k = y = 0; y < 4; k = ++y) {\n                    V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n                }\n            }\n        }\n        for (i = z = 0, ref6 = n; 0 <= ref6 ? z <= ref6 : z >= ref6; i = 0 <= ref6 ? ++z : --z) {\n            V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 3) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n            V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n        }\n        ni = (n - 1) * 6;\n        this.I_triangles = I = new Uint32Array(ni);\n        results = [];\n        for (i = i1 = 0, ref7 = n; 0 <= ref7 ? i1 < ref7 : i1 > ref7; i = 0 <= ref7 ? ++i1 : --i1) {\n            I[i * 6 + 0] = 0 + 4 * i;\n            I[i * 6 + 1] = 1 + 4 * i;\n            I[i * 6 + 2] = 3 + 4 * i;\n            I[i * 6 + 3] = 2 + 4 * i;\n            I[i * 6 + 4] = 0 + 4 * i;\n            results.push(I[i * 6 + 5] = 3 + 4 * i);\n        }\n        return results;\n    };\n    LineGLGlyph.prototype._update_scale = function (sx, sy) {\n        var N, T, V_segment, V_segment2, cumsum, i, j, k, l, m, n, p, q, r, ref, ref1, ref2, s;\n        n = this.nvertices;\n        m = 4 * n - 4;\n        T = this.tangents;\n        N = new Float32Array(n - 1);\n        V_segment = new Float32Array(n * 2);\n        this.V_segment = V_segment2 = new Float32Array(m * 2);\n        for (i = l = 0, ref = n - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            N[i] = Math.sqrt(Math.pow(T[i * 2 + 0] * sx, 2) + Math.pow(T[i * 2 + 1] * sy, 2));\n        }\n        cumsum = 0;\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            cumsum += N[i];\n            V_segment[(i + 1) * 2 + 0] = cumsum;\n            V_segment[i * 2 + 1] = cumsum;\n        }\n        for (i = q = 0, ref2 = n; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            for (j = r = 0; r < 4; j = ++r) {\n                for (k = s = 0; s < 2; k = ++s) {\n                    V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n                }\n            }\n        }\n        this.cumsum = cumsum;\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        return this.vbo_segment.set_data(0, this.V_segment);\n    };\n    return LineGLGlyph;\n})(base_1.BaseGLGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./index\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MarkerGLGlyph, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gloo2 = require(\"gloo2\");\nvar logging_1 = require(\"core/logging\");\nvar base_1 = require(\"./base\");\nMarkerGLGlyph = (function (superClass) {\n    extend(MarkerGLGlyph, superClass);\n    function MarkerGLGlyph() {\n        return MarkerGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    MarkerGLGlyph.prototype.VERT = \"precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\n//\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size;\\nuniform vec2 u_offset;\\nuniform vec2 u_scale;\\nuniform float u_antialias;\\n//\\nattribute float a_x;\\nattribute float a_y;\\nattribute float a_size;\\nattribute float a_angle;  // in radians\\nattribute float a_linewidth;\\nattribute vec4  a_fg_color;\\nattribute vec4  a_bg_color;\\n//\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying vec2  v_rotation;\\n\\nvoid main (void)\\n{\\n    v_size = a_size * u_pixel_ratio;\\n    v_linewidth = a_linewidth * u_pixel_ratio;\\n    v_fg_color = a_fg_color;\\n    v_bg_color = a_bg_color;\\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\\n    // Calculate position - the -0.5 is to correct for canvas origin\\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\\n    pos += 0.5;  // make up for Bokeh's offset\\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\\n}\";\n    MarkerGLGlyph.prototype.FRAG = \"precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\nconst float PI = 3.14159265358979323846264;\\n//\\nuniform float u_antialias;\\n//\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec2  v_rotation;\\n\\nMARKERCODE\\n\\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\\n{\\n    vec4 frag_color;\\n    float t = linewidth/2.0 - antialias;\\n    float signed_distance = distance;\\n    float border_distance = abs(signed_distance) - t;\\n    float alpha = border_distance/antialias;\\n    alpha = exp(-alpha*alpha);\\n\\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\\n    float select = float(bool(fg_color.a));\\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\\n    // Similarly, if we want a transparent bg\\n    select = float(bool(bg_color.a));\\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\\n\\n    if( border_distance < 0.0)\\n        frag_color = fg_color;\\n    else if( signed_distance < 0.0 ) {\\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\\n    } else {\\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\\n        } else {\\n            discard;\\n        }\\n    }\\n    return frag_color;\\n}\\n\\nvoid main()\\n{\\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\\n             v_rotation.y*P.x + v_rotation.x*P.y);\\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\\n    float distance = marker(P*point_size, v_size);\\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\\n}\";\n    MarkerGLGlyph.prototype.MARKERCODE = \"<defined in subclasses>\";\n    MarkerGLGlyph.prototype.init = function () {\n        var frag, gl;\n        gl = this.gl;\n        frag = this.FRAG.replace(/MARKERCODE/, this.MARKERCODE);\n        this.last_trans = {};\n        this.prog = new gloo2.Program(gl);\n        this.prog.set_shaders(this.VERT, frag);\n        this.vbo_x = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_x', 'float', this.vbo_x);\n        this.vbo_y = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_y', 'float', this.vbo_y);\n        this.vbo_s = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_size', 'float', this.vbo_s);\n        this.vbo_a = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n        this.vbo_linewidth = new gloo2.VertexBuffer(gl);\n        this.vbo_fg_color = new gloo2.VertexBuffer(gl);\n        this.vbo_bg_color = new gloo2.VertexBuffer(gl);\n        return this.index_buffer = new gloo2.IndexBuffer(gl);\n    };\n    MarkerGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, j, k, l, mainGlGlyph, nvertices, offset, ref, ref1, ref2, results, s, these_indices, ua, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        nvertices = mainGlGlyph.nvertices;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy];\n            mainGlGlyph._set_data(nvertices);\n            mainGlGlyph.data_changed = false;\n        }\n        else if ((this.glyph._radius != null) && (trans.sx !== this.last_trans.sx || trans.sy !== this.last_trans.sy)) {\n            this.last_trans = trans;\n            this.vbo_s.set_data(0, new Float32Array((function () {\n                var j, len, ref, results;\n                ref = this.glyph.sradius;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    s = ref[j];\n                    results.push(s * 2);\n                }\n                return results;\n            }).call(this)));\n        }\n        if (this.visuals_changed) {\n            this._set_visuals(nvertices);\n            this.visuals_changed = false;\n        }\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale', 'vec2', [trans.sx, trans.sy]);\n        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n        if (indices.length === 0) {\n        }\n        else if (indices.length === nvertices) {\n            return this.prog.draw(this.gl.POINTS, [0, nvertices]);\n        }\n        else if (nvertices < 65535) {\n            ua = window.navigator.userAgent;\n            if (ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\") > 0) {\n                logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n            }\n            this.index_buffer.set_size(indices.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(indices));\n            return this.prog.draw(this.gl.POINTS, this.index_buffer);\n        }\n        else {\n            chunksize = 64000;\n            chunks = [];\n            for (i = j = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                chunks.push([]);\n            }\n            for (i = k = 0, ref1 = indices.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            for (chunk = l = 0, ref2 = chunks.length; 0 <= ref2 ? l < ref2 : l > ref2; chunk = 0 <= ref2 ? ++l : --l) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                if (this.vbo_linewidth.used) {\n                    this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                }\n                if (this.vbo_fg_color.used) {\n                    this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                }\n                if (this.vbo_bg_color.used) {\n                    this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                }\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.POINTS, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    MarkerGLGlyph.prototype._set_data = function (nvertices) {\n        var i, j, n, ref, s, xx, yy;\n        n = nvertices * 4;\n        this.vbo_x.set_size(n);\n        this.vbo_y.set_size(n);\n        this.vbo_a.set_size(n);\n        this.vbo_s.set_size(n);\n        xx = new Float64Array(this.glyph._x);\n        yy = new Float64Array(this.glyph._y);\n        for (i = j = 0, ref = nvertices; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            xx[i] += this._baked_offset[0];\n            yy[i] += this._baked_offset[1];\n        }\n        this.vbo_x.set_data(0, new Float32Array(xx));\n        this.vbo_y.set_data(0, new Float32Array(yy));\n        if (this.glyph._angle != null) {\n            this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n        }\n        if (this.glyph._radius != null) {\n            return this.vbo_s.set_data(0, new Float32Array((function () {\n                var k, len, ref1, results;\n                ref1 = this.glyph.sradius;\n                results = [];\n                for (k = 0, len = ref1.length; k < len; k++) {\n                    s = ref1[k];\n                    results.push(s * 2);\n                }\n                return results;\n            }).call(this)));\n        }\n        else {\n            return this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n        }\n    };\n    MarkerGLGlyph.prototype._set_visuals = function (nvertices) {\n        base_1.attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n        base_1.attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n        base_1.attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n        return this.prog.set_uniform('u_antialias', 'float', [0.8]);\n    };\n    return MarkerGLGlyph;\n})(base_1.BaseGLGlyph);\nexports.CircleGLGlyph = (function (superClass) {\n    extend(CircleGLGlyph, superClass);\n    function CircleGLGlyph() {\n        return CircleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleGLGlyph.prototype.GLYPH = 'circle';\n    CircleGLGlyph.prototype.MARKERCODE = \"// --- disc\\nfloat marker(vec2 P, float size)\\n{\\n    return length(P) - size/2.0;\\n}\";\n    return CircleGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareGLGlyph = (function (superClass) {\n    extend(SquareGLGlyph, superClass);\n    function SquareGLGlyph() {\n        return SquareGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareGLGlyph.prototype.GLYPH = 'square';\n    SquareGLGlyph.prototype.MARKERCODE = \"// --- square\\nfloat marker(vec2 P, float size)\\n{\\n    return max(abs(P.x), abs(P.y)) - size/2.0;\\n}\";\n    return SquareGLGlyph;\n})(MarkerGLGlyph);\nexports.AnnulusGLGlyph = (function (superClass) {\n    extend(AnnulusGLGlyph, superClass);\n    function AnnulusGLGlyph() {\n        return AnnulusGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    AnnulusGLGlyph.prototype.GLYPH = 'annulus';\n    AnnulusGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float r1 = length(P) - size/2.0;\\n    float r2 = length(P) - size/4.0;  // half width\\n    return max(r1, -r2);\\n}\";\n    return AnnulusGLGlyph;\n})(MarkerGLGlyph);\nexports.DiamondGLGlyph = (function (superClass) {\n    extend(DiamondGLGlyph, superClass);\n    function DiamondGLGlyph() {\n        return DiamondGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    DiamondGLGlyph.prototype.GLYPH = 'diamond';\n    DiamondGLGlyph.prototype.MARKERCODE = \"// --- diamond\\nfloat marker(vec2 P, float size)\\n{\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    return r1 / SQRT_2;\\n}\";\n    return DiamondGLGlyph;\n})(MarkerGLGlyph);\nexports.TriangleGLGlyph = (function (superClass) {\n    extend(TriangleGLGlyph, superClass);\n    function TriangleGLGlyph() {\n        return TriangleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    TriangleGLGlyph.prototype.GLYPH = 'triangle';\n    TriangleGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    P.y -= size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}\";\n    return TriangleGLGlyph;\n})(MarkerGLGlyph);\nexports.InvertedTriangleGLGlyph = (function (superClass) {\n    extend(InvertedTriangleGLGlyph, superClass);\n    function InvertedTriangleGLGlyph() {\n        return InvertedTriangleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    InvertedTriangleGLGlyph.prototype.GLYPH = 'invertedtriangle';\n    InvertedTriangleGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    P.y += size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = - P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}\";\n    return InvertedTriangleGLGlyph;\n})(MarkerGLGlyph);\nexports.CrossGLGlyph = (function (superClass) {\n    extend(CrossGLGlyph, superClass);\n    function CrossGLGlyph() {\n        return CrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CrossGLGlyph.prototype.GLYPH = 'cross';\n    CrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;  // 2.5 is a tweak\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return max(square, cross);\\n}\";\n    return CrossGLGlyph;\n})(MarkerGLGlyph);\nexports.CircleCrossGLGlyph = (function (superClass) {\n    extend(CircleCrossGLGlyph, superClass);\n    function CircleCrossGLGlyph() {\n        return CircleCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleCrossGLGlyph.prototype.GLYPH = 'circlecross';\n    CircleCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return CircleCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareCrossGLGlyph = (function (superClass) {\n    extend(SquareCrossGLGlyph, superClass);\n    function SquareCrossGLGlyph() {\n        return SquareCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareCrossGLGlyph.prototype.GLYPH = 'squarecross';\n    SquareCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return SquareCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.DiamondCrossGLGlyph = (function (superClass) {\n    extend(DiamondCrossGLGlyph, superClass);\n    function DiamondCrossGLGlyph() {\n        return DiamondCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    DiamondCrossGLGlyph.prototype.GLYPH = 'diamondcross';\n    DiamondCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    diamond /= SQRT_2;\\n    float c1 = max(diamond, s1);\\n    float c2 = max(diamond, s2);\\n    float c3 = max(diamond, s3);\\n    float c4 = max(diamond, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return DiamondCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.XGLGlyph = (function (superClass) {\n    extend(XGLGlyph, superClass);\n    function XGLGlyph() {\n        return XGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    XGLGlyph.prototype.GLYPH = 'x';\n    XGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float circle = length(P) - size / 1.6;\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return max(circle, X);\\n}\";\n    return XGLGlyph;\n})(MarkerGLGlyph);\nexports.CircleXGLGlyph = (function (superClass) {\n    extend(CircleXGLGlyph, superClass);\n    function CircleXGLGlyph() {\n        return CircleXGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleXGLGlyph.prototype.GLYPH = 'circlex';\n    CircleXGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    float almost = min(min(min(c1, c2), c3), c4);\\n    // In this case, the X is also outside of the main shape\\n    float Xmask = length(P) - size / 1.6;  // a circle\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return min(max(X, Xmask), almost);\\n}\";\n    return CircleXGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareXGLGlyph = (function (superClass) {\n    extend(SquareXGLGlyph, superClass);\n    function SquareXGLGlyph() {\n        return SquareXGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareXGLGlyph.prototype.GLYPH = 'squarex';\n    SquareXGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return SquareXGLGlyph;\n})(MarkerGLGlyph);\nexports.AsteriskGLGlyph = (function (superClass) {\n    extend(AsteriskGLGlyph, superClass);\n    function AsteriskGLGlyph() {\n        return AsteriskGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    AsteriskGLGlyph.prototype.GLYPH = 'asterisk';\n    AsteriskGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Masks\\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\\n    // Shapes\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    // Result is union of masked shapes\\n    return min(max(X, diamond), max(cross, square));\\n}\";\n    return AsteriskGLGlyph;\n})(MarkerGLGlyph);\n","/* Do not edit, autogenerated by flexx.pyscript */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports !== 'undefined') {\n        // Node or CommonJS\n        module.exports = factory();\n        if (typeof window === 'undefined') {\n            root.gloo2 = module.exports;  // also create global module in Node\n        }\n    } else {\n        // Browser globals (root is window)\n        root.gloo2 = factory();\n    }\n}(this, function () {\n    var _pyfunc_add = function (a, b) { // nargs: 2\n        if (Array.isArray(a) && Array.isArray(b)) {\n            return a.concat(b);\n        } return a + b;\n    };\n    var _pyfunc_all = function (x) { // nargs: 1\n        for (var i=0; i<x.length; i++) {\n            if (!_pyfunc_truthy(x[i])){return false;}\n        } return true;\n    };\n    var _pyfunc_contains = function contains (a, b) { // nargs: 2\n        if (b == null) {\n        } else if (Array.isArray(b)) {\n            for (var i=0; i<b.length; i++) {if (_pyfunc_equals(a, b[i]))\n                                               return true;}\n            return false;\n        } else if (b.constructor === Object) {\n            for (var k in b) {if (a == k) return true;}\n            return false;\n        } else if (b.constructor == String) {\n            return b.indexOf(a) >= 0;\n        } var e = Error('Not a container: ' + b); e.name='TypeError'; throw e;\n    };\n    var _pyfunc_equals = function equals (a, b) { // nargs: 2\n        if (a == null || b == null) {\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            var i = 0, iseq = a.length == b.length;\n            while (iseq && i < a.length) {iseq = equals(a[i], b[i]); i+=1;}\n            return iseq;\n        } else if (a.constructor === Object && b.constructor === Object) {\n            var akeys = Object.keys(a), bkeys = Object.keys(b);\n            akeys.sort(); bkeys.sort();\n            var i=0, k, iseq = equals(akeys, bkeys);\n            while (iseq && i < akeys.length) {k=akeys[i]; iseq = equals(a[k], b[k]); i+=1;}\n            return iseq;\n        } return a == b;\n    };\n    var _pyfunc_instantiate = function (ob, args) { // nargs: 2\n        if ((typeof ob === \"undefined\") ||\n                (typeof window !== \"undefined\" && window === ob) ||\n                (typeof global !== \"undefined\" && global === ob))\n                {throw \"Class constructor is called as a function.\";}\n        for (var name in ob) {\n            if (Object[name] === undefined &&\n                typeof ob[name] === 'function' && !ob[name].nobind) {\n                ob[name] = ob[name].bind(ob);\n            }\n        }\n        if (ob.__init__) {\n            ob.__init__.apply(ob, args);\n        }\n    };\n    var _pyfunc_mult = function (a, b) { // nargs: 2\n        if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n            if (a.constructor === String) return _pymeth_repeat.call(a, b);\n            if (b.constructor === String) return _pymeth_repeat.call(b, a);\n            if (Array.isArray(b)) {var t=a; a=b; b=t;}\n            if (Array.isArray(a)) {\n                var res = []; for (var i=0; i<b; i++) res = res.concat(a);\n                return res;\n            }\n        } return a * b;\n    };\n    var _pyfunc_range = function (start, end, step) {\n    var i, res = [];\n        var val = start;\n        var n = (end - start) / step;\n        for (i=0; i<n; i++) {\n            res.push(val);\n            val += step;\n        }\n        return res;\n    };\n    var _pyfunc_truthy = function (v) {\n        if (v === null || typeof v !== \"object\") {return v;}\n        else if (v.length !== undefined) {return v.length ? v : false;}\n        else if (v.byteLength !== undefined) {return v.byteLength ? v : false;}\n        else if (v.constructor !== Object) {return true;}\n        else {return Object.getOwnPropertyNames(v).length ? v : false;}\n    };\n    var _pymeth_append = function (x) { // nargs: 1\n        if (!Array.isArray(this)) return this.append.apply(this, arguments);\n        this.push(x);\n    };\n    var _pymeth_get = function (key, d) { // nargs: 1 2\n        if (this.constructor !== Object) return this.get.apply(this, arguments);\n        if (this[key] !== undefined) {return this[key];}\n        else if (d !== undefined) {return d;}\n        else {return null;}\n    };\n    var _pymeth_keys = function () { // nargs: 0\n        if (typeof this['keys'] === 'function') return this.keys.apply(this, arguments);\n        return Object.keys(this);\n    };\n    var _pymeth_lstrip = function (chars) { // nargs: 0 1\n        if (this.constructor !== String) return this.lstrip.apply(this, arguments);\n        chars = (chars === undefined) ? ' \\t\\r\\n' : chars;\n        for (var i=0; i<this.length; i++) {\n            if (chars.indexOf(this[i]) < 0) return this.slice(i);\n        } return '';\n    };\n    var _pymeth_remove = function (x) { // nargs: 1\n        if (!Array.isArray(this)) return this.remove.apply(this, arguments);\n        for (var i=0; i<this.length; i++) {\n            if (_pyfunc_equals(this[i], x)) {this.splice(i, 1); return;}\n        }\n        var e = Error(x); e.name='ValueError'; throw e;\n    };\n    var _pymeth_repeat = function(count) { // nargs: 0\n        if (this.repeat) return this.repeat(count);\n        if (count < 1) return '';\n        var result = '', pattern = this.valueOf();\n        while (count > 1) {\n            if (count & 1) result += pattern;\n            count >>= 1, pattern += pattern;\n        }\n        return result + pattern;\n    };\n    var _pymeth_startswith = function (x) { // nargs: 1\n        if (this.constructor !== String) return this.startswith.apply(this, arguments);\n        return this.indexOf(x) == 0;\n    };\n    var Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n    // PyScript module for gloo2.js - lightweight object oriented GL.\n\n    { /* if this_is_js() */\n    console = window.console;\n    }\n    __version__ = \"0.3\";\n    check_error = function (gl, when) {\n        var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n        when = (when === undefined) ? \"periodic check\": when;\n        // Check this from time to time to detect GL errors.\n        // \n        //     Parameters\n        //     ----------\n        //     when : str\n        //         Shown in the exception to help the developer determine when\n        //         this check was done.\n        errors = [];\n        while (true) {\n            err = gl.getError();\n            if ((_pyfunc_equals(err, gl.NO_ERROR) || (_pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length -1])))) {\n                break;\n            }\n            _pymeth_append.call(errors, err);\n        }\n        if (errors.length) {\n            msg = \"\";\n            stub1_seq = errors;\n            if ((typeof stub1_seq === \"object\") && (!Array.isArray(stub1_seq))) {\n                stub1_seq = Object.keys(stub1_seq);\n            }\n            for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n                e = stub1_seq[stub2_itr];\n                msg=_pyfunc_add(msg, e)\n            }\n            err_3 = new Error('RuntimeError:' + (\"OpenGL got errors (\" + when + \"): \" + msg + \"\")); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return null;\n    };\n\n    GlooObject = function () {\n        // Abstract base class for all Gloo classes.\n        _pyfunc_instantiate(this, arguments);\n    }\n    GlooObject.prototype._base_class = Object;\n    GlooObject.prototype._class_name = \"GlooObject\";\n    \n    GlooObject.prototype.__init__ = function (gl) {\n        // Init by passing the webgl context object.\n        this._gl = gl;\n        this.handle = null;\n        this._create();\n        if (!(this.handle !== null)) {throw \"AssertionError: \" + \"this.handle !== null\";}\n        return null;\n    };\n\n    GlooObject.prototype._create = function () {\n        var err_2;\n        err_2 = new Error('NotImplementedError:' + \"\"); err_2.name = \"NotImplementedError\"; throw err_2;\n        return null;\n    };\n\n\n    Program = function () {\n        // The program is the central component to connect gloo objects and shaders.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Program.prototype = Object.create(GlooObject.prototype);\n    Program.prototype._base_class = GlooObject.prototype;\n    Program.prototype._class_name = \"Program\";\n    \n    Program.prototype.UTYPEMAP = {\"float\": \"uniform1fv\", \"vec2\": \"uniform2fv\", \"vec3\": \"uniform3fv\", \"vec4\": \"uniform4fv\", \"int\": \"uniform1iv\", \"ivec2\": \"uniform2iv\", \"ivec3\": \"uniform3iv\", \"ivec4\": \"uniform4iv\", \"bool\": \"uniform1iv\", \"bvec2\": \"uniform2iv\", \"bvec3\": \"uniform3iv\", \"bvec4\": \"uniform4iv\", \"mat2\": \"uniformMatrix2fv\", \"mat3\": \"uniformMatrix3fv\", \"mat4\": \"uniformMatrix4fv\", \"sampler1D\": \"uniform1i\", \"sampler2D\": \"uniform1i\", \"sampler3D\": \"uniform1i\"};\n    Program.prototype.ATYPEMAP = {\"float\": \"vertexAttrib1f\", \"vec2\": \"vertexAttrib2f\", \"vec3\": \"vertexAttrib3f\", \"vec4\": \"vertexAttrib4f\"};\n    Program.prototype.ATYPEINFO = {\"float\": [1, 5126], \"vec2\": [2, 5126], \"vec3\": [3, 5126], \"vec4\": [4, 5126]};\n    Program.prototype._create = function () {\n        this.handle = this._gl.createProgram();\n        this.locations = {};\n        this._unset_variables = [];\n        this._validated = false;\n        this._samplers = {};\n        this._attributes = {};\n        this._known_invalid = [];\n        return null;\n    };\n\n    Program.prototype.delete = function () {\n        // Delete the program.\n        this._gl.deleteProgram(this.handle);\n        return null;\n    };\n\n    Program.prototype.activate = function () {\n        // Activate the program.\n        this._gl.useProgram(this.handle);\n        return null;\n    };\n\n    Program.prototype.deactivate = function () {\n        // Disable the program.\n        this._gl.useProgram(0);\n        return null;\n    };\n\n    Program.prototype.set_shaders = function (vert, frag) {\n        var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n        // Set GLSL code for the vertex and fragment shader.\n        // \n        // This function takes care of setting the shading code and\n        // compiling+linking it into a working program object that is ready\n        // to use.\n        // \n        // Parameters\n        // ----------\n        // vert : str\n        //     GLSL code for the vertex shader.\n        // frag : str\n        //     GLSL code for the fragment shader.\n        gl = this._gl;\n        this._linked = false;\n        vert_handle = gl.createShader(gl.VERTEX_SHADER);\n        frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n        tmp = [[vert, vert_handle, \"vertex\"], [frag, frag_handle, \"fragment\"]];\n        for (i = 0; i < 2; i += 1) {\n            stub3_ = tmp[i];\n            code = stub3_[0];handle = stub3_[1];type_ = stub3_[2];\n            gl.shaderSource(handle, code);\n            gl.compileShader(handle);\n            status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n            if ((!_pyfunc_truthy(status))) {\n                errors = gl.getShaderInfoLog(handle);\n                err_4 = new Error('RuntimeError:' + (_pyfunc_add(((\"errors in \" + type_) + \" shader:\\n\"), errors))); err_4.name = \"RuntimeError\"; throw err_4;\n            }\n        }\n        gl.attachShader(this.handle, vert_handle);\n        gl.attachShader(this.handle, frag_handle);\n        gl.linkProgram(this.handle);\n        if ((!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS)))) {\n            err_3 = new Error('RuntimeError:' + (\"Program link error:\\n\" + gl.getProgramInfoLog(this.handle))); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        this._unset_variables = this._get_active_attributes_and_uniforms();\n        gl.detachShader(this.handle, vert_handle);\n        gl.detachShader(this.handle, frag_handle);\n        gl.deleteShader(vert_handle);\n        gl.deleteShader(frag_handle);\n        this._known_invalid = [];\n        this._linked = true;\n        return null;\n    };\n\n    Program.prototype._get_active_attributes_and_uniforms = function () {\n        var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n        // Retrieve active attributes and uniforms to be able to check that\n        // all uniforms/attributes are set by the user.\n        gl = this._gl;\n        this.locations = {};\n        regex = new window.RegExp(\"(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*\");\n        cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n        ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n        attributes = [];\n        uniforms = [];\n        stub5_seq = [[attributes, ca, gl.getActiveAttrib, gl.getAttribLocation], [uniforms, cu, gl.getActiveUniform, gl.getUniformLocation]];\n        if ((typeof stub5_seq === \"object\") && (!Array.isArray(stub5_seq))) {\n            stub5_seq = Object.keys(stub5_seq);\n        }\n        for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n            x = stub5_seq[stub6_itr];\n            stub4_ = x;\n            container = stub4_[0];count = stub4_[1];getActive = stub4_[2];getLocation = stub4_[3];\n            for (i = 0; i < count; i += 1) {\n                info = getActive.call(gl, this.handle, i);\n                name = info.name;\n                m = name.match(regex);\n                if (_pyfunc_truthy(m)) {\n                    name = m[1];\n                    for (j = 0; j < info.size; j += 1) {\n                        _pymeth_append.call(container, ([\"\" + name + \"[\" + j + \"]\", info.type]));\n                    }\n                } else {\n                    _pymeth_append.call(container, [name, info.type]);\n                }\n                this.locations[name] = getLocation.call(gl, this.handle, name);\n            }\n        }\n        return _pyfunc_add(((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = attributes;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)), ((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = uniforms;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)));\n    };\n\n    Program.prototype.set_texture = function (name, value) {\n        var err_3, handle, unit;\n        // Set a texture sampler.\n        // \n        // A texture is a 2 dimensional grid of colors/intensities that\n        // can be applied to a face (or used for other means by providing\n        // a regular grid of data).\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the texture is known in the GLSL code.\n        // value : Texture2D\n        //     The gloo Texture2D object to bind.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log(\"Variable \" + name + \" is not an active texture\");\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if (true) {\n            unit = _pymeth_keys.call(this._samplers).length;\n            if (_pyfunc_contains(name, this._samplers)) {\n                unit = this._samplers[name][this._samplers[name].length -1];\n            }\n            this._samplers[name] = [value._target, value.handle, unit];\n            this._gl.uniform1i(handle, unit);\n        }\n        return null;\n    };\n\n    Program.prototype.set_uniform = function (name, type_, value) {\n        var a_type, count, err_3, funcname, handle, j, name_;\n        // Set a uniform value.\n        // \n        // A uniform is a value that is global to both the vertex and\n        // fragment shader.\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the uniform is known in the GLSL code.\n        // type_ : str\n        //     The type of the uniform, e.g. 'float', 'vec2', etc.\n        // value : list of scalars\n        //     The value for the uniform. Should be a list even for type float.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log(\"Variable \" + name + \" is not an active uniform\");\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        count = 1;\n        if ((!_pymeth_startswith.call(type_, \"mat\"))) {\n            a_type = _pymeth_get.call({\"int\": \"float\", \"bool\": \"float\"}, type_, _pymeth_lstrip.call(type_, \"ib\"));\n            count = Math.floor(value.length/(this.ATYPEINFO[a_type][0]));\n        }\n        if (_pyfunc_truthy(count > 1)) {\n            for (j = 0; j < count; j += 1) {\n                if ((_pyfunc_contains((\"\" + name + \"[\" + j + \"]\"), this._unset_variables))) {\n                    name_ = \"\" + name + \"[\" + j + \"]\";\n                    if (_pyfunc_contains(name_, this._unset_variables)) {\n                        _pymeth_remove.call(this._unset_variables, name_);\n                    }\n                }\n            }\n        }\n        funcname = this.UTYPEMAP[type_];\n        this.activate();\n        if (_pymeth_startswith.call(type_, \"mat\")) {\n            this._gl[funcname](handle, false, value);\n        } else {\n            this._gl[funcname](handle, value);\n        }\n        return null;\n    };\n\n    Program.prototype.set_attribute = function (name, type_, value, stride, offset) {\n        var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n        stride = (stride === undefined) ? 0: stride;\n        offset = (offset === undefined) ? 0: offset;\n        // Set an attribute value. \n        // \n        // An attribute represents per-vertex data and can only be used\n        // in the vertex shader.\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the attribute is known in the GLSL code.\n        // type_ : str\n        //     The type of the attribute, e.g. 'float', 'vec2', etc.\n        // value : VertexBuffer, array\n        //     If value is a VertexBuffer, it is used (with stride and offset)\n        //     for the vertex data. If value is an array, its used to set\n        //     the value of all vertices (similar to a uniform).\n        // stide : int, default 0\n        //     The stride to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, this should\n        //     be zero.\n        // offset : int, default 0\n        //     The offset to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, or only\n        //     a part of the data must be used, this should probably be zero.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set attribute when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        is_vbo = value instanceof VertexBuffer;\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                if ((_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0))) {\n                } else {\n                    console.log(\"Variable \" + name + \" is not an active attribute\");\n                }\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if ((!_pyfunc_truthy(is_vbo))) {\n            funcname = this.ATYPEMAP[type_];\n            this._attributes[name] = [0, handle, funcname, value];\n        } else {\n            stub7_ = this.ATYPEINFO[type_];\n            size = stub7_[0];gtype = stub7_[1];\n            funcname = \"vertexAttribPointer\";\n            args = [size, gtype, this._gl.FALSE, stride, offset];\n            this._attributes[name] = [value.handle, handle, funcname, args];\n        }\n        return null;\n    };\n\n    Program.prototype._pre_draw = function () {\n        var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n        // Prepare for drawing.\n        this.activate();\n        stub9_seq = this._samplers;\n        for (x in stub9_seq) {\n            if (!stub9_seq.hasOwnProperty(x)){ continue; }\n            x = stub9_seq[x];\n            stub8_ = x;\n            tex_target = stub8_[0];tex_handle = stub8_[1];unit = stub8_[2];\n            this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n            this._gl.bindTexture(tex_target, tex_handle);\n        }\n        stub11_seq = this._attributes;\n        for (x in stub11_seq) {\n            if (!stub11_seq.hasOwnProperty(x)){ continue; }\n            x = stub11_seq[x];\n            stub10_ = x;\n            vbo_handle = stub10_[0];attr_handle = stub10_[1];funcname = stub10_[2];args = stub10_[3];\n            if (_pyfunc_truthy(vbo_handle)) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n                this._gl.enableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            } else {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n                this._gl.disableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            }\n        }\n        if ((!_pyfunc_truthy(this._validated))) {\n            this._validated = true;\n            this._validate();\n        }\n        return null;\n    };\n\n    Program.prototype._validate = function () {\n        var err_3;\n        if (this._unset_variables.length) {\n            console.log(\"Program has unset variables: \" + this._unset_variables + \"\");\n        }\n        this._gl.validateProgram(this.handle);\n        if ((!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS)))) {\n            console.log(this._gl.getProgramInfoLog(this.handle));\n            err_3 = new Error('RuntimeError:' + \"Program validation error\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return null;\n    };\n\n    Program.prototype.draw = function (mode, selection) {\n        var count, err_3, first, gtype, stub12_;\n        // Draw the current visualization defined by the program.\n        // \n        // Parameters\n        // ----------\n        // mode : GL enum\n        //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n        // selection : 2-element tuple or IndexBuffer\n        //     The selection to draw, specified either as (first, count) or an\n        //     IndexBuffer object.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot draw program if code has not been set\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        check_error(this._gl, \"before draw\");\n        if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n            this._pre_draw();\n            selection.activate();\n            count = selection._buffer_size / 2;\n            gtype = this._gl.UNSIGNED_SHORT;\n            this._gl.drawElements(mode, count, gtype, 0);\n            selection.deactivate();\n        } else {\n            stub12_ = selection;\n            first = stub12_[0];count = stub12_[1];\n            if (_pyfunc_truthy(count)) {\n                this._pre_draw();\n                this._gl.drawArrays(mode, first, count);\n            }\n        }\n        check_error(this._gl, \"after draw\");\n        return null;\n    };\n\n\n    Buffer = function () {\n        // Base buffer class for vertex data or index data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Buffer.prototype = Object.create(GlooObject.prototype);\n    Buffer.prototype._base_class = GlooObject.prototype;\n    Buffer.prototype._class_name = \"Buffer\";\n    \n    Buffer.prototype._target = null;\n    Buffer.prototype._usage = 35048;\n    Buffer.prototype._create = function () {\n        this.handle = this._gl.createBuffer();\n        this._buffer_size = 0;\n        return null;\n    };\n\n    Buffer.prototype.delete = function () {\n        // Delete the buffer.\n        this._gl.deleteBuffer(this.handle);\n        return null;\n    };\n\n    Buffer.prototype.activate = function () {\n        // Activete the buffer.\n        this._gl.bindBuffer(this._target, this.handle);\n        return null;\n    };\n\n    Buffer.prototype.deactivate = function () {\n        // Disable the buffer.\n        this._gl.bindBuffer(this._target, null);\n        return null;\n    };\n\n    Buffer.prototype.set_size = function (nbytes) {\n        // Set the size of the buffer in bytes.\n        // \n        // Parameters\n        // ----------\n        // nbytes : int\n        //     The number of bytes that the buffer needs to hold.\n        if ((!_pyfunc_equals(nbytes, this._buffer_size))) {\n            this.activate();\n            this._gl.bufferData(this._target, nbytes, this._usage);\n            this._buffer_size = nbytes;\n        }\n        return null;\n    };\n\n    Buffer.prototype.set_data = function (offset, data) {\n        // Set the buffer data.\n        // \n        // Parameters\n        // ----------\n        // offset : int\n        //     The offset in bytes for the new data.\n        // data : typed array\n        //     The data to upload.\n        this.activate();\n        this._gl.bufferSubData(this._target, offset, data);\n        return null;\n    };\n\n\n    VertexBuffer = function () {\n        // A buffer for vertex data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    VertexBuffer.prototype = Object.create(Buffer.prototype);\n    VertexBuffer.prototype._base_class = Buffer.prototype;\n    VertexBuffer.prototype._class_name = \"VertexBuffer\";\n    \n    VertexBuffer.prototype._target = 34962;\n\n    IndexBuffer = function () {\n        // A buffer for index data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    IndexBuffer.prototype = Object.create(Buffer.prototype);\n    IndexBuffer.prototype._base_class = Buffer.prototype;\n    IndexBuffer.prototype._class_name = \"IndexBuffer\";\n    \n    IndexBuffer.prototype._target = 34963;\n\n    Texture2D = function () {\n        // A 2 dimensional regular grid.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Texture2D.prototype = Object.create(GlooObject.prototype);\n    Texture2D.prototype._base_class = GlooObject.prototype;\n    Texture2D.prototype._class_name = \"Texture2D\";\n    \n    Texture2D.prototype._target = 3553;\n    Texture2D.prototype._types = {\"Int8Array\": 5120, \"Uint8Array\": 5121, \"Int16Array\": 5122, \"Uint16Array\": 5123, \"Int32Array\": 5124, \"Uint32Array\": 5125, \"Float32Array\": 5126};\n    Texture2D.prototype._create = function () {\n        this.handle = this._gl.createTexture();\n        this._shape_format = null;\n        return null;\n    };\n\n    Texture2D.prototype.delete = function () {\n        // Delete the texture.\n        this._gl.deleteTexture(this.handle);\n        return null;\n    };\n\n    Texture2D.prototype.activate = function () {\n        // Activate the texture.\n        this._gl.bindTexture(this._target, this.handle);\n        return null;\n    };\n\n    Texture2D.prototype.deactivate = function () {\n        // Disable the texture.\n        this._gl.bindTexture(this._target, 0);\n        return null;\n    };\n\n    Texture2D.prototype._get_alignment = function (width) {\n        var alignment, alignments, stub13_seq, stub14_itr;\n        // Determines a textures byte alignment. If the width isn't a\n        //         power of 2 we need to adjust the byte alignment of the image.\n        //         The image height is unimportant.\n        // \n        //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n        alignments = [4, 8, 2, 1];\n        stub13_seq = alignments;\n        if ((typeof stub13_seq === \"object\") && (!Array.isArray(stub13_seq))) {\n            stub13_seq = Object.keys(stub13_seq);\n        }\n        for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n            alignment = stub13_seq[stub14_itr];\n            if ((_pyfunc_equals((width % alignment), 0))) {\n                return alignment;\n            }\n        }\n        return null;\n    };\n\n    Texture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n        // Set the texture wrapping mode.\n        // \n        // Parameters\n        // ----------\n        // wrap_s : GL enum\n        //     The mode to wrap the x dimension. Valid values are REPEAT\n        //     CLAMP_TO_EDGE MIRRORED_REPEAT\n        // wrap_t : GL enum\n        //     The mode to wrap the y dimension. Same options as for wrap_s.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n        return null;\n    };\n\n    Texture2D.prototype.set_interpolation = function (min, mag) {\n        // Set the texture interpolation mode\n        // \n        // Parameters\n        // ----------\n        // min : GL enum\n        //     The interpolation mode when minifying (i.e. zoomed out). Valid\n        //     values are LINEAR and NEAREST.\n        // max : GL enum\n        //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n        //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n        //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n        return null;\n    };\n\n    Texture2D.prototype.set_size = function (shape, format) {\n        var height, stub15_, width;\n        // Set the size of the 2D texture.\n        // \n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub15_ = shape;\n        height = stub15_[0];width = stub15_[1];\n        if ((!_pyfunc_equals([height, width, format], this._shape_format))) {\n            this._shape_format = [height, width, format];\n            this.activate();\n            this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n        }\n        this.u_shape = [height, width];\n        return null;\n    };\n\n    Texture2D.prototype.set_data = function (offset, shape, data) {\n        var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n        // Set the 2D texture data.\n        // \n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 2)) {\n            shape = [shape[0], shape[1], 1];\n        }\n        this.activate();\n        format = this._shape_format[2];\n        stub16_ = shape;\n        height = stub16_[0];width = stub16_[1];_ = stub16_[2];\n        stub17_ = offset;\n        y = stub17_[0];x = stub17_[1];\n        gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n        if ((gtype === null)) {\n            err_3 = new Error('ValueError:' + (\"Type \" + data.constructor.name + \" not allowed for texture\")); err_3.name = \"ValueError\"; throw err_3;\n        }\n        alignment = this._get_alignment(_pyfunc_mult(shape[shape.length -2], shape[shape.length -1]));\n        if ((!_pyfunc_equals(alignment, 4))) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n        }\n        this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n        if ((!_pyfunc_equals(alignment, 4))) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n        }\n        return null;\n    };\n\n\n    Texture3DLike = function () {\n        // A 2D texture with support to simulate a 3D texture.\n        // \n        // To use this class, use set_size() and set_data() as if it was a 3D\n        // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n        // shader to add the sample3D() function that can be used instead of\n        // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n        // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n        // attributes of this object.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Texture3DLike.prototype = Object.create(Texture2D.prototype);\n    Texture3DLike.prototype._base_class = Texture2D.prototype;\n    Texture3DLike.prototype._class_name = \"Texture3DLike\";\n    \n    Texture3DLike.prototype.GLSL_SAMPLE_NEAREST = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    \";\n    Texture3DLike.prototype.GLSL_SAMPLE_LINEAR = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    \";\n    Texture3DLike.prototype._get_tile_info = function (shape) {\n        var err_3, max_size, ncols, nrows;\n        max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n        nrows = Math.floor(max_size/shape[1]);\n        nrows = Math.min(nrows, shape[0]);\n        ncols = window.Math.ceil(shape[0] / nrows);\n        if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n            err_3 = new Error('RuntimeError:' + (\"Cannot fit 3D data with shape \" + shape + \" onto simulated 2D texture.\")); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return [nrows, ncols];\n    };\n\n    Texture3DLike.prototype.set_size = function (shape, format) {\n        var ncols, nrows, sim_shape, stub18_;\n        // Set the size of the 3D texture.\n        // \n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub18_ = this._get_tile_info(shape);\n        nrows = stub18_[0];ncols = stub18_[1];\n        sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols)];\n        Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n        this.u_shape = [shape[0], shape[1], shape[2]];\n        this.u_tiles = [ncols, nrows];\n        return null;\n    };\n\n    Texture3DLike.prototype.set_data = function (offset, shape, data) {\n        var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n        // Set the 3D texture data.\n        // \n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 3)) {\n            shape = [shape[0], shape[1], shape[2], 1];\n        }\n        if ((!(_pyfunc_all(((function list_comprehenson () {var res = [];var i, iter0, i0;iter0 = offset;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {i = iter0[i0];{res.push(_pyfunc_equals(i, 0));}}return res;}).apply(this)))))) {\n            err_3 = new Error('ValueError:' + \"Texture3DLike does not support nonzero offset (for now)\"); err_3.name = \"ValueError\"; throw err_3;\n        }\n        stub19_ = this._get_tile_info(shape);\n        nrows = stub19_[0];ncols = stub19_[1];\n        sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols), shape[3]];\n        if (_pyfunc_equals(ncols, 1)) {\n            Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, data);\n        } else {\n            Type = data.constructor;\n            zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n            Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, zeros);\n            for (z = 0; z < shape[0]; z += 1) {\n                stub20_ = [Math.floor(z/ncols), z % ncols];\n                row = stub20_[0];col = stub20_[1];\n                elements_per_tile = Math.floor(data.length/shape[0]);\n                tile = data.slice(_pyfunc_mult(z, elements_per_tile),_pyfunc_mult((z + 1), elements_per_tile));\n                Texture3DLike.prototype._base_class.set_data.call(this, [_pyfunc_mult(row, shape[1]), _pyfunc_mult(col, shape[2])], shape.slice(1), tile);\n            }\n        }\n        return null;\n    };\n\n\n    return {\"Buffer\": Buffer, \"GlooObject\": GlooObject, \"IndexBuffer\": IndexBuffer, \"Program\": Program, \"Texture2D\": Texture2D, \"Texture3DLike\": Texture3DLike, \"VertexBuffer\": VertexBuffer, \"check_error\": check_error, \"console\": console};\n}));\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi93b3JrL2Jva2VoL2Jva2VoanMvc3JjL2pzL3BsdWdpbi1wcmVsdWRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3dlYmdsL2Jhc2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvd2ViZ2wvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvd2ViZ2wvbGluZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy93ZWJnbC9tYWluLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3dlYmdsL21hcmtlcnMuanMiLCJzcmMvdmVuZG9yL2dsb28vZ2xvbzIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gb3V0ZXIobW9kdWxlcywgY2FjaGUsIGVudHJ5KSB7XG4gIGlmIChCb2tlaCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtb2R1bGVzKSB7XG4gICAgICBCb2tlaC5yZXF1aXJlLm1vZHVsZXNbbmFtZV0gPSBtb2R1bGVzW25hbWVdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwbHVnaW4gPSBCb2tlaC5yZXF1aXJlKGVudHJ5WzBdKTtcbiAgICAgIEJva2VoLk1vZGVscy5yZWdpc3Rlcl9tb2RlbHMocGx1Z2luLm1vZGVscyk7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBcIm1vZGVsc1wiKSB7XG4gICAgICAgICAgQm9rZWhbbmFtZV0gPSBwbHVnaW5bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgQm9rZWguIFlvdSBoYXZlIHRvIGxvYWQgaXQgcHJpb3IgdG8gbG9hZGluZyBwbHVnaW5zLlwiKTtcbiAgfVxufSlcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2NvbG9yXCIpO1xuZXhwb3J0cy5CYXNlR0xHbHlwaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJyc7XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLlZFUlQgPSAnJztcbiAgICBCYXNlR0xHbHlwaC5wcm90b3R5cGUuRlJBRyA9ICcnO1xuICAgIGZ1bmN0aW9uIEJhc2VHTEdseXBoKGdsLCBnbHlwaCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMuZ2x5cGggPSBnbHlwaDtcbiAgICAgICAgdGhpcy5udmVydGljZXMgPSAwO1xuICAgICAgICB0aGlzLnNpemVfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRhdGFfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc3VhbHNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLnNldF9kYXRhX2NoYW5nZWQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiAhPT0gdGhpcy5udmVydGljZXMpIHtcbiAgICAgICAgICAgIHRoaXMubnZlcnRpY2VzID0gbjtcbiAgICAgICAgICAgIHRoaXMuc2l6ZV9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhX2NoYW5nZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLnNldF92aXN1YWxzX2NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc3VhbHNfY2hhbmdlZCA9IHRydWU7XG4gICAgfTtcbiAgICBCYXNlR0xHbHlwaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgbWFpbmdseXBoKSB7XG4gICAgICAgIHZhciBkeCwgZHksIHJlZiwgcmVmMSwgcmVmMiwgc3gsIHN5LCB0cmFucywgd3gsIHd5O1xuICAgICAgICB3eCA9IHd5ID0gMTtcbiAgICAgICAgcmVmID0gdGhpcy5nbHlwaC5yZW5kZXJlci5tYXBfdG9fc2NyZWVuKFswICogd3gsIDEgKiB3eCwgMiAqIHd4XSwgWzAgKiB3eSwgMSAqIHd5LCAyICogd3ldKSwgZHggPSByZWZbMF0sIGR5ID0gcmVmWzFdO1xuICAgICAgICB3eCA9IDEwMCAvIE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKGR4WzFdIC0gZHhbMF0pLCAxZS0xMiksIDFlMTIpO1xuICAgICAgICB3eSA9IDEwMCAvIE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKGR5WzFdIC0gZHlbMF0pLCAxZS0xMiksIDFlMTIpO1xuICAgICAgICByZWYxID0gdGhpcy5nbHlwaC5yZW5kZXJlci5tYXBfdG9fc2NyZWVuKFswICogd3gsIDEgKiB3eCwgMiAqIHd4XSwgWzAgKiB3eSwgMSAqIHd5LCAyICogd3ldKSwgZHggPSByZWYxWzBdLCBkeSA9IHJlZjFbMV07XG4gICAgICAgIGlmIChNYXRoLmFicygoZHhbMV0gLSBkeFswXSkgLSAoZHhbMl0gLSBkeFsxXSkpID4gMWUtNiB8fCBNYXRoLmFicygoZHlbMV0gLSBkeVswXSkgLSAoZHlbMl0gLSBkeVsxXSkpID4gMWUtNikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlZjIgPSBbKGR4WzFdIC0gZHhbMF0pIC8gd3gsIChkeVsxXSAtIGR5WzBdKSAvIHd5XSwgc3ggPSByZWYyWzBdLCBzeSA9IHJlZjJbMV07XG4gICAgICAgIHRyYW5zID0ge1xuICAgICAgICAgICAgcGl4ZWxfcmF0aW86IGN0eC5waXhlbF9yYXRpbyxcbiAgICAgICAgICAgIHdpZHRoOiBjdHguZ2xjYW52YXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGN0eC5nbGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBkeDogZHhbMF0gLyBzeCxcbiAgICAgICAgICAgIGR5OiBkeVswXSAvIHN5LFxuICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgc3k6IHN5XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZHJhdyhpbmRpY2VzLCBtYWluZ2x5cGgsIHRyYW5zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUdMR2x5cGg7XG59KSgpO1xuZXhwb3J0cy5saW5lX3dpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoIDwgMikge1xuICAgICAgICB3aWR0aCA9IE1hdGguc3FydCh3aWR0aCAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59O1xuZXhwb3J0cy5maWxsX2FycmF5X3dpdGhfZmxvYXQgPSBmdW5jdGlvbiAobiwgdmFsKSB7XG4gICAgdmFyIGEsIGksIGssIHJlZjtcbiAgICBhID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbjsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgIGFbaV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbmV4cG9ydHMuZmlsbF9hcnJheV93aXRoX3ZlYyA9IGZ1bmN0aW9uIChuLCBtLCB2YWwpIHtcbiAgICB2YXIgYSwgaSwgaiwgaywgbCwgcmVmLCByZWYxO1xuICAgIGEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcbiAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbjsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0gbTsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgYVtpICogbSArIGpdID0gdmFsW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbmV4cG9ydHMudmlzdWFsX3Byb3BfaXNfc2luZ3VsYXIgPSBmdW5jdGlvbiAodmlzdWFsLCBwcm9wbmFtZSkge1xuICAgIHJldHVybiB2aXN1YWxbcHJvcG5hbWVdLnNwZWMudmFsdWUgIT09IHZvaWQgMDtcbn07XG5leHBvcnRzLmF0dGFjaF9mbG9hdCA9IGZ1bmN0aW9uIChwcm9nLCB2Ym8sIGF0dF9uYW1lLCBuLCB2aXN1YWwsIG5hbWUpIHtcbiAgICB2YXIgYTtcbiAgICBpZiAoIXZpc3VhbC5kb2l0KSB7XG4gICAgICAgIHZiby51c2VkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBwcm9nLnNldF9hdHRyaWJ1dGUoYXR0X25hbWUsICdmbG9hdCcsIFswXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cG9ydHMudmlzdWFsX3Byb3BfaXNfc2luZ3VsYXIodmlzdWFsLCBuYW1lKSkge1xuICAgICAgICB2Ym8udXNlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcHJvZy5zZXRfYXR0cmlidXRlKGF0dF9uYW1lLCAnZmxvYXQnLCB2aXN1YWxbbmFtZV0udmFsdWUoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2Ym8udXNlZCA9IHRydWU7XG4gICAgICAgIGEgPSBuZXcgRmxvYXQzMkFycmF5KHZpc3VhbC5jYWNoZVtuYW1lICsgJ19hcnJheSddKTtcbiAgICAgICAgdmJvLnNldF9zaXplKG4gKiA0KTtcbiAgICAgICAgdmJvLnNldF9kYXRhKDAsIGEpO1xuICAgICAgICByZXR1cm4gcHJvZy5zZXRfYXR0cmlidXRlKGF0dF9uYW1lLCAnZmxvYXQnLCB2Ym8pO1xuICAgIH1cbn07XG5leHBvcnRzLmF0dGFjaF9jb2xvciA9IGZ1bmN0aW9uIChwcm9nLCB2Ym8sIGF0dF9uYW1lLCBuLCB2aXN1YWwsIHByZWZpeCkge1xuICAgIHZhciBhLCBhbHBoYW5hbWUsIGFscGhhcywgY29sb3JuYW1lLCBjb2xvcnMsIGksIGosIGssIGwsIG0sIHJlZiwgcmVmMSwgcmdiYTtcbiAgICBtID0gNDtcbiAgICBjb2xvcm5hbWUgPSBwcmVmaXggKyAnX2NvbG9yJztcbiAgICBhbHBoYW5hbWUgPSBwcmVmaXggKyAnX2FscGhhJztcbiAgICBpZiAoIXZpc3VhbC5kb2l0KSB7XG4gICAgICAgIHZiby51c2VkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBwcm9nLnNldF9hdHRyaWJ1dGUoYXR0X25hbWUsICd2ZWM0JywgWzAsIDAsIDAsIDBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy52aXN1YWxfcHJvcF9pc19zaW5ndWxhcih2aXN1YWwsIGNvbG9ybmFtZSkgJiYgZXhwb3J0cy52aXN1YWxfcHJvcF9pc19zaW5ndWxhcih2aXN1YWwsIGFscGhhbmFtZSkpIHtcbiAgICAgICAgdmJvLnVzZWQgPSBmYWxzZTtcbiAgICAgICAgcmdiYSA9IGNvbG9yXzEuY29sb3IycmdiYSh2aXN1YWxbY29sb3JuYW1lXS52YWx1ZSgpLCB2aXN1YWxbYWxwaGFuYW1lXS52YWx1ZSgpKTtcbiAgICAgICAgcmV0dXJuIHByb2cuc2V0X2F0dHJpYnV0ZShhdHRfbmFtZSwgJ3ZlYzQnLCByZ2JhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZiby51c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV4cG9ydHMudmlzdWFsX3Byb3BfaXNfc2luZ3VsYXIodmlzdWFsLCBjb2xvcm5hbWUpKSB7XG4gICAgICAgICAgICBjb2xvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBrLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBuOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZpc3VhbFtjb2xvcm5hbWVdLnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvcnMgPSB2aXN1YWwuY2FjaGVbY29sb3JuYW1lICsgJ19hcnJheSddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLnZpc3VhbF9wcm9wX2lzX3Npbmd1bGFyKHZpc3VhbCwgYWxwaGFuYW1lKSkge1xuICAgICAgICAgICAgYWxwaGFzID0gZXhwb3J0cy5maWxsX2FycmF5X3dpdGhfZmxvYXQobiwgdmlzdWFsW2FscGhhbmFtZV0udmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbHBoYXMgPSB2aXN1YWwuY2FjaGVbYWxwaGFuYW1lICsgJ19hcnJheSddO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IG47IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgcmdiYSA9IGNvbG9yXzEuY29sb3IycmdiYShjb2xvcnNbaV0sIGFscGhhc1tpXSk7XG4gICAgICAgICAgICBmb3IgKGogPSBsID0gMCwgcmVmMSA9IG07IDAgPD0gcmVmMSA/IGwgPCByZWYxIDogbCA+IHJlZjE7IGogPSAwIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBhW2kgKiBtICsgal0gPSByZ2JhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZiby5zZXRfc2l6ZShuICogbSAqIDQpO1xuICAgICAgICB2Ym8uc2V0X2RhdGEoMCwgYSk7XG4gICAgICAgIHJldHVybiBwcm9nLnNldF9hdHRyaWJ1dGUoYXR0X25hbWUsICd2ZWM0JywgdmJvKTtcbiAgICB9XG59O1xuIiwiLypcbkNvcHlyaWdodCBub3RpY2U6IG1hbnkgb2YgdGhlIGF3ZXNvbWUgdGVjaG5pcXVlcyBhbmQgIEdMU0wgY29kZSBjb250YWluZWQgaW5cbnRoaXMgbW9kdWxlIGFyZSBiYXNlZCBvbiB3b3JrIGJ5IE5pY29sYXMgUm91Z2llciBhcyBwYXJ0IG9mIHRoZSBHbHVtcHkgYW5kXG5WaXNweSBwcm9qZWN0cy4gVGhlIGFsZ29yaXRobXMgYXJlIHB1Ymxpc2hlZCBpblxuaHR0cDovL2pjZ3Qub3JnL3B1Ymxpc2hlZC8wMDAzLzA0LzAxLyBhbmQgaHR0cDovL2pjZ3Qub3JnL3B1Ymxpc2hlZC8wMDAyLzAyLzA4L1xuXG5UaGlzIG1vZHVsZSBjb250YWlucyBhbGwgZ2wtc3BlY2lmaWMgY29kZSB0byBhZGQgZ2wgc3VwcG9ydCBmb3IgdGhlIGdseXBocy5cbkJ5IGltcGxlbWVudGluZyBpdCBzZXBhcmV0ZWx5LCB0aGUgR0wgZnVuY3Rpb25hbGl0eSBjYW4gYmUgc3B1biBvZmYgaW4gYVxuc2VwYXJhdGUgbGlicmFyeS5cbk90aGVyIGxvY2F0aW9ucyB3aGVyZSB3ZSB3b3JrIHdpdGggR0wsIG9yIHByZXBhcmUgZm9yIEdMLXJlbmRlcmluZzpcbi0gY2FudmFzLmNvZmZlZVxuLSBwbG90LmNvZmZlZVxuLSBnbHlwaC5jb2ZmZWVcbi0gZ2x5cGhfcmVuZGVyZXIuY29mZmVlXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vbGluZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tYXJrZXJzXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhc2hBdGxhcywgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdsb28yID0gcmVxdWlyZShcImdsb28yXCIpO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2NvbG9yXCIpO1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5EYXNoQXRsYXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhc2hBdGxhcyhnbCkge1xuICAgICAgICB0aGlzLl9hdGxhcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gMjU2O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSAyNTY7XG4gICAgICAgIHRoaXMudGV4ID0gbmV3IGdsb28yLlRleHR1cmUyRChnbCk7XG4gICAgICAgIHRoaXMudGV4LnNldF93cmFwcGluZyhnbC5SRVBFQVQsIGdsLlJFUEVBVCk7XG4gICAgICAgIHRoaXMudGV4LnNldF9pbnRlcnBvbGF0aW9uKGdsLk5FQVJFU1QsIGdsLk5FQVJFU1QpO1xuICAgICAgICB0aGlzLnRleC5zZXRfc2l6ZShbdGhpcy5faGVpZ2h0LCB0aGlzLl93aWR0aF0sIGdsLlJHQkEpO1xuICAgICAgICB0aGlzLnRleC5zZXRfZGF0YShbMCwgMF0sIFt0aGlzLl9oZWlnaHQsIHRoaXMuX3dpZHRoXSwgbmV3IFVpbnQ4QXJyYXkodGhpcy5faGVpZ2h0ICogdGhpcy5fd2lkdGggKiA0KSk7XG4gICAgICAgIHRoaXMuZ2V0X2F0bGFzX2RhdGEoWzFdKTtcbiAgICB9XG4gICAgRGFzaEF0bGFzLnByb3RvdHlwZS5nZXRfYXRsYXNfZGF0YSA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBkYXRhLCBmaW5kZXhfcGVyaW9kLCBrZXksIHBlcmlvZCwgcmVmLCB4O1xuICAgICAgICBrZXkgPSBwYXR0ZXJuLmpvaW4oJy0nKTtcbiAgICAgICAgZmluZGV4X3BlcmlvZCA9IHRoaXMuX2F0bGFzW2tleV07XG4gICAgICAgIGlmIChmaW5kZXhfcGVyaW9kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMubWFrZV9wYXR0ZXJuKHBhdHRlcm4pLCBkYXRhID0gcmVmWzBdLCBwZXJpb2QgPSByZWZbMV07XG4gICAgICAgICAgICB0aGlzLnRleC5zZXRfZGF0YShbdGhpcy5faW5kZXgsIDBdLCBbMSwgdGhpcy5fd2lkdGhdLCBuZXcgVWludDhBcnJheSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGRhdGFbbF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4ICsgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpKTtcbiAgICAgICAgICAgIHRoaXMuX2F0bGFzW2tleV0gPSBbdGhpcy5faW5kZXggLyB0aGlzLl9oZWlnaHQsIHBlcmlvZF07XG4gICAgICAgICAgICB0aGlzLl9pbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hdGxhc1trZXldO1xuICAgIH07XG4gICAgRGFzaEF0bGFzLnByb3RvdHlwZS5tYWtlX3BhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICB2YXIgQywgWiwgYSwgYiwgYywgZGFzaF9lbmQsIGRhc2hfc3RhcnQsIGRhc2hfdHlwZSwgaSwgaW5kZXgsIGosIGwsIGxlbiwgbiwgcCwgcGVyaW9kLCBxLCByLCByZWYsIHJlZjEsIHJlZjIsIHYsIHZhbCwgdmFsX2F0X2luZGV4LCB4O1xuICAgICAgICBpZiAocGF0dGVybi5sZW5ndGggPiAxICYmIHBhdHRlcm4ubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uY29uY2F0KHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgICAgIHBlcmlvZCA9IDA7XG4gICAgICAgIGZvciAobCA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgIHYgPSBwYXR0ZXJuW2xdO1xuICAgICAgICAgICAgcGVyaW9kICs9IHY7XG4gICAgICAgIH1cbiAgICAgICAgQyA9IFtdO1xuICAgICAgICBjID0gMDtcbiAgICAgICAgZm9yIChpID0gcCA9IDAsIHJlZiA9IHBhdHRlcm4ubGVuZ3RoICsgMjsgcCA8IHJlZjsgaSA9IHAgKz0gMikge1xuICAgICAgICAgICAgYSA9IE1hdGgubWF4KDAuMDAwMSwgcGF0dGVybltpICUgcGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgICAgIGIgPSBNYXRoLm1heCgwLjAwMDEsIHBhdHRlcm5bKGkgKyAxKSAlIHBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgICAgICBDLnB1c2guYXBwbHkoQywgW2MsIGMgKyBhXSk7XG4gICAgICAgICAgICBjICs9IGEgKyBiO1xuICAgICAgICB9XG4gICAgICAgIG4gPSB0aGlzLl93aWR0aDtcbiAgICAgICAgWiA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIDQpO1xuICAgICAgICBmb3IgKGkgPSBxID0gMCwgcmVmMSA9IG47IDAgPD0gcmVmMSA/IHEgPCByZWYxIDogcSA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK3EgOiAtLXEpIHtcbiAgICAgICAgICAgIHggPSBwZXJpb2QgKiBpIC8gKG4gLSAxKTtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhbF9hdF9pbmRleCA9IDFlMTY7XG4gICAgICAgICAgICBmb3IgKGogPSByID0gMCwgcmVmMiA9IEMubGVuZ3RoOyAwIDw9IHJlZjIgPyByIDwgcmVmMiA6IHIgPiByZWYyOyBqID0gMCA8PSByZWYyID8gKytyIDogLS1yKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gTWF0aC5hYnMoQ1tqXSAtIHgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPCB2YWxfYXRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICB2YWxfYXRfaW5kZXggPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRhc2hfdHlwZSA9IHggPD0gQ1tpbmRleF0gPyArMSA6IDA7XG4gICAgICAgICAgICAgICAgZGFzaF9zdGFydCA9IENbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGRhc2hfZW5kID0gQ1tpbmRleCArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFzaF90eXBlID0geCA+IENbaW5kZXhdID8gLTEgOiAwO1xuICAgICAgICAgICAgICAgIGRhc2hfc3RhcnQgPSBDW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZGFzaF9lbmQgPSBDW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFpbaSAqIDQgKyAwXSA9IENbaW5kZXhdO1xuICAgICAgICAgICAgWltpICogNCArIDFdID0gZGFzaF90eXBlO1xuICAgICAgICAgICAgWltpICogNCArIDJdID0gZGFzaF9zdGFydDtcbiAgICAgICAgICAgIFpbaSAqIDQgKyAzXSA9IGRhc2hfZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbWiwgcGVyaW9kXTtcbiAgICB9O1xuICAgIHJldHVybiBEYXNoQXRsYXM7XG59KSgpO1xuZXhwb3J0cy5MaW5lR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMaW5lR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZUdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBMaW5lR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ2xpbmUnO1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5KT0lOUyA9IHtcbiAgICAgICAgJ21pdGVyJzogMCxcbiAgICAgICAgJ3JvdW5kJzogMSxcbiAgICAgICAgJ2JldmVsJzogMlxuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLkNBUFMgPSB7XG4gICAgICAgICcnOiAwLFxuICAgICAgICAnbm9uZSc6IDAsXG4gICAgICAgICcuJzogMCxcbiAgICAgICAgJ3JvdW5kJzogMSxcbiAgICAgICAgJyknOiAxLFxuICAgICAgICAnKCc6IDEsXG4gICAgICAgICdvJzogMSxcbiAgICAgICAgJ3RyaWFuZ2xlIGluJzogMixcbiAgICAgICAgJzwnOiAyLFxuICAgICAgICAndHJpYW5nbGUgb3V0JzogMyxcbiAgICAgICAgJz4nOiAzLFxuICAgICAgICAnc3F1YXJlJzogNCxcbiAgICAgICAgJ1snOiA0LFxuICAgICAgICAnXSc6IDQsXG4gICAgICAgICc9JzogNCxcbiAgICAgICAgJ2J1dHQnOiA1LFxuICAgICAgICAnfCc6IDVcbiAgICB9O1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5WRVJUID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQ7XFxuY29uc3QgZmxvYXQgVEhFVEEgPSAxNS4wICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NC8xODAuMDtcXG5cXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfY2FudmFzX3NpemUsIHVfb2Zmc2V0O1xcbnVuaWZvcm0gdmVjMiB1X3NjYWxlX2FzcGVjdDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfbGVuZ3RoO1xcblxcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9hbnRpYWxpYXM7XFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aDtcXG51bmlmb3JtIGZsb2F0IHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgdV9kYXNoX2luZGV4O1xcbnVuaWZvcm0gZmxvYXQgdV9jbG9zZWQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RhbmdlbnRzO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfc2VnbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiBhX2FuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcblxcbnZhcnlpbmcgdmVjNCAgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgIHZfc2VnbWVudDtcXG52YXJ5aW5nIHZlYzIgIHZfYW5nbGVzO1xcbnZhcnlpbmcgdmVjMiAgdl90ZXhjb29yZDtcXG52YXJ5aW5nIHZlYzIgIHZfbWl0ZXI7XFxudmFyeWluZyBmbG9hdCB2X2xlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXdpZHRoO1xcblxcbmZsb2F0IGNyb3NzKGluIHZlYzIgdjEsIGluIHZlYzIgdjIpXFxue1xcbiAgICByZXR1cm4gdjEueCp2Mi55IC0gdjEueSp2Mi54O1xcbn1cXG5cXG5mbG9hdCBzaWduZWRfZGlzdGFuY2UoaW4gdmVjMiB2MSwgaW4gdmVjMiB2MiwgaW4gdmVjMiB2MylcXG57XFxuICAgIHJldHVybiBjcm9zcyh2Mi12MSx2MS12MykgLyBsZW5ndGgodjItdjEpO1xcbn1cXG5cXG52b2lkIHJvdGF0ZSggaW4gdmVjMiB2LCBpbiBmbG9hdCBhbHBoYSwgb3V0IHZlYzIgcmVzdWx0IClcXG57XFxuICAgIGZsb2F0IGMgPSBjb3MoYWxwaGEpO1xcbiAgICBmbG9hdCBzID0gc2luKGFscGhhKTtcXG4gICAgcmVzdWx0ID0gdmVjMiggYyp2LnggLSBzKnYueSxcXG4gICAgICAgICAgICAgICAgICAgcyp2LnggKyBjKnYueSApO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgYm9vbCBjbG9zZWQgPSAodV9jbG9zZWQgPiAwLjApO1xcblxcbiAgICAvLyBBdHRyaWJ1dGVzIGFuZCB1bmlmb3JtcyB0byB2YXJ5aW5nc1xcbiAgICB2X2NvbG9yID0gdV9jb2xvcjtcXG4gICAgdl9saW5ld2lkdGggPSB1X2xpbmV3aWR0aDtcXG4gICAgdl9zZWdtZW50ID0gYV9zZWdtZW50ICogdV9zY2FsZV9sZW5ndGg7XFxuICAgIHZfbGVuZ3RoID0gdV9sZW5ndGggKiB1X3NjYWxlX2xlbmd0aDtcXG5cXG4gICAgLy8gU2NhbGUgdG8gbWFwIHRvIHBpeGVsIGNvb3JkaW5hdGVzLiBUaGUgb3JpZ2luYWwgYWxnb3JpdGhtIGZyb20gdGhlIHBhcGVyXFxuICAgIC8vIGFzc3VtZWQgaXNvdHJvcGljIHNjYWxlLiBXZSBvYnZpb3VzbHkgZG8gbm90IGhhdmUgdGhpcy5cXG4gICAgdmVjMiBhYnNfc2NhbGVfYXNwZWN0ID0gYWJzKHVfc2NhbGVfYXNwZWN0KTtcXG4gICAgdmVjMiBhYnNfc2NhbGUgPSB1X3NjYWxlX2xlbmd0aCAqIGFic19zY2FsZV9hc3BlY3Q7XFxuXFxuICAgIC8vIENvcnJlY3QgYW5nbGVzIGZvciBhc3BlY3QgcmF0aW9cXG4gICAgdmVjMiBhdjtcXG4gICAgYXYgPSB2ZWMyKDEuMCwgdGFuKGFfYW5nbGVzLngpKSAvIGFic19zY2FsZV9hc3BlY3Q7XFxuICAgIHZfYW5nbGVzLnggPSBhdGFuKGF2LnksIGF2LngpO1xcbiAgICBhdiA9IHZlYzIoMS4wLCB0YW4oYV9hbmdsZXMueSkpIC8gYWJzX3NjYWxlX2FzcGVjdDtcXG4gICAgdl9hbmdsZXMueSA9IGF0YW4oYXYueSwgYXYueCk7XFxuXFxuICAgIC8vIFRoaWNrbmVzcyBiZWxvdyAxIHBpeGVsIGFyZSByZXByZXNlbnRlZCB1c2luZyBhIDEgcGl4ZWwgdGhpY2tuZXNzXFxuICAgIC8vIGFuZCBhIG1vZGlmaWVkIGFscGhhXFxuICAgIHZfY29sb3IuYSA9IG1pbih2X2xpbmV3aWR0aCwgdl9jb2xvci5hKTtcXG4gICAgdl9saW5ld2lkdGggPSBtYXgodl9saW5ld2lkdGgsIDEuMCk7XFxuXFxuICAgIC8vIElmIGNvbG9yIGlzIGZ1bGx5IHRyYW5zcGFyZW50IHdlIGp1c3Qgd2lsbCBkaXNjYXJkIHRoZSBmcmFnbWVudCBhbnl3YXlcXG4gICAgaWYoIHZfY29sb3IuYSA8PSAwLjAgKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLDAuMCwwLjAsMS4wKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBUaGlzIGlzIHRoZSBhY3R1YWwgaGFsZiB3aWR0aCBvZiB0aGUgbGluZVxcbiAgICBmbG9hdCB3ID0gY2VpbCh1X2FudGlhbGlhcyt2X2xpbmV3aWR0aCkvMi4wO1xcblxcbiAgICB2ZWMyIHBvc2l0aW9uID0gKGFfcG9zaXRpb24gKyB1X29mZnNldCkgKiBhYnNfc2NhbGU7XFxuXFxuICAgIHZlYzIgdDEgPSBub3JtYWxpemUoYV90YW5nZW50cy54eSAqIGFic19zY2FsZV9hc3BlY3QpOyAgLy8gbm90ZSB0aGUgc2NhbGluZyBmb3IgYXNwZWN0IHJhdGlvIGhlcmVcXG4gICAgdmVjMiB0MiA9IG5vcm1hbGl6ZShhX3RhbmdlbnRzLnp3ICogYWJzX3NjYWxlX2FzcGVjdCk7XFxuICAgIGZsb2F0IHUgPSBhX3RleGNvb3JkLng7XFxuICAgIGZsb2F0IHYgPSBhX3RleGNvb3JkLnk7XFxuICAgIHZlYzIgbzEgPSB2ZWMyKCArdDEueSwgLXQxLngpO1xcbiAgICB2ZWMyIG8yID0gdmVjMiggK3QyLnksIC10Mi54KTtcXG5cXG4gICAgLy8gVGhpcyBpcyBhIGpvaW5cXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBpZiggdDEgIT0gdDIgKSB7XFxuICAgICAgICBmbG9hdCBhbmdsZSA9IGF0YW4gKHQxLngqdDIueS10MS55KnQyLngsIHQxLngqdDIueCt0MS55KnQyLnkpOyAgLy8gQW5nbGUgbmVlZHMgcmVjYWxjdWxhdGlvbiBmb3Igc29tZSByZWFzb25cXG4gICAgICAgIHZlYzIgdCAgPSBub3JtYWxpemUodDErdDIpO1xcbiAgICAgICAgdmVjMiBvICA9IHZlYzIoICsgdC55LCAtIHQueCk7XFxuXFxuICAgICAgICBpZiAoIHVfZGFzaF9pbmRleCA+IDAuMCApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgLy8gQnJva2VuIGFuZ2xlXFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgICAgIGlmKCAoYWJzKGFuZ2xlKSA+IFRIRVRBKSApIHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdiAqIHcgKiBvIC8gY29zKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBzaWduKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgaWYoIGFuZ2xlIDwgMC4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYoIHUgPT0gKzEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gdl9zZWdtZW50LnkgKyB2ICogdyAqIHRhbihhbmdsZS8yLjApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB2ID09IDEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gMi4wICogdyAqIHQxIC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSAtPSAyLjAgKiB3IC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueCAtIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHYgPT0gMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyLjAgKiB3ICogdDIgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ICs9IDIuMCp3IC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiggdSA9PSArMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueSArIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHYgPT0gLTEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMi4wICogdyAqIHQxIC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSArPSAyLjAgKiB3IC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueCAtIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHYgPT0gLTEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gMi4wICogdyAqIHQyIC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSAtPSAyLjAqdyAvIHNpbihhbmdsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVvdXMgYW5nbGVcXG4gICAgICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdiAqIHcgKiBvIC8gY29zKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgIGlmKCB1ID09ICsxLjAgKSB1ID0gdl9zZWdtZW50Lnk7XFxuICAgICAgICAgICAgICAgIGVsc2UgICAgICAgICAgICB1ID0gdl9zZWdtZW50Lng7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gU29saWQgbGluZVxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgICAgIGVsc2VcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi54eSArPSB2ICogdyAqIG8gLyBjb3MoYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICBpZiggYW5nbGUgPCAwLjAgKSB7XFxuICAgICAgICAgICAgICAgIGlmKCB1ID09ICsxLjAgKSB7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gdl9zZWdtZW50LnkgKyB2ICogdyAqIHRhbihhbmdsZS8yLjApO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdSA9IHZfc2VnbWVudC54IC0gdiAqIHcgKiB0YW4oYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmKCB1ID09ICsxLjAgKSB7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gdl9zZWdtZW50LnkgKyB2ICogdyAqIHRhbihhbmdsZS8yLjApO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdSA9IHZfc2VnbWVudC54IC0gdiAqIHcgKiB0YW4oYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgLy8gVGhpcyBpcyBhIGxpbmUgc3RhcnQgb3IgZW5kICh0MSA9PSB0MilcXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBwb3NpdGlvbiArPSB2ICogdyAqIG8xO1xcbiAgICAgICAgaWYoIHUgPT0gLTEuMCApIHtcXG4gICAgICAgICAgICB1ID0gdl9zZWdtZW50LnggLSB3O1xcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IHcgKiB0MTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdSA9IHZfc2VnbWVudC55ICsgdztcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSB3ICogdDI7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gTWl0ZXIgZGlzdGFuY2VcXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIHZlYzIgdDtcXG4gICAgdmVjMiBjdXJyID0gYV9wb3NpdGlvbiAqIGFic19zY2FsZTtcXG4gICAgaWYoIGFfdGV4Y29vcmQueCA8IDAuMCApIHtcXG4gICAgICAgIHZlYzIgbmV4dCA9IGN1cnIgKyB0Mioodl9zZWdtZW50Lnktdl9zZWdtZW50LngpO1xcblxcbiAgICAgICAgcm90YXRlKCB0MSwgK3ZfYW5nbGVzLngvMi4wLCB0KTtcXG4gICAgICAgIHZfbWl0ZXIueCA9IHNpZ25lZF9kaXN0YW5jZShjdXJyLCBjdXJyK3QsIHBvc2l0aW9uKTtcXG5cXG4gICAgICAgIHJvdGF0ZSggdDIsICt2X2FuZ2xlcy55LzIuMCwgdCk7XFxuICAgICAgICB2X21pdGVyLnkgPSBzaWduZWRfZGlzdGFuY2UobmV4dCwgbmV4dCt0LCBwb3NpdGlvbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2ZWMyIHByZXYgPSBjdXJyIC0gdDEqKHZfc2VnbWVudC55LXZfc2VnbWVudC54KTtcXG5cXG4gICAgICAgIHJvdGF0ZSggdDEsIC12X2FuZ2xlcy54LzIuMCx0KTtcXG4gICAgICAgIHZfbWl0ZXIueCA9IHNpZ25lZF9kaXN0YW5jZShwcmV2LCBwcmV2K3QsIHBvc2l0aW9uKTtcXG5cXG4gICAgICAgIHJvdGF0ZSggdDIsIC12X2FuZ2xlcy55LzIuMCx0KTtcXG4gICAgICAgIHZfbWl0ZXIueSA9IHNpZ25lZF9kaXN0YW5jZShjdXJyLCBjdXJyK3QsIHBvc2l0aW9uKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIWNsb3NlZCAmJiB2X3NlZ21lbnQueCA8PSAwLjApIHtcXG4gICAgICAgIHZfbWl0ZXIueCA9IDFlMTA7XFxuICAgIH1cXG4gICAgaWYgKCFjbG9zZWQgJiYgdl9zZWdtZW50LnkgPj0gdl9sZW5ndGgpXFxuICAgIHtcXG4gICAgICAgIHZfbWl0ZXIueSA9IDFlMTA7XFxuICAgIH1cXG5cXG4gICAgdl90ZXhjb29yZCA9IHZlYzIoIHUsIHYqdyApO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaW4gZGV2aWNlIGNvb3JkaW5hdGVzLiBOb3RlIHRoYXQgd2VcXG4gICAgLy8gYWxyZWFkeSBzY2FsZWQgd2l0aCBhYnMgc2NhbGUgYWJvdmUuXFxuICAgIHZlYzIgbm9ybXBvcyA9IHBvc2l0aW9uICogc2lnbih1X3NjYWxlX2FzcGVjdCk7XFxuICAgIG5vcm1wb3MgKz0gMC41OyAgLy8gbWFrZSB1cCBmb3IgQm9rZWgncyBvZmZzZXRcXG4gICAgbm9ybXBvcyAvPSB1X2NhbnZhc19zaXplIC8gdV9waXhlbF9yYXRpbzsgIC8vIGluIDAuLjFcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG5vcm1wb3MqMi4wLTEuMCwgMC4wLCAxLjApO1xcbiAgICBnbF9Qb3NpdGlvbi55ICo9IC0xLjA7XFxufVxcblwiO1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5GUkFHXyA9IFwiLy8gRnJhZ21lbnQgc2hhZGVyIHRoYXQgY2FuIGJlIGNvbnZlbmllbnQgZHVyaW5nIGRlYnVnZ2luZyB0byBzaG93IHRoZSBsaW5lIHNrZWxldG9uLlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCAgdV9jb2xvcjtcXG52b2lkIG1haW4gKCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG59XCI7XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLkZSQUcgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDtcXG5jb25zdCBmbG9hdCBUSEVUQSA9IDE1LjAgKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0LzE4MC4wO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZGFzaF9hdGxhcztcXG5cXG51bmlmb3JtIHZlYzIgdV9saW5lY2FwcztcXG51bmlmb3JtIGZsb2F0IHVfbWl0ZXJfbGltaXQ7XFxudW5pZm9ybSBmbG9hdCB1X2xpbmVqb2luO1xcbnVuaWZvcm0gZmxvYXQgdV9hbnRpYWxpYXM7XFxudW5pZm9ybSBmbG9hdCB1X2Rhc2hfcGhhc2U7XFxudW5pZm9ybSBmbG9hdCB1X2Rhc2hfcGVyaW9kO1xcbnVuaWZvcm0gZmxvYXQgdV9kYXNoX2luZGV4O1xcbnVuaWZvcm0gdmVjMiB1X2Rhc2hfY2FwcztcXG51bmlmb3JtIGZsb2F0IHVfY2xvc2VkO1xcblxcbnZhcnlpbmcgdmVjNCAgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgIHZfc2VnbWVudDtcXG52YXJ5aW5nIHZlYzIgIHZfYW5nbGVzO1xcbnZhcnlpbmcgdmVjMiAgdl90ZXhjb29yZDtcXG52YXJ5aW5nIHZlYzIgIHZfbWl0ZXI7XFxudmFyeWluZyBmbG9hdCB2X2xlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXdpZHRoO1xcblxcbi8vIENvbXB1dGUgZGlzdGFuY2UgdG8gY2FwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5mbG9hdCBjYXAoIGludCB0eXBlLCBmbG9hdCBkeCwgZmxvYXQgZHksIGZsb2F0IHQsIGZsb2F0IGxpbmV3aWR0aCApXFxue1xcbiAgICBmbG9hdCBkID0gMC4wO1xcbiAgICBkeCA9IGFicyhkeCk7XFxuICAgIGR5ID0gYWJzKGR5KTtcXG4gICAgaWYgICAgICAodHlwZSA9PSAwKSAgZGlzY2FyZDsgIC8vIE5vbmVcXG4gICAgZWxzZSBpZiAodHlwZSA9PSAxKSAgZCA9IHNxcnQoZHgqZHgrZHkqZHkpOyAgLy8gUm91bmRcXG4gICAgZWxzZSBpZiAodHlwZSA9PSAzKSAgZCA9IChkeCthYnMoZHkpKTsgIC8vIFRyaWFuZ2xlIGluXFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgIGQgPSBtYXgoYWJzKGR5KSwodCtkeC1hYnMoZHkpKSk7ICAvLyBUcmlhbmdsZSBvdXRcXG4gICAgZWxzZSBpZiAodHlwZSA9PSA0KSAgZCA9IG1heChkeCxkeSk7ICAvLyBTcXVhcmVcXG4gICAgZWxzZSBpZiAodHlwZSA9PSA1KSAgZCA9IG1heChkeCt0LGR5KTsgIC8vIEJ1dHRcXG4gICAgcmV0dXJuIGQ7XFxufVxcblxcbi8vIENvbXB1dGUgZGlzdGFuY2UgdG8gam9pbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuZmxvYXQgam9pbiggaW4gaW50IHR5cGUsIGluIGZsb2F0IGQsIGluIHZlYzIgc2VnbWVudCwgaW4gdmVjMiB0ZXhjb29yZCwgaW4gdmVjMiBtaXRlcixcXG4gICAgICAgICAgIGluIGZsb2F0IGxpbmV3aWR0aCApXFxue1xcbiAgICAvLyB0ZXhjb29yZC54IGlzIGRpc3RhbmNlIGZyb20gc3RhcnRcXG4gICAgLy8gdGV4Y29vcmQueSBpcyBkaXN0YW5jZSBmcm9tIGNlbnRlcmxpbmVcXG4gICAgLy8gc2VnbWVudC54IGFuZCB5IGluZGljYXRlIHRoZSBsaW1pdHMgKGFzIGZvciB0ZXhjb29yZC54KSBmb3IgdGhpcyBzZWdtZW50XFxuXFxuICAgIGZsb2F0IGR4ID0gdGV4Y29vcmQueDtcXG5cXG4gICAgLy8gUm91bmQgam9pblxcbiAgICBpZiggdHlwZSA9PSAxICkge1xcbiAgICAgICAgaWYgKGR4IDwgc2VnbWVudC54KSB7XFxuICAgICAgICAgICAgZCA9IG1heChkLGxlbmd0aCggdGV4Y29vcmQgLSB2ZWMyKHNlZ21lbnQueCwwLjApKSk7XFxuICAgICAgICAgICAgLy9kID0gbGVuZ3RoKCB0ZXhjb29yZCAtIHZlYzIoc2VnbWVudC54LDAuMCkpO1xcbiAgICAgICAgfSBlbHNlIGlmIChkeCA+IHNlZ21lbnQueSkge1xcbiAgICAgICAgICAgIGQgPSBtYXgoZCxsZW5ndGgoIHRleGNvb3JkIC0gdmVjMihzZWdtZW50LnksMC4wKSkpO1xcbiAgICAgICAgICAgIC8vZCA9IGxlbmd0aCggdGV4Y29vcmQgLSB2ZWMyKHNlZ21lbnQueSwwLjApKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBCZXZlbCBqb2luXFxuICAgIGVsc2UgaWYgKCB0eXBlID09IDIgKSB7XFxuICAgICAgICBpZiAoZHggPCBzZWdtZW50LngpIHtcXG4gICAgICAgICAgICB2ZWMyIHggPSB0ZXhjb29yZCAtIHZlYzIoc2VnbWVudC54LDAuMCk7XFxuICAgICAgICAgICAgZCA9IG1heChkLCBtYXgoYWJzKHgueCksIGFicyh4LnkpKSk7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGR4ID4gc2VnbWVudC55KSB7XFxuICAgICAgICAgICAgdmVjMiB4ID0gdGV4Y29vcmQgLSB2ZWMyKHNlZ21lbnQueSwwLjApO1xcbiAgICAgICAgICAgIGQgPSBtYXgoZCwgbWF4KGFicyh4LngpLCBhYnMoeC55KSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyogIE9yaWdpbmFsIGNvZGUgZm9yIGJldmVsIHdoaWNoIGRvZXMgbm90IHdvcmsgZm9yIHVzXFxuICAgICAgICBpZiggKGR4IDwgc2VnbWVudC54KSB8fCAgKGR4ID4gc2VnbWVudC55KSApXFxuICAgICAgICAgICAgZCA9IG1heChkLCBtaW4oYWJzKHgueCksYWJzKHgueSkpKTtcXG4gICAgICAgICovXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGQ7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICAvLyBJZiBjb2xvciBpcyBmdWxseSB0cmFuc3BhcmVudCB3ZSBqdXN0IGRpc2NhcmQgdGhlIGZyYWdtZW50XFxuICAgIGlmKCB2X2NvbG9yLmEgPD0gMC4wICkge1xcbiAgICAgICAgZGlzY2FyZDtcXG4gICAgfVxcblxcbiAgICAvLyBUZXN0IGlmIGRhc2ggcGF0dGVybiBpcyB0aGUgc29saWQgb25lICgwKVxcbiAgICBib29sIHNvbGlkID0gICh1X2Rhc2hfaW5kZXggPT0gMC4wKTtcXG5cXG4gICAgLy8gVGVzdCBpZiBwYXRoIGlzIGNsb3NlZFxcbiAgICBib29sIGNsb3NlZCA9ICh1X2Nsb3NlZCA+IDAuMCk7XFxuXFxuICAgIHZlYzQgY29sb3IgPSB2X2NvbG9yO1xcbiAgICBmbG9hdCBkeCA9IHZfdGV4Y29vcmQueDtcXG4gICAgZmxvYXQgZHkgPSB2X3RleGNvb3JkLnk7XFxuICAgIGZsb2F0IHQgPSB2X2xpbmV3aWR0aC8yLjAtdV9hbnRpYWxpYXM7XFxuICAgIGZsb2F0IHdpZHRoID0gMS4wOyAgLy92X2xpbmV3aWR0aDsgb3JpZ2luYWwgY29kZSBoYWQgZGFzaGVzIHNjYWxlIHdpdGggbGluZSB3aWR0aCwgd2UgZG8gbm90XFxuICAgIGZsb2F0IGQgPSAwLjA7XFxuXFxuICAgIHZlYzIgbGluZWNhcHMgPSB1X2xpbmVjYXBzO1xcbiAgICB2ZWMyIGRhc2hfY2FwcyA9IHVfZGFzaF9jYXBzO1xcbiAgICBmbG9hdCBsaW5lX3N0YXJ0ID0gMC4wO1xcbiAgICBmbG9hdCBsaW5lX3N0b3AgPSB2X2xlbmd0aDtcXG5cXG4gICAgLy8gQXBwbHkgbWl0ZXIgbGltaXQ7IGZyYWdtZW50cyB0b28gZmFyIGludG8gdGhlIG1pdGVyIGFyZSBzaW1wbHkgZGlzY2FyZGVkXFxuICAgIGlmKCAoZHggPCB2X3NlZ21lbnQueCkgfHwgKGR4ID4gdl9zZWdtZW50LnkpICkge1xcbiAgICAgICAgZmxvYXQgaW50b19taXRlciA9IG1heCh2X3NlZ21lbnQueCAtIGR4LCBkeCAtIHZfc2VnbWVudC55KTtcXG4gICAgICAgIGlmIChpbnRvX21pdGVyID4gdV9taXRlcl9saW1pdCp2X2xpbmV3aWR0aC8yLjApXFxuICAgICAgICAgIGRpc2NhcmQ7XFxuICAgIH1cXG5cXG4gICAgLy8gU29saWQgbGluZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBpZiggc29saWQgKSB7XFxuICAgICAgICBkID0gYWJzKGR5KTtcXG4gICAgICAgIGlmKCAoIWNsb3NlZCkgJiYgKGR4IDwgbGluZV9zdGFydCkgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KHVfbGluZWNhcHMueCksIGFicyhkeCksIGFicyhkeSksIHQsIHZfbGluZXdpZHRoICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKCAoIWNsb3NlZCkgJiYgIChkeCA+IGxpbmVfc3RvcCkgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KHVfbGluZWNhcHMueSksIGFicyhkeCktbGluZV9zdG9wLCBhYnMoZHkpLCB0LCB2X2xpbmV3aWR0aCApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgZCA9IGpvaW4oIGludCh1X2xpbmVqb2luKSwgYWJzKGR5KSwgdl9zZWdtZW50LCB2X3RleGNvb3JkLCB2X21pdGVyLCB2X2xpbmV3aWR0aCApO1xcbiAgICAgICAgfVxcblxcbiAgICAvLyBEYXNoIGxpbmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRfc3RhcnQgPSB2X3NlZ21lbnQueDtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRfc3RvcCAgPSB2X3NlZ21lbnQueTtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRfY2VudGVyPSAoc2VnbWVudF9zdGFydCtzZWdtZW50X3N0b3ApLzIuMDtcXG4gICAgICAgIGZsb2F0IGZyZXEgICAgICAgICAgPSB1X2Rhc2hfcGVyaW9kKndpZHRoO1xcbiAgICAgICAgZmxvYXQgdSA9IG1vZCggZHggKyB1X2Rhc2hfcGhhc2Uqd2lkdGgsIGZyZXEpO1xcbiAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodV9kYXNoX2F0bGFzLCB2ZWMyKHUvZnJlcSwgdV9kYXNoX2luZGV4KSkgKiAyNTUuMCAtMTAuMDsgIC8vIGNvbnZlcnNpb24gdG8gaW50LWxpa2VcXG4gICAgICAgIGZsb2F0IGRhc2hfY2VudGVyPSB0ZXgueCAqIHdpZHRoO1xcbiAgICAgICAgZmxvYXQgZGFzaF90eXBlICA9IHRleC55O1xcbiAgICAgICAgZmxvYXQgX3N0YXJ0ID0gdGV4LnogKiB3aWR0aDtcXG4gICAgICAgIGZsb2F0IF9zdG9wICA9IHRleC5hICogd2lkdGg7XFxuICAgICAgICBmbG9hdCBkYXNoX3N0YXJ0ID0gZHggLSB1ICsgX3N0YXJ0O1xcbiAgICAgICAgZmxvYXQgZGFzaF9zdG9wICA9IGR4IC0gdSArIF9zdG9wO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbnRzIG9mIHRoZSBmaXJzdCBkYXNoICh0aGUgb25lIHJlbGF0aXZlIHRvIHZfc2VnbWVudC54KVxcbiAgICAgICAgLy8gTm90ZTogdGhpcyBjb3VsZCBiZSBjb21wdXRlZCBpbiB0aGUgdmVydGV4IHNoYWRlclxcbiAgICAgICAgaWYoIChkYXNoX3N0b3AgPCBzZWdtZW50X3N0YXJ0KSAmJiAoZGFzaF9jYXBzLnggIT0gNS4wKSApIHtcXG4gICAgICAgICAgICBmbG9hdCB1ID0gbW9kKHNlZ21lbnRfc3RhcnQgKyB1X2Rhc2hfcGhhc2Uqd2lkdGgsIGZyZXEpO1xcbiAgICAgICAgICAgIHZlYzQgdGV4ID0gdGV4dHVyZTJEKHVfZGFzaF9hdGxhcywgdmVjMih1L2ZyZXEsIHVfZGFzaF9pbmRleCkpICogMjU1LjAgLTEwLjA7ICAvLyBjb252ZXJzaW9uIHRvIGludC1saWtlXFxuICAgICAgICAgICAgZGFzaF9jZW50ZXI9IHRleC54ICogd2lkdGg7XFxuICAgICAgICAgICAgLy9kYXNoX3R5cGUgID0gdGV4Lnk7XFxuICAgICAgICAgICAgZmxvYXQgX3N0YXJ0ID0gdGV4LnogKiB3aWR0aDtcXG4gICAgICAgICAgICBmbG9hdCBfc3RvcCAgPSB0ZXguYSAqIHdpZHRoO1xcbiAgICAgICAgICAgIGRhc2hfc3RhcnQgPSBzZWdtZW50X3N0YXJ0IC0gdSArIF9zdGFydDtcXG4gICAgICAgICAgICBkYXNoX3N0b3AgPSBzZWdtZW50X3N0YXJ0IC0gdSArIF9zdG9wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbnRzIG9mIHRoZSBsYXN0IGRhc2ggKHRoZSBvbmUgcmVsYXRpdmVzIHRvIHZfc2VnbWVudC55KVxcbiAgICAgICAgLy8gTm90ZTogVGhpcyBjb3VsZCBiZSBjb21wdXRlZCBpbiB0aGUgdmVydGV4IHNoYWRlclxcbiAgICAgICAgZWxzZSBpZiggKGRhc2hfc3RhcnQgPiBzZWdtZW50X3N0b3ApICAmJiAoZGFzaF9jYXBzLnkgIT0gNS4wKSApIHtcXG4gICAgICAgICAgICBmbG9hdCB1ID0gbW9kKHNlZ21lbnRfc3RvcCArIHVfZGFzaF9waGFzZSp3aWR0aCwgZnJlcSk7XFxuICAgICAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodV9kYXNoX2F0bGFzLCB2ZWMyKHUvZnJlcSwgdV9kYXNoX2luZGV4KSkgKiAyNTUuMCAtMTAuMDsgIC8vIGNvbnZlcnNpb24gdG8gaW50LWxpa2VcXG4gICAgICAgICAgICBkYXNoX2NlbnRlcj0gdGV4LnggKiB3aWR0aDtcXG4gICAgICAgICAgICAvL2Rhc2hfdHlwZSAgPSB0ZXgueTtcXG4gICAgICAgICAgICBmbG9hdCBfc3RhcnQgPSB0ZXgueiAqIHdpZHRoO1xcbiAgICAgICAgICAgIGZsb2F0IF9zdG9wICA9IHRleC5hICogd2lkdGg7XFxuICAgICAgICAgICAgZGFzaF9zdGFydCA9IHNlZ21lbnRfc3RvcCAtIHUgKyBfc3RhcnQ7XFxuICAgICAgICAgICAgZGFzaF9zdG9wICA9IHNlZ21lbnRfc3RvcCAtIHUgKyBfc3RvcDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFRoaXMgdGVzdCBpZiB0aGUgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIGRpc2NvbnRpbnVvdXMgYW5nbGVcXG4gICAgICAgIGJvb2wgZGlzY29udGludW91cyA9ICgoZHggPCAgc2VnbWVudF9jZW50ZXIpICYmIGFicyh2X2FuZ2xlcy54KSA+IFRIRVRBKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChkeCA+PSBzZWdtZW50X2NlbnRlcikgJiYgYWJzKHZfYW5nbGVzLnkpID4gVEhFVEEpO1xcbiAgICAgICAgLy9pZiggZHggPCBsaW5lX3N0YXJ0KSBkaXNjb250aW51b3VzID0gZmFsc2U7XFxuICAgICAgICAvL2lmKCBkeCA+IGxpbmVfc3RvcCkgIGRpc2NvbnRpbnVvdXMgPSBmYWxzZTtcXG5cXG4gICAgICAgIGZsb2F0IGRfam9pbiA9IGpvaW4oIGludCh1X2xpbmVqb2luKSwgYWJzKGR5KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdl9zZWdtZW50LCB2X3RleGNvb3JkLCB2X21pdGVyLCB2X2xpbmV3aWR0aCApO1xcblxcbiAgICAgICAgLy8gV2hlbiBwYXRoIGlzIGNsb3NlZCwgd2UgZG8gbm90IGhhdmUgcm9vbSBmb3IgbGluZWNhcHMsIHNvIHdlIG1ha2Ugcm9vbVxcbiAgICAgICAgLy8gYnkgc2hvcnRlbmluZyB0aGUgdG90YWwgbGVuZ3RoXFxuICAgICAgICBpZiAoY2xvc2VkKSB7XFxuICAgICAgICAgICAgIGxpbmVfc3RhcnQgKz0gdl9saW5ld2lkdGgvMi4wO1xcbiAgICAgICAgICAgICBsaW5lX3N0b3AgIC09IHZfbGluZXdpZHRoLzIuMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byB0YWtlIGFudGlhbGlhcyBhcmVhIGludG8gYWNjb3VudFxcbiAgICAgICAgLy9saW5lX3N0YXJ0ICs9IHVfYW50aWFsaWFzO1xcbiAgICAgICAgLy9saW5lX3N0b3AgIC09IHVfYW50aWFsaWFzO1xcblxcbiAgICAgICAgLy8gQ2hlY2sgaXMgZGFzaCBzdG9wIGlzIGJlZm9yZSBsaW5lIHN0YXJ0XFxuICAgICAgICBpZiggZGFzaF9zdG9wIDw9IGxpbmVfc3RhcnQgKSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIENoZWNrIGlzIGRhc2ggc3RhcnQgaXMgYmV5b25kIGxpbmUgc3RvcFxcbiAgICAgICAgaWYoIGRhc2hfc3RhcnQgPj0gbGluZV9zdG9wICkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGRhc2ggc3RhcnQgaXMgYmV5b25kIHNlZ21lbnQgc3RvcFxcbiAgICAgICAgaWYoIGRpc2NvbnRpbnVvdXMgKSB7XFxuICAgICAgICAgICAgLy8gRGFzaCBzdGFydCBpcyBiZXlvbmQgc2VnbWVudCwgd2UgZGlzY2FyZFxcbiAgICAgICAgICAgIGlmKCAoZGFzaF9zdGFydCA+IHNlZ21lbnRfc3RvcCkgKSB7XFxuICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgICAgIC8vZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsMC4wLDAuMCwuMjUpOyByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIERhc2ggc3RvcCBpcyBiZWZvcmUgc2VnbWVudCwgd2UgZGlzY2FyZFxcbiAgICAgICAgICAgIGlmKCAoZGFzaF9zdG9wIDwgc2VnbWVudF9zdGFydCkgKSB7XFxuICAgICAgICAgICAgICAgIGRpc2NhcmQ7ICAvL2dsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLDEuMCwwLjAsLjI1KTsgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJvdW5kIGNhcHMgKG5pY2VyIHdpdGggdGhpcylcXG4gICAgICAgICAgICBpZiggZGFzaF9jYXBzLnggPT0gMS4wICkge1xcbiAgICAgICAgICAgICAgICBpZiggKHUgPiBfc3RvcCkgJiYgKGRhc2hfc3RvcCA+IHNlZ21lbnRfc3RvcCApICAmJiAoYWJzKHZfYW5nbGVzLnkpIDwgUEkvMi4wKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJvdW5kIGNhcHMgIChuaWNlciB3aXRoIHRoaXMpXFxuICAgICAgICAgICAgaWYoIGRhc2hfY2Fwcy55ID09IDEuMCApIHtcXG4gICAgICAgICAgICAgICAgaWYoICh1IDwgX3N0YXJ0KSAmJiAoZGFzaF9zdGFydCA8IHNlZ21lbnRfc3RhcnQgKSAgJiYgKGFicyh2X2FuZ2xlcy54KSA8IFBJLzIuMCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0cmlhbmdsZSBjYXBzIChpbiAmIG91dCkgYW5kIHNxdWFyZVxcbiAgICAgICAgICAgIC8vIFdlIG1ha2Ugc3VyZSB0aGUgY2FwIHN0b3AgYXQgY3Jvc3NpbmcgZnJvbnRpZXJcXG4gICAgICAgICAgICBpZiggKGRhc2hfY2Fwcy54ICE9IDEuMCkgJiYgKGRhc2hfY2Fwcy54ICE9IDUuMCkgKSB7XFxuICAgICAgICAgICAgICAgIGlmKCAoZGFzaF9zdGFydCA8IHNlZ21lbnRfc3RhcnQgKSAgJiYgKGFicyh2X2FuZ2xlcy54KSA8IFBJLzIuMCkgKSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhID0gdl9hbmdsZXMueC8yLjA7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB4ID0gKHNlZ21lbnRfc3RhcnQtZHgpKmNvcyhhKSAtIGR5KnNpbihhKTtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHkgPSAoc2VnbWVudF9zdGFydC1keCkqc2luKGEpICsgZHkqY29zKGEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoIHggPiAwLjAgKSBkaXNjYXJkO1xcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJhbnNmb3JtIHRoZSBjYXAgaW50byBzcXVhcmUgdG8gYXZvaWQgaG9sZXNcXG4gICAgICAgICAgICAgICAgICAgIGRhc2hfY2Fwcy54ID0gNC4wO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdHJpYW5nbGUgY2FwcyAoaW4gJiBvdXQpIGFuZCBzcXVhcmVcXG4gICAgICAgICAgICAvLyBXZSBtYWtlIHN1cmUgdGhlIGNhcCBzdG9wIGF0IGNyb3NzaW5nIGZyb250aWVyXFxuICAgICAgICAgICAgaWYoIChkYXNoX2NhcHMueSAhPSAxLjApICYmIChkYXNoX2NhcHMueSAhPSA1LjApICkge1xcbiAgICAgICAgICAgICAgICBpZiggKGRhc2hfc3RvcCA+IHNlZ21lbnRfc3RvcCApICAmJiAoYWJzKHZfYW5nbGVzLnkpIDwgUEkvMi4wKSApIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGEgPSB2X2FuZ2xlcy55LzIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHggPSAoZHgtc2VnbWVudF9zdG9wKSpjb3MoYSkgLSBkeSpzaW4oYSk7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB5ID0gKGR4LXNlZ21lbnRfc3RvcCkqc2luKGEpICsgZHkqY29zKGEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoIHggPiAwLjAgKSBkaXNjYXJkO1xcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJhbnNmb3JtIHRoZSBjYXBzIGludG8gc3F1YXJlIHRvIGF2b2lkIGhvbGVzXFxuICAgICAgICAgICAgICAgICAgICBkYXNoX2NhcHMueSA9IDQuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIExpbmUgY2FwIGF0IHN0YXJ0XFxuICAgICAgICBpZiggKGR4IDwgbGluZV9zdGFydCkgJiYgKGRhc2hfc3RhcnQgPCBsaW5lX3N0YXJ0KSAmJiAoZGFzaF9zdG9wID4gbGluZV9zdGFydCkgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KGxpbmVjYXBzLngpLCBkeC1saW5lX3N0YXJ0LCBkeSwgdCwgdl9saW5ld2lkdGgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gTGluZSBjYXAgYXQgc3RvcFxcbiAgICAgICAgZWxzZSBpZiggKGR4ID4gbGluZV9zdG9wKSAmJiAoZGFzaF9zdG9wID4gbGluZV9zdG9wKSAmJiAoZGFzaF9zdGFydCA8IGxpbmVfc3RvcCkgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KGxpbmVjYXBzLnkpLCBkeC1saW5lX3N0b3AsIGR5LCB0LCB2X2xpbmV3aWR0aCk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBEYXNoIGNhcCBsZWZ0IC0gZGFzaF90eXBlID0gLTEsIDAgb3IgMSwgYnV0IHRoZXJlIG1heSBiZSByb3VuZG9mZiBlcnJvcnNcXG4gICAgICAgIGVsc2UgaWYoIGRhc2hfdHlwZSA8IC0wLjUgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KGRhc2hfY2Fwcy55KSwgYWJzKHUtZGFzaF9jZW50ZXIpLCBkeSwgdCwgdl9saW5ld2lkdGgpO1xcbiAgICAgICAgICAgIGlmKCAoZHggPiBsaW5lX3N0YXJ0KSAmJiAoZHggPCBsaW5lX3N0b3ApIClcXG4gICAgICAgICAgICAgICAgZCA9IG1heChkLGRfam9pbik7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBEYXNoIGNhcCByaWdodFxcbiAgICAgICAgZWxzZSBpZiggZGFzaF90eXBlID4gMC41ICkge1xcbiAgICAgICAgICAgIGQgPSBjYXAoIGludChkYXNoX2NhcHMueCksIGFicyhkYXNoX2NlbnRlci11KSwgZHksIHQsIHZfbGluZXdpZHRoKTtcXG4gICAgICAgICAgICBpZiggKGR4ID4gbGluZV9zdGFydCkgJiYgKGR4IDwgbGluZV9zdG9wKSApXFxuICAgICAgICAgICAgICAgIGQgPSBtYXgoZCxkX2pvaW4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRGFzaCBib2R5IChwbGFpbilcXG4gICAgICAgIGVsc2Ugey8vIGlmKCBkYXNoX3R5cGUgPiAtMC41ICYmICBkYXNoX3R5cGUgPCAwLjUpIHtcXG4gICAgICAgICAgICBkID0gYWJzKGR5KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIExpbmUgam9pblxcbiAgICAgICAgaWYoIChkeCA+IGxpbmVfc3RhcnQpICYmIChkeCA8IGxpbmVfc3RvcCkpIHtcXG4gICAgICAgICAgICBpZiggKGR4IDw9IHNlZ21lbnRfc3RhcnQpICYmIChkYXNoX3N0YXJ0IDw9IHNlZ21lbnRfc3RhcnQpXFxuICAgICAgICAgICAgICAgICYmIChkYXNoX3N0b3AgPj0gc2VnbWVudF9zdGFydCkgKSB7XFxuICAgICAgICAgICAgICAgIGQgPSBkX2pvaW47XFxuICAgICAgICAgICAgICAgIC8vIEFudGlhbGlhcyBhdCBvdXRlciBib3JkZXJcXG4gICAgICAgICAgICAgICAgZmxvYXQgYW5nbGUgPSBQSS8yLit2X2FuZ2xlcy54O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBmID0gYWJzKCAoc2VnbWVudF9zdGFydCAtIGR4KSpjb3MoYW5nbGUpIC0gZHkqc2luKGFuZ2xlKSk7XFxuICAgICAgICAgICAgICAgIGQgPSBtYXgoZixkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiggKGR4ID4gc2VnbWVudF9zdG9wKSAmJiAoZGFzaF9zdGFydCA8PSBzZWdtZW50X3N0b3ApXFxuICAgICAgICAgICAgICAgICAgICAgJiYgKGRhc2hfc3RvcCA+PSBzZWdtZW50X3N0b3ApICkge1xcbiAgICAgICAgICAgICAgICBkID0gZF9qb2luO1xcbiAgICAgICAgICAgICAgICAvLyBBbnRpYWxpYXMgYXQgb3V0ZXIgYm9yZGVyXFxuICAgICAgICAgICAgICAgIGZsb2F0IGFuZ2xlID0gUEkvMi4rdl9hbmdsZXMueTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZiA9IGFicygoZHggLSBzZWdtZW50X3N0b3ApKmNvcyhhbmdsZSkgLSBkeSpzaW4oYW5nbGUpKTtcXG4gICAgICAgICAgICAgICAgZCA9IG1heChmLGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmKCBkeCA8IChzZWdtZW50X3N0YXJ0IC0gdl9saW5ld2lkdGgvMi4pKSB7XFxuICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYoIGR4ID4gKHNlZ21lbnRfc3RvcCArIHZfbGluZXdpZHRoLzIuKSkge1xcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYoIGR4IDwgKHNlZ21lbnRfc3RhcnQgLSB2X2xpbmV3aWR0aC8yLikpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiggZHggPiAoc2VnbWVudF9zdG9wICsgdl9saW5ld2lkdGgvMi4pKSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBEaXN0YW5jZSB0byBib3JkZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGQgPSBkIC0gdDtcXG4gICAgaWYoIGQgPCAwLjAgKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGQgLz0gdV9hbnRpYWxpYXM7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgZXhwKC1kKmQpKmNvbG9yLmEpO1xcbiAgICB9XFxufVwiO1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2w7XG4gICAgICAgIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5fc2NhbGVfYXNwZWN0ID0gMDtcbiAgICAgICAgdGhpcy5wcm9nID0gbmV3IGdsb28yLlByb2dyYW0oZ2wpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3NoYWRlcnModGhpcy5WRVJULCB0aGlzLkZSQUcpO1xuICAgICAgICB0aGlzLmluZGV4X2J1ZmZlciA9IG5ldyBnbG9vMi5JbmRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX3Bvc2l0aW9uID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX3RhbmdlbnRzID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX3NlZ21lbnQgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fYW5nbGVzID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX3RleGNvb3JkID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhc2hfYXRsYXMgPSBuZXcgRGFzaEF0bGFzKGdsKTtcbiAgICB9O1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGluZGljZXMsIG1haW5HbHlwaCwgdHJhbnMpIHtcbiAgICAgICAgdmFyIGJha2VkX29mZnNldCwgY2h1bmssIGNodW5rcywgY2h1bmtzaXplLCBpLCBsLCBtYWluR2xHbHlwaCwgbnZlcnRpY2VzLCBvZmZzZXQsIHAsIHEsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0cywgc2NhbGVfbGVuZ3RoLCBzeCwgc3ksIHRoZXNlX2luZGljZXMsIHVpbnQxNl9pbmRleDtcbiAgICAgICAgbWFpbkdsR2x5cGggPSBtYWluR2x5cGguZ2xnbHlwaDtcbiAgICAgICAgaWYgKG1haW5HbEdseXBoLmRhdGFfY2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKCEoaXNGaW5pdGUodHJhbnMuZHgpICYmIGlzRmluaXRlKHRyYW5zLmR5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWluR2xHbHlwaC5fYmFrZWRfb2Zmc2V0ID0gW3RyYW5zLmR4LCB0cmFucy5keV07XG4gICAgICAgICAgICBtYWluR2xHbHlwaC5fc2V0X2RhdGEoKTtcbiAgICAgICAgICAgIG1haW5HbEdseXBoLmRhdGFfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHNfY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0X3Zpc3VhbHMoKTtcbiAgICAgICAgICAgIHRoaXMudmlzdWFsc19jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0cmFucy5zeDtcbiAgICAgICAgc3kgPSB0cmFucy5zeTtcbiAgICAgICAgc2NhbGVfbGVuZ3RoID0gTWF0aC5zcXJ0KHN4ICogc3ggKyBzeSAqIHN5KTtcbiAgICAgICAgc3ggLz0gc2NhbGVfbGVuZ3RoO1xuICAgICAgICBzeSAvPSBzY2FsZV9sZW5ndGg7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9zY2FsZV9hc3BlY3QgLSAoc3kgLyBzeCkpID4gTWF0aC5hYnMoMWUtMyAqIHRoaXMuX3NjYWxlX2FzcGVjdCkpIHtcbiAgICAgICAgICAgIG1haW5HbEdseXBoLl91cGRhdGVfc2NhbGUoc3gsIHN5KTtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlX2FzcGVjdCA9IHN5IC8gc3g7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfcG9zaXRpb24nLCAndmVjMicsIG1haW5HbEdseXBoLnZib19wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3RhbmdlbnRzJywgJ3ZlYzQnLCBtYWluR2xHbHlwaC52Ym9fdGFuZ2VudHMpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9zZWdtZW50JywgJ3ZlYzInLCBtYWluR2xHbHlwaC52Ym9fc2VnbWVudCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2FuZ2xlcycsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX2FuZ2xlcyk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3RleGNvb3JkJywgJ3ZlYzInLCBtYWluR2xHbHlwaC52Ym9fdGV4Y29vcmQpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfbGVuZ3RoJywgJ2Zsb2F0JywgW21haW5HbEdseXBoLmN1bXN1bV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3RleHR1cmUoJ3VfZGFzaF9hdGxhcycsIHRoaXMuZGFzaF9hdGxhcy50ZXgpO1xuICAgICAgICBiYWtlZF9vZmZzZXQgPSBtYWluR2xHbHlwaC5fYmFrZWRfb2Zmc2V0O1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfcGl4ZWxfcmF0aW8nLCAnZmxvYXQnLCBbdHJhbnMucGl4ZWxfcmF0aW9dKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X2NhbnZhc19zaXplJywgJ3ZlYzInLCBbdHJhbnMud2lkdGgsIHRyYW5zLmhlaWdodF0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3Vfb2Zmc2V0JywgJ3ZlYzInLCBbdHJhbnMuZHggLSBiYWtlZF9vZmZzZXRbMF0sIHRyYW5zLmR5IC0gYmFrZWRfb2Zmc2V0WzFdXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9zY2FsZV9hc3BlY3QnLCAndmVjMicsIFtzeCwgc3ldKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X3NjYWxlX2xlbmd0aCcsICdmbG9hdCcsIFtzY2FsZV9sZW5ndGhdKTtcbiAgICAgICAgdGhpcy5JX3RyaWFuZ2xlcyA9IG1haW5HbEdseXBoLklfdHJpYW5nbGVzO1xuICAgICAgICBpZiAodGhpcy5JX3RyaWFuZ2xlcy5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X3NpemUodGhpcy5JX3RyaWFuZ2xlcy5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyLnNldF9kYXRhKDAsIG5ldyBVaW50MTZBcnJheSh0aGlzLklfdHJpYW5nbGVzKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9nLmRyYXcodGhpcy5nbC5UUklBTkdMRVMsIHRoaXMuaW5kZXhfYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXMgPSB0aGlzLklfdHJpYW5nbGVzO1xuICAgICAgICAgICAgbnZlcnRpY2VzID0gdGhpcy5JX3RyaWFuZ2xlcy5sZW5ndGg7XG4gICAgICAgICAgICBjaHVua3NpemUgPSA2NDAwODtcbiAgICAgICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gbCA9IDAsIHJlZiA9IE1hdGguY2VpbChudmVydGljZXMgLyBjaHVua3NpemUpOyAwIDw9IHJlZiA/IGwgPCByZWYgOiBsID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBwID0gMCwgcmVmMSA9IGluZGljZXMubGVuZ3RoOyAwIDw9IHJlZjEgPyBwIDwgcmVmMSA6IHAgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytwIDogLS1wKSB7XG4gICAgICAgICAgICAgICAgdWludDE2X2luZGV4ID0gaW5kaWNlc1tpXSAlIGNodW5rc2l6ZTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoaW5kaWNlc1tpXSAvIGNodW5rc2l6ZSk7XG4gICAgICAgICAgICAgICAgY2h1bmtzW2NodW5rXS5wdXNoKHVpbnQxNl9pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNodW5rID0gcSA9IDAsIHJlZjIgPSBjaHVua3MubGVuZ3RoOyAwIDw9IHJlZjIgPyBxIDwgcmVmMiA6IHEgPiByZWYyOyBjaHVuayA9IDAgPD0gcmVmMiA/ICsrcSA6IC0tcSkge1xuICAgICAgICAgICAgICAgIHRoZXNlX2luZGljZXMgPSBuZXcgVWludDE2QXJyYXkoY2h1bmtzW2NodW5rXSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2h1bmsgKiBjaHVua3NpemUgKiA0O1xuICAgICAgICAgICAgICAgIGlmICh0aGVzZV9pbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfcG9zaXRpb24nLCAndmVjMicsIG1haW5HbEdseXBoLnZib19wb3NpdGlvbiwgMCwgb2Zmc2V0ICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfdGFuZ2VudHMnLCAndmVjNCcsIG1haW5HbEdseXBoLnZib190YW5nZW50cywgMCwgb2Zmc2V0ICogNCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2Ffc2VnbWVudCcsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX3NlZ21lbnQsIDAsIG9mZnNldCAqIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2FuZ2xlcycsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX2FuZ2xlcywgMCwgb2Zmc2V0ICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfdGV4Y29vcmQnLCAndmVjMicsIG1haW5HbEdseXBoLnZib190ZXhjb29yZCwgMCwgb2Zmc2V0ICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X3NpemUodGhlc2VfaW5kaWNlcy5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4X2J1ZmZlci5zZXRfZGF0YSgwLCB0aGVzZV9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5wcm9nLmRyYXcodGhpcy5nbC5UUklBTkdMRVMsIHRoaXMuaW5kZXhfYnVmZmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmFrZSgpO1xuICAgICAgICB0aGlzLnZib19wb3NpdGlvbi5zZXRfc2l6ZSh0aGlzLlZfcG9zaXRpb24ubGVuZ3RoICogNCk7XG4gICAgICAgIHRoaXMudmJvX3Bvc2l0aW9uLnNldF9kYXRhKDAsIHRoaXMuVl9wb3NpdGlvbik7XG4gICAgICAgIHRoaXMudmJvX3RhbmdlbnRzLnNldF9zaXplKHRoaXMuVl90YW5nZW50cy5sZW5ndGggKiA0KTtcbiAgICAgICAgdGhpcy52Ym9fdGFuZ2VudHMuc2V0X2RhdGEoMCwgdGhpcy5WX3RhbmdlbnRzKTtcbiAgICAgICAgdGhpcy52Ym9fYW5nbGVzLnNldF9zaXplKHRoaXMuVl9hbmdsZXMubGVuZ3RoICogNCk7XG4gICAgICAgIHRoaXMudmJvX2FuZ2xlcy5zZXRfZGF0YSgwLCB0aGlzLlZfYW5nbGVzKTtcbiAgICAgICAgdGhpcy52Ym9fdGV4Y29vcmQuc2V0X3NpemUodGhpcy5WX3RleGNvb3JkLmxlbmd0aCAqIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy52Ym9fdGV4Y29vcmQuc2V0X2RhdGEoMCwgdGhpcy5WX3RleGNvb3JkKTtcbiAgICB9O1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5fc2V0X3Zpc3VhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXAsIGNvbG9yLCBkYXNoX2luZGV4LCBkYXNoX3BhdHRlcm4sIGRhc2hfcGVyaW9kLCBqb2luLCByZWY7XG4gICAgICAgIGNvbG9yID0gY29sb3JfMS5jb2xvcjJyZ2JhKHRoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfY29sb3IudmFsdWUoKSwgdGhpcy5nbHlwaC52aXN1YWxzLmxpbmUubGluZV9hbHBoYS52YWx1ZSgpKTtcbiAgICAgICAgY2FwID0gdGhpcy5DQVBTW3RoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfY2FwLnZhbHVlKCldO1xuICAgICAgICBqb2luID0gdGhpcy5KT0lOU1t0aGlzLmdseXBoLnZpc3VhbHMubGluZS5saW5lX2pvaW4udmFsdWUoKV07XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9jb2xvcicsICd2ZWM0JywgY29sb3IpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfbGluZXdpZHRoJywgJ2Zsb2F0JywgW3RoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfd2lkdGgudmFsdWUoKV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfYW50aWFsaWFzJywgJ2Zsb2F0JywgWzAuOV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfbGluZWNhcHMnLCAndmVjMicsIFtjYXAsIGNhcF0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfbGluZWpvaW4nLCAnZmxvYXQnLCBbam9pbl0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfbWl0ZXJfbGltaXQnLCAnZmxvYXQnLCBbMTAuMF0pO1xuICAgICAgICBkYXNoX3BhdHRlcm4gPSB0aGlzLmdseXBoLnZpc3VhbHMubGluZS5saW5lX2Rhc2gudmFsdWUoKTtcbiAgICAgICAgZGFzaF9pbmRleCA9IDA7XG4gICAgICAgIGRhc2hfcGVyaW9kID0gMTtcbiAgICAgICAgaWYgKGRhc2hfcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZGFzaF9hdGxhcy5nZXRfYXRsYXNfZGF0YShkYXNoX3BhdHRlcm4pLCBkYXNoX2luZGV4ID0gcmVmWzBdLCBkYXNoX3BlcmlvZCA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfZGFzaF9pbmRleCcsICdmbG9hdCcsIFtkYXNoX2luZGV4XSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9kYXNoX3BoYXNlJywgJ2Zsb2F0JywgW3RoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfZGFzaF9vZmZzZXQudmFsdWUoKV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfZGFzaF9wZXJpb2QnLCAnZmxvYXQnLCBbZGFzaF9wZXJpb2RdKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X2Rhc2hfY2FwcycsICd2ZWMyJywgW2NhcCwgY2FwXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfY2xvc2VkJywgJ2Zsb2F0JywgWzBdKTtcbiAgICB9O1xuICAgIExpbmVHTEdseXBoLnByb3RvdHlwZS5fYmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEEsIEksIFQsIFZfYW5nbGVzLCBWX2FuZ2xlczIsIFZfcG9zaXRpb24sIFZfcG9zaXRpb24yLCBWX3RhbmdlbnRzLCBWX3RhbmdlbnRzMiwgVl90ZXhjb29yZCwgVl90ZXhjb29yZDIsIFZwLCBWdCwgX3gsIF95LCBpLCBpMSwgaiwgaywgbCwgbSwgbiwgbmksIG8sIHAsIHEsIHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVzdWx0cywgcywgdCwgdSwgdywgeSwgejtcbiAgICAgICAgbiA9IHRoaXMubnZlcnRpY2VzO1xuICAgICAgICBfeCA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5nbHlwaC5feCk7XG4gICAgICAgIF95ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLmdseXBoLl95KTtcbiAgICAgICAgVl9wb3NpdGlvbiA9IFZwID0gbmV3IEZsb2F0MzJBcnJheShuICogMik7XG4gICAgICAgIFZfYW5nbGVzID0gbmV3IEZsb2F0MzJBcnJheShuICogMik7XG4gICAgICAgIFZfdGFuZ2VudHMgPSBWdCA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIDQpO1xuICAgICAgICBWX3RleGNvb3JkID0gbmV3IEZsb2F0MzJBcnJheShuICogMik7XG4gICAgICAgIGZvciAoaSA9IGwgPSAwLCByZWYgPSBuOyAwIDw9IHJlZiA/IGwgPCByZWYgOiBsID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIFZfcG9zaXRpb25baSAqIDIgKyAwXSA9IF94W2ldICsgdGhpcy5fYmFrZWRfb2Zmc2V0WzBdO1xuICAgICAgICAgICAgVl9wb3NpdGlvbltpICogMiArIDFdID0gX3lbaV0gKyB0aGlzLl9iYWtlZF9vZmZzZXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YW5nZW50cyA9IFQgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiAyIC0gMik7XG4gICAgICAgIGZvciAoaSA9IHAgPSAwLCByZWYxID0gbiAtIDE7IDAgPD0gcmVmMSA/IHAgPCByZWYxIDogcCA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK3AgOiAtLXApIHtcbiAgICAgICAgICAgIFRbaSAqIDIgKyAwXSA9IFZwWyhpICsgMSkgKiAyICsgMF0gLSBWcFtpICogMiArIDBdO1xuICAgICAgICAgICAgVFtpICogMiArIDFdID0gVnBbKGkgKyAxKSAqIDIgKyAxXSAtIFZwW2kgKiAyICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gcSA9IDAsIHJlZjIgPSBuIC0gMTsgMCA8PSByZWYyID8gcSA8IHJlZjIgOiBxID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsrcSA6IC0tcSkge1xuICAgICAgICAgICAgVl90YW5nZW50c1soaSArIDEpICogNCArIDBdID0gVFtpICogMiArIDBdO1xuICAgICAgICAgICAgVl90YW5nZW50c1soaSArIDEpICogNCArIDFdID0gVFtpICogMiArIDFdO1xuICAgICAgICAgICAgVl90YW5nZW50c1tpICogNCArIDJdID0gVFtpICogMiArIDBdO1xuICAgICAgICAgICAgVl90YW5nZW50c1tpICogNCArIDNdID0gVFtpICogMiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIFZfdGFuZ2VudHNbMCAqIDQgKyAwXSA9IFRbMF07XG4gICAgICAgIFZfdGFuZ2VudHNbMCAqIDQgKyAxXSA9IFRbMV07XG4gICAgICAgIFZfdGFuZ2VudHNbKG4gLSAxKSAqIDQgKyAyXSA9IFRbKG4gLSAyKSAqIDIgKyAwXTtcbiAgICAgICAgVl90YW5nZW50c1sobiAtIDEpICogNCArIDNdID0gVFsobiAtIDIpICogMiArIDFdO1xuICAgICAgICBBID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICAgICAgZm9yIChpID0gciA9IDAsIHJlZjMgPSBuOyAwIDw9IHJlZjMgPyByIDwgcmVmMyA6IHIgPiByZWYzOyBpID0gMCA8PSByZWYzID8gKytyIDogLS1yKSB7XG4gICAgICAgICAgICBBW2ldID0gTWF0aC5hdGFuMihWdFtpICogNCArIDBdICogVnRbaSAqIDQgKyAzXSAtIFZ0W2kgKiA0ICsgMV0gKiBWdFtpICogNCArIDJdLCBWdFtpICogNCArIDBdICogVnRbaSAqIDQgKyAyXSArIFZ0W2kgKiA0ICsgMV0gKiBWdFtpICogNCArIDNdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBzID0gMCwgcmVmNCA9IG4gLSAxOyAwIDw9IHJlZjQgPyBzIDwgcmVmNCA6IHMgPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytzIDogLS1zKSB7XG4gICAgICAgICAgICBWX2FuZ2xlc1tpICogMiArIDBdID0gQVtpXTtcbiAgICAgICAgICAgIFZfYW5nbGVzW2kgKiAyICsgMV0gPSBBW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBtID0gNCAqIG4gLSA0O1xuICAgICAgICB0aGlzLlZfcG9zaXRpb24gPSBWX3Bvc2l0aW9uMiA9IG5ldyBGbG9hdDMyQXJyYXkobSAqIDIpO1xuICAgICAgICB0aGlzLlZfYW5nbGVzID0gVl9hbmdsZXMyID0gbmV3IEZsb2F0MzJBcnJheShtICogMik7XG4gICAgICAgIHRoaXMuVl90YW5nZW50cyA9IFZfdGFuZ2VudHMyID0gbmV3IEZsb2F0MzJBcnJheShtICogNCk7XG4gICAgICAgIHRoaXMuVl90ZXhjb29yZCA9IFZfdGV4Y29vcmQyID0gbmV3IEZsb2F0MzJBcnJheShtICogMik7XG4gICAgICAgIG8gPSAyO1xuICAgICAgICBmb3IgKGkgPSB0ID0gMCwgcmVmNSA9IG47IDAgPD0gcmVmNSA/IHQgPCByZWY1IDogdCA+IHJlZjU7IGkgPSAwIDw9IHJlZjUgPyArK3QgOiAtLXQpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IHUgPSAwOyB1IDwgNDsgaiA9ICsrdSkge1xuICAgICAgICAgICAgICAgIGZvciAoayA9IHcgPSAwOyB3IDwgMjsgayA9ICsrdykge1xuICAgICAgICAgICAgICAgICAgICBWX3Bvc2l0aW9uMlsoaSAqIDQgKyBqIC0gbykgKiAyICsga10gPSBWX3Bvc2l0aW9uW2kgKiAyICsga107XG4gICAgICAgICAgICAgICAgICAgIFZfYW5nbGVzMlsoaSAqIDQgKyBqKSAqIDIgKyBrXSA9IFZfYW5nbGVzW2kgKiAyICsga107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoayA9IHkgPSAwOyB5IDwgNDsgayA9ICsreSkge1xuICAgICAgICAgICAgICAgICAgICBWX3RhbmdlbnRzMlsoaSAqIDQgKyBqIC0gbykgKiA0ICsga10gPSBWX3RhbmdlbnRzW2kgKiA0ICsga107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHogPSAwLCByZWY2ID0gbjsgMCA8PSByZWY2ID8geiA8PSByZWY2IDogeiA+PSByZWY2OyBpID0gMCA8PSByZWY2ID8gKyt6IDogLS16KSB7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAwKSAqIDIgKyAwXSA9IC0xO1xuICAgICAgICAgICAgVl90ZXhjb29yZDJbKGkgKiA0ICsgMSkgKiAyICsgMF0gPSAtMTtcbiAgICAgICAgICAgIFZfdGV4Y29vcmQyWyhpICogNCArIDIpICogMiArIDBdID0gKzE7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAzKSAqIDIgKyAwXSA9ICsxO1xuICAgICAgICAgICAgVl90ZXhjb29yZDJbKGkgKiA0ICsgMCkgKiAyICsgMV0gPSAtMTtcbiAgICAgICAgICAgIFZfdGV4Y29vcmQyWyhpICogNCArIDEpICogMiArIDFdID0gKzE7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAyKSAqIDIgKyAxXSA9IC0xO1xuICAgICAgICAgICAgVl90ZXhjb29yZDJbKGkgKiA0ICsgMykgKiAyICsgMV0gPSArMTtcbiAgICAgICAgfVxuICAgICAgICBuaSA9IChuIC0gMSkgKiA2O1xuICAgICAgICB0aGlzLklfdHJpYW5nbGVzID0gSSA9IG5ldyBVaW50MzJBcnJheShuaSk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaTEgPSAwLCByZWY3ID0gbjsgMCA8PSByZWY3ID8gaTEgPCByZWY3IDogaTEgPiByZWY3OyBpID0gMCA8PSByZWY3ID8gKytpMSA6IC0taTEpIHtcbiAgICAgICAgICAgIElbaSAqIDYgKyAwXSA9IDAgKyA0ICogaTtcbiAgICAgICAgICAgIElbaSAqIDYgKyAxXSA9IDEgKyA0ICogaTtcbiAgICAgICAgICAgIElbaSAqIDYgKyAyXSA9IDMgKyA0ICogaTtcbiAgICAgICAgICAgIElbaSAqIDYgKyAzXSA9IDIgKyA0ICogaTtcbiAgICAgICAgICAgIElbaSAqIDYgKyA0XSA9IDAgKyA0ICogaTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChJW2kgKiA2ICsgNV0gPSAzICsgNCAqIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLl91cGRhdGVfc2NhbGUgPSBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgIHZhciBOLCBULCBWX3NlZ21lbnQsIFZfc2VnbWVudDIsIGN1bXN1bSwgaSwgaiwgaywgbCwgbSwgbiwgcCwgcSwgciwgcmVmLCByZWYxLCByZWYyLCBzO1xuICAgICAgICBuID0gdGhpcy5udmVydGljZXM7XG4gICAgICAgIG0gPSA0ICogbiAtIDQ7XG4gICAgICAgIFQgPSB0aGlzLnRhbmdlbnRzO1xuICAgICAgICBOID0gbmV3IEZsb2F0MzJBcnJheShuIC0gMSk7XG4gICAgICAgIFZfc2VnbWVudCA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIDIpO1xuICAgICAgICB0aGlzLlZfc2VnbWVudCA9IFZfc2VnbWVudDIgPSBuZXcgRmxvYXQzMkFycmF5KG0gKiAyKTtcbiAgICAgICAgZm9yIChpID0gbCA9IDAsIHJlZiA9IG4gLSAxOyAwIDw9IHJlZiA/IGwgPCByZWYgOiBsID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIE5baV0gPSBNYXRoLnNxcnQoTWF0aC5wb3coVFtpICogMiArIDBdICogc3gsIDIpICsgTWF0aC5wb3coVFtpICogMiArIDFdICogc3ksIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBjdW1zdW0gPSAwO1xuICAgICAgICBmb3IgKGkgPSBwID0gMCwgcmVmMSA9IG4gLSAxOyAwIDw9IHJlZjEgPyBwIDwgcmVmMSA6IHAgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytwIDogLS1wKSB7XG4gICAgICAgICAgICBjdW1zdW0gKz0gTltpXTtcbiAgICAgICAgICAgIFZfc2VnbWVudFsoaSArIDEpICogMiArIDBdID0gY3Vtc3VtO1xuICAgICAgICAgICAgVl9zZWdtZW50W2kgKiAyICsgMV0gPSBjdW1zdW07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gcSA9IDAsIHJlZjIgPSBuOyAwIDw9IHJlZjIgPyBxIDwgcmVmMiA6IHEgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytxIDogLS1xKSB7XG4gICAgICAgICAgICBmb3IgKGogPSByID0gMDsgciA8IDQ7IGogPSArK3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSBzID0gMDsgcyA8IDI7IGsgPSArK3MpIHtcbiAgICAgICAgICAgICAgICAgICAgVl9zZWdtZW50MlsoaSAqIDQgKyBqKSAqIDIgKyBrXSA9IFZfc2VnbWVudFtpICogMiArIGtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1bXN1bSA9IGN1bXN1bTtcbiAgICAgICAgdGhpcy52Ym9fc2VnbWVudC5zZXRfc2l6ZSh0aGlzLlZfc2VnbWVudC5sZW5ndGggKiA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmJvX3NlZ21lbnQuc2V0X2RhdGEoMCwgdGhpcy5WX3NlZ21lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVHTEdseXBoO1xufSkoYmFzZV8xLkJhc2VHTEdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcIi4vaW5kZXhcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXJrZXJHTEdseXBoLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2xvbzIgPSByZXF1aXJlKFwiZ2xvbzJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuTWFya2VyR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNYXJrZXJHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXJrZXJHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gTWFya2VyR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWFya2VyR0xHbHlwaC5wcm90b3R5cGUuVkVSVCA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuY29uc3QgZmxvYXQgU1FSVF8yID0gMS40MTQyMTM1NjIzNzMwOTUxO1xcbi8vXFxudW5pZm9ybSBmbG9hdCB1X3BpeGVsX3JhdGlvO1xcbnVuaWZvcm0gdmVjMiB1X2NhbnZhc19zaXplO1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG51bmlmb3JtIHZlYzIgdV9zY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVfYW50aWFsaWFzO1xcbi8vXFxuYXR0cmlidXRlIGZsb2F0IGFfeDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV95O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7ICAvLyBpbiByYWRpYW5zXFxuYXR0cmlidXRlIGZsb2F0IGFfbGluZXdpZHRoO1xcbmF0dHJpYnV0ZSB2ZWM0ICBhX2ZnX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0ICBhX2JnX2NvbG9yO1xcbi8vXFxudmFyeWluZyBmbG9hdCB2X2xpbmV3aWR0aDtcXG52YXJ5aW5nIGZsb2F0IHZfc2l6ZTtcXG52YXJ5aW5nIHZlYzQgIHZfZmdfY29sb3I7XFxudmFyeWluZyB2ZWM0ICB2X2JnX2NvbG9yO1xcbnZhcnlpbmcgdmVjMiAgdl9yb3RhdGlvbjtcXG5cXG52b2lkIG1haW4gKHZvaWQpXFxue1xcbiAgICB2X3NpemUgPSBhX3NpemUgKiB1X3BpeGVsX3JhdGlvO1xcbiAgICB2X2xpbmV3aWR0aCA9IGFfbGluZXdpZHRoICogdV9waXhlbF9yYXRpbztcXG4gICAgdl9mZ19jb2xvciA9IGFfZmdfY29sb3I7XFxuICAgIHZfYmdfY29sb3IgPSBhX2JnX2NvbG9yO1xcbiAgICB2X3JvdGF0aW9uID0gdmVjMihjb3MoLWFfYW5nbGUpLCBzaW4oLWFfYW5nbGUpKTtcXG4gICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIC0gdGhlIC0wLjUgaXMgdG8gY29ycmVjdCBmb3IgY2FudmFzIG9yaWdpblxcbiAgICB2ZWMyIHBvcyA9ICh2ZWMyKGFfeCwgYV95KSArIHVfb2Zmc2V0KSAqIHVfc2NhbGU7IC8vIGluIHBpeGVsc1xcbiAgICBwb3MgKz0gMC41OyAgLy8gbWFrZSB1cCBmb3IgQm9rZWgncyBvZmZzZXRcXG4gICAgcG9zIC89IHVfY2FudmFzX3NpemUgLyB1X3BpeGVsX3JhdGlvOyAgLy8gaW4gMC4uMVxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zKjIuMC0xLjAsIDAuMCwgMS4wKTtcXG4gICAgZ2xfUG9zaXRpb24ueSAqPSAtMS4wO1xcbiAgICBnbF9Qb2ludFNpemUgPSBTUVJUXzIgKiB2X3NpemUgKyAyLjAgKiAodl9saW5ld2lkdGggKyAxLjUqdV9hbnRpYWxpYXMpO1xcbn1cIjtcbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5GUkFHID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5jb25zdCBmbG9hdCBTUVJUXzIgPSAxLjQxNDIxMzU2MjM3MzA5NTE7XFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0O1xcbi8vXFxudW5pZm9ybSBmbG9hdCB1X2FudGlhbGlhcztcXG4vL1xcbnZhcnlpbmcgdmVjNCAgdl9mZ19jb2xvcjtcXG52YXJ5aW5nIHZlYzQgIHZfYmdfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X2xpbmV3aWR0aDtcXG52YXJ5aW5nIGZsb2F0IHZfc2l6ZTtcXG52YXJ5aW5nIHZlYzIgIHZfcm90YXRpb247XFxuXFxuTUFSS0VSQ09ERVxcblxcbnZlYzQgb3V0bGluZShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgbGluZXdpZHRoLCBmbG9hdCBhbnRpYWxpYXMsIHZlYzQgZmdfY29sb3IsIHZlYzQgYmdfY29sb3IpXFxue1xcbiAgICB2ZWM0IGZyYWdfY29sb3I7XFxuICAgIGZsb2F0IHQgPSBsaW5ld2lkdGgvMi4wIC0gYW50aWFsaWFzO1xcbiAgICBmbG9hdCBzaWduZWRfZGlzdGFuY2UgPSBkaXN0YW5jZTtcXG4gICAgZmxvYXQgYm9yZGVyX2Rpc3RhbmNlID0gYWJzKHNpZ25lZF9kaXN0YW5jZSkgLSB0O1xcbiAgICBmbG9hdCBhbHBoYSA9IGJvcmRlcl9kaXN0YW5jZS9hbnRpYWxpYXM7XFxuICAgIGFscGhhID0gZXhwKC1hbHBoYSphbHBoYSk7XFxuXFxuICAgIC8vIElmIGZnIGFscGhhIGlzIHplcm8sIGl0IHByb2JhYmx5IG1lYW5zIG5vIG91dGxpbmUuIFRvIGF2b2lkIGEgZGFyayBvdXRsaW5lXFxuICAgIC8vIHNoaW5pbmcgdGhyb3VnaCBkdWUgdG8gYWEsIHdlIHNldCB0aGUgZmcgY29sb3IgdG8gdGhlIGJnIGNvbG9yLiBBdm9pZCBpZiAoaS5lLiBicmFuY2hpbmcpLlxcbiAgICBmbG9hdCBzZWxlY3QgPSBmbG9hdChib29sKGZnX2NvbG9yLmEpKTtcXG4gICAgZmdfY29sb3IucmdiID0gc2VsZWN0ICogZmdfY29sb3IucmdiICsgKDEuMCAgLSBzZWxlY3QpICogYmdfY29sb3IucmdiO1xcbiAgICAvLyBTaW1pbGFybHksIGlmIHdlIHdhbnQgYSB0cmFuc3BhcmVudCBiZ1xcbiAgICBzZWxlY3QgPSBmbG9hdChib29sKGJnX2NvbG9yLmEpKTtcXG4gICAgYmdfY29sb3IucmdiID0gc2VsZWN0ICogYmdfY29sb3IucmdiICsgKDEuMCAgLSBzZWxlY3QpICogZmdfY29sb3IucmdiO1xcblxcbiAgICBpZiggYm9yZGVyX2Rpc3RhbmNlIDwgMC4wKVxcbiAgICAgICAgZnJhZ19jb2xvciA9IGZnX2NvbG9yO1xcbiAgICBlbHNlIGlmKCBzaWduZWRfZGlzdGFuY2UgPCAwLjAgKSB7XFxuICAgICAgICBmcmFnX2NvbG9yID0gbWl4KGJnX2NvbG9yLCBmZ19jb2xvciwgc3FydChhbHBoYSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYoIGFicyhzaWduZWRfZGlzdGFuY2UpIDwgKGxpbmV3aWR0aC8yLjAgKyBhbnRpYWxpYXMpICkge1xcbiAgICAgICAgICAgIGZyYWdfY29sb3IgPSB2ZWM0KGZnX2NvbG9yLnJnYiwgZmdfY29sb3IuYSAqIGFscGhhKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZnJhZ19jb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzIgUCA9IGdsX1BvaW50Q29vcmQueHkgLSB2ZWMyKDAuNSwgMC41KTtcXG4gICAgUCA9IHZlYzIodl9yb3RhdGlvbi54KlAueCAtIHZfcm90YXRpb24ueSpQLnksXFxuICAgICAgICAgICAgIHZfcm90YXRpb24ueSpQLnggKyB2X3JvdGF0aW9uLngqUC55KTtcXG4gICAgZmxvYXQgcG9pbnRfc2l6ZSA9IFNRUlRfMip2X3NpemUgICsgMi4wICogKHZfbGluZXdpZHRoICsgMS41KnVfYW50aWFsaWFzKTtcXG4gICAgZmxvYXQgZGlzdGFuY2UgPSBtYXJrZXIoUCpwb2ludF9zaXplLCB2X3NpemUpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBvdXRsaW5lKGRpc3RhbmNlLCB2X2xpbmV3aWR0aCwgdV9hbnRpYWxpYXMsIHZfZmdfY29sb3IsIHZfYmdfY29sb3IpO1xcbiAgICAvL2dsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7ICAvLyBwcmUtbXVsdGlwbHkgYWxwaGFcXG59XCI7XG4gICAgTWFya2VyR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiPGRlZmluZWQgaW4gc3ViY2xhc3Nlcz5cIjtcbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZywgZ2w7XG4gICAgICAgIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZnJhZyA9IHRoaXMuRlJBRy5yZXBsYWNlKC9NQVJLRVJDT0RFLywgdGhpcy5NQVJLRVJDT0RFKTtcbiAgICAgICAgdGhpcy5sYXN0X3RyYW5zID0ge307XG4gICAgICAgIHRoaXMucHJvZyA9IG5ldyBnbG9vMi5Qcm9ncmFtKGdsKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9zaGFkZXJzKHRoaXMuVkVSVCwgZnJhZyk7XG4gICAgICAgIHRoaXMudmJvX3ggPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfeCcsICdmbG9hdCcsIHRoaXMudmJvX3gpO1xuICAgICAgICB0aGlzLnZib195ID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3knLCAnZmxvYXQnLCB0aGlzLnZib195KTtcbiAgICAgICAgdGhpcy52Ym9fcyA9IG5ldyBnbG9vMi5WZXJ0ZXhCdWZmZXIoZ2wpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9zaXplJywgJ2Zsb2F0JywgdGhpcy52Ym9fcyk7XG4gICAgICAgIHRoaXMudmJvX2EgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfYW5nbGUnLCAnZmxvYXQnLCB0aGlzLnZib19hKTtcbiAgICAgICAgdGhpcy52Ym9fbGluZXdpZHRoID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX2ZnX2NvbG9yID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMudmJvX2JnX2NvbG9yID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4X2J1ZmZlciA9IG5ldyBnbG9vMi5JbmRleEJ1ZmZlcihnbCk7XG4gICAgfTtcbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGluZGljZXMsIG1haW5HbHlwaCwgdHJhbnMpIHtcbiAgICAgICAgdmFyIGJha2VkX29mZnNldCwgY2h1bmssIGNodW5rcywgY2h1bmtzaXplLCBpLCBqLCBrLCBsLCBtYWluR2xHbHlwaCwgbnZlcnRpY2VzLCBvZmZzZXQsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0cywgcywgdGhlc2VfaW5kaWNlcywgdWEsIHVpbnQxNl9pbmRleDtcbiAgICAgICAgbWFpbkdsR2x5cGggPSBtYWluR2x5cGguZ2xnbHlwaDtcbiAgICAgICAgbnZlcnRpY2VzID0gbWFpbkdsR2x5cGgubnZlcnRpY2VzO1xuICAgICAgICBpZiAobWFpbkdsR2x5cGguZGF0YV9jaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoIShpc0Zpbml0ZSh0cmFucy5keCkgJiYgaXNGaW5pdGUodHJhbnMuZHkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5HbEdseXBoLl9iYWtlZF9vZmZzZXQgPSBbdHJhbnMuZHgsIHRyYW5zLmR5XTtcbiAgICAgICAgICAgIG1haW5HbEdseXBoLl9zZXRfZGF0YShudmVydGljZXMpO1xuICAgICAgICAgICAgbWFpbkdsR2x5cGguZGF0YV9jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMuZ2x5cGguX3JhZGl1cyAhPSBudWxsKSAmJiAodHJhbnMuc3ggIT09IHRoaXMubGFzdF90cmFucy5zeCB8fCB0cmFucy5zeSAhPT0gdGhpcy5sYXN0X3RyYW5zLnN5KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0X3RyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICB0aGlzLnZib19zLnNldF9kYXRhKDAsIG5ldyBGbG9hdDMyQXJyYXkoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5nbHlwaC5zcmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHMgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFsc19jaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRfdmlzdWFscyhudmVydGljZXMpO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBiYWtlZF9vZmZzZXQgPSBtYWluR2xHbHlwaC5fYmFrZWRfb2Zmc2V0O1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfcGl4ZWxfcmF0aW8nLCAnZmxvYXQnLCBbdHJhbnMucGl4ZWxfcmF0aW9dKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X2NhbnZhc19zaXplJywgJ3ZlYzInLCBbdHJhbnMud2lkdGgsIHRyYW5zLmhlaWdodF0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3Vfb2Zmc2V0JywgJ3ZlYzInLCBbdHJhbnMuZHggLSBiYWtlZF9vZmZzZXRbMF0sIHRyYW5zLmR5IC0gYmFrZWRfb2Zmc2V0WzFdXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9zY2FsZScsICd2ZWMyJywgW3RyYW5zLnN4LCB0cmFucy5zeV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV94JywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX3gpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV95JywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX3kpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9zaXplJywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX3MpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9hbmdsZScsICdmbG9hdCcsIG1haW5HbEdseXBoLnZib19hKTtcbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kaWNlcy5sZW5ndGggPT09IG52ZXJ0aWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZy5kcmF3KHRoaXMuZ2wuUE9JTlRTLCBbMCwgbnZlcnRpY2VzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnZlcnRpY2VzIDwgNjU1MzUpIHtcbiAgICAgICAgICAgIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICBpZiAodWEuaW5kZXhPZihcIk1TSUUgXCIpICsgdWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpICsgdWEuaW5kZXhPZihcIkVkZ2UvXCIpID4gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybignV2ViR0wgd2FybmluZzogSUUgaXMga25vd24gdG8gcHJvZHVjZSAxcHggc3ByaXRlcyB3aGl0aCBzZWxlY3Rpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X3NpemUoaW5kaWNlcy5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyLnNldF9kYXRhKDAsIG5ldyBVaW50MTZBcnJheShpbmRpY2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9nLmRyYXcodGhpcy5nbC5QT0lOVFMsIHRoaXMuaW5kZXhfYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rc2l6ZSA9IDY0MDAwO1xuICAgICAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gTWF0aC5jZWlsKG52ZXJ0aWNlcyAvIGNodW5rc2l6ZSk7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gaW5kaWNlcy5sZW5ndGg7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICB1aW50MTZfaW5kZXggPSBpbmRpY2VzW2ldICUgY2h1bmtzaXplO1xuICAgICAgICAgICAgICAgIGNodW5rID0gTWF0aC5mbG9vcihpbmRpY2VzW2ldIC8gY2h1bmtzaXplKTtcbiAgICAgICAgICAgICAgICBjaHVua3NbY2h1bmtdLnB1c2godWludDE2X2luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY2h1bmsgPSBsID0gMCwgcmVmMiA9IGNodW5rcy5sZW5ndGg7IDAgPD0gcmVmMiA/IGwgPCByZWYyIDogbCA+IHJlZjI7IGNodW5rID0gMCA8PSByZWYyID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgdGhlc2VfaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShjaHVua3NbY2h1bmtdKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaHVuayAqIGNodW5rc2l6ZSAqIDQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoZXNlX2luZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV94JywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX3gsIDAsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfeScsICdmbG9hdCcsIG1haW5HbEdseXBoLnZib195LCAwLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3NpemUnLCAnZmxvYXQnLCBtYWluR2xHbHlwaC52Ym9fcywgMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9hbmdsZScsICdmbG9hdCcsIG1haW5HbEdseXBoLnZib19hLCAwLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZib19saW5ld2lkdGgudXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9saW5ld2lkdGgnLCAnZmxvYXQnLCB0aGlzLnZib19saW5ld2lkdGgsIDAsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZib19mZ19jb2xvci51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2ZnX2NvbG9yJywgJ3ZlYzQnLCB0aGlzLnZib19mZ19jb2xvciwgMCwgb2Zmc2V0ICogNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZib19iZ19jb2xvci51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2JnX2NvbG9yJywgJ3ZlYzQnLCB0aGlzLnZib19iZ19jb2xvciwgMCwgb2Zmc2V0ICogNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyLnNldF9zaXplKHRoZXNlX2luZGljZXMubGVuZ3RoICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X2RhdGEoMCwgdGhlc2VfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucHJvZy5kcmF3KHRoaXMuZ2wuUE9JTlRTLCB0aGlzLmluZGV4X2J1ZmZlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtlckdMR2x5cGgucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uIChudmVydGljZXMpIHtcbiAgICAgICAgdmFyIGksIGosIG4sIHJlZiwgcywgeHgsIHl5O1xuICAgICAgICBuID0gbnZlcnRpY2VzICogNDtcbiAgICAgICAgdGhpcy52Ym9feC5zZXRfc2l6ZShuKTtcbiAgICAgICAgdGhpcy52Ym9feS5zZXRfc2l6ZShuKTtcbiAgICAgICAgdGhpcy52Ym9fYS5zZXRfc2l6ZShuKTtcbiAgICAgICAgdGhpcy52Ym9fcy5zZXRfc2l6ZShuKTtcbiAgICAgICAgeHggPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuZ2x5cGguX3gpO1xuICAgICAgICB5eSA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5nbHlwaC5feSk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBudmVydGljZXM7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgeHhbaV0gKz0gdGhpcy5fYmFrZWRfb2Zmc2V0WzBdO1xuICAgICAgICAgICAgeXlbaV0gKz0gdGhpcy5fYmFrZWRfb2Zmc2V0WzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmJvX3guc2V0X2RhdGEoMCwgbmV3IEZsb2F0MzJBcnJheSh4eCkpO1xuICAgICAgICB0aGlzLnZib195LnNldF9kYXRhKDAsIG5ldyBGbG9hdDMyQXJyYXkoeXkpKTtcbiAgICAgICAgaWYgKHRoaXMuZ2x5cGguX2FuZ2xlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmJvX2Euc2V0X2RhdGEoMCwgbmV3IEZsb2F0MzJBcnJheSh0aGlzLmdseXBoLl9hbmdsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdseXBoLl9yYWRpdXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmJvX3Muc2V0X2RhdGEoMCwgbmV3IEZsb2F0MzJBcnJheSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBrLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmMSA9IHRoaXMuZ2x5cGguc3JhZGl1cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBzID0gcmVmMVtrXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHMgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52Ym9fcy5zZXRfZGF0YSgwLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZ2x5cGguX3NpemUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyR0xHbHlwaC5wcm90b3R5cGUuX3NldF92aXN1YWxzID0gZnVuY3Rpb24gKG52ZXJ0aWNlcykge1xuICAgICAgICBiYXNlXzEuYXR0YWNoX2Zsb2F0KHRoaXMucHJvZywgdGhpcy52Ym9fbGluZXdpZHRoLCAnYV9saW5ld2lkdGgnLCBudmVydGljZXMsIHRoaXMuZ2x5cGgudmlzdWFscy5saW5lLCAnbGluZV93aWR0aCcpO1xuICAgICAgICBiYXNlXzEuYXR0YWNoX2NvbG9yKHRoaXMucHJvZywgdGhpcy52Ym9fZmdfY29sb3IsICdhX2ZnX2NvbG9yJywgbnZlcnRpY2VzLCB0aGlzLmdseXBoLnZpc3VhbHMubGluZSwgJ2xpbmUnKTtcbiAgICAgICAgYmFzZV8xLmF0dGFjaF9jb2xvcih0aGlzLnByb2csIHRoaXMudmJvX2JnX2NvbG9yLCAnYV9iZ19jb2xvcicsIG52ZXJ0aWNlcywgdGhpcy5nbHlwaC52aXN1YWxzLmZpbGwsICdmaWxsJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfYW50aWFsaWFzJywgJ2Zsb2F0JywgWzAuOF0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtlckdMR2x5cGg7XG59KShiYXNlXzEuQmFzZUdMR2x5cGgpO1xuZXhwb3J0cy5DaXJjbGVHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENpcmNsZUdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENpcmNsZUdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBDaXJjbGVHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDaXJjbGVHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdjaXJjbGUnO1xuICAgIENpcmNsZUdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcIi8vIC0tLSBkaXNjXFxuZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIHJldHVybiBsZW5ndGgoUCkgLSBzaXplLzIuMDtcXG59XCI7XG4gICAgcmV0dXJuIENpcmNsZUdMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuU3F1YXJlR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTcXVhcmVHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcXVhcmVHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gU3F1YXJlR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3F1YXJlR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnc3F1YXJlJztcbiAgICBTcXVhcmVHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCIvLyAtLS0gc3F1YXJlXFxuZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIHJldHVybiBtYXgoYWJzKFAueCksIGFicyhQLnkpKSAtIHNpemUvMi4wO1xcbn1cIjtcbiAgICByZXR1cm4gU3F1YXJlR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5Bbm51bHVzR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbm51bHVzR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5udWx1c0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBBbm51bHVzR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5udWx1c0dMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ2FubnVsdXMnO1xuICAgIEFubnVsdXNHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgcjEgPSBsZW5ndGgoUCkgLSBzaXplLzIuMDtcXG4gICAgZmxvYXQgcjIgPSBsZW5ndGgoUCkgLSBzaXplLzQuMDsgIC8vIGhhbGYgd2lkdGhcXG4gICAgcmV0dXJuIG1heChyMSwgLXIyKTtcXG59XCI7XG4gICAgcmV0dXJuIEFubnVsdXNHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkRpYW1vbmRHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERpYW1vbmRHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaWFtb25kR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIERpYW1vbmRHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFtb25kR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnZGlhbW9uZCc7XG4gICAgRGlhbW9uZEdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcIi8vIC0tLSBkaWFtb25kXFxuZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIGZsb2F0IHggPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS41IC0gUC55KTtcXG4gICAgZmxvYXQgeSA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjUgKyBQLnkpO1xcbiAgICBmbG9hdCByMSA9IG1heChhYnMoeCksIGFicyh5KSkgLSBzaXplIC8gKDIuMCAqIFNRUlRfMik7XFxuICAgIHJldHVybiByMSAvIFNRUlRfMjtcXG59XCI7XG4gICAgcmV0dXJuIERpYW1vbmRHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLlRyaWFuZ2xlR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUcmlhbmdsZUdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRyaWFuZ2xlR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIFRyaWFuZ2xlR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVHJpYW5nbGVHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICd0cmlhbmdsZSc7XG4gICAgVHJpYW5nbGVHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgUC55IC09IHNpemUgKiAwLjM7XFxuICAgIGZsb2F0IHggPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS43IC0gUC55KTtcXG4gICAgZmxvYXQgeSA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjcgKyBQLnkpO1xcbiAgICBmbG9hdCByMSA9IG1heChhYnMoeCksIGFicyh5KSkgLSBzaXplIC8gMS42O1xcbiAgICBmbG9hdCByMiA9IFAueTtcXG4gICAgcmV0dXJuIG1heChyMSAvIFNRUlRfMiwgcjIpOyAgLy8gSW5zdGVyc2VjdCBkaWFtb25kIHdpdGggcmVjdGFuZ2xlXFxufVwiO1xuICAgIHJldHVybiBUcmlhbmdsZUdMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuSW52ZXJ0ZWRUcmlhbmdsZUdMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW52ZXJ0ZWRUcmlhbmdsZUdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEludmVydGVkVHJpYW5nbGVHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZUdMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEludmVydGVkVHJpYW5nbGVHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdpbnZlcnRlZHRyaWFuZ2xlJztcbiAgICBJbnZlcnRlZFRyaWFuZ2xlR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIFAueSArPSBzaXplICogMC4zO1xcbiAgICBmbG9hdCB4ID0gU1FSVF8yIC8gMi4wICogKFAueCAqIDEuNyAtIFAueSk7XFxuICAgIGZsb2F0IHkgPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS43ICsgUC55KTtcXG4gICAgZmxvYXQgcjEgPSBtYXgoYWJzKHgpLCBhYnMoeSkpIC0gc2l6ZSAvIDEuNjtcXG4gICAgZmxvYXQgcjIgPSAtIFAueTtcXG4gICAgcmV0dXJuIG1heChyMSAvIFNRUlRfMiwgcjIpOyAgLy8gSW5zdGVyc2VjdCBkaWFtb25kIHdpdGggcmVjdGFuZ2xlXFxufVwiO1xuICAgIHJldHVybiBJbnZlcnRlZFRyaWFuZ2xlR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5Dcm9zc0dMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ3Jvc3NHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDcm9zc0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBDcm9zc0dMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENyb3NzR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnY3Jvc3MnO1xuICAgIENyb3NzR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIGZsb2F0IHNxdWFyZSA9IG1heChhYnMoUC54KSwgYWJzKFAueSkpIC0gc2l6ZSAvIDIuNTsgIC8vIDIuNSBpcyBhIHR3ZWFrXFxuICAgIGZsb2F0IGNyb3NzID0gbWluKGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplIC8gMTAwLjA7ICAvLyBiaXQgb2YgXFxcIndpZHRoXFxcIiBmb3IgYWFcXG4gICAgcmV0dXJuIG1heChzcXVhcmUsIGNyb3NzKTtcXG59XCI7XG4gICAgcmV0dXJuIENyb3NzR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5DaXJjbGVDcm9zc0dMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2lyY2xlQ3Jvc3NHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDaXJjbGVDcm9zc0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBDaXJjbGVDcm9zc0dMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENpcmNsZUNyb3NzR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnY2lyY2xlY3Jvc3MnO1xuICAgIENpcmNsZUNyb3NzR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIC8vIERlZmluZSBxdWFkcmFudHNcXG4gICAgZmxvYXQgcXMgPSBzaXplIC8gMi4wOyAgLy8gcXVhZHJhbnQgc2l6ZVxcbiAgICBmbG9hdCBzMSA9IG1heChhYnMoUC54IC0gcXMpLCBhYnMoUC55IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMiA9IG1heChhYnMoUC54ICsgcXMpLCBhYnMoUC55IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMyA9IG1heChhYnMoUC54IC0gcXMpLCBhYnMoUC55ICsgcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzNCA9IG1heChhYnMoUC54ICsgcXMpLCBhYnMoUC55ICsgcXMpKSAtIHFzO1xcbiAgICAvLyBJbnRlcnNlY3QgbWFpbiBzaGFwZSB3aXRoIHF1YWRyYW50cyAodG8gZm9ybSBjcm9zcylcXG4gICAgZmxvYXQgY2lyY2xlID0gbGVuZ3RoKFApIC0gc2l6ZS8yLjA7XFxuICAgIGZsb2F0IGMxID0gbWF4KGNpcmNsZSwgczEpO1xcbiAgICBmbG9hdCBjMiA9IG1heChjaXJjbGUsIHMyKTtcXG4gICAgZmxvYXQgYzMgPSBtYXgoY2lyY2xlLCBzMyk7XFxuICAgIGZsb2F0IGM0ID0gbWF4KGNpcmNsZSwgczQpO1xcbiAgICAvLyBVbmlvblxcbiAgICByZXR1cm4gbWluKG1pbihtaW4oYzEsIGMyKSwgYzMpLCBjNCk7XFxufVwiO1xuICAgIHJldHVybiBDaXJjbGVDcm9zc0dMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuU3F1YXJlQ3Jvc3NHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNxdWFyZUNyb3NzR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU3F1YXJlQ3Jvc3NHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gU3F1YXJlQ3Jvc3NHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcXVhcmVDcm9zc0dMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ3NxdWFyZWNyb3NzJztcbiAgICBTcXVhcmVDcm9zc0dMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICAvLyBEZWZpbmUgcXVhZHJhbnRzXFxuICAgIGZsb2F0IHFzID0gc2l6ZSAvIDIuMDsgIC8vIHF1YWRyYW50IHNpemVcXG4gICAgZmxvYXQgczEgPSBtYXgoYWJzKFAueCAtIHFzKSwgYWJzKFAueSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczIgPSBtYXgoYWJzKFAueCArIHFzKSwgYWJzKFAueSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczMgPSBtYXgoYWJzKFAueCAtIHFzKSwgYWJzKFAueSArIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczQgPSBtYXgoYWJzKFAueCArIHFzKSwgYWJzKFAueSArIHFzKSkgLSBxcztcXG4gICAgLy8gSW50ZXJzZWN0IG1haW4gc2hhcGUgd2l0aCBxdWFkcmFudHMgKHRvIGZvcm0gY3Jvc3MpXFxuICAgIGZsb2F0IHNxdWFyZSA9IG1heChhYnMoUC54KSwgYWJzKFAueSkpIC0gc2l6ZS8yLjA7XFxuICAgIGZsb2F0IGMxID0gbWF4KHNxdWFyZSwgczEpO1xcbiAgICBmbG9hdCBjMiA9IG1heChzcXVhcmUsIHMyKTtcXG4gICAgZmxvYXQgYzMgPSBtYXgoc3F1YXJlLCBzMyk7XFxuICAgIGZsb2F0IGM0ID0gbWF4KHNxdWFyZSwgczQpO1xcbiAgICAvLyBVbmlvblxcbiAgICByZXR1cm4gbWluKG1pbihtaW4oYzEsIGMyKSwgYzMpLCBjNCk7XFxufVwiO1xuICAgIHJldHVybiBTcXVhcmVDcm9zc0dMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuRGlhbW9uZENyb3NzR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaWFtb25kQ3Jvc3NHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaWFtb25kQ3Jvc3NHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gRGlhbW9uZENyb3NzR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlhbW9uZENyb3NzR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnZGlhbW9uZGNyb3NzJztcbiAgICBEaWFtb25kQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgLy8gRGVmaW5lIHF1YWRyYW50c1xcbiAgICBmbG9hdCBxcyA9IHNpemUgLyAyLjA7ICAvLyBxdWFkcmFudCBzaXplXFxuICAgIGZsb2F0IHMxID0gbWF4KGFicyhQLnggLSBxcyksIGFicyhQLnkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMyID0gbWF4KGFicyhQLnggKyBxcyksIGFicyhQLnkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMzID0gbWF4KGFicyhQLnggLSBxcyksIGFicyhQLnkgKyBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHM0ID0gbWF4KGFicyhQLnggKyBxcyksIGFicyhQLnkgKyBxcykpIC0gcXM7XFxuICAgIC8vIEludGVyc2VjdCBtYWluIHNoYXBlIHdpdGggcXVhZHJhbnRzICh0byBmb3JtIGNyb3NzKVxcbiAgICBmbG9hdCB4ID0gU1FSVF8yIC8gMi4wICogKFAueCAqIDEuNSAtIFAueSk7XFxuICAgIGZsb2F0IHkgPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS41ICsgUC55KTtcXG4gICAgZmxvYXQgZGlhbW9uZCA9IG1heChhYnMoeCksIGFicyh5KSkgLSBzaXplIC8gKDIuMCAqIFNRUlRfMik7XFxuICAgIGRpYW1vbmQgLz0gU1FSVF8yO1xcbiAgICBmbG9hdCBjMSA9IG1heChkaWFtb25kLCBzMSk7XFxuICAgIGZsb2F0IGMyID0gbWF4KGRpYW1vbmQsIHMyKTtcXG4gICAgZmxvYXQgYzMgPSBtYXgoZGlhbW9uZCwgczMpO1xcbiAgICBmbG9hdCBjNCA9IG1heChkaWFtb25kLCBzNCk7XFxuICAgIC8vIFVuaW9uXFxuICAgIHJldHVybiBtaW4obWluKG1pbihjMSwgYzIpLCBjMyksIGM0KTtcXG59XCI7XG4gICAgcmV0dXJuIERpYW1vbmRDcm9zc0dMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuWEdMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWEdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFhHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gWEdMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFhHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICd4JztcbiAgICBYR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIGZsb2F0IGNpcmNsZSA9IGxlbmd0aChQKSAtIHNpemUgLyAxLjY7XFxuICAgIGZsb2F0IFggPSBtaW4oYWJzKFAueCAtIFAueSksIGFicyhQLnggKyBQLnkpKSAtIHNpemUgLyAxMDAuMDsgIC8vIGJpdCBvZiBcXFwid2lkdGhcXFwiIGZvciBhYVxcbiAgICByZXR1cm4gbWF4KGNpcmNsZSwgWCk7XFxufVwiO1xuICAgIHJldHVybiBYR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5DaXJjbGVYR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaXJjbGVYR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2lyY2xlWEdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBDaXJjbGVYR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2lyY2xlWEdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ2NpcmNsZXgnO1xuICAgIENpcmNsZVhHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgeCA9IFAueCAtIFAueTtcXG4gICAgZmxvYXQgeSA9IFAueCArIFAueTtcXG4gICAgLy8gRGVmaW5lIHF1YWRyYW50c1xcbiAgICBmbG9hdCBxcyA9IHNpemUgLyAyLjA7ICAvLyBxdWFkcmFudCBzaXplXFxuICAgIGZsb2F0IHMxID0gbWF4KGFicyh4IC0gcXMpLCBhYnMoeSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczIgPSBtYXgoYWJzKHggKyBxcyksIGFicyh5IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMyA9IG1heChhYnMoeCAtIHFzKSwgYWJzKHkgKyBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHM0ID0gbWF4KGFicyh4ICsgcXMpLCBhYnMoeSArIHFzKSkgLSBxcztcXG4gICAgLy8gSW50ZXJzZWN0IG1haW4gc2hhcGUgd2l0aCBxdWFkcmFudHMgKHRvIGZvcm0gY3Jvc3MpXFxuICAgIGZsb2F0IGNpcmNsZSA9IGxlbmd0aChQKSAtIHNpemUvMi4wO1xcbiAgICBmbG9hdCBjMSA9IG1heChjaXJjbGUsIHMxKTtcXG4gICAgZmxvYXQgYzIgPSBtYXgoY2lyY2xlLCBzMik7XFxuICAgIGZsb2F0IGMzID0gbWF4KGNpcmNsZSwgczMpO1xcbiAgICBmbG9hdCBjNCA9IG1heChjaXJjbGUsIHM0KTtcXG4gICAgLy8gVW5pb25cXG4gICAgZmxvYXQgYWxtb3N0ID0gbWluKG1pbihtaW4oYzEsIGMyKSwgYzMpLCBjNCk7XFxuICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIFggaXMgYWxzbyBvdXRzaWRlIG9mIHRoZSBtYWluIHNoYXBlXFxuICAgIGZsb2F0IFhtYXNrID0gbGVuZ3RoKFApIC0gc2l6ZSAvIDEuNjsgIC8vIGEgY2lyY2xlXFxuICAgIGZsb2F0IFggPSBtaW4oYWJzKFAueCAtIFAueSksIGFicyhQLnggKyBQLnkpKSAtIHNpemUgLyAxMDAuMDsgIC8vIGJpdCBvZiBcXFwid2lkdGhcXFwiIGZvciBhYVxcbiAgICByZXR1cm4gbWluKG1heChYLCBYbWFzayksIGFsbW9zdCk7XFxufVwiO1xuICAgIHJldHVybiBDaXJjbGVYR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5TcXVhcmVYR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTcXVhcmVYR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU3F1YXJlWEdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBTcXVhcmVYR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3F1YXJlWEdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ3NxdWFyZXgnO1xuICAgIFNxdWFyZVhHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgeCA9IFAueCAtIFAueTtcXG4gICAgZmxvYXQgeSA9IFAueCArIFAueTtcXG4gICAgLy8gRGVmaW5lIHF1YWRyYW50c1xcbiAgICBmbG9hdCBxcyA9IHNpemUgLyAyLjA7ICAvLyBxdWFkcmFudCBzaXplXFxuICAgIGZsb2F0IHMxID0gbWF4KGFicyh4IC0gcXMpLCBhYnMoeSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczIgPSBtYXgoYWJzKHggKyBxcyksIGFicyh5IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMyA9IG1heChhYnMoeCAtIHFzKSwgYWJzKHkgKyBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHM0ID0gbWF4KGFicyh4ICsgcXMpLCBhYnMoeSArIHFzKSkgLSBxcztcXG4gICAgLy8gSW50ZXJzZWN0IG1haW4gc2hhcGUgd2l0aCBxdWFkcmFudHMgKHRvIGZvcm0gY3Jvc3MpXFxuICAgIGZsb2F0IHNxdWFyZSA9IG1heChhYnMoUC54KSwgYWJzKFAueSkpIC0gc2l6ZS8yLjA7XFxuICAgIGZsb2F0IGMxID0gbWF4KHNxdWFyZSwgczEpO1xcbiAgICBmbG9hdCBjMiA9IG1heChzcXVhcmUsIHMyKTtcXG4gICAgZmxvYXQgYzMgPSBtYXgoc3F1YXJlLCBzMyk7XFxuICAgIGZsb2F0IGM0ID0gbWF4KHNxdWFyZSwgczQpO1xcbiAgICAvLyBVbmlvblxcbiAgICByZXR1cm4gbWluKG1pbihtaW4oYzEsIGMyKSwgYzMpLCBjNCk7XFxufVwiO1xuICAgIHJldHVybiBTcXVhcmVYR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5Bc3Rlcmlza0dMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXN0ZXJpc2tHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBc3Rlcmlza0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBBc3Rlcmlza0dMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFzdGVyaXNrR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnYXN0ZXJpc2snO1xuICAgIEFzdGVyaXNrR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIC8vIE1hc2tzXFxuICAgIGZsb2F0IGRpYW1vbmQgPSBtYXgoYWJzKFNRUlRfMiAvIDIuMCAqIChQLnggLSBQLnkpKSwgYWJzKFNRUlRfMiAvIDIuMCAqIChQLnggKyBQLnkpKSkgLSBzaXplIC8gKDIuMCAqIFNRUlRfMik7XFxuICAgIGZsb2F0IHNxdWFyZSA9IG1heChhYnMoUC54KSwgYWJzKFAueSkpIC0gc2l6ZSAvICgyLjAgKiBTUVJUXzIpO1xcbiAgICAvLyBTaGFwZXNcXG4gICAgZmxvYXQgWCA9IG1pbihhYnMoUC54IC0gUC55KSwgYWJzKFAueCArIFAueSkpIC0gc2l6ZSAvIDEwMC4wOyAgLy8gYml0IG9mIFxcXCJ3aWR0aFxcXCIgZm9yIGFhXFxuICAgIGZsb2F0IGNyb3NzID0gbWluKGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplIC8gMTAwLjA7ICAvLyBiaXQgb2YgXFxcIndpZHRoXFxcIiBmb3IgYWFcXG4gICAgLy8gUmVzdWx0IGlzIHVuaW9uIG9mIG1hc2tlZCBzaGFwZXNcXG4gICAgcmV0dXJuIG1pbihtYXgoWCwgZGlhbW9uZCksIG1heChjcm9zcywgc3F1YXJlKSk7XFxufVwiO1xuICAgIHJldHVybiBBc3Rlcmlza0dMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbiIsIi8qIERvIG5vdCBlZGl0LCBhdXRvZ2VuZXJhdGVkIGJ5IGZsZXh4LnB5c2NyaXB0ICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5vZGUgb3IgQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcm9vdC5nbG9vMiA9IG1vZHVsZS5leHBvcnRzOyAgLy8gYWxzbyBjcmVhdGUgZ2xvYmFsIG1vZHVsZSBpbiBOb2RlXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290Lmdsb28yID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHlmdW5jX2FkZCA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vIG5hcmdzOiAyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgICAgfSByZXR1cm4gYSArIGI7XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY19hbGwgPSBmdW5jdGlvbiAoeCkgeyAvLyBuYXJnczogMVxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8eC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFfcHlmdW5jX3RydXRoeSh4W2ldKSl7cmV0dXJuIGZhbHNlO31cbiAgICAgICAgfSByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBfcHlmdW5jX2NvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKGEsIGIpIHsgLy8gbmFyZ3M6IDJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxiLmxlbmd0aDsgaSsrKSB7aWYgKF9weWZ1bmNfZXF1YWxzKGEsIGJbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTt9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGIpIHtpZiAoYSA9PSBrKSByZXR1cm4gdHJ1ZTt9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYi5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmluZGV4T2YoYSkgPj0gMDtcbiAgICAgICAgfSB2YXIgZSA9IEVycm9yKCdOb3QgYSBjb250YWluZXI6ICcgKyBiKTsgZS5uYW1lPSdUeXBlRXJyb3InOyB0aHJvdyBlO1xuICAgIH07XG4gICAgdmFyIF9weWZ1bmNfZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChhLCBiKSB7IC8vIG5hcmdzOiAyXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGlzZXEgPSBhLmxlbmd0aCA9PSBiLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpc2VxICYmIGkgPCBhLmxlbmd0aCkge2lzZXEgPSBlcXVhbHMoYVtpXSwgYltpXSk7IGkrPTE7fVxuICAgICAgICAgICAgcmV0dXJuIGlzZXE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIGIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGFrZXlzID0gT2JqZWN0LmtleXMoYSksIGJrZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgICBha2V5cy5zb3J0KCk7IGJrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBpPTAsIGssIGlzZXEgPSBlcXVhbHMoYWtleXMsIGJrZXlzKTtcbiAgICAgICAgICAgIHdoaWxlIChpc2VxICYmIGkgPCBha2V5cy5sZW5ndGgpIHtrPWFrZXlzW2ldOyBpc2VxID0gZXF1YWxzKGFba10sIGJba10pOyBpKz0xO31cbiAgICAgICAgICAgIHJldHVybiBpc2VxO1xuICAgICAgICB9IHJldHVybiBhID09IGI7XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY19pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChvYiwgYXJncykgeyAvLyBuYXJnczogMlxuICAgICAgICBpZiAoKHR5cGVvZiBvYiA9PT0gXCJ1bmRlZmluZWRcIikgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgPT09IG9iKSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCA9PT0gb2IpKVxuICAgICAgICAgICAgICAgIHt0aHJvdyBcIkNsYXNzIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiO31cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYikge1xuICAgICAgICAgICAgaWYgKE9iamVjdFtuYW1lXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iW25hbWVdID09PSAnZnVuY3Rpb24nICYmICFvYltuYW1lXS5ub2JpbmQpIHtcbiAgICAgICAgICAgICAgICBvYltuYW1lXSA9IG9iW25hbWVdLmJpbmQob2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYi5fX2luaXRfXykge1xuICAgICAgICAgICAgb2IuX19pbml0X18uYXBwbHkob2IsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY19tdWx0ID0gZnVuY3Rpb24gKGEsIGIpIHsgLy8gbmFyZ3M6IDJcbiAgICAgICAgaWYgKCh0eXBlb2YgYSA9PT0gJ251bWJlcicpICsgKHR5cGVvZiBiID09PSAnbnVtYmVyJykgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHJldHVybiBfcHltZXRoX3JlcGVhdC5jYWxsKGEsIGIpO1xuICAgICAgICAgICAgaWYgKGIuY29uc3RydWN0b3IgPT09IFN0cmluZykgcmV0dXJuIF9weW1ldGhfcmVwZWF0LmNhbGwoYiwgYSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge3ZhciB0PWE7IGE9YjsgYj10O31cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdOyBmb3IgKHZhciBpPTA7IGk8YjsgaSsrKSByZXMgPSByZXMuY29uY2F0KGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gcmV0dXJuIGEgKiBiO1xuICAgIH07XG4gICAgdmFyIF9weWZ1bmNfcmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbCA9IHN0YXJ0O1xuICAgICAgICB2YXIgbiA9IChlbmQgLSBzdGFydCkgLyBzdGVwO1xuICAgICAgICBmb3IgKGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB2YWwgKz0gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgdmFyIF9weWZ1bmNfdHJ1dGh5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgIT09IFwib2JqZWN0XCIpIHtyZXR1cm4gdjt9XG4gICAgICAgIGVsc2UgaWYgKHYubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtyZXR1cm4gdi5sZW5ndGggPyB2IDogZmFsc2U7fVxuICAgICAgICBlbHNlIGlmICh2LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCkge3JldHVybiB2LmJ5dGVMZW5ndGggPyB2IDogZmFsc2U7fVxuICAgICAgICBlbHNlIGlmICh2LmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtyZXR1cm4gdHJ1ZTt9XG4gICAgICAgIGVsc2Uge3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2KS5sZW5ndGggPyB2IDogZmFsc2U7fVxuICAgIH07XG4gICAgdmFyIF9weW1ldGhfYXBwZW5kID0gZnVuY3Rpb24gKHgpIHsgLy8gbmFyZ3M6IDFcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMpKSByZXR1cm4gdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wdXNoKHgpO1xuICAgIH07XG4gICAgdmFyIF9weW1ldGhfZ2V0ID0gZnVuY3Rpb24gKGtleSwgZCkgeyAvLyBuYXJnczogMSAyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHJldHVybiB0aGlzLmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtyZXR1cm4gdGhpc1trZXldO31cbiAgICAgICAgZWxzZSBpZiAoZCAhPT0gdW5kZWZpbmVkKSB7cmV0dXJuIGQ7fVxuICAgICAgICBlbHNlIHtyZXR1cm4gbnVsbDt9XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9rZXlzID0gZnVuY3Rpb24gKCkgeyAvLyBuYXJnczogMFxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbJ2tleXMnXSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMua2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcyk7XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9sc3RyaXAgPSBmdW5jdGlvbiAoY2hhcnMpIHsgLy8gbmFyZ3M6IDAgMVxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKSByZXR1cm4gdGhpcy5sc3RyaXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY2hhcnMgPSAoY2hhcnMgPT09IHVuZGVmaW5lZCkgPyAnIFxcdFxcclxcbicgOiBjaGFycztcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFycy5pbmRleE9mKHRoaXNbaV0pIDwgMCkgcmV0dXJuIHRoaXMuc2xpY2UoaSk7XG4gICAgICAgIH0gcmV0dXJuICcnO1xuICAgIH07XG4gICAgdmFyIF9weW1ldGhfcmVtb3ZlID0gZnVuY3Rpb24gKHgpIHsgLy8gbmFyZ3M6IDFcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMpKSByZXR1cm4gdGhpcy5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfcHlmdW5jX2VxdWFscyh0aGlzW2ldLCB4KSkge3RoaXMuc3BsaWNlKGksIDEpOyByZXR1cm47fVxuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gRXJyb3IoeCk7IGUubmFtZT0nVmFsdWVFcnJvcic7IHRocm93IGU7XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9yZXBlYXQgPSBmdW5jdGlvbihjb3VudCkgeyAvLyBuYXJnczogMFxuICAgICAgICBpZiAodGhpcy5yZXBlYXQpIHJldHVybiB0aGlzLnJlcGVhdChjb3VudCk7XG4gICAgICAgIGlmIChjb3VudCA8IDEpIHJldHVybiAnJztcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBwYXR0ZXJuID0gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgIHdoaWxlIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb3VudCAmIDEpIHJlc3VsdCArPSBwYXR0ZXJuO1xuICAgICAgICAgICAgY291bnQgPj49IDEsIHBhdHRlcm4gKz0gcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcGF0dGVybjtcbiAgICB9O1xuICAgIHZhciBfcHltZXRoX3N0YXJ0c3dpdGggPSBmdW5jdGlvbiAoeCkgeyAvLyBuYXJnczogMVxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKSByZXR1cm4gdGhpcy5zdGFydHN3aXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoeCkgPT0gMDtcbiAgICB9O1xuICAgIHZhciBCdWZmZXIsIEdsb29PYmplY3QsIEluZGV4QnVmZmVyLCBQcm9ncmFtLCBUZXh0dXJlMkQsIFRleHR1cmUzRExpa2UsIFZlcnRleEJ1ZmZlciwgX192ZXJzaW9uX18sIGNoZWNrX2Vycm9yLCBjb25zb2xlO1xuICAgIC8vIFB5U2NyaXB0IG1vZHVsZSBmb3IgZ2xvbzIuanMgLSBsaWdodHdlaWdodCBvYmplY3Qgb3JpZW50ZWQgR0wuXG5cbiAgICB7IC8qIGlmIHRoaXNfaXNfanMoKSAqL1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbiAgICB9XG4gICAgX192ZXJzaW9uX18gPSBcIjAuM1wiO1xuICAgIGNoZWNrX2Vycm9yID0gZnVuY3Rpb24gKGdsLCB3aGVuKSB7XG4gICAgICAgIHZhciBlLCBlcnIsIGVycl8zLCBlcnJvcnMsIG1zZywgc3R1YjFfc2VxLCBzdHViMl9pdHI7XG4gICAgICAgIHdoZW4gPSAod2hlbiA9PT0gdW5kZWZpbmVkKSA/IFwicGVyaW9kaWMgY2hlY2tcIjogd2hlbjtcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBmcm9tIHRpbWUgdG8gdGltZSB0byBkZXRlY3QgR0wgZXJyb3JzLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gICAgIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gICAgIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgIHdoZW4gOiBzdHJcbiAgICAgICAgLy8gICAgICAgICBTaG93biBpbiB0aGUgZXhjZXB0aW9uIHRvIGhlbHAgdGhlIGRldmVsb3BlciBkZXRlcm1pbmUgd2hlblxuICAgICAgICAvLyAgICAgICAgIHRoaXMgY2hlY2sgd2FzIGRvbmUuXG4gICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZXJyID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgICAgIGlmICgoX3B5ZnVuY19lcXVhbHMoZXJyLCBnbC5OT19FUlJPUikgfHwgKF9weWZ1bmNfdHJ1dGh5KGVycm9ycykgJiYgX3B5ZnVuY19lcXVhbHMoZXJyLCBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtMV0pKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwoZXJyb3JzLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cgPSBcIlwiO1xuICAgICAgICAgICAgc3R1YjFfc2VxID0gZXJyb3JzO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2Ygc3R1YjFfc2VxID09PSBcIm9iamVjdFwiKSAmJiAoIUFycmF5LmlzQXJyYXkoc3R1YjFfc2VxKSkpIHtcbiAgICAgICAgICAgICAgICBzdHViMV9zZXEgPSBPYmplY3Qua2V5cyhzdHViMV9zZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChzdHViMl9pdHIgPSAwOyBzdHViMl9pdHIgPCBzdHViMV9zZXEubGVuZ3RoOyBzdHViMl9pdHIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGUgPSBzdHViMV9zZXFbc3R1YjJfaXRyXTtcbiAgICAgICAgICAgICAgICBtc2c9X3B5ZnVuY19hZGQobXNnLCBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgKFwiT3BlbkdMIGdvdCBlcnJvcnMgKFwiICsgd2hlbiArIFwiKTogXCIgKyBtc2cgKyBcIlwiKSk7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgR2xvb09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIEdsb28gY2xhc3Nlcy5cbiAgICAgICAgX3B5ZnVuY19pbnN0YW50aWF0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHbG9vT2JqZWN0LnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IE9iamVjdDtcbiAgICBHbG9vT2JqZWN0LnByb3RvdHlwZS5fY2xhc3NfbmFtZSA9IFwiR2xvb09iamVjdFwiO1xuICAgIFxuICAgIEdsb29PYmplY3QucHJvdG90eXBlLl9faW5pdF9fID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgICAgIC8vIEluaXQgYnkgcGFzc2luZyB0aGUgd2ViZ2wgY29udGV4dCBvYmplY3QuXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgIGlmICghKHRoaXMuaGFuZGxlICE9PSBudWxsKSkge3Rocm93IFwiQXNzZXJ0aW9uRXJyb3I6IFwiICsgXCJ0aGlzLmhhbmRsZSAhPT0gbnVsbFwiO31cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEdsb29PYmplY3QucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJfMjtcbiAgICAgICAgZXJyXzIgPSBuZXcgRXJyb3IoJ05vdEltcGxlbWVudGVkRXJyb3I6JyArIFwiXCIpOyBlcnJfMi5uYW1lID0gXCJOb3RJbXBsZW1lbnRlZEVycm9yXCI7IHRocm93IGVycl8yO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBQcm9ncmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGUgcHJvZ3JhbSBpcyB0aGUgY2VudHJhbCBjb21wb25lbnQgdG8gY29ubmVjdCBnbG9vIG9iamVjdHMgYW5kIHNoYWRlcnMuXG4gICAgICAgIF9weWZ1bmNfaW5zdGFudGlhdGUodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJvZ3JhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdsb29PYmplY3QucHJvdG90eXBlKTtcbiAgICBQcm9ncmFtLnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IEdsb29PYmplY3QucHJvdG90eXBlO1xuICAgIFByb2dyYW0ucHJvdG90eXBlLl9jbGFzc19uYW1lID0gXCJQcm9ncmFtXCI7XG4gICAgXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuVVRZUEVNQVAgPSB7XCJmbG9hdFwiOiBcInVuaWZvcm0xZnZcIiwgXCJ2ZWMyXCI6IFwidW5pZm9ybTJmdlwiLCBcInZlYzNcIjogXCJ1bmlmb3JtM2Z2XCIsIFwidmVjNFwiOiBcInVuaWZvcm00ZnZcIiwgXCJpbnRcIjogXCJ1bmlmb3JtMWl2XCIsIFwiaXZlYzJcIjogXCJ1bmlmb3JtMml2XCIsIFwiaXZlYzNcIjogXCJ1bmlmb3JtM2l2XCIsIFwiaXZlYzRcIjogXCJ1bmlmb3JtNGl2XCIsIFwiYm9vbFwiOiBcInVuaWZvcm0xaXZcIiwgXCJidmVjMlwiOiBcInVuaWZvcm0yaXZcIiwgXCJidmVjM1wiOiBcInVuaWZvcm0zaXZcIiwgXCJidmVjNFwiOiBcInVuaWZvcm00aXZcIiwgXCJtYXQyXCI6IFwidW5pZm9ybU1hdHJpeDJmdlwiLCBcIm1hdDNcIjogXCJ1bmlmb3JtTWF0cml4M2Z2XCIsIFwibWF0NFwiOiBcInVuaWZvcm1NYXRyaXg0ZnZcIiwgXCJzYW1wbGVyMURcIjogXCJ1bmlmb3JtMWlcIiwgXCJzYW1wbGVyMkRcIjogXCJ1bmlmb3JtMWlcIiwgXCJzYW1wbGVyM0RcIjogXCJ1bmlmb3JtMWlcIn07XG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuQVRZUEVNQVAgPSB7XCJmbG9hdFwiOiBcInZlcnRleEF0dHJpYjFmXCIsIFwidmVjMlwiOiBcInZlcnRleEF0dHJpYjJmXCIsIFwidmVjM1wiOiBcInZlcnRleEF0dHJpYjNmXCIsIFwidmVjNFwiOiBcInZlcnRleEF0dHJpYjRmXCJ9O1xuICAgIFByb2dyYW0ucHJvdG90eXBlLkFUWVBFSU5GTyA9IHtcImZsb2F0XCI6IFsxLCA1MTI2XSwgXCJ2ZWMyXCI6IFsyLCA1MTI2XSwgXCJ2ZWMzXCI6IFszLCA1MTI2XSwgXCJ2ZWM0XCI6IFs0LCA1MTI2XX07XG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLl9nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25zID0ge307XG4gICAgICAgIHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2FtcGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl9rbm93bl9pbnZhbGlkID0gW107XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcHJvZ3JhbS5cbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIHByb2dyYW0uXG4gICAgICAgIHRoaXMuX2dsLnVzZVByb2dyYW0odGhpcy5oYW5kbGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgcHJvZ3JhbS5cbiAgICAgICAgdGhpcy5fZ2wudXNlUHJvZ3JhbSgwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLnNldF9zaGFkZXJzID0gZnVuY3Rpb24gKHZlcnQsIGZyYWcpIHtcbiAgICAgICAgdmFyIGNvZGUsIGVycl8zLCBlcnJfNCwgZXJyb3JzLCBmcmFnX2hhbmRsZSwgZ2wsIGhhbmRsZSwgaSwgc3RhdHVzLCBzdHViM18sIHRtcCwgdHlwZV8sIHZlcnRfaGFuZGxlO1xuICAgICAgICAvLyBTZXQgR0xTTCBjb2RlIGZvciB0aGUgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGNhcmUgb2Ygc2V0dGluZyB0aGUgc2hhZGluZyBjb2RlIGFuZFxuICAgICAgICAvLyBjb21waWxpbmcrbGlua2luZyBpdCBpbnRvIGEgd29ya2luZyBwcm9ncmFtIG9iamVjdCB0aGF0IGlzIHJlYWR5XG4gICAgICAgIC8vIHRvIHVzZS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyB2ZXJ0IDogc3RyXG4gICAgICAgIC8vICAgICBHTFNMIGNvZGUgZm9yIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAgICAvLyBmcmFnIDogc3RyXG4gICAgICAgIC8vICAgICBHTFNMIGNvZGUgZm9yIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgIGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIHRoaXMuX2xpbmtlZCA9IGZhbHNlO1xuICAgICAgICB2ZXJ0X2hhbmRsZSA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgZnJhZ19oYW5kbGUgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdG1wID0gW1t2ZXJ0LCB2ZXJ0X2hhbmRsZSwgXCJ2ZXJ0ZXhcIl0sIFtmcmFnLCBmcmFnX2hhbmRsZSwgXCJmcmFnbWVudFwiXV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHN0dWIzXyA9IHRtcFtpXTtcbiAgICAgICAgICAgIGNvZGUgPSBzdHViM19bMF07aGFuZGxlID0gc3R1YjNfWzFdO3R5cGVfID0gc3R1YjNfWzJdO1xuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKGhhbmRsZSwgY29kZSk7XG4gICAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKGhhbmRsZSk7XG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoaGFuZGxlLCBnbC5DT01QSUxFX1NUQVRVUyk7XG4gICAgICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeShzdGF0dXMpKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBlcnJfNCA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyAoX3B5ZnVuY19hZGQoKChcImVycm9ycyBpbiBcIiArIHR5cGVfKSArIFwiIHNoYWRlcjpcXG5cIiksIGVycm9ycykpKTsgZXJyXzQubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl80O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLmhhbmRsZSwgdmVydF9oYW5kbGUpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIGZyYWdfaGFuZGxlKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0odGhpcy5oYW5kbGUpO1xuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeShnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBnbC5MSU5LX1NUQVRVUykpKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgKFwiUHJvZ3JhbSBsaW5rIGVycm9yOlxcblwiICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5oYW5kbGUpKSk7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91bnNldF92YXJpYWJsZXMgPSB0aGlzLl9nZXRfYWN0aXZlX2F0dHJpYnV0ZXNfYW5kX3VuaWZvcm1zKCk7XG4gICAgICAgIGdsLmRldGFjaFNoYWRlcih0aGlzLmhhbmRsZSwgdmVydF9oYW5kbGUpO1xuICAgICAgICBnbC5kZXRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIGZyYWdfaGFuZGxlKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRfaGFuZGxlKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdfaGFuZGxlKTtcbiAgICAgICAgdGhpcy5fa25vd25faW52YWxpZCA9IFtdO1xuICAgICAgICB0aGlzLl9saW5rZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuX2dldF9hY3RpdmVfYXR0cmlidXRlc19hbmRfdW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzLCBjYSwgY29udGFpbmVyLCBjb3VudCwgY3UsIGdldEFjdGl2ZSwgZ2V0TG9jYXRpb24sIGdsLCBpLCBpbmZvLCBqLCBtLCBuYW1lLCByZWdleCwgc3R1YjRfLCBzdHViNV9zZXEsIHN0dWI2X2l0ciwgdW5pZm9ybXMsIHg7XG4gICAgICAgIC8vIFJldHJpZXZlIGFjdGl2ZSBhdHRyaWJ1dGVzIGFuZCB1bmlmb3JtcyB0byBiZSBhYmxlIHRvIGNoZWNrIHRoYXRcbiAgICAgICAgLy8gYWxsIHVuaWZvcm1zL2F0dHJpYnV0ZXMgYXJlIHNldCBieSB0aGUgdXNlci5cbiAgICAgICAgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSB7fTtcbiAgICAgICAgcmVnZXggPSBuZXcgd2luZG93LlJlZ0V4cChcIihcXFxcdyspXFxcXHMqKFxcXFxbKFxcXFxkKylcXFxcXSlcXFxccypcIik7XG4gICAgICAgIGN1ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLmhhbmRsZSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcbiAgICAgICAgY2EgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgdW5pZm9ybXMgPSBbXTtcbiAgICAgICAgc3R1YjVfc2VxID0gW1thdHRyaWJ1dGVzLCBjYSwgZ2wuZ2V0QWN0aXZlQXR0cmliLCBnbC5nZXRBdHRyaWJMb2NhdGlvbl0sIFt1bmlmb3JtcywgY3UsIGdsLmdldEFjdGl2ZVVuaWZvcm0sIGdsLmdldFVuaWZvcm1Mb2NhdGlvbl1dO1xuICAgICAgICBpZiAoKHR5cGVvZiBzdHViNV9zZXEgPT09IFwib2JqZWN0XCIpICYmICghQXJyYXkuaXNBcnJheShzdHViNV9zZXEpKSkge1xuICAgICAgICAgICAgc3R1YjVfc2VxID0gT2JqZWN0LmtleXMoc3R1YjVfc2VxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHN0dWI2X2l0ciA9IDA7IHN0dWI2X2l0ciA8IHN0dWI1X3NlcS5sZW5ndGg7IHN0dWI2X2l0ciArPSAxKSB7XG4gICAgICAgICAgICB4ID0gc3R1YjVfc2VxW3N0dWI2X2l0cl07XG4gICAgICAgICAgICBzdHViNF8gPSB4O1xuICAgICAgICAgICAgY29udGFpbmVyID0gc3R1YjRfWzBdO2NvdW50ID0gc3R1YjRfWzFdO2dldEFjdGl2ZSA9IHN0dWI0X1syXTtnZXRMb2NhdGlvbiA9IHN0dWI0X1szXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaW5mbyA9IGdldEFjdGl2ZS5jYWxsKGdsLCB0aGlzLmhhbmRsZSwgaSk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgICAgICAgICAgICBtID0gbmFtZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KG0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBtWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5mby5zaXplOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwoY29udGFpbmVyLCAoW1wiXCIgKyBuYW1lICsgXCJbXCIgKyBqICsgXCJdXCIsIGluZm8udHlwZV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwoY29udGFpbmVyLCBbbmFtZSwgaW5mby50eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb25zW25hbWVdID0gZ2V0TG9jYXRpb24uY2FsbChnbCwgdGhpcy5oYW5kbGUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcHlmdW5jX2FkZCgoKGZ1bmN0aW9uIGxpc3RfY29tcHJlaGVuc29uICgpIHt2YXIgcmVzID0gW107dmFyIHYsIGl0ZXIwLCBpMDtpdGVyMCA9IGF0dHJpYnV0ZXM7aWYgKCh0eXBlb2YgaXRlcjAgPT09IFwib2JqZWN0XCIpICYmICghQXJyYXkuaXNBcnJheShpdGVyMCkpKSB7aXRlcjAgPSBPYmplY3Qua2V5cyhpdGVyMCk7fWZvciAoaTA9MDsgaTA8aXRlcjAubGVuZ3RoOyBpMCsrKSB7diA9IGl0ZXIwW2kwXTt7cmVzLnB1c2godlswXSk7fX1yZXR1cm4gcmVzO30pLmFwcGx5KHRoaXMpKSwgKChmdW5jdGlvbiBsaXN0X2NvbXByZWhlbnNvbiAoKSB7dmFyIHJlcyA9IFtdO3ZhciB2LCBpdGVyMCwgaTA7aXRlcjAgPSB1bmlmb3JtcztpZiAoKHR5cGVvZiBpdGVyMCA9PT0gXCJvYmplY3RcIikgJiYgKCFBcnJheS5pc0FycmF5KGl0ZXIwKSkpIHtpdGVyMCA9IE9iamVjdC5rZXlzKGl0ZXIwKTt9Zm9yIChpMD0wOyBpMDxpdGVyMC5sZW5ndGg7IGkwKyspIHt2ID0gaXRlcjBbaTBdO3tyZXMucHVzaCh2WzBdKTt9fXJldHVybiByZXM7fSkuYXBwbHkodGhpcykpKTtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuc2V0X3RleHR1cmUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVycl8zLCBoYW5kbGUsIHVuaXQ7XG4gICAgICAgIC8vIFNldCBhIHRleHR1cmUgc2FtcGxlci5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIEEgdGV4dHVyZSBpcyBhIDIgZGltZW5zaW9uYWwgZ3JpZCBvZiBjb2xvcnMvaW50ZW5zaXRpZXMgdGhhdFxuICAgICAgICAvLyBjYW4gYmUgYXBwbGllZCB0byBhIGZhY2UgKG9yIHVzZWQgZm9yIG90aGVyIG1lYW5zIGJ5IHByb3ZpZGluZ1xuICAgICAgICAvLyBhIHJlZ3VsYXIgZ3JpZCBvZiBkYXRhKS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBuYW1lIDogc3RyXG4gICAgICAgIC8vICAgICBUaGUgbmFtZSBieSB3aGljaCB0aGUgdGV4dHVyZSBpcyBrbm93biBpbiB0aGUgR0xTTCBjb2RlLlxuICAgICAgICAvLyB2YWx1ZSA6IFRleHR1cmUyRFxuICAgICAgICAvLyAgICAgVGhlIGdsb28gVGV4dHVyZTJEIG9iamVjdCB0byBiaW5kLlxuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeSh0aGlzLl9saW5rZWQpKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgXCJDYW5ub3Qgc2V0IHVuaWZvcm0gd2hlbiBwcm9ncmFtIGhhcyBubyBjb2RlXCIpOyBlcnJfMy5uYW1lID0gXCJSdW50aW1lRXJyb3JcIjsgdGhyb3cgZXJyXzM7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlID0gX3B5bWV0aF9nZXQuY2FsbCh0aGlzLmxvY2F0aW9ucywgbmFtZSwgKC0xKSk7XG4gICAgICAgIGlmIChfcHlmdW5jX3RydXRoeShoYW5kbGUgPCAwKSkge1xuICAgICAgICAgICAgaWYgKCghX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl9rbm93bl9pbnZhbGlkKSkpIHtcbiAgICAgICAgICAgICAgICBfcHltZXRoX2FwcGVuZC5jYWxsKHRoaXMuX2tub3duX2ludmFsaWQsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyBuYW1lICsgXCIgaXMgbm90IGFuIGFjdGl2ZSB0ZXh0dXJlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9weWZ1bmNfY29udGFpbnMobmFtZSwgdGhpcy5fdW5zZXRfdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgX3B5bWV0aF9yZW1vdmUuY2FsbCh0aGlzLl91bnNldF92YXJpYWJsZXMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgIHVuaXQgPSBfcHltZXRoX2tleXMuY2FsbCh0aGlzLl9zYW1wbGVycykubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKF9weWZ1bmNfY29udGFpbnMobmFtZSwgdGhpcy5fc2FtcGxlcnMpKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9IHRoaXMuX3NhbXBsZXJzW25hbWVdW3RoaXMuX3NhbXBsZXJzW25hbWVdLmxlbmd0aCAtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zYW1wbGVyc1tuYW1lXSA9IFt2YWx1ZS5fdGFyZ2V0LCB2YWx1ZS5oYW5kbGUsIHVuaXRdO1xuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFpKGhhbmRsZSwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLnNldF91bmlmb3JtID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVfLCB2YWx1ZSkge1xuICAgICAgICB2YXIgYV90eXBlLCBjb3VudCwgZXJyXzMsIGZ1bmNuYW1lLCBoYW5kbGUsIGosIG5hbWVfO1xuICAgICAgICAvLyBTZXQgYSB1bmlmb3JtIHZhbHVlLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gQSB1bmlmb3JtIGlzIGEgdmFsdWUgdGhhdCBpcyBnbG9iYWwgdG8gYm90aCB0aGUgdmVydGV4IGFuZFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gbmFtZSA6IHN0clxuICAgICAgICAvLyAgICAgVGhlIG5hbWUgYnkgd2hpY2ggdGhlIHVuaWZvcm0gaXMga25vd24gaW4gdGhlIEdMU0wgY29kZS5cbiAgICAgICAgLy8gdHlwZV8gOiBzdHJcbiAgICAgICAgLy8gICAgIFRoZSB0eXBlIG9mIHRoZSB1bmlmb3JtLCBlLmcuICdmbG9hdCcsICd2ZWMyJywgZXRjLlxuICAgICAgICAvLyB2YWx1ZSA6IGxpc3Qgb2Ygc2NhbGFyc1xuICAgICAgICAvLyAgICAgVGhlIHZhbHVlIGZvciB0aGUgdW5pZm9ybS4gU2hvdWxkIGJlIGEgbGlzdCBldmVuIGZvciB0eXBlIGZsb2F0LlxuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeSh0aGlzLl9saW5rZWQpKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgXCJDYW5ub3Qgc2V0IHVuaWZvcm0gd2hlbiBwcm9ncmFtIGhhcyBubyBjb2RlXCIpOyBlcnJfMy5uYW1lID0gXCJSdW50aW1lRXJyb3JcIjsgdGhyb3cgZXJyXzM7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlID0gX3B5bWV0aF9nZXQuY2FsbCh0aGlzLmxvY2F0aW9ucywgbmFtZSwgKC0xKSk7XG4gICAgICAgIGlmIChfcHlmdW5jX3RydXRoeShoYW5kbGUgPCAwKSkge1xuICAgICAgICAgICAgaWYgKCghX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl9rbm93bl9pbnZhbGlkKSkpIHtcbiAgICAgICAgICAgICAgICBfcHltZXRoX2FwcGVuZC5jYWxsKHRoaXMuX2tub3duX2ludmFsaWQsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyBuYW1lICsgXCIgaXMgbm90IGFuIGFjdGl2ZSB1bmlmb3JtXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9weWZ1bmNfY29udGFpbnMobmFtZSwgdGhpcy5fdW5zZXRfdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgX3B5bWV0aF9yZW1vdmUuY2FsbCh0aGlzLl91bnNldF92YXJpYWJsZXMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgaWYgKCghX3B5bWV0aF9zdGFydHN3aXRoLmNhbGwodHlwZV8sIFwibWF0XCIpKSkge1xuICAgICAgICAgICAgYV90eXBlID0gX3B5bWV0aF9nZXQuY2FsbCh7XCJpbnRcIjogXCJmbG9hdFwiLCBcImJvb2xcIjogXCJmbG9hdFwifSwgdHlwZV8sIF9weW1ldGhfbHN0cmlwLmNhbGwodHlwZV8sIFwiaWJcIikpO1xuICAgICAgICAgICAgY291bnQgPSBNYXRoLmZsb29yKHZhbHVlLmxlbmd0aC8odGhpcy5BVFlQRUlORk9bYV90eXBlXVswXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcHlmdW5jX3RydXRoeShjb3VudCA+IDEpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICgoX3B5ZnVuY19jb250YWlucygoXCJcIiArIG5hbWUgKyBcIltcIiArIGogKyBcIl1cIiksIHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVfID0gXCJcIiArIG5hbWUgKyBcIltcIiArIGogKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9weWZ1bmNfY29udGFpbnMobmFtZV8sIHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9weW1ldGhfcmVtb3ZlLmNhbGwodGhpcy5fdW5zZXRfdmFyaWFibGVzLCBuYW1lXyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY25hbWUgPSB0aGlzLlVUWVBFTUFQW3R5cGVfXTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICBpZiAoX3B5bWV0aF9zdGFydHN3aXRoLmNhbGwodHlwZV8sIFwibWF0XCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9nbFtmdW5jbmFtZV0oaGFuZGxlLCBmYWxzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2xbZnVuY25hbWVdKGhhbmRsZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5zZXRfYXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVfLCB2YWx1ZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIGVycl8zLCBmdW5jbmFtZSwgZ3R5cGUsIGhhbmRsZSwgaXNfdmJvLCBzaXplLCBzdHViN187XG4gICAgICAgIHN0cmlkZSA9IChzdHJpZGUgPT09IHVuZGVmaW5lZCkgPyAwOiBzdHJpZGU7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPT09IHVuZGVmaW5lZCkgPyAwOiBvZmZzZXQ7XG4gICAgICAgIC8vIFNldCBhbiBhdHRyaWJ1dGUgdmFsdWUuIFxuICAgICAgICAvLyBcbiAgICAgICAgLy8gQW4gYXR0cmlidXRlIHJlcHJlc2VudHMgcGVyLXZlcnRleCBkYXRhIGFuZCBjYW4gb25seSBiZSB1c2VkXG4gICAgICAgIC8vIGluIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG5hbWUgOiBzdHJcbiAgICAgICAgLy8gICAgIFRoZSBuYW1lIGJ5IHdoaWNoIHRoZSBhdHRyaWJ1dGUgaXMga25vd24gaW4gdGhlIEdMU0wgY29kZS5cbiAgICAgICAgLy8gdHlwZV8gOiBzdHJcbiAgICAgICAgLy8gICAgIFRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUsIGUuZy4gJ2Zsb2F0JywgJ3ZlYzInLCBldGMuXG4gICAgICAgIC8vIHZhbHVlIDogVmVydGV4QnVmZmVyLCBhcnJheVxuICAgICAgICAvLyAgICAgSWYgdmFsdWUgaXMgYSBWZXJ0ZXhCdWZmZXIsIGl0IGlzIHVzZWQgKHdpdGggc3RyaWRlIGFuZCBvZmZzZXQpXG4gICAgICAgIC8vICAgICBmb3IgdGhlIHZlcnRleCBkYXRhLiBJZiB2YWx1ZSBpcyBhbiBhcnJheSwgaXRzIHVzZWQgdG8gc2V0XG4gICAgICAgIC8vICAgICB0aGUgdmFsdWUgb2YgYWxsIHZlcnRpY2VzIChzaW1pbGFyIHRvIGEgdW5pZm9ybSkuXG4gICAgICAgIC8vIHN0aWRlIDogaW50LCBkZWZhdWx0IDBcbiAgICAgICAgLy8gICAgIFRoZSBzdHJpZGUgdG8gXCJzYW1wbGVcIiB0aGUgdmVydGV4IGRhdGEgaW5zaWRlIHRoZSBidWZmZXIuIFVubGVzc1xuICAgICAgICAvLyAgICAgbXVsdGlwbGUgdmVydGV4IGRhdGEgYXJlIHBhY2tlZCBpbnRvIGEgc2luZ2xlIGJ1ZmZlciwgdGhpcyBzaG91bGRcbiAgICAgICAgLy8gICAgIGJlIHplcm8uXG4gICAgICAgIC8vIG9mZnNldCA6IGludCwgZGVmYXVsdCAwXG4gICAgICAgIC8vICAgICBUaGUgb2Zmc2V0IHRvIFwic2FtcGxlXCIgdGhlIHZlcnRleCBkYXRhIGluc2lkZSB0aGUgYnVmZmVyLiBVbmxlc3NcbiAgICAgICAgLy8gICAgIG11bHRpcGxlIHZlcnRleCBkYXRhIGFyZSBwYWNrZWQgaW50byBhIHNpbmdsZSBidWZmZXIsIG9yIG9ubHlcbiAgICAgICAgLy8gICAgIGEgcGFydCBvZiB0aGUgZGF0YSBtdXN0IGJlIHVzZWQsIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHplcm8uXG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHRoaXMuX2xpbmtlZCkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyBcIkNhbm5vdCBzZXQgYXR0cmlidXRlIHdoZW4gcHJvZ3JhbSBoYXMgbm8gY29kZVwiKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIGlzX3ZibyA9IHZhbHVlIGluc3RhbmNlb2YgVmVydGV4QnVmZmVyO1xuICAgICAgICBoYW5kbGUgPSBfcHltZXRoX2dldC5jYWxsKHRoaXMubG9jYXRpb25zLCBuYW1lLCAoLTEpKTtcbiAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KGhhbmRsZSA8IDApKSB7XG4gICAgICAgICAgICBpZiAoKCFfcHlmdW5jX2NvbnRhaW5zKG5hbWUsIHRoaXMuX2tub3duX2ludmFsaWQpKSkge1xuICAgICAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwodGhpcy5fa25vd25faW52YWxpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKChfcHlmdW5jX3RydXRoeShpc192Ym8pICYmIF9weWZ1bmNfdHJ1dGh5KG9mZnNldCA+IDApKSkge1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyBuYW1lICsgXCIgaXMgbm90IGFuIGFjdGl2ZSBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9weWZ1bmNfY29udGFpbnMobmFtZSwgdGhpcy5fdW5zZXRfdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgX3B5bWV0aF9yZW1vdmUuY2FsbCh0aGlzLl91bnNldF92YXJpYWJsZXMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgaWYgKCghX3B5ZnVuY190cnV0aHkoaXNfdmJvKSkpIHtcbiAgICAgICAgICAgIGZ1bmNuYW1lID0gdGhpcy5BVFlQRU1BUFt0eXBlX107XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gWzAsIGhhbmRsZSwgZnVuY25hbWUsIHZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0dWI3XyA9IHRoaXMuQVRZUEVJTkZPW3R5cGVfXTtcbiAgICAgICAgICAgIHNpemUgPSBzdHViN19bMF07Z3R5cGUgPSBzdHViN19bMV07XG4gICAgICAgICAgICBmdW5jbmFtZSA9IFwidmVydGV4QXR0cmliUG9pbnRlclwiO1xuICAgICAgICAgICAgYXJncyA9IFtzaXplLCBndHlwZSwgdGhpcy5fZ2wuRkFMU0UsIHN0cmlkZSwgb2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSBbdmFsdWUuaGFuZGxlLCBoYW5kbGUsIGZ1bmNuYW1lLCBhcmdzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuX3ByZV9kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncywgYXR0cl9oYW5kbGUsIGZ1bmNuYW1lLCBzdHViMTBfLCBzdHViMTFfc2VxLCBzdHViOF8sIHN0dWI5X3NlcSwgdGV4X2hhbmRsZSwgdGV4X3RhcmdldCwgdW5pdCwgdmJvX2hhbmRsZSwgeDtcbiAgICAgICAgLy8gUHJlcGFyZSBmb3IgZHJhd2luZy5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICBzdHViOV9zZXEgPSB0aGlzLl9zYW1wbGVycztcbiAgICAgICAgZm9yICh4IGluIHN0dWI5X3NlcSkge1xuICAgICAgICAgICAgaWYgKCFzdHViOV9zZXEuaGFzT3duUHJvcGVydHkoeCkpeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgeCA9IHN0dWI5X3NlcVt4XTtcbiAgICAgICAgICAgIHN0dWI4XyA9IHg7XG4gICAgICAgICAgICB0ZXhfdGFyZ2V0ID0gc3R1YjhfWzBdO3RleF9oYW5kbGUgPSBzdHViOF9bMV07dW5pdCA9IHN0dWI4X1syXTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmFjdGl2ZVRleHR1cmUoX3B5ZnVuY19hZGQodGhpcy5fZ2wuVEVYVFVSRTAsIHVuaXQpKTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRleF90YXJnZXQsIHRleF9oYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0dWIxMV9zZXEgPSB0aGlzLl9hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHggaW4gc3R1YjExX3NlcSkge1xuICAgICAgICAgICAgaWYgKCFzdHViMTFfc2VxLmhhc093blByb3BlcnR5KHgpKXsgY29udGludWU7IH1cbiAgICAgICAgICAgIHggPSBzdHViMTFfc2VxW3hdO1xuICAgICAgICAgICAgc3R1YjEwXyA9IHg7XG4gICAgICAgICAgICB2Ym9faGFuZGxlID0gc3R1YjEwX1swXTthdHRyX2hhbmRsZSA9IHN0dWIxMF9bMV07ZnVuY25hbWUgPSBzdHViMTBfWzJdO2FyZ3MgPSBzdHViMTBfWzNdO1xuICAgICAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KHZib19oYW5kbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHZib19oYW5kbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJfaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbFtmdW5jbmFtZV0uYXBwbHkodGhpcy5fZ2wsIFtdLmNvbmNhdChbYXR0cl9oYW5kbGVdLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cl9oYW5kbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsW2Z1bmNuYW1lXS5hcHBseSh0aGlzLl9nbCwgW10uY29uY2F0KFthdHRyX2hhbmRsZV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeSh0aGlzLl92YWxpZGF0ZWQpKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycl8zO1xuICAgICAgICBpZiAodGhpcy5fdW5zZXRfdmFyaWFibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ncmFtIGhhcyB1bnNldCB2YXJpYWJsZXM6IFwiICsgdGhpcy5fdW5zZXRfdmFyaWFibGVzICsgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudmFsaWRhdGVQcm9ncmFtKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgaWYgKCghX3B5ZnVuY190cnV0aHkodGhpcy5fZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLmhhbmRsZSwgdGhpcy5fZ2wuVkFMSURBVEVfU1RBVFVTKSkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9nbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLmhhbmRsZSkpO1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgXCJQcm9ncmFtIHZhbGlkYXRpb24gZXJyb3JcIik7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChtb2RlLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNvdW50LCBlcnJfMywgZmlyc3QsIGd0eXBlLCBzdHViMTJfO1xuICAgICAgICAvLyBEcmF3IHRoZSBjdXJyZW50IHZpc3VhbGl6YXRpb24gZGVmaW5lZCBieSB0aGUgcHJvZ3JhbS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBtb2RlIDogR0wgZW51bVxuICAgICAgICAvLyAgICAgQ2FuIGJlIFBPSU5UUywgTElORVMsIExJTkVfTE9PUCwgTElORV9TVFJJUCwgTElORV9GQU4sIFRSSUFOR0xFU1xuICAgICAgICAvLyBzZWxlY3Rpb24gOiAyLWVsZW1lbnQgdHVwbGUgb3IgSW5kZXhCdWZmZXJcbiAgICAgICAgLy8gICAgIFRoZSBzZWxlY3Rpb24gdG8gZHJhdywgc3BlY2lmaWVkIGVpdGhlciBhcyAoZmlyc3QsIGNvdW50KSBvciBhblxuICAgICAgICAvLyAgICAgSW5kZXhCdWZmZXIgb2JqZWN0LlxuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeSh0aGlzLl9saW5rZWQpKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgXCJDYW5ub3QgZHJhdyBwcm9ncmFtIGlmIGNvZGUgaGFzIG5vdCBiZWVuIHNldFwiKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrX2Vycm9yKHRoaXMuX2dsLCBcImJlZm9yZSBkcmF3XCIpO1xuICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkoc2VsZWN0aW9uIGluc3RhbmNlb2YgSW5kZXhCdWZmZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVfZHJhdygpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICBjb3VudCA9IHNlbGVjdGlvbi5fYnVmZmVyX3NpemUgLyAyO1xuICAgICAgICAgICAgZ3R5cGUgPSB0aGlzLl9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgICAgIHRoaXMuX2dsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgZ3R5cGUsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0dWIxMl8gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBmaXJzdCA9IHN0dWIxMl9bMF07Y291bnQgPSBzdHViMTJfWzFdO1xuICAgICAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KGNvdW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZV9kcmF3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZHJhd0FycmF5cyhtb2RlLCBmaXJzdCwgY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoZWNrX2Vycm9yKHRoaXMuX2dsLCBcImFmdGVyIGRyYXdcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFzZSBidWZmZXIgY2xhc3MgZm9yIHZlcnRleCBkYXRhIG9yIGluZGV4IGRhdGEuXG4gICAgICAgIF9weWZ1bmNfaW5zdGFudGlhdGUodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR2xvb09iamVjdC5wcm90b3R5cGUpO1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX2Jhc2VfY2xhc3MgPSBHbG9vT2JqZWN0LnByb3RvdHlwZTtcbiAgICBCdWZmZXIucHJvdG90eXBlLl9jbGFzc19uYW1lID0gXCJCdWZmZXJcIjtcbiAgICBcbiAgICBCdWZmZXIucHJvdG90eXBlLl90YXJnZXQgPSBudWxsO1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX3VzYWdlID0gMzUwNDg7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IHRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9idWZmZXJfc2l6ZSA9IDA7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBCdWZmZXIucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBidWZmZXIuXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZUJ1ZmZlcih0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBCdWZmZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBY3RpdmV0ZSB0aGUgYnVmZmVyLlxuICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX3RhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQnVmZmVyLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBidWZmZXIuXG4gICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fdGFyZ2V0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEJ1ZmZlci5wcm90b3R5cGUuc2V0X3NpemUgPSBmdW5jdGlvbiAobmJ5dGVzKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG5ieXRlcyA6IGludFxuICAgICAgICAvLyAgICAgVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IHRoZSBidWZmZXIgbmVlZHMgdG8gaG9sZC5cbiAgICAgICAgaWYgKCghX3B5ZnVuY19lcXVhbHMobmJ5dGVzLCB0aGlzLl9idWZmZXJfc2l6ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX3RhcmdldCwgbmJ5dGVzLCB0aGlzLl91c2FnZSk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJfc2l6ZSA9IG5ieXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQnVmZmVyLnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChvZmZzZXQsIGRhdGEpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBidWZmZXIgZGF0YS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBvZmZzZXQgOiBpbnRcbiAgICAgICAgLy8gICAgIFRoZSBvZmZzZXQgaW4gYnl0ZXMgZm9yIHRoZSBuZXcgZGF0YS5cbiAgICAgICAgLy8gZGF0YSA6IHR5cGVkIGFycmF5XG4gICAgICAgIC8vICAgICBUaGUgZGF0YSB0byB1cGxvYWQuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl90YXJnZXQsIG9mZnNldCwgZGF0YSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIFZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQSBidWZmZXIgZm9yIHZlcnRleCBkYXRhLlxuICAgICAgICBfcHlmdW5jX2luc3RhbnRpYXRlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpO1xuICAgIFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuX2Jhc2VfY2xhc3MgPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIlZlcnRleEJ1ZmZlclwiO1xuICAgIFxuICAgIFZlcnRleEJ1ZmZlci5wcm90b3R5cGUuX3RhcmdldCA9IDM0OTYyO1xuXG4gICAgSW5kZXhCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEEgYnVmZmVyIGZvciBpbmRleCBkYXRhLlxuICAgICAgICBfcHlmdW5jX2luc3RhbnRpYXRlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEluZGV4QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG4gICAgSW5kZXhCdWZmZXIucHJvdG90eXBlLl9iYXNlX2NsYXNzID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICBJbmRleEJ1ZmZlci5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIkluZGV4QnVmZmVyXCI7XG4gICAgXG4gICAgSW5kZXhCdWZmZXIucHJvdG90eXBlLl90YXJnZXQgPSAzNDk2MztcblxuICAgIFRleHR1cmUyRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQSAyIGRpbWVuc2lvbmFsIHJlZ3VsYXIgZ3JpZC5cbiAgICAgICAgX3B5ZnVuY19pbnN0YW50aWF0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHbG9vT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IEdsb29PYmplY3QucHJvdG90eXBlO1xuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIlRleHR1cmUyRFwiO1xuICAgIFxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuX3RhcmdldCA9IDM1NTM7XG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fdHlwZXMgPSB7XCJJbnQ4QXJyYXlcIjogNTEyMCwgXCJVaW50OEFycmF5XCI6IDUxMjEsIFwiSW50MTZBcnJheVwiOiA1MTIyLCBcIlVpbnQxNkFycmF5XCI6IDUxMjMsIFwiSW50MzJBcnJheVwiOiA1MTI0LCBcIlVpbnQzMkFycmF5XCI6IDUxMjUsIFwiRmxvYXQzMkFycmF5XCI6IDUxMjZ9O1xuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLl9nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIHRoaXMuX3NoYXBlX2Zvcm1hdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9nbC5kZWxldGVUZXh0dXJlKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFjdGl2YXRlIHRoZSB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl90YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgdGV4dHVyZS5cbiAgICAgICAgdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fdGFyZ2V0LCAwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuX2dldF9hbGlnbm1lbnQgPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgdmFyIGFsaWdubWVudCwgYWxpZ25tZW50cywgc3R1YjEzX3NlcSwgc3R1YjE0X2l0cjtcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBhIHRleHR1cmVzIGJ5dGUgYWxpZ25tZW50LiBJZiB0aGUgd2lkdGggaXNuJ3QgYVxuICAgICAgICAvLyAgICAgICAgIHBvd2VyIG9mIDIgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGJ5dGUgYWxpZ25tZW50IG9mIHRoZSBpbWFnZS5cbiAgICAgICAgLy8gICAgICAgICBUaGUgaW1hZ2UgaGVpZ2h0IGlzIHVuaW1wb3J0YW50LlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gICAgICAgICB3d3cub3BlbmdsLm9yZy93aWtpL0NvbW1vbl9NaXN0YWtlcyNUZXh0dXJlX3VwbG9hZF9hbmRfcGl4ZWxfcmVhZHNcbiAgICAgICAgYWxpZ25tZW50cyA9IFs0LCA4LCAyLCAxXTtcbiAgICAgICAgc3R1YjEzX3NlcSA9IGFsaWdubWVudHM7XG4gICAgICAgIGlmICgodHlwZW9mIHN0dWIxM19zZXEgPT09IFwib2JqZWN0XCIpICYmICghQXJyYXkuaXNBcnJheShzdHViMTNfc2VxKSkpIHtcbiAgICAgICAgICAgIHN0dWIxM19zZXEgPSBPYmplY3Qua2V5cyhzdHViMTNfc2VxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHN0dWIxNF9pdHIgPSAwOyBzdHViMTRfaXRyIDwgc3R1YjEzX3NlcS5sZW5ndGg7IHN0dWIxNF9pdHIgKz0gMSkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gc3R1YjEzX3NlcVtzdHViMTRfaXRyXTtcbiAgICAgICAgICAgIGlmICgoX3B5ZnVuY19lcXVhbHMoKHdpZHRoICUgYWxpZ25tZW50KSwgMCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5zZXRfd3JhcHBpbmcgPSBmdW5jdGlvbiAod3JhcF9zLCB3cmFwX3QpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIHdyYXBwaW5nIG1vZGUuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gd3JhcF9zIDogR0wgZW51bVxuICAgICAgICAvLyAgICAgVGhlIG1vZGUgdG8gd3JhcCB0aGUgeCBkaW1lbnNpb24uIFZhbGlkIHZhbHVlcyBhcmUgUkVQRUFUXG4gICAgICAgIC8vICAgICBDTEFNUF9UT19FREdFIE1JUlJPUkVEX1JFUEVBVFxuICAgICAgICAvLyB3cmFwX3QgOiBHTCBlbnVtXG4gICAgICAgIC8vICAgICBUaGUgbW9kZSB0byB3cmFwIHRoZSB5IGRpbWVuc2lvbi4gU2FtZSBvcHRpb25zIGFzIGZvciB3cmFwX3MuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyZih0aGlzLl90YXJnZXQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLCB3cmFwX3MpO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuX3RhcmdldCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBfdCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLnNldF9pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKG1pbiwgbWFnKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBpbnRlcnBvbGF0aW9uIG1vZGVcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBtaW4gOiBHTCBlbnVtXG4gICAgICAgIC8vICAgICBUaGUgaW50ZXJwb2xhdGlvbiBtb2RlIHdoZW4gbWluaWZ5aW5nIChpLmUuIHpvb21lZCBvdXQpLiBWYWxpZFxuICAgICAgICAvLyAgICAgdmFsdWVzIGFyZSBMSU5FQVIgYW5kIE5FQVJFU1QuXG4gICAgICAgIC8vIG1heCA6IEdMIGVudW1cbiAgICAgICAgLy8gICAgIFRoZSBpbnRlcnBvbGF0aW9uIG1vZGUgd2hlbiBtYWduaWZ5aW5nIChpLmUuIHpvb21lZCBpbikuIFZhbGlkXG4gICAgICAgIC8vICAgICB2YWx1ZXMgYXJlIExJTkVBUiwgTkVBUkVTVCwgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcbiAgICAgICAgLy8gICAgIExJTkVBUl9NSVBNQVBfTkVBUkVTVCwgTkVBUkVTVF9NSVBNQVBfTElORUFSLCBMSU5FQVJfTUlQTUFQX0xJTkVBUi5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuX3RhcmdldCwgdGhpcy5fZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW4pO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuX3RhcmdldCwgdGhpcy5fZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5zZXRfc2l6ZSA9IGZ1bmN0aW9uIChzaGFwZSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHN0dWIxNV8sIHdpZHRoO1xuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIDJEIHRleHR1cmUuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gc2hhcGUgOiB0dXBsZSBvZiBpbnRzXG4gICAgICAgIC8vICAgICBUaGUgc2hhcGUgb2YgdGhlIGRhdGEgdG8gdXBsb2FkXG4gICAgICAgIC8vIGZvcm1hdCA6IEdMIGVudW1cbiAgICAgICAgLy8gICAgIFRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUgZGF0YS4gQ2FuIGJlIExVTUlOQU5DRSwgTFVNSU5BTkNFX0FMUEhBLFxuICAgICAgICAvLyAgICAgUkdCLCBhbmQgUkdCQS5cbiAgICAgICAgc3R1YjE1XyA9IHNoYXBlO1xuICAgICAgICBoZWlnaHQgPSBzdHViMTVfWzBdO3dpZHRoID0gc3R1YjE1X1sxXTtcbiAgICAgICAgaWYgKCghX3B5ZnVuY19lcXVhbHMoW2hlaWdodCwgd2lkdGgsIGZvcm1hdF0sIHRoaXMuX3NoYXBlX2Zvcm1hdCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZV9mb3JtYXQgPSBbaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleEltYWdlMkQodGhpcy5fdGFyZ2V0LCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdGhpcy5fZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51X3NoYXBlID0gW2hlaWdodCwgd2lkdGhdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChvZmZzZXQsIHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBfLCBhbGlnbm1lbnQsIGVycl8zLCBmb3JtYXQsIGd0eXBlLCBoZWlnaHQsIHN0dWIxNl8sIHN0dWIxN18sIHdpZHRoLCB4LCB5O1xuICAgICAgICAvLyBTZXQgdGhlIDJEIHRleHR1cmUgZGF0YS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBvZmZzZXQgOiB0dXBsZSBvZiBpbnRzXG4gICAgICAgIC8vICAgICBPZmZzZXQgaW4gcGl4ZWxzIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgICAgICAgLy8gc2hhcGUgOiB0dXBsZSBvZiBpbnRzXG4gICAgICAgIC8vICAgICBUaGUgc2hhcGUgb2YgdGhlIGRhdGEgdG8gdXBsb2FkXG4gICAgICAgIC8vIGRhdGEgOiB0eXBlZCBhcnJheVxuICAgICAgICAvLyAgICAgVGhlIGFjdHVhbCBwaXhlbCBkYXRhLiBDYW4gYmUgb2YgYW55IHR5cGUsIGJ1dCBvbiB0aGUgR1BVIHRoZVxuICAgICAgICAvLyAgICAgZGF0IGlzIHN0b3JlZCBpbiA4IGJpdCBwcmVjaXNpb24uXG4gICAgICAgIGlmIChfcHlmdW5jX2VxdWFscyhzaGFwZS5sZW5ndGgsIDIpKSB7XG4gICAgICAgICAgICBzaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5fc2hhcGVfZm9ybWF0WzJdO1xuICAgICAgICBzdHViMTZfID0gc2hhcGU7XG4gICAgICAgIGhlaWdodCA9IHN0dWIxNl9bMF07d2lkdGggPSBzdHViMTZfWzFdO18gPSBzdHViMTZfWzJdO1xuICAgICAgICBzdHViMTdfID0gb2Zmc2V0O1xuICAgICAgICB5ID0gc3R1YjE3X1swXTt4ID0gc3R1YjE3X1sxXTtcbiAgICAgICAgZ3R5cGUgPSBfcHltZXRoX2dldC5jYWxsKHRoaXMuX3R5cGVzLCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUsIG51bGwpO1xuICAgICAgICBpZiAoKGd0eXBlID09PSBudWxsKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1ZhbHVlRXJyb3I6JyArIChcIlR5cGUgXCIgKyBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBub3QgYWxsb3dlZCBmb3IgdGV4dHVyZVwiKSk7IGVycl8zLm5hbWUgPSBcIlZhbHVlRXJyb3JcIjsgdGhyb3cgZXJyXzM7XG4gICAgICAgIH1cbiAgICAgICAgYWxpZ25tZW50ID0gdGhpcy5fZ2V0X2FsaWdubWVudChfcHlmdW5jX211bHQoc2hhcGVbc2hhcGUubGVuZ3RoIC0yXSwgc2hhcGVbc2hhcGUubGVuZ3RoIC0xXSkpO1xuICAgICAgICBpZiAoKCFfcHlmdW5jX2VxdWFscyhhbGlnbm1lbnQsIDQpKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0FMSUdOTUVOVCwgYWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC50ZXhTdWJJbWFnZTJEKHRoaXMuX3RhcmdldCwgMCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCBndHlwZSwgZGF0YSk7XG4gICAgICAgIGlmICgoIV9weWZ1bmNfZXF1YWxzKGFsaWdubWVudCwgNCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfQUxJR05NRU5ULCA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBUZXh0dXJlM0RMaWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBIDJEIHRleHR1cmUgd2l0aCBzdXBwb3J0IHRvIHNpbXVsYXRlIGEgM0QgdGV4dHVyZS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFRvIHVzZSB0aGlzIGNsYXNzLCB1c2Ugc2V0X3NpemUoKSBhbmQgc2V0X2RhdGEoKSBhcyBpZiBpdCB3YXMgYSAzRFxuICAgICAgICAvLyB0ZXh0dXJlLiBBZGQgdGhlIEdMU0xfU0FNUExFX05FQVJFU1Qgb3IgR0xTTF9TQU1QTEVfTElORUFSIHRvIHRoZVxuICAgICAgICAvLyBzaGFkZXIgdG8gYWRkIHRoZSBzYW1wbGUzRCgpIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZlxuICAgICAgICAvLyB0ZXh0dXJlMkQoKS4gVGhpcyBmdW5jdGlvbiBuZWVkcyBgYHNoYXBlYGAgYW5kIGBgdGlsZXNgYCBhcmd1bWVudHNcbiAgICAgICAgLy8gd2hpY2ggY2FuIGJlIHNldCB2aWEgdW5pZm9ybXMsIHVzaW5nIHRoZSBgYHVfc2hhcGVgYCBhbmQgYGB1X3RpbGVzYGBcbiAgICAgICAgLy8gYXR0cmlidXRlcyBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgX3B5ZnVuY19pbnN0YW50aWF0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGV4dHVyZTJELnByb3RvdHlwZSk7XG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2Jhc2VfY2xhc3MgPSBUZXh0dXJlMkQucHJvdG90eXBlO1xuICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlLl9jbGFzc19uYW1lID0gXCJUZXh0dXJlM0RMaWtlXCI7XG4gICAgXG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuR0xTTF9TQU1QTEVfTkVBUkVTVCA9IFwiXFxuICAgICAgICB2ZWM0IHNhbXBsZTNEKHNhbXBsZXIyRCB0ZXgsIHZlYzMgdGV4Y29vcmQsIHZlYzMgc2hhcGUsIHZlYzIgdGlsZXMpIHtcXG4gICAgICAgICAgICBzaGFwZS54eXogPSBzaGFwZS56eXg7ICAvLyBzaWxseSByb3ctbWFqb3IgY29udmVudGlvblxcbiAgICAgICAgICAgIGZsb2F0IG5yb3dzID0gdGlsZXMueSwgbmNvbHMgPSB0aWxlcy54O1xcbiAgICAgICAgICAgIC8vIERvbid0IGxldCBhZGphY2VudCBmcmFtZXMgYmUgaW50ZXJwb2xhdGVkIGludG8gdGhpcyBvbmVcXG4gICAgICAgICAgICB0ZXhjb29yZC54ID0gbWluKHRleGNvb3JkLnggKiBzaGFwZS54LCBzaGFwZS54IC0gMC41KTtcXG4gICAgICAgICAgICB0ZXhjb29yZC54ID0gbWF4KDAuNSwgdGV4Y29vcmQueCkgLyBzaGFwZS54O1xcbiAgICAgICAgICAgIHRleGNvb3JkLnkgPSBtaW4odGV4Y29vcmQueSAqIHNoYXBlLnksIHNoYXBlLnkgLSAwLjUpO1xcbiAgICAgICAgICAgIHRleGNvb3JkLnkgPSBtYXgoMC41LCB0ZXhjb29yZC55KSAvIHNoYXBlLnk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgemluZGV4ID0gZmxvb3IodGV4Y29vcmQueiAqIHNoYXBlLnopO1xcblxcbiAgICAgICAgICAgIC8vIERvIGEgbG9va3VwIGluIHRoZSAyRCB0ZXh0dXJlXFxuICAgICAgICAgICAgZmxvYXQgdSA9IChtb2QoemluZGV4LCBuY29scykgKyB0ZXhjb29yZC54KSAvIG5jb2xzO1xcbiAgICAgICAgICAgIGZsb2F0IHYgPSAoZmxvb3IoemluZGV4IC8gbmNvbHMpICsgdGV4Y29vcmQueSkgLyBucm93cztcXG5cXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdmVjMih1LHYpKTtcXG4gICAgICAgIH1cXG4gICAgXCI7XG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuR0xTTF9TQU1QTEVfTElORUFSID0gXCJcXG4gICAgICAgIHZlYzQgc2FtcGxlM0Qoc2FtcGxlcjJEIHRleCwgdmVjMyB0ZXhjb29yZCwgdmVjMyBzaGFwZSwgdmVjMiB0aWxlcykge1xcbiAgICAgICAgICAgIHNoYXBlLnh5eiA9IHNoYXBlLnp5eDsgIC8vIHNpbGx5IHJvdy1tYWpvciBjb252ZW50aW9uXFxuICAgICAgICAgICAgZmxvYXQgbnJvd3MgPSB0aWxlcy55LCBuY29scyA9IHRpbGVzLng7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IGFkamFjZW50IGZyYW1lcyBiZSBpbnRlcnBvbGF0ZWQgaW50byB0aGlzIG9uZVxcbiAgICAgICAgICAgIHRleGNvb3JkLnggPSBtaW4odGV4Y29vcmQueCAqIHNoYXBlLngsIHNoYXBlLnggLSAwLjUpO1xcbiAgICAgICAgICAgIHRleGNvb3JkLnggPSBtYXgoMC41LCB0ZXhjb29yZC54KSAvIHNoYXBlLng7XFxuICAgICAgICAgICAgdGV4Y29vcmQueSA9IG1pbih0ZXhjb29yZC55ICogc2hhcGUueSwgc2hhcGUueSAtIDAuNSk7XFxuICAgICAgICAgICAgdGV4Y29vcmQueSA9IG1heCgwLjUsIHRleGNvb3JkLnkpIC8gc2hhcGUueTtcXG5cXG4gICAgICAgICAgICBmbG9hdCB6ID0gdGV4Y29vcmQueiAqIHNoYXBlLno7XFxuICAgICAgICAgICAgZmxvYXQgemluZGV4MSA9IGZsb29yKHopO1xcbiAgICAgICAgICAgIGZsb2F0IHUxID0gKG1vZCh6aW5kZXgxLCBuY29scykgKyB0ZXhjb29yZC54KSAvIG5jb2xzO1xcbiAgICAgICAgICAgIGZsb2F0IHYxID0gKGZsb29yKHppbmRleDEgLyBuY29scykgKyB0ZXhjb29yZC55KSAvIG5yb3dzO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHppbmRleDIgPSB6aW5kZXgxICsgMS4wO1xcbiAgICAgICAgICAgIGZsb2F0IHUyID0gKG1vZCh6aW5kZXgyLCBuY29scykgKyB0ZXhjb29yZC54KSAvIG5jb2xzO1xcbiAgICAgICAgICAgIGZsb2F0IHYyID0gKGZsb29yKHppbmRleDIgLyBuY29scykgKyB0ZXhjb29yZC55KSAvIG5yb3dzO1xcblxcbiAgICAgICAgICAgIHZlYzQgczEgPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHUxLCB2MSkpO1xcbiAgICAgICAgICAgIHZlYzQgczIgPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHUyLCB2MikpO1xcblxcbiAgICAgICAgICAgIHJldHVybiBzMSAqICh6aW5kZXgyIC0geikgKyBzMiAqICh6IC0gemluZGV4MSk7XFxuICAgICAgICB9XFxuICAgIFwiO1xuICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlLl9nZXRfdGlsZV9pbmZvID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHZhciBlcnJfMywgbWF4X3NpemUsIG5jb2xzLCBucm93cztcbiAgICAgICAgbWF4X3NpemUgPSB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgICAgIG5yb3dzID0gTWF0aC5mbG9vcihtYXhfc2l6ZS9zaGFwZVsxXSk7XG4gICAgICAgIG5yb3dzID0gTWF0aC5taW4obnJvd3MsIHNoYXBlWzBdKTtcbiAgICAgICAgbmNvbHMgPSB3aW5kb3cuTWF0aC5jZWlsKHNoYXBlWzBdIC8gbnJvd3MpO1xuICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkoX3B5ZnVuY19tdWx0KG5jb2xzLCBzaGFwZVsyXSkgPiBtYXhfc2l6ZSkpIHtcbiAgICAgICAgICAgIGVycl8zID0gbmV3IEVycm9yKCdSdW50aW1lRXJyb3I6JyArIChcIkNhbm5vdCBmaXQgM0QgZGF0YSB3aXRoIHNoYXBlIFwiICsgc2hhcGUgKyBcIiBvbnRvIHNpbXVsYXRlZCAyRCB0ZXh0dXJlLlwiKSk7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25yb3dzLCBuY29sc107XG4gICAgfTtcblxuICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlLnNldF9zaXplID0gZnVuY3Rpb24gKHNoYXBlLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIG5jb2xzLCBucm93cywgc2ltX3NoYXBlLCBzdHViMThfO1xuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIDNEIHRleHR1cmUuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gc2hhcGUgOiB0dXBsZSBvZiBpbnRzXG4gICAgICAgIC8vICAgICBUaGUgc2hhcGUgb2YgdGhlIGRhdGEgdG8gdXBsb2FkXG4gICAgICAgIC8vIGZvcm1hdCA6IEdMIGVudW1cbiAgICAgICAgLy8gICAgIFRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUgZGF0YS4gQ2FuIGJlIExVTUlOQU5DRSwgTFVNSU5BTkNFX0FMUEhBLFxuICAgICAgICAvLyAgICAgUkdCLCBhbmQgUkdCQS5cbiAgICAgICAgc3R1YjE4XyA9IHRoaXMuX2dldF90aWxlX2luZm8oc2hhcGUpO1xuICAgICAgICBucm93cyA9IHN0dWIxOF9bMF07bmNvbHMgPSBzdHViMThfWzFdO1xuICAgICAgICBzaW1fc2hhcGUgPSBbX3B5ZnVuY19tdWx0KHNoYXBlWzFdLCBucm93cyksIF9weWZ1bmNfbXVsdChzaGFwZVsyXSwgbmNvbHMpXTtcbiAgICAgICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2Jhc2VfY2xhc3Muc2V0X3NpemUuY2FsbCh0aGlzLCBzaW1fc2hhcGUsIGZvcm1hdCk7XG4gICAgICAgIHRoaXMudV9zaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIHNoYXBlWzJdXTtcbiAgICAgICAgdGhpcy51X3RpbGVzID0gW25jb2xzLCBucm93c107XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChvZmZzZXQsIHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBUeXBlLCBjb2wsIGVsZW1lbnRzX3Blcl90aWxlLCBlcnJfMywgbmNvbHMsIG5yb3dzLCByb3csIHNpbV9zaGFwZSwgc3R1YjE5Xywgc3R1YjIwXywgdGlsZSwgeiwgemVyb3M7XG4gICAgICAgIC8vIFNldCB0aGUgM0QgdGV4dHVyZSBkYXRhLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG9mZnNldCA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIE9mZnNldCBpbiBwaXhlbHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBzaGFwZSA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIFRoZSBzaGFwZSBvZiB0aGUgZGF0YSB0byB1cGxvYWRcbiAgICAgICAgLy8gZGF0YSA6IHR5cGVkIGFycmF5XG4gICAgICAgIC8vICAgICBUaGUgYWN0dWFsIHBpeGVsIGRhdGEuIENhbiBiZSBvZiBhbnkgdHlwZSwgYnV0IG9uIHRoZSBHUFUgdGhlXG4gICAgICAgIC8vICAgICBkYXQgaXMgc3RvcmVkIGluIDggYml0IHByZWNpc2lvbi5cbiAgICAgICAgaWYgKF9weWZ1bmNfZXF1YWxzKHNoYXBlLmxlbmd0aCwgMykpIHtcbiAgICAgICAgICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgc2hhcGVbMl0sIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIShfcHlmdW5jX2FsbCgoKGZ1bmN0aW9uIGxpc3RfY29tcHJlaGVuc29uICgpIHt2YXIgcmVzID0gW107dmFyIGksIGl0ZXIwLCBpMDtpdGVyMCA9IG9mZnNldDtpZiAoKHR5cGVvZiBpdGVyMCA9PT0gXCJvYmplY3RcIikgJiYgKCFBcnJheS5pc0FycmF5KGl0ZXIwKSkpIHtpdGVyMCA9IE9iamVjdC5rZXlzKGl0ZXIwKTt9Zm9yIChpMD0wOyBpMDxpdGVyMC5sZW5ndGg7IGkwKyspIHtpID0gaXRlcjBbaTBdO3tyZXMucHVzaChfcHlmdW5jX2VxdWFscyhpLCAwKSk7fX1yZXR1cm4gcmVzO30pLmFwcGx5KHRoaXMpKSkpKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1ZhbHVlRXJyb3I6JyArIFwiVGV4dHVyZTNETGlrZSBkb2VzIG5vdCBzdXBwb3J0IG5vbnplcm8gb2Zmc2V0IChmb3Igbm93KVwiKTsgZXJyXzMubmFtZSA9IFwiVmFsdWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICBzdHViMTlfID0gdGhpcy5fZ2V0X3RpbGVfaW5mbyhzaGFwZSk7XG4gICAgICAgIG5yb3dzID0gc3R1YjE5X1swXTtuY29scyA9IHN0dWIxOV9bMV07XG4gICAgICAgIHNpbV9zaGFwZSA9IFtfcHlmdW5jX211bHQoc2hhcGVbMV0sIG5yb3dzKSwgX3B5ZnVuY19tdWx0KHNoYXBlWzJdLCBuY29scyksIHNoYXBlWzNdXTtcbiAgICAgICAgaWYgKF9weWZ1bmNfZXF1YWxzKG5jb2xzLCAxKSkge1xuICAgICAgICAgICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2Jhc2VfY2xhc3Muc2V0X2RhdGEuY2FsbCh0aGlzLCBbMCwgMF0sIHNpbV9zaGFwZSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUeXBlID0gZGF0YS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHplcm9zID0gbmV3IFR5cGUoX3B5ZnVuY19tdWx0KF9weWZ1bmNfbXVsdChzaW1fc2hhcGVbMF0sIHNpbV9zaGFwZVsxXSksIHNpbV9zaGFwZVsyXSkpO1xuICAgICAgICAgICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2Jhc2VfY2xhc3Muc2V0X2RhdGEuY2FsbCh0aGlzLCBbMCwgMF0sIHNpbV9zaGFwZSwgemVyb3MpO1xuICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IHNoYXBlWzBdOyB6ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzdHViMjBfID0gW01hdGguZmxvb3Ioei9uY29scyksIHogJSBuY29sc107XG4gICAgICAgICAgICAgICAgcm93ID0gc3R1YjIwX1swXTtjb2wgPSBzdHViMjBfWzFdO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzX3Blcl90aWxlID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aC9zaGFwZVswXSk7XG4gICAgICAgICAgICAgICAgdGlsZSA9IGRhdGEuc2xpY2UoX3B5ZnVuY19tdWx0KHosIGVsZW1lbnRzX3Blcl90aWxlKSxfcHlmdW5jX211bHQoKHogKyAxKSwgZWxlbWVudHNfcGVyX3RpbGUpKTtcbiAgICAgICAgICAgICAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5fYmFzZV9jbGFzcy5zZXRfZGF0YS5jYWxsKHRoaXMsIFtfcHlmdW5jX211bHQocm93LCBzaGFwZVsxXSksIF9weWZ1bmNfbXVsdChjb2wsIHNoYXBlWzJdKV0sIHNoYXBlLnNsaWNlKDEpLCB0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4ge1wiQnVmZmVyXCI6IEJ1ZmZlciwgXCJHbG9vT2JqZWN0XCI6IEdsb29PYmplY3QsIFwiSW5kZXhCdWZmZXJcIjogSW5kZXhCdWZmZXIsIFwiUHJvZ3JhbVwiOiBQcm9ncmFtLCBcIlRleHR1cmUyRFwiOiBUZXh0dXJlMkQsIFwiVGV4dHVyZTNETGlrZVwiOiBUZXh0dXJlM0RMaWtlLCBcIlZlcnRleEJ1ZmZlclwiOiBWZXJ0ZXhCdWZmZXIsIFwiY2hlY2tfZXJyb3JcIjogY2hlY2tfZXJyb3IsIFwiY29uc29sZVwiOiBjb25zb2xlfTtcbn0pKTtcbiJdfQ=="}