{"version":3,"sources":["src/js/prelude.js","build/js/tree/base.js","build/js/tree/client.js","build/js/tree/core/backbone.js","build/js/tree/core/bokeh_events.js","build/js/tree/core/bokeh_view.js","build/js/tree/core/build_views.js","build/js/tree/core/dom.js","build/js/tree/core/enums.js","build/js/tree/core/events.js","build/js/tree/core/has_props.js","build/js/tree/core/hittest.js","build/js/tree/core/layout/layout_canvas.js","build/js/tree/core/layout/side_panel.js","build/js/tree/core/layout/solver.js","build/js/tree/core/logging.js","build/js/tree/core/properties.js","build/js/tree/core/property_mixins.js","build/js/tree/core/selection_manager.js","build/js/tree/core/selector.js","build/js/tree/core/ui_events.js","build/js/tree/core/util/array.js","build/js/tree/core/util/bbox.js","build/js/tree/core/util/callback.js","build/js/tree/core/util/canvas.js","build/js/tree/core/util/color.js","build/js/tree/core/util/data_structures.js","build/js/tree/core/util/eq.js","build/js/tree/core/util/math.js","build/js/tree/core/util/object.js","build/js/tree/core/util/proj4.js","build/js/tree/core/util/projections.js","build/js/tree/core/util/refs.js","build/js/tree/core/util/selection.js","build/js/tree/core/util/serialization.js","build/js/tree/core/util/spatial.js","build/js/tree/core/util/string.js","build/js/tree/core/util/svg_colors.js","build/js/tree/core/util/templating.js","build/js/tree/core/util/text.js","build/js/tree/core/util/throttle.js","build/js/tree/core/util/types.js","build/js/tree/core/util/wheel.js","build/js/tree/core/util/zoom.js","build/js/tree/core/visuals.js","build/js/tree/document.js","build/js/tree/embed.js","build/js/tree/main.js","build/js/tree/model.js","build/js/tree/models/annotations/annotation.js","build/js/tree/models/annotations/arrow.js","build/js/tree/models/annotations/arrow_head.js","build/js/tree/models/annotations/box_annotation.js","build/js/tree/models/annotations/color_bar.js","build/js/tree/models/annotations/index.js","build/js/tree/models/annotations/label.js","build/js/tree/models/annotations/label_set.js","build/js/tree/models/annotations/legend.js","build/js/tree/models/annotations/legend_item.js","build/js/tree/models/annotations/poly_annotation.js","build/js/tree/models/annotations/span.js","build/js/tree/models/annotations/text_annotation.js","build/js/tree/models/annotations/title.js","build/js/tree/models/annotations/tooltip.js","build/js/tree/models/axes/axis.js","build/js/tree/models/axes/categorical_axis.js","build/js/tree/models/axes/continuous_axis.js","build/js/tree/models/axes/datetime_axis.js","build/js/tree/models/axes/index.js","build/js/tree/models/axes/linear_axis.js","build/js/tree/models/axes/log_axis.js","build/js/tree/models/callbacks/customjs.js","build/js/tree/models/callbacks/index.js","build/js/tree/models/callbacks/open_url.js","build/js/tree/models/canvas/canvas.js","build/js/tree/models/canvas/canvas_template.js","build/js/tree/models/canvas/cartesian_frame.js","build/js/tree/models/canvas/index.js","build/js/tree/models/formatters/basic_tick_formatter.js","build/js/tree/models/formatters/categorical_tick_formatter.js","build/js/tree/models/formatters/datetime_tick_formatter.js","build/js/tree/models/formatters/func_tick_formatter.js","build/js/tree/models/formatters/index.js","build/js/tree/models/formatters/log_tick_formatter.js","build/js/tree/models/formatters/mercator_tick_formatter.js","build/js/tree/models/formatters/numeral_tick_formatter.js","build/js/tree/models/formatters/printf_tick_formatter.js","build/js/tree/models/formatters/tick_formatter.js","build/js/tree/models/glyphs/annular_wedge.js","build/js/tree/models/glyphs/annulus.js","build/js/tree/models/glyphs/arc.js","build/js/tree/models/glyphs/bezier.js","build/js/tree/models/glyphs/circle.js","build/js/tree/models/glyphs/ellipse.js","build/js/tree/models/glyphs/glyph.js","build/js/tree/models/glyphs/hbar.js","build/js/tree/models/glyphs/image.js","build/js/tree/models/glyphs/image_rgba.js","build/js/tree/models/glyphs/image_url.js","build/js/tree/models/glyphs/index.js","build/js/tree/models/glyphs/line.js","build/js/tree/models/glyphs/multi_line.js","build/js/tree/models/glyphs/oval.js","build/js/tree/models/glyphs/patch.js","build/js/tree/models/glyphs/patches.js","build/js/tree/models/glyphs/quad.js","build/js/tree/models/glyphs/quadratic.js","build/js/tree/models/glyphs/ray.js","build/js/tree/models/glyphs/rect.js","build/js/tree/models/glyphs/segment.js","build/js/tree/models/glyphs/text.js","build/js/tree/models/glyphs/vbar.js","build/js/tree/models/glyphs/wedge.js","build/js/tree/models/glyphs/xy_glyph.js","build/js/tree/models/grids/grid.js","build/js/tree/models/grids/index.js","build/js/tree/models/index.js","build/js/tree/models/layouts/box.js","build/js/tree/models/layouts/column.js","build/js/tree/models/layouts/index.js","build/js/tree/models/layouts/layout_dom.js","build/js/tree/models/layouts/row.js","build/js/tree/models/layouts/spacer.js","build/js/tree/models/layouts/widget_box.js","build/js/tree/models/mappers/categorical_color_mapper.js","build/js/tree/models/mappers/categorical_mapper.js","build/js/tree/models/mappers/color_mapper.js","build/js/tree/models/mappers/grid_mapper.js","build/js/tree/models/mappers/index.js","build/js/tree/models/mappers/linear_color_mapper.js","build/js/tree/models/mappers/linear_mapper.js","build/js/tree/models/mappers/log_color_mapper.js","build/js/tree/models/mappers/log_mapper.js","build/js/tree/models/markers/index.js","build/js/tree/models/markers/marker.js","build/js/tree/models/plots/gmap_plot.js","build/js/tree/models/plots/gmap_plot_canvas.js","build/js/tree/models/plots/index.js","build/js/tree/models/plots/plot.js","build/js/tree/models/plots/plot_canvas.js","build/js/tree/models/ranges/data_range.js","build/js/tree/models/ranges/data_range1d.js","build/js/tree/models/ranges/factor_range.js","build/js/tree/models/ranges/index.js","build/js/tree/models/ranges/range.js","build/js/tree/models/ranges/range1d.js","build/js/tree/models/renderers/glyph_renderer.js","build/js/tree/models/renderers/guide_renderer.js","build/js/tree/models/renderers/index.js","build/js/tree/models/renderers/renderer.js","build/js/tree/models/sources/ajax_data_source.js","build/js/tree/models/sources/column_data_source.js","build/js/tree/models/sources/columnar_data_source.js","build/js/tree/models/sources/data_source.js","build/js/tree/models/sources/geojson_data_source.js","build/js/tree/models/sources/index.js","build/js/tree/models/sources/remote_data_source.js","build/js/tree/models/tickers/adaptive_ticker.js","build/js/tree/models/tickers/basic_ticker.js","build/js/tree/models/tickers/categorical_ticker.js","build/js/tree/models/tickers/composite_ticker.js","build/js/tree/models/tickers/continuous_ticker.js","build/js/tree/models/tickers/datetime_ticker.js","build/js/tree/models/tickers/days_ticker.js","build/js/tree/models/tickers/fixed_ticker.js","build/js/tree/models/tickers/index.js","build/js/tree/models/tickers/log_ticker.js","build/js/tree/models/tickers/mercator_ticker.js","build/js/tree/models/tickers/months_ticker.js","build/js/tree/models/tickers/single_interval_ticker.js","build/js/tree/models/tickers/ticker.js","build/js/tree/models/tickers/util.js","build/js/tree/models/tickers/years_ticker.js","build/js/tree/models/tiles/bbox_tile_source.js","build/js/tree/models/tiles/dynamic_image_renderer.js","build/js/tree/models/tiles/image_pool.js","build/js/tree/models/tiles/image_source.js","build/js/tree/models/tiles/index.js","build/js/tree/models/tiles/mercator_tile_source.js","build/js/tree/models/tiles/quadkey_tile_source.js","build/js/tree/models/tiles/tile_renderer.js","build/js/tree/models/tiles/tile_source.js","build/js/tree/models/tiles/tile_utils.js","build/js/tree/models/tiles/tms_tile_source.js","build/js/tree/models/tiles/wmts_tile_source.js","build/js/tree/models/tools/actions/action_tool.js","build/js/tree/models/tools/actions/help_tool.js","build/js/tree/models/tools/actions/redo_tool.js","build/js/tree/models/tools/actions/reset_tool.js","build/js/tree/models/tools/actions/save_tool.js","build/js/tree/models/tools/actions/undo_tool.js","build/js/tree/models/tools/actions/zoom_in_tool.js","build/js/tree/models/tools/actions/zoom_out_tool.js","build/js/tree/models/tools/button_tool.js","build/js/tree/models/tools/gestures/box_select_tool.js","build/js/tree/models/tools/gestures/box_zoom_tool.js","build/js/tree/models/tools/gestures/gesture_tool.js","build/js/tree/models/tools/gestures/lasso_select_tool.js","build/js/tree/models/tools/gestures/pan_tool.js","build/js/tree/models/tools/gestures/poly_select_tool.js","build/js/tree/models/tools/gestures/resize_tool.js","build/js/tree/models/tools/gestures/select_tool.js","build/js/tree/models/tools/gestures/tap_tool.js","build/js/tree/models/tools/gestures/wheel_pan_tool.js","build/js/tree/models/tools/gestures/wheel_zoom_tool.js","build/js/tree/models/tools/index.js","build/js/tree/models/tools/inspectors/crosshair_tool.js","build/js/tree/models/tools/inspectors/hover_tool.js","build/js/tree/models/tools/inspectors/inspect_tool.js","build/js/tree/models/tools/on_off_button.js","build/js/tree/models/tools/tool.js","build/js/tree/models/tools/tool_events.js","build/js/tree/models/tools/tool_proxy.js","build/js/tree/models/tools/toolbar.js","build/js/tree/models/tools/toolbar_base.js","build/js/tree/models/tools/toolbar_box.js","build/js/tree/models/tools/toolbar_template.js","build/js/tree/models/transforms/customjs_transform.js","build/js/tree/models/transforms/index.js","build/js/tree/models/transforms/interpolator.js","build/js/tree/models/transforms/jitter.js","build/js/tree/models/transforms/linear_interpolator.js","build/js/tree/models/transforms/step_interpolator.js","build/js/tree/models/transforms/transform.js","build/js/tree/safely.js","build/js/tree/version.js","node_modules/es6-promise/dist/es6-promise.js","node_modules/hammerjs/hammer.js","node_modules/kiwi/index.js","node_modules/numbro/numbro.js","node_modules/process/browser.js","node_modules/proj4/lib/Proj.js","node_modules/proj4/lib/adjust_axis.js","node_modules/proj4/lib/common/adjust_lon.js","node_modules/proj4/lib/common/msfnz.js","node_modules/proj4/lib/common/phi2z.js","node_modules/proj4/lib/common/sign.js","node_modules/proj4/lib/common/toPoint.js","node_modules/proj4/lib/common/tsfnz.js","node_modules/proj4/lib/constants/Datum.js","node_modules/proj4/lib/constants/Ellipsoid.js","node_modules/proj4/lib/constants/PrimeMeridian.js","node_modules/proj4/lib/constants/units.js","node_modules/proj4/lib/core.js","node_modules/proj4/lib/datum.js","node_modules/proj4/lib/datumUtils.js","node_modules/proj4/lib/datum_transform.js","node_modules/proj4/lib/defs.js","node_modules/proj4/lib/deriveConstants.js","node_modules/proj4/lib/extend.js","node_modules/proj4/lib/global.js","node_modules/proj4/lib/parseCode.js","node_modules/proj4/lib/projString.js","node_modules/proj4/lib/projections.js","node_modules/proj4/lib/projections/longlat.js","node_modules/proj4/lib/projections/merc.js","node_modules/proj4/lib/transform.js","node_modules/proj4/lib/wkt.js","node_modules/quickselect/index.js","node_modules/rbush/index.js","node_modules/sprintf/lib/sprintf.js","node_modules/timezone/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACv8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bokeh.js","sourcesContent":["(function outer(modules, cache, entry) {\n    function newRequire(name) {\n        if (!cache[name]) {\n            if (!modules[name]) {\n                var err = new Error('Cannot find module \\'' + name + '\\'');\n                err.code = 'MODULE_NOT_FOUND';\n                throw err;\n            }\n\n            var m = cache[name] = {exports: {}};\n\n            var moduleRequire = function foo(x) {\n                var id = modules[name][1][x];\n                return newRequire(id ? id : x);\n            }\n            moduleRequire.modules = newRequire.modules;\n\n            modules[name][0].call(m.exports, moduleRequire, m, m.exports, outer, modules, cache, entry);\n        }\n\n        return cache[name].exports;\n    }\n\n    newRequire.modules = modules;\n\n    var main = newRequire(entry[0]);\n    main.require = newRequire;\n    return main;\n})\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _all_models, hasProp = {}.hasOwnProperty;\nvar models = require(\"./models/index\");\nvar object_1 = require(\"./core/util/object\");\nexports.overrides = {};\n_all_models = object_1.clone(models);\nexports.Models = function (name) {\n    var model, ref;\n    model = (ref = exports.overrides[name]) != null ? ref : _all_models[name];\n    if (model == null) {\n        throw new Error(\"Model `\" + name + \"' does not exist. This could be due to a widget or a custom model not being registered before first usage.\");\n    }\n    return model;\n};\nexports.Models.register = function (name, model) {\n    return exports.overrides[name] = model;\n};\nexports.Models.unregister = function (name) {\n    return delete exports.overrides[name];\n};\nexports.Models.register_models = function (models, force, errorFn) {\n    var model, name, results;\n    if (force == null) {\n        force = false;\n    }\n    if (errorFn == null) {\n        errorFn = null;\n    }\n    if (models == null) {\n        return;\n    }\n    results = [];\n    for (name in models) {\n        if (!hasProp.call(models, name))\n            continue;\n        model = models[name];\n        if (force || !_all_models.hasOwnProperty(name)) {\n            results.push(_all_models[name] = model);\n        }\n        else {\n            results.push(typeof errorFn === \"function\" ? errorFn(name) : void 0);\n        }\n    }\n    return results;\n};\nexports.Models.registered_names = function () {\n    return Object.keys(_all_models);\n};\nexports.index = {};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClientConnection, ClientSession, Message, message_handlers;\nvar es6_promise_1 = require(\"es6-promise\");\nvar logging_1 = require(\"./core/logging\");\nvar string_1 = require(\"./core/util/string\");\nvar object_1 = require(\"./core/util/object\");\nvar document_1 = require(\"./document\");\nexports.DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\nexports.DEFAULT_SESSION_ID = \"default\";\nMessage = (function () {\n    function Message(header1, metadata1, content1) {\n        this.header = header1;\n        this.metadata = metadata1;\n        this.content = content1;\n        this.buffers = [];\n    }\n    Message.assemble = function (header_json, metadata_json, content_json) {\n        var content, e, header, metadata;\n        try {\n            header = JSON.parse(header_json);\n            metadata = JSON.parse(metadata_json);\n            content = JSON.parse(content_json);\n            return new Message(header, metadata, content);\n        }\n        catch (error1) {\n            e = error1;\n            logging_1.logger.error(\"Failure parsing json \" + e + \" \" + header_json + \" \" + metadata_json + \" \" + content_json, e);\n            throw e;\n        }\n    };\n    Message.create_header = function (msgtype, options) {\n        var header;\n        header = {\n            'msgid': string_1.uniqueId(),\n            'msgtype': msgtype\n        };\n        return object_1.extend(header, options);\n    };\n    Message.create = function (msgtype, header_options, content) {\n        var header;\n        if (content == null) {\n            content = {};\n        }\n        header = Message.create_header(msgtype, header_options);\n        return new Message(header, {}, content);\n    };\n    Message.prototype.send = function (socket) {\n        var content_json, e, header_json, metadata_json;\n        try {\n            header_json = JSON.stringify(this.header);\n            metadata_json = JSON.stringify(this.metadata);\n            content_json = JSON.stringify(this.content);\n            socket.send(header_json);\n            socket.send(metadata_json);\n            return socket.send(content_json);\n        }\n        catch (error1) {\n            e = error1;\n            logging_1.logger.error(\"Error sending \", this, e);\n            throw e;\n        }\n    };\n    Message.prototype.complete = function () {\n        if ((this.header != null) && (this.metadata != null) && (this.content != null)) {\n            if ('num_buffers' in this.header) {\n                return this.buffers.length === this.header['num_buffers'];\n            }\n            else {\n                return true;\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    Message.prototype.add_buffer = function (buffer) {\n        return this.buffers.push(buffer);\n    };\n    Message.prototype._header_field = function (field) {\n        if (field in this.header) {\n            return this.header[field];\n        }\n        else {\n            return null;\n        }\n    };\n    Message.prototype.msgid = function () {\n        return this._header_field('msgid');\n    };\n    Message.prototype.msgtype = function () {\n        return this._header_field('msgtype');\n    };\n    Message.prototype.sessid = function () {\n        return this._header_field('sessid');\n    };\n    Message.prototype.reqid = function () {\n        return this._header_field('reqid');\n    };\n    Message.prototype.problem = function () {\n        if (!('msgid' in this.header)) {\n            return \"No msgid in header\";\n        }\n        else if (!('msgtype' in this.header)) {\n            return \"No msgtype in header\";\n        }\n        else {\n            return null;\n        }\n    };\n    return Message;\n})();\nmessage_handlers = {\n    'PATCH-DOC': function (connection, message) {\n        return connection._for_session(function (session) {\n            return session._handle_patch(message);\n        });\n    },\n    'OK': function (connection, message) {\n        return logging_1.logger.debug(\"Unhandled OK reply to \" + (message.reqid()));\n    },\n    'ERROR': function (connection, message) {\n        return logging_1.logger.error(\"Unhandled ERROR reply to \" + (message.reqid()) + \": \" + message.content['text']);\n    }\n};\nClientConnection = (function () {\n    ClientConnection._connection_count = 0;\n    function ClientConnection(url1, id, args_string1, _on_have_session_hook, _on_closed_permanently_hook) {\n        this.url = url1;\n        this.id = id;\n        this.args_string = args_string1;\n        this._on_have_session_hook = _on_have_session_hook;\n        this._on_closed_permanently_hook = _on_closed_permanently_hook;\n        this._number = ClientConnection._connection_count;\n        ClientConnection._connection_count = this._number + 1;\n        if (this.url == null) {\n            this.url = exports.DEFAULT_SERVER_WEBSOCKET_URL;\n        }\n        if (this.id == null) {\n            this.id = exports.DEFAULT_SESSION_ID;\n        }\n        logging_1.logger.debug(\"Creating websocket \" + this._number + \" to '\" + this.url + \"' session '\" + this.id + \"'\");\n        this.socket = null;\n        this.closed_permanently = false;\n        this._fragments = [];\n        this._partial = null;\n        this._current_handler = null;\n        this._pending_ack = null;\n        this._pending_replies = {};\n        this.session = null;\n    }\n    ClientConnection.prototype._for_session = function (f) {\n        if (this.session !== null) {\n            return f(this.session);\n        }\n    };\n    ClientConnection.prototype.connect = function () {\n        var error, ref, versioned_url;\n        if (this.closed_permanently) {\n            return es6_promise_1.Promise.reject(new Error(\"Cannot connect() a closed ClientConnection\"));\n        }\n        if (this.socket != null) {\n            return es6_promise_1.Promise.reject(new Error(\"Already connected\"));\n        }\n        this._fragments = [];\n        this._partial = null;\n        this._pending_replies = {};\n        this._current_handler = null;\n        try {\n            versioned_url = this.url + \"?bokeh-protocol-version=1.0&bokeh-session-id=\" + this.id;\n            if (((ref = this.args_string) != null ? ref.length : void 0) > 0) {\n                versioned_url += \"&\" + this.args_string;\n            }\n            if (window.MozWebSocket != null) {\n                this.socket = new MozWebSocket(versioned_url);\n            }\n            else {\n                this.socket = new WebSocket(versioned_url);\n            }\n            return new es6_promise_1.Promise((function (_this) {\n                return function (resolve, reject) {\n                    _this.socket.binarytype = \"arraybuffer\";\n                    _this.socket.onopen = function () {\n                        return _this._on_open(resolve, reject);\n                    };\n                    _this.socket.onmessage = function (event) {\n                        return _this._on_message(event);\n                    };\n                    _this.socket.onclose = function (event) {\n                        return _this._on_close(event);\n                    };\n                    return _this.socket.onerror = function () {\n                        return _this._on_error(reject);\n                    };\n                };\n            })(this));\n        }\n        catch (error1) {\n            error = error1;\n            logging_1.logger.error(\"websocket creation failed to url: \" + this.url);\n            logging_1.logger.error(\" - \" + error);\n            return es6_promise_1.Promise.reject(error);\n        }\n    };\n    ClientConnection.prototype.close = function () {\n        if (!this.closed_permanently) {\n            logging_1.logger.debug(\"Permanently closing websocket connection \" + this._number);\n            this.closed_permanently = true;\n            if (this.socket != null) {\n                this.socket.close(1000, \"close method called on ClientConnection \" + this._number);\n            }\n            this._for_session(function (session) {\n                return session._connection_closed();\n            });\n            if (this._on_closed_permanently_hook != null) {\n                this._on_closed_permanently_hook();\n                return this._on_closed_permanently_hook = null;\n            }\n        }\n    };\n    ClientConnection.prototype._schedule_reconnect = function (milliseconds) {\n        var retry;\n        retry = (function (_this) {\n            return function () {\n                if (true || _this.closed_permanently) {\n                    if (!_this.closed_permanently) {\n                        logging_1.logger.info(\"Websocket connection \" + _this._number + \" disconnected, will not attempt to reconnect\");\n                    }\n                }\n                else {\n                    logging_1.logger.debug(\"Attempting to reconnect websocket \" + _this._number);\n                    return _this.connect();\n                }\n            };\n        })(this);\n        return setTimeout(retry, milliseconds);\n    };\n    ClientConnection.prototype.send = function (message) {\n        var e;\n        try {\n            if (this.socket === null) {\n                throw new Error(\"not connected so cannot send \" + message);\n            }\n            return message.send(this.socket);\n        }\n        catch (error1) {\n            e = error1;\n            return logging_1.logger.error(\"Error sending message \", e, message);\n        }\n    };\n    ClientConnection.prototype.send_event = function (event) {\n        var message;\n        message = Message.create('EVENT', {}, JSON.stringify(event));\n        return this.send(message);\n    };\n    ClientConnection.prototype.send_with_reply = function (message) {\n        var promise;\n        promise = new es6_promise_1.Promise((function (_this) {\n            return function (resolve, reject) {\n                _this._pending_replies[message.msgid()] = [resolve, reject];\n                return _this.send(message);\n            };\n        })(this));\n        return promise.then(function (message) {\n            if (message.msgtype() === 'ERROR') {\n                throw new Error(\"Error reply \" + message.content['text']);\n            }\n            else {\n                return message;\n            }\n        }, function (error) {\n            throw error;\n        });\n    };\n    ClientConnection.prototype._pull_doc_json = function () {\n        var message, promise;\n        message = Message.create('PULL-DOC-REQ', {});\n        promise = this.send_with_reply(message);\n        return promise.then(function (reply) {\n            if (!('doc' in reply.content)) {\n                throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\n            }\n            return reply.content['doc'];\n        }, function (error) {\n            throw error;\n        });\n    };\n    ClientConnection.prototype._repull_session_doc = function () {\n        if (this.session === null) {\n            logging_1.logger.debug(\"Pulling session for first time\");\n        }\n        else {\n            logging_1.logger.debug(\"Repulling session\");\n        }\n        return this._pull_doc_json().then((function (_this) {\n            return function (doc_json) {\n                var document, patch, patch_message;\n                if (_this.session === null) {\n                    if (_this.closed_permanently) {\n                        return logging_1.logger.debug(\"Got new document after connection was already closed\");\n                    }\n                    else {\n                        document = document_1.Document.from_json(doc_json);\n                        patch = document_1.Document._compute_patch_since_json(doc_json, document);\n                        if (patch.events.length > 0) {\n                            logging_1.logger.debug(\"Sending \" + patch.events.length + \" changes from model construction back to server\");\n                            patch_message = Message.create('PATCH-DOC', {}, patch);\n                            _this.send(patch_message);\n                        }\n                        _this.session = new ClientSession(_this, document, _this.id);\n                        logging_1.logger.debug(\"Created a new session from new pulled doc\");\n                        if (_this._on_have_session_hook != null) {\n                            _this._on_have_session_hook(_this.session);\n                            return _this._on_have_session_hook = null;\n                        }\n                    }\n                }\n                else {\n                    _this.session.document.replace_with_json(doc_json);\n                    return logging_1.logger.debug(\"Updated existing session with new pulled doc\");\n                }\n            };\n        })(this), function (error) {\n            throw error;\n        })[\"catch\"](function (error) {\n            if (console.trace != null) {\n                console.trace(error);\n            }\n            return logging_1.logger.error(\"Failed to repull session \" + error);\n        });\n    };\n    ClientConnection.prototype._on_open = function (resolve, reject) {\n        logging_1.logger.info(\"Websocket connection \" + this._number + \" is now open\");\n        this._pending_ack = [resolve, reject];\n        return this._current_handler = (function (_this) {\n            return function (message) {\n                return _this._awaiting_ack_handler(message);\n            };\n        })(this);\n    };\n    ClientConnection.prototype._on_message = function (event) {\n        var e;\n        try {\n            return this._on_message_unchecked(event);\n        }\n        catch (error1) {\n            e = error1;\n            return logging_1.logger.error(\"Error handling message: \" + e + \", \" + event);\n        }\n    };\n    ClientConnection.prototype._on_message_unchecked = function (event) {\n        var msg, problem;\n        if (this._current_handler == null) {\n            logging_1.logger.error(\"got a message but haven't set _current_handler\");\n        }\n        if (event.data instanceof ArrayBuffer) {\n            if ((this._partial != null) && !this._partial.complete()) {\n                this._partial.add_buffer(event.data);\n            }\n            else {\n                this._close_bad_protocol(\"Got binary from websocket but we were expecting text\");\n            }\n        }\n        else if (this._partial != null) {\n            this._close_bad_protocol(\"Got text from websocket but we were expecting binary\");\n        }\n        else {\n            this._fragments.push(event.data);\n            if (this._fragments.length === 3) {\n                this._partial = Message.assemble(this._fragments[0], this._fragments[1], this._fragments[2]);\n                this._fragments = [];\n                problem = this._partial.problem();\n                if (problem !== null) {\n                    this._close_bad_protocol(problem);\n                }\n            }\n        }\n        if ((this._partial != null) && this._partial.complete()) {\n            msg = this._partial;\n            this._partial = null;\n            return this._current_handler(msg);\n        }\n    };\n    ClientConnection.prototype._on_close = function (event) {\n        var pop_pending, promise_funcs;\n        logging_1.logger.info(\"Lost websocket \" + this._number + \" connection, \" + event.code + \" (\" + event.reason + \")\");\n        this.socket = null;\n        if (this._pending_ack != null) {\n            this._pending_ack[1](new Error(\"Lost websocket connection, \" + event.code + \" (\" + event.reason + \")\"));\n            this._pending_ack = null;\n        }\n        pop_pending = (function (_this) {\n            return function () {\n                var promise_funcs, ref, reqid;\n                ref = _this._pending_replies;\n                for (reqid in ref) {\n                    promise_funcs = ref[reqid];\n                    delete _this._pending_replies[reqid];\n                    return promise_funcs;\n                }\n                return null;\n            };\n        })(this);\n        promise_funcs = pop_pending();\n        while (promise_funcs !== null) {\n            promise_funcs[1](\"Disconnected\");\n            promise_funcs = pop_pending();\n        }\n        if (!this.closed_permanently) {\n            return this._schedule_reconnect(2000);\n        }\n    };\n    ClientConnection.prototype._on_error = function (reject) {\n        logging_1.logger.debug(\"Websocket error on socket  \" + this._number);\n        return reject(new Error(\"Could not open websocket\"));\n    };\n    ClientConnection.prototype._close_bad_protocol = function (detail) {\n        logging_1.logger.error(\"Closing connection: \" + detail);\n        if (this.socket != null) {\n            return this.socket.close(1002, detail);\n        }\n    };\n    ClientConnection.prototype._awaiting_ack_handler = function (message) {\n        if (message.msgtype() === \"ACK\") {\n            this._current_handler = (function (_this) {\n                return function (message) {\n                    return _this._steady_state_handler(message);\n                };\n            })(this);\n            this._repull_session_doc();\n            if (this._pending_ack != null) {\n                this._pending_ack[0](this);\n                return this._pending_ack = null;\n            }\n        }\n        else {\n            return this._close_bad_protocol(\"First message was not an ACK\");\n        }\n    };\n    ClientConnection.prototype._steady_state_handler = function (message) {\n        var promise_funcs;\n        if (message.reqid() in this._pending_replies) {\n            promise_funcs = this._pending_replies[message.reqid()];\n            delete this._pending_replies[message.reqid()];\n            return promise_funcs[0](message);\n        }\n        else if (message.msgtype() in message_handlers) {\n            return message_handlers[message.msgtype()](this, message);\n        }\n        else {\n            return logging_1.logger.debug(\"Doing nothing with message \" + (message.msgtype()));\n        }\n    };\n    return ClientConnection;\n})();\nClientSession = (function () {\n    function ClientSession(_connection, document1, id) {\n        this._connection = _connection;\n        this.document = document1;\n        this.id = id;\n        this.document_listener = (function (_this) {\n            return function (event) {\n                return _this._document_changed(event);\n            };\n        })(this);\n        this.document.on_change(this.document_listener);\n        this.event_manager = this.document.event_manager;\n        this.event_manager.session = this;\n    }\n    ClientSession.prototype.close = function () {\n        return this._connection.close();\n    };\n    ClientSession.prototype.send_event = function (type) {\n        return this._connection.send_event(type);\n    };\n    ClientSession.prototype._connection_closed = function () {\n        return this.document.remove_on_change(this.document_listener);\n    };\n    ClientSession.prototype.request_server_info = function () {\n        var message, promise;\n        message = Message.create('SERVER-INFO-REQ', {});\n        promise = this._connection.send_with_reply(message);\n        return promise.then(function (reply) {\n            return reply.content;\n        });\n    };\n    ClientSession.prototype.force_roundtrip = function () {\n        return this.request_server_info().then(function (ignored) {\n            return void 0;\n        });\n    };\n    ClientSession.prototype._document_changed = function (event) {\n        var patch;\n        if (event.setter_id === this.id) {\n            return;\n        }\n        if (event instanceof document_1.ModelChangedEvent && !(event.attr in event.model.serializable_attributes())) {\n            return;\n        }\n        patch = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));\n        return this._connection.send(patch);\n    };\n    ClientSession.prototype._handle_patch = function (message) {\n        return this.document.apply_json_patch(message.content, this.id);\n    };\n    return ClientSession;\n})();\nexports.pull_session = function (url, session_id, args_string) {\n    var connection, promise, rejecter;\n    rejecter = null;\n    connection = null;\n    promise = new es6_promise_1.Promise(function (resolve, reject) {\n        connection = new ClientConnection(url, session_id, args_string, function (session) {\n            var e;\n            try {\n                return resolve(session);\n            }\n            catch (error1) {\n                e = error1;\n                logging_1.logger.error(\"Promise handler threw an error, closing session \" + error);\n                session.close();\n                throw e;\n            }\n        }, function () {\n            return reject(new Error(\"Connection was closed before we successfully pulled a session\"));\n        });\n        return connection.connect().then(function (whatever) { }, function (error) {\n            logging_1.logger.error(\"Failed to connect to Bokeh server \" + error);\n            throw error;\n        });\n    });\n    promise.close = function () {\n        return connection.close();\n    };\n    return promise;\n};\n","//     Backbone.js 1.3.3\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\nvar events_1 = require(\"./events\");\nvar eq_1 = require(\"./util/eq\");\nvar object_1 = require(\"./util/object\");\n// Backbone.Model\n// --------------\n// Backbone **Models** are the basic data object in the framework --\n// frequently representing a row in a table in a database on your server.\n// A discrete chunk of data and a bunch of useful, related methods for\n// performing computations and transformations on that data.\n// Create a new model with the specified attributes.\nexports.Model = function (attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.attributes = {};\n    this.setv(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n};\n// Attach all inheritable methods to the Model prototype.\nobject_1.extend(exports.Model.prototype, events_1.Events, {\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function () { },\n    // Get the value of an attribute.\n    getv: function (attr) {\n        return this.attributes[attr];\n    },\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    setv: function (key, val, options) {\n        if (key == null)\n            return this;\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        var attrs;\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val;\n        }\n        else {\n            (attrs = {})[key] = val;\n        }\n        options || (options = {});\n        // Extract attributes and options.\n        var silent = options.silent;\n        var changes = [];\n        var changing = this._changing;\n        this._changing = true;\n        if (!changing) {\n            this._previousAttributes = object_1.clone(this.attributes);\n            this.changed = {};\n        }\n        var current = this.attributes;\n        var changed = this.changed;\n        var prev = this._previousAttributes;\n        // For each `set` attribute, update or delete the current value.\n        for (var attr in attrs) {\n            val = attrs[attr];\n            if (!eq_1.isEqual(current[attr], val))\n                changes.push(attr);\n            if (!eq_1.isEqual(prev[attr], val)) {\n                changed[attr] = val;\n            }\n            else {\n                delete changed[attr];\n            }\n            current[attr] = val;\n        }\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length)\n                this._pending = true;\n            for (var i = 0; i < changes.length; i++) {\n                this.trigger('change:' + changes[i], this, current[changes[i]]);\n            }\n        }\n        // You might be wondering why there's a `while` loop here. Changes can\n        // be recursively nested within `\"change\"` events.\n        if (changing)\n            return this;\n        if (!silent) {\n            while (this._pending) {\n                this._pending = false;\n                this.trigger('change', this);\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this;\n    },\n    destroy: function () {\n        this.stopListening();\n        this.trigger('destroy', this);\n    },\n    // Create a new model with identical attributes to this one.\n    clone: function () {\n        return new this.constructor(this.attributes);\n    }\n});\n// Backbone.View\n// -------------\n// Backbone Views are almost more convention than they are actual code. A View\n// is simply a JavaScript object that represents a logical chunk of UI in the\n// DOM. This might be a single item, an entire list, a sidebar or panel, or\n// even the surrounding frame which wraps your whole app. Defining a chunk of\n// UI as a **View** allows you to define your DOM events declaratively, without\n// having to worry about render order ... and makes it easy for the view to\n// react to specific changes in the state of your models.\n// Creating a Backbone.View creates its initial element outside of the DOM,\n// if an existing element is not provided...\nexports.View = function (options) {\n    options = options || {};\n    this.model = options.model;\n    this.id = options.id;\n    this.el = options.el;\n    this._ensureElement();\n    this.initialize(options);\n};\n// Set up all inheritable **Backbone.View** properties and methods.\nobject_1.extend(exports.View.prototype, events_1.Events, {\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function (options) { },\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function () {\n        return this;\n    },\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function () {\n        this._removeElement();\n        this.stopListening();\n        return this;\n    },\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function () {\n        var parent = this.el.parentNode;\n        if (parent != null) {\n            parent.removeChild(this.el);\n        }\n    },\n    setElement: function (element) {\n        this._setElement(element);\n        return this;\n    },\n    // Creates the `this.el`.\n    _setElement: function (el) {\n        this.el = el;\n    },\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function (tagName) {\n        return document.createElement(tagName);\n    },\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function () {\n        if (!this.el) {\n            this.setElement(this._createElement(this.tagName));\n            if (this.id) {\n                this.el.setAttribute('id', this.id);\n            }\n            if (this.className) {\n                this.el.setAttribute('class', this.className);\n            }\n        }\n        else {\n            this.setElement(this.el);\n        }\n    }\n});\nexports.Model.getter = exports.View.getter = function (name, get) {\n    Object.defineProperty(this.prototype, name, { get: get });\n};\nexports.Model.getters = exports.View.getters = function (specs) {\n    for (var name in specs) {\n        this.getter(name, specs[name]);\n    }\n};\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logging_1 = require(\"./logging\");\nvar object_1 = require(\"./util/object\");\nvar event_classes = {};\nfunction register_event_class(event_name) {\n    return function (event_cls) {\n        event_cls.prototype.event_name = event_name;\n        event_classes[event_name] = event_cls;\n    };\n}\nexports.register_event_class = register_event_class;\nfunction register_with_event(event_cls) {\n    var models = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        models[_i - 1] = arguments[_i];\n    }\n    var applicable_models = event_cls.prototype.applicable_models.concat(models);\n    event_cls.prototype.applicable_models = applicable_models;\n}\nexports.register_with_event = register_with_event;\nvar BokehEvent = (function () {\n    function BokehEvent(options) {\n        if (options === void 0) { options = {}; }\n        this._options = options;\n        if (options.model_id) {\n            this.model_id = options.model_id;\n        }\n    }\n    BokehEvent.prototype.set_model_id = function (id) {\n        this._options.model_id = id;\n        this.model_id = id;\n        return this;\n    };\n    BokehEvent.prototype.is_applicable_to = function (obj) {\n        return this.applicable_models.some(function (model) { return obj instanceof model; });\n    };\n    BokehEvent.event_class = function (e) {\n        // Given an event with a type attribute matching the event_name,\n        // return the appropriate BokehEvent class\n        if (e.type) {\n            return event_classes[e.type];\n        }\n        else {\n            logging_1.logger.warn('BokehEvent.event_class required events with a string type attribute');\n        }\n    };\n    BokehEvent.prototype.toJSON = function () {\n        return {\n            event_name: this.event_name,\n            event_values: object_1.clone(this._options),\n        };\n    };\n    BokehEvent.prototype._customize_event = function (model) {\n        return this;\n    };\n    return BokehEvent;\n}());\nexports.BokehEvent = BokehEvent;\nBokehEvent.prototype.applicable_models = [];\nvar ButtonClick = (function (_super) {\n    __extends(ButtonClick, _super);\n    function ButtonClick() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ButtonClick;\n}(BokehEvent));\nButtonClick = __decorate([\n    register_event_class(\"button_click\")\n], ButtonClick);\nexports.ButtonClick = ButtonClick;\n// A UIEvent is an event originating on a PlotCanvas this includes\n// DOM events such as keystrokes as well as hammer events and LOD events.\nvar UIEvent = (function (_super) {\n    __extends(UIEvent, _super);\n    function UIEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return UIEvent;\n}(BokehEvent));\nexports.UIEvent = UIEvent;\nvar LODStart = (function (_super) {\n    __extends(LODStart, _super);\n    function LODStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LODStart;\n}(UIEvent));\nLODStart = __decorate([\n    register_event_class(\"lodstart\")\n], LODStart);\nexports.LODStart = LODStart;\nvar LODEnd = (function (_super) {\n    __extends(LODEnd, _super);\n    function LODEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LODEnd;\n}(UIEvent));\nLODEnd = __decorate([\n    register_event_class(\"lodend\")\n], LODEnd);\nexports.LODEnd = LODEnd;\nvar PointEvent = (function (_super) {\n    __extends(PointEvent, _super);\n    function PointEvent(options) {\n        var _this = _super.call(this, options) || this;\n        _this.sx = options.sx;\n        _this.sy = options.sy;\n        _this.x = null;\n        _this.y = null;\n        return _this;\n    }\n    PointEvent.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({ sx: e.bokeh['sx'], sy: e.bokeh['sy'], model_id: model_id });\n    };\n    PointEvent.prototype._customize_event = function (plot) {\n        var xmapper = plot.plot_canvas.frame.x_mappers['default'];\n        var ymapper = plot.plot_canvas.frame.y_mappers['default'];\n        this.x = xmapper.map_from_target(plot.plot_canvas.canvas.sx_to_vx(this.sx));\n        this.y = ymapper.map_from_target(plot.plot_canvas.canvas.sy_to_vy(this.sy));\n        this._options['x'] = this.x;\n        this._options['y'] = this.y;\n        return this;\n    };\n    return PointEvent;\n}(UIEvent));\nexports.PointEvent = PointEvent;\nvar Pan = (function (_super) {\n    __extends(Pan, _super);\n    function Pan(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.delta_x = options.delta_x;\n        _this.delta_y = options.delta_y;\n        return _this;\n    }\n    Pan.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            delta_x: e.deltaX,\n            delta_y: e.deltaY,\n            direction: e.direction,\n            model_id: model_id\n        });\n    };\n    return Pan;\n}(PointEvent));\nPan = __decorate([\n    register_event_class(\"pan\")\n], Pan);\nexports.Pan = Pan;\nvar Pinch = (function (_super) {\n    __extends(Pinch, _super);\n    function Pinch(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.scale = options.scale;\n        return _this;\n    }\n    Pinch.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            scale: e.scale,\n            model_id: model_id,\n        });\n    };\n    return Pinch;\n}(PointEvent));\nPinch = __decorate([\n    register_event_class(\"pinch\")\n], Pinch);\nexports.Pinch = Pinch;\nvar MouseWheel = (function (_super) {\n    __extends(MouseWheel, _super);\n    function MouseWheel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.delta = options.delta;\n        return _this;\n    }\n    MouseWheel.from_event = function (e, model_id) {\n        if (model_id === void 0) { model_id = null; }\n        return new this({\n            sx: e.bokeh['sx'],\n            sy: e.bokeh['sy'],\n            delta: e.delta,\n            model_id: model_id,\n        });\n    };\n    return MouseWheel;\n}(PointEvent));\nMouseWheel = __decorate([\n    register_event_class(\"wheel\")\n], MouseWheel);\nexports.MouseWheel = MouseWheel;\nvar MouseMove = (function (_super) {\n    __extends(MouseMove, _super);\n    function MouseMove() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseMove;\n}(PointEvent));\nMouseMove = __decorate([\n    register_event_class(\"mousemove\")\n], MouseMove);\nexports.MouseMove = MouseMove;\nvar MouseEnter = (function (_super) {\n    __extends(MouseEnter, _super);\n    function MouseEnter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseEnter;\n}(PointEvent));\nMouseEnter = __decorate([\n    register_event_class(\"mouseenter\")\n], MouseEnter);\nexports.MouseEnter = MouseEnter;\nvar MouseLeave = (function (_super) {\n    __extends(MouseLeave, _super);\n    function MouseLeave() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MouseLeave;\n}(PointEvent));\nMouseLeave = __decorate([\n    register_event_class(\"mouseleave\")\n], MouseLeave);\nexports.MouseLeave = MouseLeave;\nvar Tap = (function (_super) {\n    __extends(Tap, _super);\n    function Tap() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Tap;\n}(PointEvent));\nTap = __decorate([\n    register_event_class(\"tap\")\n], Tap);\nexports.Tap = Tap;\nvar DoubleTap = (function (_super) {\n    __extends(DoubleTap, _super);\n    function DoubleTap() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DoubleTap;\n}(PointEvent));\nDoubleTap = __decorate([\n    register_event_class(\"doubletap\")\n], DoubleTap);\nexports.DoubleTap = DoubleTap;\nvar Press = (function (_super) {\n    __extends(Press, _super);\n    function Press() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Press;\n}(PointEvent));\nPress = __decorate([\n    register_event_class(\"press\")\n], Press);\nexports.Press = Press;\nvar PanStart = (function (_super) {\n    __extends(PanStart, _super);\n    function PanStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PanStart;\n}(PointEvent));\nPanStart = __decorate([\n    register_event_class(\"panstart\")\n], PanStart);\nexports.PanStart = PanStart;\nvar PanEnd = (function (_super) {\n    __extends(PanEnd, _super);\n    function PanEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PanEnd;\n}(PointEvent));\nPanEnd = __decorate([\n    register_event_class(\"panend\")\n], PanEnd);\nexports.PanEnd = PanEnd;\nvar PinchStart = (function (_super) {\n    __extends(PinchStart, _super);\n    function PinchStart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PinchStart;\n}(PointEvent));\nPinchStart = __decorate([\n    register_event_class(\"pinchstart\")\n], PinchStart);\nexports.PinchStart = PinchStart;\nvar PinchEnd = (function (_super) {\n    __extends(PinchEnd, _super);\n    function PinchEnd() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PinchEnd;\n}(PointEvent));\nPinchEnd = __decorate([\n    register_event_class(\"pinchend\")\n], PinchEnd);\nexports.PinchEnd = PinchEnd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar Backbone = require(\"./backbone\");\nvar string_1 = require(\"./util/string\");\nexports.BokehView = (function (superClass) {\n    extend(BokehView, superClass);\n    function BokehView() {\n        return BokehView.__super__.constructor.apply(this, arguments);\n    }\n    BokehView.prototype.initialize = function (options) {\n        if (options.id == null) {\n            return this.id = string_1.uniqueId('BokehView');\n        }\n    };\n    BokehView.prototype.toString = function () {\n        return this.model.type + \"View(\" + this.id + \")\";\n    };\n    BokehView.prototype.bind_bokeh_events = function () { };\n    BokehView.prototype.remove = function () {\n        this.trigger('remove', this);\n        return BokehView.__super__.remove.call(this);\n    };\n    return BokehView;\n})(Backbone.View);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_1 = require(\"./util/array\");\nvar object_1 = require(\"./util/object\");\nexports.build_views = function (view_storage, view_models, options, view_types) {\n    var cls, created_views, i, i_model, j, key, len, len1, model, newmodels, ref, to_remove, view, view_options;\n    if (view_types == null) {\n        view_types = [];\n    }\n    created_views = [];\n    newmodels = view_models.filter(function (x) {\n        return view_storage[x.id] == null;\n    });\n    for (i_model = i = 0, len = newmodels.length; i < len; i_model = ++i) {\n        model = newmodels[i_model];\n        cls = (ref = view_types[i_model]) != null ? ref : model.default_view;\n        view_options = object_1.extend({\n            model: model\n        }, options);\n        view_storage[model.id] = view = new cls(view_options);\n        created_views.push(view);\n    }\n    to_remove = array_1.difference(Object.keys(view_storage), (function () {\n        var j, len1, results;\n        results = [];\n        for (j = 0, len1 = view_models.length; j < len1; j++) {\n            view = view_models[j];\n            results.push(view.id);\n        }\n        return results;\n    })());\n    for (j = 0, len1 = to_remove.length; j < len1; j++) {\n        key = to_remove[j];\n        view_storage[key].remove();\n        delete view_storage[key];\n    }\n    return created_views;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./util/types\");\nvar _createElement = function (tag) { return function (attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var children = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        children[_i - 1] = arguments[_i];\n    }\n    var element;\n    if (tag === \"fragment\") {\n        // XXX: this is wrong, but the the common super type of DocumentFragment and HTMLElement is\n        // Node, which doesn't support classList, style, etc. attributes.\n        element = document.createDocumentFragment();\n    }\n    else {\n        element = document.createElement(tag);\n        for (var attr in attrs) {\n            var value = attrs[attr];\n            if (value == null || types_1.isBoolean(value) && !value)\n                continue;\n            if (attr === \"class\" && types_1.isArray(value)) {\n                for (var _a = 0, _b = value; _a < _b.length; _a++) {\n                    var cls = _b[_a];\n                    if (cls != null)\n                        element.classList.add(cls);\n                }\n                continue;\n            }\n            if (attr === \"style\" && types_1.isObject(value)) {\n                for (var prop in value) {\n                    element.style[prop] = value[prop];\n                }\n                continue;\n            }\n            element.setAttribute(attr, value);\n        }\n    }\n    function append(child) {\n        if (child instanceof HTMLElement)\n            element.appendChild(child);\n        else if (types_1.isString(child))\n            element.appendChild(document.createTextNode(child));\n        else if (child != null && child !== false)\n            throw new Error(\"expected an HTMLElement, string, false or null, got \" + JSON.stringify(child));\n    }\n    for (var _c = 0, children_1 = children; _c < children_1.length; _c++) {\n        var child = children_1[_c];\n        if (types_1.isArray(child)) {\n            for (var _d = 0, child_1 = child; _d < child_1.length; _d++) {\n                var _child = child_1[_d];\n                append(_child);\n            }\n        }\n        else\n            append(child);\n    }\n    return element;\n}; };\nfunction createElement(tag, attrs) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    return _createElement(tag).apply(void 0, [attrs].concat(children));\n}\nexports.createElement = createElement;\nexports.div = _createElement(\"div\"), exports.span = _createElement(\"span\"), exports.link = _createElement(\"link\"), exports.style = _createElement(\"style\"), exports.a = _createElement(\"a\"), exports.p = _createElement(\"p\"), exports.pre = _createElement(\"pre\"), exports.input = _createElement(\"input\"), exports.label = _createElement(\"label\"), exports.canvas = _createElement(\"canvas\"), exports.ul = _createElement(\"ul\"), exports.ol = _createElement(\"ol\"), exports.li = _createElement(\"li\");\nfunction show(element) {\n    element.style.display = \"\";\n}\nexports.show = show;\nfunction hide(element) {\n    element.style.display = \"none\";\n}\nexports.hide = hide;\nfunction empty(element) {\n    var child;\n    while (child = element.firstChild) {\n        element.removeChild(child);\n    }\n}\nexports.empty = empty;\nfunction position(element) {\n    return {\n        top: element.offsetTop,\n        left: element.offsetLeft,\n    };\n}\nexports.position = position;\nfunction offset(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + window.pageYOffset - document.documentElement.clientTop,\n        left: rect.left + window.pageXOffset - document.documentElement.clientLeft,\n    };\n}\nexports.offset = offset;\nfunction replaceWith(element, replacement) {\n    var parent = element.parentNode;\n    if (parent != null) {\n        parent.replaceChild(replacement, element);\n    }\n}\nexports.replaceWith = replaceWith;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AngleUnits = [\"deg\", \"rad\"];\nexports.Dimension = [\"width\", \"height\"];\nexports.Dimensions = [\"width\", \"height\", \"both\"];\nexports.Direction = [\"clock\", \"anticlock\"];\nexports.FontStyle = [\"normal\", \"italic\", \"bold\"];\nexports.LatLon = [\"lat\", \"lon\"];\nexports.LineCap = [\"butt\", \"round\", \"square\"];\nexports.LineJoin = [\"miter\", \"round\", \"bevel\"];\nexports.Location = [\"above\", \"below\", \"left\", \"right\"];\nexports.LegendLocation = [\"top_left\", \"top_center\", \"top_right\", \"center_left\", \"center\", \"center_right\", \"bottom_left\", \"bottom_center\", \"bottom_right\"];\nexports.Orientation = [\"vertical\", \"horizontal\"];\nexports.RenderLevel = [\"image\", \"underlay\", \"glyph\", \"annotation\", \"overlay\"];\nexports.RenderMode = [\"canvas\", \"css\"];\nexports.Side = [\"left\", \"right\"];\nexports.SpatialUnits = [\"screen\", \"data\"];\nexports.StartEnd = [\"start\", \"end\"];\nexports.TextAlign = [\"left\", \"right\", \"center\"];\nexports.TextBaseline = [\"top\", \"middle\", \"bottom\", \"alphabetic\", \"hanging\", \"ideographic\"];\nexports.DistributionTypes = [\"uniform\", \"normal\"];\nexports.TransformStepModes = [\"after\", \"before\", \"center\"];\nexports.SizingMode = [\"stretch_both\", \"scale_width\", \"scale_height\", \"scale_both\", \"fixed\"];\n","//     Backbone.js 1.3.3\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\nvar string_1 = require(\"./util/string\");\nvar callback_1 = require(\"./util/callback\");\n// Backbone.Events\n// ---------------\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     var object = {};\n//     extend(object, Backbone.Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nexports.Events = {};\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function (iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n        // Handle event maps.\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0)\n            opts.context = callback;\n        for (names = Object.keys(name); i < names.length; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        }\n    }\n    else if (name && eventSplitter.test(name)) {\n        // Handle space-separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, opts);\n        }\n    }\n    else {\n        // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n    }\n    return events;\n};\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nexports.Events.on = function (name, callback, context) {\n    return internalOn(this, name, callback, context);\n};\n// Guard the `listening` argument from the public API.\nvar internalOn = function (obj, name, callback, context, listening) {\n    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\n        context: context,\n        ctx: obj,\n        listening: listening\n    });\n    if (listening) {\n        var listeners = obj._listeners || (obj._listeners = {});\n        listeners[listening.id] = listening;\n    }\n    return obj;\n};\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nexports.Events.listenTo = function (obj, name, callback) {\n    if (!obj)\n        return this;\n    var id = obj._listenId || (obj._listenId = string_1.uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = listeningTo[id];\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n        var thisId = this._listenId || (this._listenId = string_1.uniqueId('l'));\n        listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };\n    }\n    // Bind callbacks on obj, and keep track of them on listening.\n    internalOn(obj, name, callback, this, listening);\n    return this;\n};\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function (events, name, callback, options) {\n    if (callback) {\n        var handlers = events[name] || (events[name] = []);\n        var context = options.context, ctx = options.ctx, listening = options.listening;\n        if (listening)\n            listening.count++;\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n};\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nexports.Events.off = function (name, callback, context) {\n    if (!this._events)\n        return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n    return this;\n};\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nexports.Events.stopListening = function (obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo)\n        return this;\n    var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n        var listening = listeningTo[ids[i]];\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening)\n            break;\n        listening.obj.off(name, callback, this);\n    }\n    return this;\n};\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function (events, name, callback, options) {\n    if (!events)\n        return;\n    var i = 0, listening;\n    var context = options.context, listeners = options.listeners;\n    // Delete all events listeners and \"drop\" events.\n    if (!name && !callback && !context) {\n        var ids = Object.keys(listeners);\n        for (; i < ids.length; i++) {\n            listening = listeners[ids[i]];\n            delete listeners[listening.id];\n            delete listening.listeningTo[listening.objId];\n        }\n        return;\n    }\n    var names = name ? [name] : Object.keys(events);\n    for (; i < names.length; i++) {\n        name = names[i];\n        var handlers = events[name];\n        // Bail out if there are no events stored.\n        if (!handlers)\n            break;\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        var remaining = [];\n        for (var j = 0; j < handlers.length; j++) {\n            var handler = handlers[j];\n            if (callback && callback !== handler.callback &&\n                callback !== handler.callback._callback ||\n                context && context !== handler.context) {\n                remaining.push(handler);\n            }\n            else {\n                listening = handler.listening;\n                if (listening && --listening.count === 0) {\n                    delete listeners[listening.id];\n                    delete listening.listeningTo[listening.objId];\n                }\n            }\n        }\n        // Update tail event if the list has any events.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        }\n        else {\n            delete events[name];\n        }\n    }\n    return events;\n};\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nexports.Events.once = function (name, callback, context) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null)\n        callback = void 0;\n    return this.on(events, callback, context);\n};\n// Inversion-of-control versions of `once`.\nexports.Events.listenToOnce = function (obj, name, callback) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n};\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function (map, name, callback, offer) {\n    if (callback) {\n        var fn = map[name] = callback_1.once(function () {\n            offer(name, fn);\n            callback.apply(this, arguments);\n        });\n        fn._callback = callback;\n    }\n    return map;\n};\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nexports.Events.trigger = function (name) {\n    if (!this._events)\n        return this;\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++)\n        args[i] = arguments[i + 1];\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n};\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function (objEvents, name, callback, args) {\n    if (objEvents) {\n        var events = objEvents[name];\n        var allEvents = objEvents.all;\n        if (events && allEvents)\n            allEvents = allEvents.slice();\n        if (events)\n            triggerEvents(events, args);\n        if (allEvents)\n            triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n};\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// Backbone events have 3 arguments).\nvar triggerEvents = function (events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0:\n            while (++i < l)\n                (ev = events[i]).callback.call(ev.ctx);\n            return;\n        case 1:\n            while (++i < l)\n                (ev = events[i]).callback.call(ev.ctx, a1);\n            return;\n        case 2:\n            while (++i < l)\n                (ev = events[i]).callback.call(ev.ctx, a1, a2);\n            return;\n        case 3:\n            while (++i < l)\n                (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n            return;\n        default:\n            while (++i < l)\n                (ev = events[i]).callback.apply(ev.ctx, args);\n            return;\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar Backbone = require(\"./backbone\");\nvar logging_1 = require(\"./logging\");\nvar property_mixins = require(\"./property_mixins\");\nvar refs = require(\"./util/refs\");\nvar p = require(\"./properties\");\nvar string_1 = require(\"./util/string\");\nvar array_1 = require(\"./util/array\");\nvar object_1 = require(\"./util/object\");\nvar types_1 = require(\"./util/types\");\nexports.HasProps = (function (superClass) {\n    extend1(HasProps, superClass);\n    HasProps.prototype.props = {};\n    HasProps.prototype.mixins = [];\n    HasProps.define = function (object) {\n        var name, prop, results;\n        results = [];\n        for (name in object) {\n            prop = object[name];\n            results.push((function (_this) {\n                return function (name, prop) {\n                    var default_value, internal, props, refined_prop, type;\n                    if (_this.prototype.props[name] != null) {\n                        throw new Error(\"attempted to redefine property '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    if (_this.prototype[name] != null) {\n                        throw new Error(\"attempted to redefine attribute '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    Object.defineProperty(_this.prototype, name, {\n                        get: function () {\n                            var value;\n                            value = this.getv(name);\n                            return value;\n                        },\n                        set: function (value) {\n                            this.setv(name, value);\n                            return this;\n                        }\n                    }, {\n                        configurable: false,\n                        enumerable: true\n                    });\n                    type = prop[0], default_value = prop[1], internal = prop[2];\n                    refined_prop = {\n                        type: type,\n                        default_value: default_value,\n                        internal: internal != null ? internal : false\n                    };\n                    props = object_1.clone(_this.prototype.props);\n                    props[name] = refined_prop;\n                    return _this.prototype.props = props;\n                };\n            })(this)(name, prop));\n        }\n        return results;\n    };\n    HasProps.internal = function (object) {\n        var _object, fn, name, prop;\n        _object = {};\n        fn = (function (_this) {\n            return function (name, prop) {\n                var default_value, type;\n                type = prop[0], default_value = prop[1];\n                return _object[name] = [type, default_value, true];\n            };\n        })(this);\n        for (name in object) {\n            prop = object[name];\n            fn(name, prop);\n        }\n        return this.define(_object);\n    };\n    HasProps.mixin = function () {\n        var mixins, names;\n        names = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        this.define(property_mixins.create(names));\n        mixins = this.prototype.mixins.concat(names);\n        return this.prototype.mixins = mixins;\n    };\n    HasProps.mixins = function (names) {\n        return this.mixin.apply(this, names);\n    };\n    HasProps.override = function (name_or_object, default_value) {\n        var name, object, results;\n        if (types_1.isString(name_or_object)) {\n            object = {};\n            object[name] = default_value;\n        }\n        else {\n            object = name_or_object;\n        }\n        results = [];\n        for (name in object) {\n            default_value = object[name];\n            results.push((function (_this) {\n                return function (name, default_value) {\n                    var props, value;\n                    value = _this.prototype.props[name];\n                    if (value == null) {\n                        throw new Error(\"attempted to override nonexistent '\" + _this.name + \".\" + name + \"'\");\n                    }\n                    props = object_1.clone(_this.prototype.props);\n                    props[name] = object_1.extend({}, value, {\n                        default_value: default_value\n                    });\n                    return _this.prototype.props = props;\n                };\n            })(this)(name, default_value));\n        }\n        return results;\n    };\n    HasProps.define({\n        id: [p.Any]\n    });\n    HasProps.prototype.toString = function () {\n        return this.type + \"(\" + this.id + \")\";\n    };\n    function HasProps(attributes, options) {\n        var attrs, default_value, name, ref, ref1, type;\n        this.document = null;\n        attrs = attributes || {};\n        if (!options) {\n            options = {};\n        }\n        this.attributes = {};\n        this.properties = {};\n        ref = this.props;\n        for (name in ref) {\n            ref1 = ref[name], type = ref1.type, default_value = ref1.default_value;\n            if (type == null) {\n                throw new Error(\"undefined property type for \" + this.type + \".\" + name);\n            }\n            this.properties[name] = new type({\n                obj: this,\n                attr: name,\n                default_value: default_value\n            });\n        }\n        this._set_after_defaults = {};\n        this.setv(attrs, options);\n        this.changed = {};\n        this._computed = {};\n        if (attrs.id == null) {\n            this.id = string_1.uniqueId(this.type);\n        }\n        if (!options.defer_initialization) {\n            this.initialize.apply(this, arguments);\n        }\n    }\n    HasProps.prototype.initialize = function (options) {\n        var name, prop, ref, results;\n        ref = this.properties;\n        results = [];\n        for (name in ref) {\n            prop = ref[name];\n            prop.update();\n            if (prop.spec.transform) {\n                results.push(this.listenTo(prop.spec.transform, \"change\", function () {\n                    return this.trigger('transformchange', this);\n                }));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    HasProps.prototype.setv = function (key, value, options) {\n        var attrs, old, prop_name, results, val;\n        if (types_1.isObject(key) || key === null) {\n            attrs = key;\n            options = value;\n        }\n        else {\n            attrs = {};\n            attrs[key] = value;\n        }\n        for (key in attrs) {\n            if (!hasProp.call(attrs, key))\n                continue;\n            val = attrs[key];\n            prop_name = key;\n            if (this.props[prop_name] == null) {\n                throw new Error(\"property \" + this.type + \".\" + prop_name + \" wasn't declared\");\n            }\n            if (!((options != null) && options.defaults)) {\n                this._set_after_defaults[key] = true;\n            }\n        }\n        if (!object_1.isEmpty(attrs)) {\n            old = {};\n            for (key in attrs) {\n                value = attrs[key];\n                old[key] = this.getv(key);\n            }\n            HasProps.__super__.setv.call(this, attrs, options);\n            if ((options != null ? options.silent : void 0) == null) {\n                results = [];\n                for (key in attrs) {\n                    value = attrs[key];\n                    results.push(this._tell_document_about_change(key, old[key], this.getv(key), options));\n                }\n                return results;\n            }\n        }\n    };\n    HasProps.prototype.add_dependencies = function (prop_name, object, fields) {\n        var fld, j, len, prop_spec, results;\n        if (!types_1.isArray(fields)) {\n            fields = [fields];\n        }\n        prop_spec = this._computed[prop_name];\n        prop_spec.dependencies = prop_spec.dependencies.concat({\n            obj: object,\n            fields: fields\n        });\n        results = [];\n        for (j = 0, len = fields.length; j < len; j++) {\n            fld = fields[j];\n            results.push(this.listenTo(object, \"change:\" + fld, prop_spec['callbacks']['changedep']));\n        }\n        return results;\n    };\n    HasProps.prototype.define_computed_property = function (prop_name, getter, use_cache) {\n        var changedep, prop_spec, propchange;\n        if (use_cache == null) {\n            use_cache = true;\n        }\n        if (this.props[prop_name] != null) {\n            console.log(\"attempted to redefine existing property \" + this.type + \".\" + prop_name);\n        }\n        if (this._computed[prop_name] != null) {\n            throw new Error(\"attempted to redefine existing computed property \" + this.type + \".\" + prop_name);\n        }\n        changedep = (function (_this) {\n            return function () {\n                return _this.trigger('changedep:' + prop_name);\n            };\n        })(this);\n        propchange = (function (_this) {\n            return function () {\n                var firechange, new_val, old_val;\n                firechange = true;\n                if (prop_spec['use_cache']) {\n                    old_val = prop_spec.cache;\n                    prop_spec.cache = void 0;\n                    new_val = _this._get_computed(prop_name);\n                    firechange = new_val !== old_val;\n                }\n                if (firechange) {\n                    _this.trigger('change:' + prop_name, _this, _this._get_computed(prop_name));\n                    return _this.trigger('change', _this);\n                }\n            };\n        })(this);\n        prop_spec = {\n            'getter': getter,\n            'dependencies': [],\n            'use_cache': use_cache,\n            'callbacks': {\n                changedep: changedep,\n                propchange: propchange\n            }\n        };\n        this._computed[prop_name] = prop_spec;\n        this.listenTo(this, \"changedep:\" + prop_name, prop_spec['callbacks']['propchange']);\n        return prop_spec;\n    };\n    HasProps.prototype.set = function (key, value, options) {\n        logging_1.logger.warn(\"HasProps.set('prop_name', value) is deprecated, use HasProps.prop_name = value instead\");\n        return this.setv(key, value, options);\n    };\n    HasProps.prototype.get = function (prop_name) {\n        logging_1.logger.warn(\"HasProps.get('prop_name') is deprecated, use HasProps.prop_name instead\");\n        return this.getv(prop_name);\n    };\n    HasProps.prototype.getv = function (prop_name) {\n        if (this.props[prop_name] == null) {\n            throw new Error(\"property \" + this.type + \".\" + prop_name + \" wasn't declared\");\n        }\n        else {\n            return HasProps.__super__.getv.call(this, prop_name);\n        }\n    };\n    HasProps.prototype._get_computed = function (prop_name) {\n        var computed, getter, prop_spec;\n        prop_spec = this._computed[prop_name];\n        if (prop_spec == null) {\n            throw new Error(\"computed property \" + this.type + \".\" + prop_name + \" wasn't declared\");\n        }\n        if (prop_spec.use_cache && prop_spec.cache) {\n            return prop_spec.cache;\n        }\n        else {\n            getter = prop_spec.getter;\n            computed = getter.apply(this, [prop_name]);\n            if (prop_spec.use_cache) {\n                prop_spec.cache = computed;\n            }\n            return computed;\n        }\n    };\n    HasProps.prototype.ref = function () {\n        return refs.create_ref(this);\n    };\n    HasProps.prototype.set_subtype = function (subtype) {\n        return this._subtype = subtype;\n    };\n    HasProps.prototype.attribute_is_serializable = function (attr) {\n        var prop;\n        prop = this.props[attr];\n        if (prop == null) {\n            throw new Error(this.type + \".attribute_is_serializable('\" + attr + \"'): \" + attr + \" wasn't declared\");\n        }\n        else {\n            return !prop.internal;\n        }\n    };\n    HasProps.prototype.serializable_attributes = function () {\n        var attrs, name, ref, value;\n        attrs = {};\n        ref = this.attributes;\n        for (name in ref) {\n            value = ref[name];\n            if (this.attribute_is_serializable(name)) {\n                attrs[name] = value;\n            }\n        }\n        return attrs;\n    };\n    HasProps._value_to_json = function (key, value, optional_parent_object) {\n        var i, j, len, ref_array, ref_obj, subkey, v;\n        if (value instanceof HasProps) {\n            return value.ref();\n        }\n        else if (types_1.isArray(value)) {\n            ref_array = [];\n            for (i = j = 0, len = value.length; j < len; i = ++j) {\n                v = value[i];\n                ref_array.push(HasProps._value_to_json(i, v, value));\n            }\n            return ref_array;\n        }\n        else if (types_1.isObject(value)) {\n            ref_obj = {};\n            for (subkey in value) {\n                if (!hasProp.call(value, subkey))\n                    continue;\n                ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);\n            }\n            return ref_obj;\n        }\n        else {\n            return value;\n        }\n    };\n    HasProps.prototype.attributes_as_json = function (include_defaults, value_to_json) {\n        var attrs, key, ref, value;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        if (value_to_json == null) {\n            value_to_json = HasProps._value_to_json;\n        }\n        attrs = {};\n        ref = this.serializable_attributes();\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            value = ref[key];\n            if (include_defaults) {\n                attrs[key] = value;\n            }\n            else if (key in this._set_after_defaults) {\n                attrs[key] = value;\n            }\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    };\n    HasProps._json_record_references = function (doc, v, result, recurse) {\n        var elem, j, k, len, model, results, results1;\n        if (v == null) {\n        }\n        else if (refs.is_ref(v)) {\n            if (!(v.id in result)) {\n                model = doc.get_model_by_id(v.id);\n                return HasProps._value_record_references(model, result, recurse);\n            }\n        }\n        else if (types_1.isArray(v)) {\n            results = [];\n            for (j = 0, len = v.length; j < len; j++) {\n                elem = v[j];\n                results.push(HasProps._json_record_references(doc, elem, result, recurse));\n            }\n            return results;\n        }\n        else if (types_1.isObject(v)) {\n            results1 = [];\n            for (k in v) {\n                if (!hasProp.call(v, k))\n                    continue;\n                elem = v[k];\n                results1.push(HasProps._json_record_references(doc, elem, result, recurse));\n            }\n            return results1;\n        }\n    };\n    HasProps._value_record_references = function (v, result, recurse) {\n        var elem, immediate, j, k, l, len, len1, obj, results, results1, results2;\n        if (v == null) {\n        }\n        else if (v instanceof HasProps) {\n            if (!(v.id in result)) {\n                result[v.id] = v;\n                if (recurse) {\n                    immediate = v._immediate_references();\n                    results = [];\n                    for (j = 0, len = immediate.length; j < len; j++) {\n                        obj = immediate[j];\n                        results.push(HasProps._value_record_references(obj, result, true));\n                    }\n                    return results;\n                }\n            }\n        }\n        else if (v.buffer instanceof ArrayBuffer) {\n        }\n        else if (types_1.isArray(v)) {\n            results1 = [];\n            for (l = 0, len1 = v.length; l < len1; l++) {\n                elem = v[l];\n                results1.push(HasProps._value_record_references(elem, result, recurse));\n            }\n            return results1;\n        }\n        else if (types_1.isObject(v)) {\n            results2 = [];\n            for (k in v) {\n                if (!hasProp.call(v, k))\n                    continue;\n                elem = v[k];\n                results2.push(HasProps._value_record_references(elem, result, recurse));\n            }\n            return results2;\n        }\n    };\n    HasProps.prototype._immediate_references = function () {\n        var attrs, key, result, value;\n        result = {};\n        attrs = this.serializable_attributes();\n        for (key in attrs) {\n            value = attrs[key];\n            HasProps._value_record_references(value, result, false);\n        }\n        return object_1.values(result);\n    };\n    HasProps.prototype.references = function () {\n        var references;\n        references = {};\n        HasProps._value_record_references(this, references, true);\n        return object_1.values(references);\n    };\n    HasProps.prototype.attach_document = function (doc) {\n        if (this.document !== null && this.document !== doc) {\n            throw new Error(\"models must be owned by only a single document\");\n        }\n        this.document = doc;\n        if (this._doc_attached != null) {\n            return this._doc_attached();\n        }\n    };\n    HasProps.prototype.detach_document = function () {\n        return this.document = null;\n    };\n    HasProps.prototype._tell_document_about_change = function (attr, old, new_, options) {\n        var need_invalidate, new_id, new_ref, new_refs, old_id, old_ref, old_refs;\n        if (!this.attribute_is_serializable(attr)) {\n            return;\n        }\n        if (this.document !== null) {\n            new_refs = {};\n            HasProps._value_record_references(new_, new_refs, false);\n            old_refs = {};\n            HasProps._value_record_references(old, old_refs, false);\n            need_invalidate = false;\n            for (new_id in new_refs) {\n                new_ref = new_refs[new_id];\n                if (!(new_id in old_refs)) {\n                    need_invalidate = true;\n                    break;\n                }\n            }\n            if (!need_invalidate) {\n                for (old_id in old_refs) {\n                    old_ref = old_refs[old_id];\n                    if (!(old_id in new_refs)) {\n                        need_invalidate = true;\n                        break;\n                    }\n                }\n            }\n            if (need_invalidate) {\n                this.document._invalidate_all_models();\n            }\n            return this.document._notify_change(this, attr, old, new_, options);\n        }\n    };\n    HasProps.prototype.materialize_dataspecs = function (source) {\n        var data, name, prop, ref;\n        data = {};\n        ref = this.properties;\n        for (name in ref) {\n            prop = ref[name];\n            if (!prop.dataspec) {\n                continue;\n            }\n            if ((prop.optional || false) && prop.spec.value === null && (!(name in this._set_after_defaults))) {\n                continue;\n            }\n            data[\"_\" + name] = prop.array(source);\n            if ((prop.spec.field != null) && prop.spec.field in source._shapes) {\n                data[\"_\" + name + \"_shape\"] = source._shapes[prop.spec.field];\n            }\n            if (prop instanceof p.Distance) {\n                data[\"max_\" + name] = array_1.max(data[\"_\" + name]);\n            }\n        }\n        return data;\n    };\n    return HasProps;\n})(Backbone.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dist_to_segment_squared, nullreturner, sqr;\nvar array_1 = require(\"./util/array\");\nexports.point_in_poly = function (x, y, px, py) {\n    var i, inside, j, ref, x1, x2, y1, y2;\n    inside = false;\n    x1 = px[px.length - 1];\n    y1 = py[py.length - 1];\n    for (i = j = 0, ref = px.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        x2 = px[i];\n        y2 = py[i];\n        if ((y1 < y) !== (y2 < y)) {\n            if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {\n                inside = !inside;\n            }\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return inside;\n};\nnullreturner = function () {\n    return null;\n};\nexports.HitTestResult = (function () {\n    function HitTestResult() {\n        this['0d'] = {\n            glyph: null,\n            get_view: nullreturner,\n            indices: []\n        };\n        this['1d'] = {\n            indices: []\n        };\n        this['2d'] = {\n            indices: {}\n        };\n    }\n    Object.defineProperty(HitTestResult.prototype, '_0d', {\n        get: function () {\n            return this['0d'];\n        }\n    });\n    Object.defineProperty(HitTestResult.prototype, '_1d', {\n        get: function () {\n            return this['1d'];\n        }\n    });\n    Object.defineProperty(HitTestResult.prototype, '_2d', {\n        get: function () {\n            return this['2d'];\n        }\n    });\n    HitTestResult.prototype.is_empty = function () {\n        return this._0d.indices.length === 0 && this._1d.indices.length === 0;\n    };\n    return HitTestResult;\n})();\nexports.create_hit_test_result = function () {\n    return new exports.HitTestResult();\n};\nexports.create_1d_hit_test_result = function (hits) {\n    var _dist, i, result;\n    result = new exports.HitTestResult();\n    result['1d'].indices = (function () {\n        var j, len, ref, ref1, results;\n        ref = array_1.sortBy(hits, function (arg) {\n            var _i, dist;\n            _i = arg[0], dist = arg[1];\n            return dist;\n        });\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            ref1 = ref[j], i = ref1[0], _dist = ref1[1];\n            results.push(i);\n        }\n        return results;\n    })();\n    return result;\n};\nexports.validate_bbox_coords = function (arg, arg1) {\n    var ref, ref1, x0, x1, y0, y1;\n    x0 = arg[0], x1 = arg[1];\n    y0 = arg1[0], y1 = arg1[1];\n    if (x0 > x1) {\n        ref = [x1, x0], x0 = ref[0], x1 = ref[1];\n    }\n    if (y0 > y1) {\n        ref1 = [y1, y0], y0 = ref1[0], y1 = ref1[1];\n    }\n    return {\n        minX: x0,\n        minY: y0,\n        maxX: x1,\n        maxY: y1\n    };\n};\nsqr = function (x) {\n    return x * x;\n};\nexports.dist_2_pts = function (vx, vy, wx, wy) {\n    return sqr(vx - wx) + sqr(vy - wy);\n};\ndist_to_segment_squared = function (p, v, w) {\n    var l2, t;\n    l2 = exports.dist_2_pts(v.x, v.y, w.x, w.y);\n    if (l2 === 0) {\n        return exports.dist_2_pts(p.x, p.y, v.x, v.y);\n    }\n    t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    if (t < 0) {\n        return exports.dist_2_pts(p.x, p.y, v.x, v.y);\n    }\n    if (t > 1) {\n        return exports.dist_2_pts(p.x, p.y, w.x, w.y);\n    }\n    return exports.dist_2_pts(p.x, p.y, v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));\n};\nexports.dist_to_segment = function (p, v, w) {\n    return Math.sqrt(dist_to_segment_squared(p, v, w));\n};\nexports.check_2_segments_intersect = function (l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\n    /* Check if 2 segments (l0 and l1) intersect. Returns a structure with\n      the following attributes:\n        * hit (boolean): whether the 2 segments intersect\n        * x (float): x coordinate of the intersection point\n        * y (float): y coordinate of the intersection point\n     */\n    var a, b, den, num1, num2, x, y;\n    den = ((l1_y1 - l1_y0) * (l0_x1 - l0_x0)) - ((l1_x1 - l1_x0) * (l0_y1 - l0_y0));\n    if (den === 0) {\n        return {\n            hit: false,\n            x: null,\n            y: null\n        };\n    }\n    else {\n        a = l0_y0 - l1_y0;\n        b = l0_x0 - l1_x0;\n        num1 = ((l1_x1 - l1_x0) * a) - ((l1_y1 - l1_y0) * b);\n        num2 = ((l0_x1 - l0_x0) * a) - ((l0_y1 - l0_y0) * b);\n        a = num1 / den;\n        b = num2 / den;\n        x = l0_x0 + (a * (l0_x1 - l0_x0));\n        y = l0_y0 + (a * (l0_y1 - l0_y0));\n        return {\n            hit: (a > 0 && a < 1) && (b > 0 && b < 1),\n            x: x,\n            y: y\n        };\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar solver_1 = require(\"./solver\");\nvar model_1 = require(\"../../model\");\nvar p = require(\"../properties\");\nexports.LayoutCanvas = (function (superClass) {\n    extend(LayoutCanvas, superClass);\n    function LayoutCanvas() {\n        return LayoutCanvas.__super__.constructor.apply(this, arguments);\n    }\n    LayoutCanvas.prototype.type = 'LayoutCanvas';\n    LayoutCanvas.prototype.initialize = function (attrs, options) {\n        LayoutCanvas.__super__.initialize.call(this, attrs, options);\n        this._top = new solver_1.Variable(\"top \" + this.id);\n        this._left = new solver_1.Variable(\"left \" + this.id);\n        this._width = new solver_1.Variable(\"width \" + this.id);\n        this._height = new solver_1.Variable(\"height \" + this.id);\n        this._right = new solver_1.Variable(\"right \" + this.id);\n        return this._bottom = new solver_1.Variable(\"bottom \" + this.id);\n    };\n    LayoutCanvas.getters({\n        height: function () {\n            return this._height.value();\n        },\n        width: function () {\n            return this._width.value();\n        },\n        right: function () {\n            return this._right.value();\n        },\n        left: function () {\n            return this._left.value();\n        },\n        top: function () {\n            return this._top.value();\n        },\n        bottom: function () {\n            return this._bottom.value();\n        }\n    });\n    LayoutCanvas.internal({\n        layout_location: [p.Any]\n    });\n    LayoutCanvas.prototype.get_edit_variables = function () {\n        var editables;\n        editables = [];\n        editables.push({\n            edit_variable: this._top,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._left,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._width,\n            strength: solver_1.Strength.strong\n        });\n        editables.push({\n            edit_variable: this._height,\n            strength: solver_1.Strength.strong\n        });\n        return editables;\n    };\n    LayoutCanvas.prototype.get_constraints = function () {\n        return [];\n    };\n    return LayoutCanvas;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ALPHABETIC, BOTTOM, CENTER, HANGING, LEFT, MIDDLE, RIGHT, TOP, _align_lookup, _align_lookup_negative, _align_lookup_positive, _angle_lookup, _baseline_lookup, pi2, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar solver_1 = require(\"./solver\");\nvar layout_canvas_1 = require(\"./layout_canvas\");\nvar p = require(\"core/properties\");\nvar logging_1 = require(\"core/logging\");\nvar types_1 = require(\"core/util/types\");\npi2 = Math.PI / 2;\nALPHABETIC = 'alphabetic';\nTOP = 'top';\nBOTTOM = 'bottom';\nMIDDLE = 'middle';\nHANGING = 'hanging';\nLEFT = 'left';\nRIGHT = 'right';\nCENTER = 'center';\n_angle_lookup = {\n    above: {\n        parallel: 0,\n        normal: -pi2,\n        horizontal: 0,\n        vertical: -pi2\n    },\n    below: {\n        parallel: 0,\n        normal: pi2,\n        horizontal: 0,\n        vertical: pi2\n    },\n    left: {\n        parallel: -pi2,\n        normal: 0,\n        horizontal: 0,\n        vertical: -pi2\n    },\n    right: {\n        parallel: pi2,\n        normal: 0,\n        horizontal: 0,\n        vertical: pi2\n    }\n};\n_baseline_lookup = {\n    above: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: ALPHABETIC,\n        vertical: MIDDLE\n    },\n    below: {\n        justified: BOTTOM,\n        parallel: HANGING,\n        normal: MIDDLE,\n        horizontal: HANGING,\n        vertical: MIDDLE\n    },\n    left: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: MIDDLE,\n        vertical: ALPHABETIC\n    },\n    right: {\n        justified: TOP,\n        parallel: ALPHABETIC,\n        normal: MIDDLE,\n        horizontal: MIDDLE,\n        vertical: ALPHABETIC\n    }\n};\n_align_lookup = {\n    above: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: CENTER,\n        vertical: LEFT\n    },\n    below: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: CENTER,\n        vertical: RIGHT\n    },\n    left: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: RIGHT,\n        horizontal: RIGHT,\n        vertical: CENTER\n    },\n    right: {\n        justified: CENTER,\n        parallel: CENTER,\n        normal: LEFT,\n        horizontal: LEFT,\n        vertical: CENTER\n    }\n};\n_align_lookup_negative = {\n    above: RIGHT,\n    below: LEFT,\n    left: RIGHT,\n    right: LEFT\n};\n_align_lookup_positive = {\n    above: LEFT,\n    below: RIGHT,\n    left: RIGHT,\n    right: LEFT\n};\nexports.update_constraints = function (view) {\n    var s, side, size, v;\n    v = view;\n    if (v.model.props.visible != null) {\n        if (v.model.visible === false) {\n            return;\n        }\n    }\n    size = v._get_size();\n    if (v._last_size == null) {\n        v._last_size = -1;\n    }\n    if (size === v._last_size) {\n        return;\n    }\n    s = v.model.document.solver();\n    v._last_size = size;\n    if (v._size_constraint != null) {\n        s.remove_constraint(v._size_constraint, true);\n    }\n    v._size_constraint = solver_1.GE(v.model.panel._size, -size);\n    s.add_constraint(v._size_constraint);\n    if (v._full_set == null) {\n        v._full_set = false;\n    }\n    if (!v._full_set) {\n        side = v.model.panel.side;\n        if (side === 'above' || side === 'below') {\n            s.add_constraint(solver_1.EQ(v.model.panel._width, [-1, v.plot_model.canvas._width]));\n        }\n        if (side === 'left' || side === 'right') {\n            s.add_constraint(solver_1.EQ(v.model.panel._height, [-1, v.plot_model.canvas._height]));\n        }\n        return v._full_set = true;\n    }\n};\nexports.SidePanel = (function (superClass) {\n    extend(SidePanel, superClass);\n    function SidePanel() {\n        return SidePanel.__super__.constructor.apply(this, arguments);\n    }\n    SidePanel.internal({\n        side: [p.String],\n        plot: [p.Instance]\n    });\n    SidePanel.prototype.initialize = function (attrs, options) {\n        SidePanel.__super__.initialize.call(this, attrs, options);\n        switch (this.side) {\n            case \"above\":\n                this._dim = 0;\n                this._normals = [0, -1];\n                this._size = this._height;\n                return this._anchor = this._bottom;\n            case \"below\":\n                this._dim = 0;\n                this._normals = [0, 1];\n                this._size = this._height;\n                return this._anchor = this._top;\n            case \"left\":\n                this._dim = 1;\n                this._normals = [-1, 0];\n                this._size = this._width;\n                return this._anchor = this._right;\n            case \"right\":\n                this._dim = 1;\n                this._normals = [1, 0];\n                this._size = this._width;\n                return this._anchor = this._left;\n            default:\n                return logging_1.logger.error(\"unrecognized side: '\" + this.side + \"'\");\n        }\n    };\n    SidePanel.prototype.get_constraints = function () {\n        var constraints;\n        constraints = [];\n        constraints.push(solver_1.GE(this._top));\n        constraints.push(solver_1.GE(this._bottom));\n        constraints.push(solver_1.GE(this._left));\n        constraints.push(solver_1.GE(this._right));\n        constraints.push(solver_1.GE(this._width));\n        constraints.push(solver_1.GE(this._height));\n        constraints.push(solver_1.EQ(this._left, this._width, [-1, this._right]));\n        constraints.push(solver_1.EQ(this._bottom, this._height, [-1, this._top]));\n        return constraints;\n    };\n    SidePanel.prototype.apply_label_text_heuristics = function (ctx, orient) {\n        var align, baseline, side;\n        side = this.side;\n        if (types_1.isString(orient)) {\n            baseline = _baseline_lookup[side][orient];\n            align = _align_lookup[side][orient];\n        }\n        else if (orient === 0) {\n            baseline = _baseline_lookup[side][orient];\n            align = _align_lookup[side][orient];\n        }\n        else if (orient < 0) {\n            baseline = 'middle';\n            align = _align_lookup_negative[side];\n        }\n        else if (orient > 0) {\n            baseline = 'middle';\n            align = _align_lookup_positive[side];\n        }\n        ctx.textBaseline = baseline;\n        ctx.textAlign = align;\n        return ctx;\n    };\n    SidePanel.prototype.get_label_angle_heuristic = function (orient) {\n        var side;\n        side = this.side;\n        return _angle_lookup[side][orient];\n    };\n    return SidePanel;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _constrainer, _weak_constrainer, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar kiwi_1 = require(\"kiwi\");\nexports.Variable = kiwi_1.Variable;\nexports.Expression = kiwi_1.Expression;\nexports.Constraint = kiwi_1.Constraint;\nexports.Operator = kiwi_1.Operator;\nexports.Strength = kiwi_1.Strength;\nvar events_1 = require(\"../events\");\n_constrainer = function (op) {\n    return (function (_this) {\n        return function () {\n            var expr;\n            expr = Object.create(kiwi_1.Expression.prototype);\n            kiwi_1.Expression.apply(expr, arguments);\n            return new kiwi_1.Constraint(expr, op);\n        };\n    })(this);\n};\n_weak_constrainer = function (op) {\n    return function () {\n        var arg, args, i, len;\n        args = [null];\n        for (i = 0, len = arguments.length; i < len; i++) {\n            arg = arguments[i];\n            args.push(arg);\n        }\n        return new kiwi_1.Constraint(new (Function.prototype.bind.apply(kiwi_1.Expression, args)), op, kiwi_1.Strength.weak);\n    };\n};\nexports.EQ = _constrainer(kiwi_1.Operator.Eq);\nexports.LE = _constrainer(kiwi_1.Operator.Le);\nexports.GE = _constrainer(kiwi_1.Operator.Ge);\nexports.WEAK_EQ = _weak_constrainer(kiwi_1.Operator.Eq);\nexports.WEAK_LE = _weak_constrainer(kiwi_1.Operator.Le);\nexports.WEAK_GE = _weak_constrainer(kiwi_1.Operator.Ge);\nexports.Solver = (function () {\n    extend(Solver.prototype, events_1.Events);\n    function Solver() {\n        this.solver = new kiwi_1.Solver();\n    }\n    Solver.prototype.clear = function () {\n        return this.solver = new kiwi_1.Solver();\n    };\n    Solver.prototype.toString = function () {\n        return \"Solver[num_constraints=\" + (this.num_constraints()) + \", num_edit_variables=\" + (this.num_edit_variables()) + \"]\";\n    };\n    Solver.prototype.num_constraints = function () {\n        return this.solver._cnMap._array.length;\n    };\n    Solver.prototype.num_edit_variables = function () {\n        return this.solver._editMap._array.length;\n    };\n    Solver.prototype.update_variables = function (trigger) {\n        if (trigger == null) {\n            trigger = true;\n        }\n        this.solver.updateVariables();\n        if (trigger) {\n            return this.trigger('layout_update');\n        }\n    };\n    Solver.prototype.add_constraint = function (constraint) {\n        return this.solver.addConstraint(constraint);\n    };\n    Solver.prototype.remove_constraint = function (constraint, silent) {\n        if (silent == null) {\n            silent = false;\n        }\n        return this.solver.removeConstraint(constraint, silent);\n    };\n    Solver.prototype.add_edit_variable = function (variable, strength) {\n        return this.solver.addEditVariable(variable, strength);\n    };\n    Solver.prototype.remove_edit_variable = function (variable, silent) {\n        if (silent == null) {\n            silent = false;\n        }\n        return this.solver.removeEditVariable(variable, strength, silent);\n    };\n    Solver.prototype.suggest_value = function (variable, value) {\n        return this.solver.suggestValue(variable, value);\n    };\n    return Solver;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LogLevel, _loggers, _method_factory, noop, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar types_1 = require(\"./util/types\");\nnoop = function () { };\n_method_factory = function (method_name, logger_name) {\n    if (console[method_name] != null) {\n        return console[method_name].bind(console, logger_name);\n    }\n    else if (console.log != null) {\n        return console.log.bind(console, logger_name);\n    }\n    else {\n        return noop;\n    }\n};\n_loggers = {};\nLogLevel = (function () {\n    function LogLevel(name, level) {\n        this.name = name;\n        this.level = level;\n    }\n    return LogLevel;\n})();\nexports.Logger = (function () {\n    Logger.TRACE = new LogLevel(\"trace\", 0);\n    Logger.DEBUG = new LogLevel(\"debug\", 1);\n    Logger.INFO = new LogLevel(\"info\", 2);\n    Logger.WARN = new LogLevel(\"warn\", 6);\n    Logger.ERROR = new LogLevel(\"error\", 7);\n    Logger.FATAL = new LogLevel(\"fatal\", 8);\n    Logger.OFF = new LogLevel(\"off\", 9);\n    Logger.log_levels = {\n        trace: Logger.TRACE,\n        debug: Logger.DEBUG,\n        info: Logger.INFO,\n        warn: Logger.WARN,\n        error: Logger.ERROR,\n        fatal: Logger.FATAL,\n        off: Logger.OFF\n    };\n    Object.defineProperty(Logger, 'levels', {\n        get: function () {\n            return Object.keys(Logger.log_levels);\n        }\n    });\n    Logger.get = function (name, level) {\n        var logger;\n        if (level == null) {\n            level = Logger.INFO;\n        }\n        if (types_1.isString(name) && name.length > 0) {\n            logger = _loggers[name];\n            if (logger == null) {\n                logger = _loggers[name] = new Logger(name, level);\n            }\n            return logger;\n        }\n        else {\n            throw new TypeError(\"Logger.get() expects a string name and an optional log-level\");\n        }\n    };\n    function Logger(name, level) {\n        if (level == null) {\n            level = Logger.INFO;\n        }\n        this._name = name;\n        this.set_level(level);\n    }\n    Object.defineProperty(Logger.prototype, 'level', {\n        get: function () {\n            return this.get_level();\n        }\n    });\n    Logger.prototype.get_level = function () {\n        return this._log_level;\n    };\n    Logger.prototype.set_level = function (log_level) {\n        var __, logger_name, method_name, ref, results;\n        if (log_level instanceof LogLevel) {\n            this._log_level = log_level;\n        }\n        else if (types_1.isString(log_level) && (Logger.log_levels[log_level] != null)) {\n            this._log_level = Logger.log_levels[log_level];\n        }\n        else {\n            throw new Error(\"Logger.set_level() expects a log-level object or a string name of a log-level\");\n        }\n        logger_name = \"[\" + this._name + \"]\";\n        ref = Logger.log_levels;\n        results = [];\n        for (__ in ref) {\n            log_level = ref[__];\n            if (log_level === Logger.OFF) {\n                break;\n            }\n            else {\n                method_name = log_level.name;\n                if (log_level.level < this._log_level.level) {\n                    results.push(this[method_name] = noop);\n                }\n                else {\n                    results.push(this[method_name] = _method_factory(method_name, logger_name));\n                }\n            }\n        }\n        return results;\n    };\n    return Logger;\n})();\nexports.logger = exports.Logger.get(\"bokeh\");\nexports.set_log_level = function (level) {\n    if (indexOf.call(exports.Logger.levels, level) < 0) {\n        console.log(\"[bokeh] unrecognized logging level '\" + level + \"' passed to Bokeh.set_log_level(), ignoring\");\n        return console.log(\"[bokeh] valid log levels are: \" + (exports.Logger.levels.join(', ')));\n    }\n    else {\n        console.log(\"[bokeh] setting log level to: '\" + level + \"'\");\n        return exports.logger.set_level(level);\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar events_1 = require(\"./events\");\nvar enums = require(\"./enums\");\nvar svg_colors = require(\"./util/svg_colors\");\nvar color_1 = require(\"./util/color\");\nvar array_1 = require(\"./util/array\");\nvar types_1 = require(\"./util/types\");\nexports.Property = (function () {\n    extend(Property.prototype, events_1.Events);\n    Property.prototype.dataspec = false;\n    function Property(arg) {\n        this.obj = arg.obj, this.attr = arg.attr, this.default_value = arg.default_value;\n        this._init(false);\n        this.listenTo(this.obj, \"change:\" + this.attr, (function (_this) {\n            return function () {\n                _this._init();\n                return _this.obj.trigger(\"propchange\");\n            };\n        })(this));\n    }\n    Property.prototype.update = function () {\n        return this._init();\n    };\n    Property.prototype.init = function () { };\n    Property.prototype.transform = function (values) {\n        return values;\n    };\n    Property.prototype.validate = function (value) { };\n    Property.prototype.value = function (do_spec_transform) {\n        var ret;\n        if (do_spec_transform == null) {\n            do_spec_transform = true;\n        }\n        if (this.spec.value === void 0) {\n            throw new Error(\"attempted to retrieve property value for property without value specification\");\n        }\n        ret = this.transform([this.spec.value])[0];\n        if ((this.spec.transform != null) && do_spec_transform) {\n            ret = this.spec.transform.compute(ret);\n        }\n        return ret;\n    };\n    Property.prototype.array = function (source) {\n        var data, i, length, ret, value;\n        if (!this.dataspec) {\n            throw new Error(\"attempted to retrieve property array for non-dataspec property\");\n        }\n        data = source.data;\n        if (this.spec.field != null) {\n            if (this.spec.field in data) {\n                ret = this.transform(source.get_column(this.spec.field));\n            }\n            else {\n                throw new Error(\"attempted to retrieve property array for nonexistent field '\" + this.spec.field + \"'\");\n            }\n        }\n        else {\n            length = source.get_length();\n            if (length == null) {\n                length = 1;\n            }\n            value = this.value(false);\n            ret = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(value);\n                }\n                return results;\n            })();\n        }\n        if (this.spec.transform != null) {\n            ret = this.spec.transform.v_compute(ret);\n        }\n        return ret;\n    };\n    Property.prototype._init = function (trigger) {\n        var attr, attr_value, default_value, obj;\n        if (trigger == null) {\n            trigger = true;\n        }\n        obj = this.obj;\n        if (obj == null) {\n            throw new Error(\"missing property object\");\n        }\n        if (obj.properties == null) {\n            throw new Error(\"property object must be a HasProps\");\n        }\n        attr = this.attr;\n        if (attr == null) {\n            throw new Error(\"missing property attr\");\n        }\n        attr_value = obj.getv(attr);\n        if (attr_value === void 0) {\n            default_value = this.default_value;\n            attr_value = (function () {\n                switch (false) {\n                    case default_value !== void 0:\n                        return null;\n                    case !types_1.isArray(default_value):\n                        return array_1.copy(default_value);\n                    case !types_1.isFunction(default_value):\n                        return default_value(obj);\n                    default:\n                        return default_value;\n                }\n            })();\n            obj.setv(attr, attr_value, {\n                silent: true,\n                defaults: true\n            });\n        }\n        if (types_1.isArray(attr_value)) {\n            this.spec = {\n                value: attr_value\n            };\n        }\n        else if (types_1.isObject(attr_value) && ((attr_value.value === void 0) !== (attr_value.field === void 0))) {\n            this.spec = attr_value;\n        }\n        else {\n            this.spec = {\n                value: attr_value\n            };\n        }\n        if ((this.spec.field != null) && !types_1.isString(this.spec.field)) {\n            throw new Error(\"field value for property '\" + attr + \"' is not a string\");\n        }\n        if (this.spec.value != null) {\n            this.validate(this.spec.value);\n        }\n        this.init();\n        if (trigger) {\n            return this.trigger(\"change\");\n        }\n    };\n    return Property;\n})();\nexports.simple_prop = function (name, pred) {\n    var Prop;\n    return Prop = (function (superClass) {\n        extend(Prop, superClass);\n        function Prop() {\n            return Prop.__super__.constructor.apply(this, arguments);\n        }\n        Prop.prototype.toString = function () {\n            return name + \"(obj: \" + this.obj.id + \", spec: \" + (JSON.stringify(this.spec)) + \")\";\n        };\n        Prop.prototype.validate = function (value) {\n            if (!pred(value)) {\n                throw new Error(name + \" property '\" + this.attr + \"' given invalid value: \" + (JSON.stringify(value)));\n            }\n        };\n        return Prop;\n    })(exports.Property);\n};\nexports.Any = (function (superClass) {\n    extend(Any, superClass);\n    function Any() {\n        return Any.__super__.constructor.apply(this, arguments);\n    }\n    return Any;\n})(exports.simple_prop(\"Any\", function (x) {\n    return true;\n}));\nexports.Array = (function (superClass) {\n    extend(Array, superClass);\n    function Array() {\n        return Array.__super__.constructor.apply(this, arguments);\n    }\n    return Array;\n})(exports.simple_prop(\"Array\", function (x) {\n    return types_1.isArray(x) || x instanceof Float64Array;\n}));\nexports.Bool = (function (superClass) {\n    extend(Bool, superClass);\n    function Bool() {\n        return Bool.__super__.constructor.apply(this, arguments);\n    }\n    return Bool;\n})(exports.simple_prop(\"Bool\", types_1.isBoolean));\nexports.Boolean = exports.Bool;\nexports.Color = (function (superClass) {\n    extend(Color, superClass);\n    function Color() {\n        return Color.__super__.constructor.apply(this, arguments);\n    }\n    return Color;\n})(exports.simple_prop(\"Color\", function (x) {\n    return (svg_colors[x.toLowerCase()] != null) || x.substring(0, 1) === \"#\" || color_1.valid_rgb(x);\n}));\nexports.Instance = (function (superClass) {\n    extend(Instance, superClass);\n    function Instance() {\n        return Instance.__super__.constructor.apply(this, arguments);\n    }\n    return Instance;\n})(exports.simple_prop(\"Instance\", function (x) {\n    return x.properties != null;\n}));\nexports.Number = (function (superClass) {\n    extend(Number, superClass);\n    function Number() {\n        return Number.__super__.constructor.apply(this, arguments);\n    }\n    return Number;\n})(exports.simple_prop(\"Number\", function (x) {\n    return types_1.isNumber(x) || types_1.isBoolean(x);\n}));\nexports.Int = exports.Number;\nexports.Percent = (function (superClass) {\n    extend(Percent, superClass);\n    function Percent() {\n        return Percent.__super__.constructor.apply(this, arguments);\n    }\n    return Percent;\n})(exports.simple_prop(\"Number\", function (x) {\n    return (types_1.isNumber(x) || types_1.isBoolean(x)) && ((0 <= x && x <= 1.0));\n}));\nexports.String = (function (superClass) {\n    extend(String, superClass);\n    function String() {\n        return String.__super__.constructor.apply(this, arguments);\n    }\n    return String;\n})(exports.simple_prop(\"String\", types_1.isString));\nexports.Font = (function (superClass) {\n    extend(Font, superClass);\n    function Font() {\n        return Font.__super__.constructor.apply(this, arguments);\n    }\n    return Font;\n})(exports.String);\nexports.enum_prop = function (name, enum_values) {\n    var Enum;\n    return Enum = (function (superClass) {\n        extend(Enum, superClass);\n        function Enum() {\n            return Enum.__super__.constructor.apply(this, arguments);\n        }\n        Enum.prototype.toString = function () {\n            return name + \"(obj: \" + this.obj.id + \", spec: \" + (JSON.stringify(this.spec)) + \")\";\n        };\n        return Enum;\n    })(exports.simple_prop(name, function (x) {\n        return indexOf.call(enum_values, x) >= 0;\n    }));\n};\nexports.Anchor = (function (superClass) {\n    extend(Anchor, superClass);\n    function Anchor() {\n        return Anchor.__super__.constructor.apply(this, arguments);\n    }\n    return Anchor;\n})(exports.enum_prop(\"Anchor\", enums.LegendLocation));\nexports.AngleUnits = (function (superClass) {\n    extend(AngleUnits, superClass);\n    function AngleUnits() {\n        return AngleUnits.__super__.constructor.apply(this, arguments);\n    }\n    return AngleUnits;\n})(exports.enum_prop(\"AngleUnits\", enums.AngleUnits));\nexports.Direction = (function (superClass) {\n    extend(Direction, superClass);\n    function Direction() {\n        return Direction.__super__.constructor.apply(this, arguments);\n    }\n    Direction.prototype.transform = function (values) {\n        var i, j, ref, result;\n        result = new Uint8Array(values.length);\n        for (i = j = 0, ref = values.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            switch (values[i]) {\n                case 'clock':\n                    result[i] = false;\n                    break;\n                case 'anticlock':\n                    result[i] = true;\n            }\n        }\n        return result;\n    };\n    return Direction;\n})(exports.enum_prop(\"Direction\", enums.Direction));\nexports.Dimension = (function (superClass) {\n    extend(Dimension, superClass);\n    function Dimension() {\n        return Dimension.__super__.constructor.apply(this, arguments);\n    }\n    return Dimension;\n})(exports.enum_prop(\"Dimension\", enums.Dimension));\nexports.Dimensions = (function (superClass) {\n    extend(Dimensions, superClass);\n    function Dimensions() {\n        return Dimensions.__super__.constructor.apply(this, arguments);\n    }\n    return Dimensions;\n})(exports.enum_prop(\"Dimensions\", enums.Dimensions));\nexports.FontStyle = (function (superClass) {\n    extend(FontStyle, superClass);\n    function FontStyle() {\n        return FontStyle.__super__.constructor.apply(this, arguments);\n    }\n    return FontStyle;\n})(exports.enum_prop(\"FontStyle\", enums.FontStyle));\nexports.LatLon = (function (superClass) {\n    extend(LatLon, superClass);\n    function LatLon() {\n        return LatLon.__super__.constructor.apply(this, arguments);\n    }\n    return LatLon;\n})(exports.enum_prop(\"LatLon\", enums.LatLon));\nexports.LineCap = (function (superClass) {\n    extend(LineCap, superClass);\n    function LineCap() {\n        return LineCap.__super__.constructor.apply(this, arguments);\n    }\n    return LineCap;\n})(exports.enum_prop(\"LineCap\", enums.LineCap));\nexports.LineJoin = (function (superClass) {\n    extend(LineJoin, superClass);\n    function LineJoin() {\n        return LineJoin.__super__.constructor.apply(this, arguments);\n    }\n    return LineJoin;\n})(exports.enum_prop(\"LineJoin\", enums.LineJoin));\nexports.LegendLocation = (function (superClass) {\n    extend(LegendLocation, superClass);\n    function LegendLocation() {\n        return LegendLocation.__super__.constructor.apply(this, arguments);\n    }\n    return LegendLocation;\n})(exports.enum_prop(\"LegendLocation\", enums.LegendLocation));\nexports.Location = (function (superClass) {\n    extend(Location, superClass);\n    function Location() {\n        return Location.__super__.constructor.apply(this, arguments);\n    }\n    return Location;\n})(exports.enum_prop(\"Location\", enums.Location));\nexports.Orientation = (function (superClass) {\n    extend(Orientation, superClass);\n    function Orientation() {\n        return Orientation.__super__.constructor.apply(this, arguments);\n    }\n    return Orientation;\n})(exports.enum_prop(\"Orientation\", enums.Orientation));\nexports.TextAlign = (function (superClass) {\n    extend(TextAlign, superClass);\n    function TextAlign() {\n        return TextAlign.__super__.constructor.apply(this, arguments);\n    }\n    return TextAlign;\n})(exports.enum_prop(\"TextAlign\", enums.TextAlign));\nexports.TextBaseline = (function (superClass) {\n    extend(TextBaseline, superClass);\n    function TextBaseline() {\n        return TextBaseline.__super__.constructor.apply(this, arguments);\n    }\n    return TextBaseline;\n})(exports.enum_prop(\"TextBaseline\", enums.TextBaseline));\nexports.RenderLevel = (function (superClass) {\n    extend(RenderLevel, superClass);\n    function RenderLevel() {\n        return RenderLevel.__super__.constructor.apply(this, arguments);\n    }\n    return RenderLevel;\n})(exports.enum_prop(\"RenderLevel\", enums.RenderLevel));\nexports.RenderMode = (function (superClass) {\n    extend(RenderMode, superClass);\n    function RenderMode() {\n        return RenderMode.__super__.constructor.apply(this, arguments);\n    }\n    return RenderMode;\n})(exports.enum_prop(\"RenderMode\", enums.RenderMode));\nexports.SizingMode = (function (superClass) {\n    extend(SizingMode, superClass);\n    function SizingMode() {\n        return SizingMode.__super__.constructor.apply(this, arguments);\n    }\n    return SizingMode;\n})(exports.enum_prop(\"SizingMode\", enums.SizingMode));\nexports.SpatialUnits = (function (superClass) {\n    extend(SpatialUnits, superClass);\n    function SpatialUnits() {\n        return SpatialUnits.__super__.constructor.apply(this, arguments);\n    }\n    return SpatialUnits;\n})(exports.enum_prop(\"SpatialUnits\", enums.SpatialUnits));\nexports.Distribution = (function (superClass) {\n    extend(Distribution, superClass);\n    function Distribution() {\n        return Distribution.__super__.constructor.apply(this, arguments);\n    }\n    return Distribution;\n})(exports.enum_prop(\"Distribution\", enums.DistributionTypes));\nexports.TransformStepMode = (function (superClass) {\n    extend(TransformStepMode, superClass);\n    function TransformStepMode() {\n        return TransformStepMode.__super__.constructor.apply(this, arguments);\n    }\n    return TransformStepMode;\n})(exports.enum_prop(\"TransformStepMode\", enums.TransformStepModes));\nexports.units_prop = function (name, valid_units, default_units) {\n    var UnitsProp;\n    return UnitsProp = (function (superClass) {\n        extend(UnitsProp, superClass);\n        function UnitsProp() {\n            return UnitsProp.__super__.constructor.apply(this, arguments);\n        }\n        UnitsProp.prototype.toString = function () {\n            return name + \"(obj: \" + this.obj.id + \", spec: \" + (JSON.stringify(this.spec)) + \")\";\n        };\n        UnitsProp.prototype.init = function () {\n            var units;\n            if (this.spec.units == null) {\n                this.spec.units = default_units;\n            }\n            this.units = this.spec.units;\n            units = this.spec.units;\n            if (indexOf.call(valid_units, units) < 0) {\n                throw new Error(name + \" units must be one of \" + valid_units + \", given invalid value: \" + units);\n            }\n        };\n        return UnitsProp;\n    })(exports.Number);\n};\nexports.Angle = (function (superClass) {\n    extend(Angle, superClass);\n    function Angle() {\n        return Angle.__super__.constructor.apply(this, arguments);\n    }\n    Angle.prototype.transform = function (values) {\n        var x;\n        if (this.spec.units === \"deg\") {\n            values = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = values.length; j < len; j++) {\n                    x = values[j];\n                    results.push(x * Math.PI / 180.0);\n                }\n                return results;\n            })();\n        }\n        values = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = values.length; j < len; j++) {\n                x = values[j];\n                results.push(-x);\n            }\n            return results;\n        })();\n        return Angle.__super__.transform.call(this, values);\n    };\n    return Angle;\n})(exports.units_prop(\"Angle\", enums.AngleUnits, \"rad\"));\nexports.Distance = (function (superClass) {\n    extend(Distance, superClass);\n    function Distance() {\n        return Distance.__super__.constructor.apply(this, arguments);\n    }\n    return Distance;\n})(exports.units_prop(\"Distance\", enums.SpatialUnits, \"data\"));\nexports.AngleSpec = (function (superClass) {\n    extend(AngleSpec, superClass);\n    function AngleSpec() {\n        return AngleSpec.__super__.constructor.apply(this, arguments);\n    }\n    AngleSpec.prototype.dataspec = true;\n    return AngleSpec;\n})(exports.Angle);\nexports.ColorSpec = (function (superClass) {\n    extend(ColorSpec, superClass);\n    function ColorSpec() {\n        return ColorSpec.__super__.constructor.apply(this, arguments);\n    }\n    ColorSpec.prototype.dataspec = true;\n    return ColorSpec;\n})(exports.Color);\nexports.DirectionSpec = (function (superClass) {\n    extend(DirectionSpec, superClass);\n    function DirectionSpec() {\n        return DirectionSpec.__super__.constructor.apply(this, arguments);\n    }\n    DirectionSpec.prototype.dataspec = true;\n    return DirectionSpec;\n})(exports.Distance);\nexports.DistanceSpec = (function (superClass) {\n    extend(DistanceSpec, superClass);\n    function DistanceSpec() {\n        return DistanceSpec.__super__.constructor.apply(this, arguments);\n    }\n    DistanceSpec.prototype.dataspec = true;\n    return DistanceSpec;\n})(exports.Distance);\nexports.FontSizeSpec = (function (superClass) {\n    extend(FontSizeSpec, superClass);\n    function FontSizeSpec() {\n        return FontSizeSpec.__super__.constructor.apply(this, arguments);\n    }\n    FontSizeSpec.prototype.dataspec = true;\n    return FontSizeSpec;\n})(exports.String);\nexports.NumberSpec = (function (superClass) {\n    extend(NumberSpec, superClass);\n    function NumberSpec() {\n        return NumberSpec.__super__.constructor.apply(this, arguments);\n    }\n    NumberSpec.prototype.dataspec = true;\n    return NumberSpec;\n})(exports.Number);\nexports.StringSpec = (function (superClass) {\n    extend(StringSpec, superClass);\n    function StringSpec() {\n        return StringSpec.__super__.constructor.apply(this, arguments);\n    }\n    StringSpec.prototype.dataspec = true;\n    return StringSpec;\n})(exports.String);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _fill_mixin, _gen_mixin, _line_mixin, _text_mixin;\nvar p = require(\"./properties\");\nvar object_1 = require(\"./util/object\");\n_gen_mixin = function (mixin, prefix) {\n    var name, result, type;\n    result = {};\n    if (prefix == null) {\n        prefix = \"\";\n    }\n    for (name in mixin) {\n        type = mixin[name];\n        result[prefix + name] = type;\n    }\n    return result;\n};\n_line_mixin = {\n    line_color: [p.ColorSpec, 'black'],\n    line_width: [p.NumberSpec, 1],\n    line_alpha: [p.NumberSpec, 1.0],\n    line_join: [p.LineJoin, 'miter'],\n    line_cap: [p.LineCap, 'butt'],\n    line_dash: [p.Array, []],\n    line_dash_offset: [p.Number, 0]\n};\nexports.line = function (prefix) {\n    return _gen_mixin(_line_mixin, prefix);\n};\n_fill_mixin = {\n    fill_color: [p.ColorSpec, 'gray'],\n    fill_alpha: [p.NumberSpec, 1.0]\n};\nexports.fill = function (prefix) {\n    return _gen_mixin(_fill_mixin, prefix);\n};\n_text_mixin = {\n    text_font: [p.Font, 'helvetica'],\n    text_font_size: [p.FontSizeSpec, '12pt'],\n    text_font_style: [p.FontStyle, 'normal'],\n    text_color: [p.ColorSpec, '#444444'],\n    text_alpha: [p.NumberSpec, 1.0],\n    text_align: [p.TextAlign, 'left'],\n    text_baseline: [p.TextBaseline, 'bottom']\n};\nexports.text = function (prefix) {\n    return _gen_mixin(_text_mixin, prefix);\n};\nexports.create = function (configs) {\n    var config, i, kind, len, prefix, ref, result;\n    result = {};\n    for (i = 0, len = configs.length; i < len; i++) {\n        config = configs[i];\n        ref = config.split(\":\"), kind = ref[0], prefix = ref[1];\n        if (this[kind] == null) {\n            throw new Error(\"Unknown property mixin kind '\" + kind + \"'\");\n        }\n        result = object_1.extend(result, this[kind](prefix));\n    }\n    return result;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./has_props\");\nvar logging_1 = require(\"./logging\");\nvar selector_1 = require(\"./selector\");\nvar hittest = require(\"./hittest\");\nvar p = require(\"./properties\");\nexports.SelectionManager = (function (superClass) {\n    extend(SelectionManager, superClass);\n    function SelectionManager() {\n        return SelectionManager.__super__.constructor.apply(this, arguments);\n    }\n    SelectionManager.prototype.type = 'SelectionManager';\n    SelectionManager.internal({\n        source: [p.Any]\n    });\n    SelectionManager.prototype.initialize = function (attrs, options) {\n        SelectionManager.__super__.initialize.call(this, attrs, options);\n        this.selectors = {};\n        this.inspectors = {};\n        return this.last_inspection_was_empty = {};\n    };\n    SelectionManager.prototype.select = function (tool, renderer_view, geometry, final, append) {\n        var indices, selector, source;\n        if (append == null) {\n            append = false;\n        }\n        source = this.source;\n        if (source !== renderer_view.model.data_source) {\n            logging_1.logger.warn('select called with mis-matched data sources');\n        }\n        indices = renderer_view.hit_test(geometry);\n        if (indices != null) {\n            selector = this._get_selector(renderer_view);\n            selector.update(indices, final, append);\n            this.source.selected = selector.indices;\n            source.trigger('select');\n            source.trigger('select-' + renderer_view.model.id);\n            return !indices.is_empty();\n        }\n        else {\n            return false;\n        }\n    };\n    SelectionManager.prototype.inspect = function (tool, renderer_view, geometry, data) {\n        var indices, inspector, r_id, source;\n        source = this.source;\n        if (source !== renderer_view.model.data_source) {\n            logging_1.logger.warn('inspect called with mis-matched data sources');\n        }\n        indices = renderer_view.hit_test(geometry);\n        if (indices != null) {\n            r_id = renderer_view.model.id;\n            if (indices.is_empty()) {\n                if (this.last_inspection_was_empty[r_id] == null) {\n                    this.last_inspection_was_empty[r_id] = false;\n                }\n                if (this.last_inspection_was_empty[r_id]) {\n                    return;\n                }\n                else {\n                    this.last_inspection_was_empty[r_id] = true;\n                }\n            }\n            else {\n                this.last_inspection_was_empty[r_id] = false;\n            }\n            inspector = this._get_inspector(renderer_view);\n            inspector.update(indices, true, false, true);\n            this.source.setv({\n                inspected: inspector.indices\n            }, {\n                \"silent\": true\n            });\n            source.trigger('inspect', indices, tool, renderer_view, source, data);\n            source.trigger(\"inspect\" + renderer_view.model.id, indices, tool, renderer_view, source, data);\n            return !indices.is_empty();\n        }\n        else {\n            return false;\n        }\n    };\n    SelectionManager.prototype.clear = function (rview) {\n        var k, ref, s, selector;\n        if (rview != null) {\n            selector = this._get_selector(rview);\n            selector.clear();\n        }\n        else {\n            ref = this.selectors;\n            for (k in ref) {\n                s = ref[k];\n                s.clear();\n            }\n        }\n        return this.source.selected = hittest.create_hit_test_result();\n    };\n    SelectionManager.prototype._get_selector_from = function (rview, selectors) {\n        var id;\n        id = rview.model.id;\n        if (selectors[id] != null) {\n            return selectors[id];\n        }\n        else {\n            return selectors[id] = new selector_1.Selector();\n        }\n    };\n    SelectionManager.prototype._get_selector = function (rview) {\n        return this._get_selector_from(rview, this.selectors);\n    };\n    SelectionManager.prototype._get_inspector = function (rview) {\n        return this._get_selector_from(rview, this.inspectors);\n    };\n    return SelectionManager;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar merge, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./has_props\");\nvar hittest = require(\"./hittest\");\nvar p = require(\"./properties\");\nvar array_1 = require(\"./util/array\");\nmerge = function (obj1, obj2) {\n    var arr1, arr2, i, key, keys, len, result;\n    result = {};\n    keys = array_1.concat(Object.keys(obj1), Object.keys(obj2));\n    for (i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        arr1 = obj1[key] || [];\n        arr2 = obj2[key] || [];\n        result[key] = array_1.union(arr1, arr2);\n    }\n    return result;\n};\nexports.Selector = (function (superClass) {\n    extend(Selector, superClass);\n    function Selector() {\n        return Selector.__super__.constructor.apply(this, arguments);\n    }\n    Selector.prototype.type = 'Selector';\n    Selector.prototype.update = function (indices, final, append, silent) {\n        if (silent == null) {\n            silent = false;\n        }\n        this.setv('timestamp', new Date(), {\n            silent: silent\n        });\n        this.setv('final', final, {\n            silent: silent\n        });\n        if (append) {\n            indices['0d'].indices = array_1.union(this.indices['0d'].indices, indices['0d'].indices);\n            indices['0d'].glyph = this.indices['0d'].glyph || indices['0d'].glyph;\n            indices['1d'].indices = array_1.union(this.indices['1d'].indices, indices['1d'].indices);\n            indices['2d'].indices = merge(this.indices['2d'].indices, indices['2d'].indices);\n        }\n        return this.setv('indices', indices, {\n            silent: silent\n        });\n    };\n    Selector.prototype.clear = function () {\n        this.timestamp = new Date();\n        this.final = true;\n        return this.indices = hittest.create_hit_test_result();\n    };\n    Selector.internal({\n        indices: [\n            p.Any, function () {\n                return hittest.create_hit_test_result();\n            }\n        ],\n        final: [p.Boolean],\n        timestamp: [p.Any]\n    });\n    return Selector;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar Hammer = require(\"hammerjs\");\nvar events_1 = require(\"./events\");\nvar logging_1 = require(\"./logging\");\nvar dom_1 = require(\"./dom\");\nvar wheel_1 = require(\"./util/wheel\");\nvar object_1 = require(\"./util/object\");\nvar bokeh_events_1 = require(\"./bokeh_events\");\nvar array_1 = require(\"./util/array\");\nexports.UIEvents = (function () {\n    extend1(UIEvents.prototype, events_1.Events);\n    function UIEvents(plot_view, toolbar, hit_area, plot) {\n        this.plot_view = plot_view;\n        this.toolbar = toolbar;\n        this.hit_area = hit_area;\n        this.plot = plot;\n        this._configure_hammerjs();\n    }\n    UIEvents.prototype._configure_hammerjs = function () {\n        this.hammer = new Hammer(this.hit_area);\n        this.hammer.get('doubletap').recognizeWith('tap');\n        this.hammer.get('tap').requireFailure('doubletap');\n        this.hammer.get('doubletap').dropRequireFailure('tap');\n        this.hammer.on('doubletap', (function (_this) {\n            return function (e) {\n                return _this._doubletap(e);\n            };\n        })(this));\n        this.hammer.on('tap', (function (_this) {\n            return function (e) {\n                return _this._tap(e);\n            };\n        })(this));\n        this.hammer.on('press', (function (_this) {\n            return function (e) {\n                return _this._press(e);\n            };\n        })(this));\n        this.hammer.get('pan').set({\n            direction: Hammer.DIRECTION_ALL\n        });\n        this.hammer.on('panstart', (function (_this) {\n            return function (e) {\n                return _this._pan_start(e);\n            };\n        })(this));\n        this.hammer.on('pan', (function (_this) {\n            return function (e) {\n                return _this._pan(e);\n            };\n        })(this));\n        this.hammer.on('panend', (function (_this) {\n            return function (e) {\n                return _this._pan_end(e);\n            };\n        })(this));\n        this.hammer.get('pinch').set({\n            enable: true\n        });\n        this.hammer.on('pinchstart', (function (_this) {\n            return function (e) {\n                return _this._pinch_start(e);\n            };\n        })(this));\n        this.hammer.on('pinch', (function (_this) {\n            return function (e) {\n                return _this._pinch(e);\n            };\n        })(this));\n        this.hammer.on('pinchend', (function (_this) {\n            return function (e) {\n                return _this._pinch_end(e);\n            };\n        })(this));\n        this.hammer.get('rotate').set({\n            enable: true\n        });\n        this.hammer.on('rotatestart', (function (_this) {\n            return function (e) {\n                return _this._rotate_start(e);\n            };\n        })(this));\n        this.hammer.on('rotate', (function (_this) {\n            return function (e) {\n                return _this._rotate(e);\n            };\n        })(this));\n        this.hammer.on('rotateend', (function (_this) {\n            return function (e) {\n                return _this._rotate_end(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mousemove\", (function (_this) {\n            return function (e) {\n                return _this._mouse_move(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mouseenter\", (function (_this) {\n            return function (e) {\n                return _this._mouse_enter(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"mouseleave\", (function (_this) {\n            return function (e) {\n                return _this._mouse_exit(e);\n            };\n        })(this));\n        this.hit_area.addEventListener(\"wheel\", (function (_this) {\n            return function (e) {\n                return _this._mouse_wheel(e);\n            };\n        })(this));\n        document.addEventListener(\"keydown\", (function (_this) {\n            return function (e) {\n                return _this._key_down(e);\n            };\n        })(this));\n        return document.addEventListener(\"keyup\", (function (_this) {\n            return function (e) {\n                return _this._key_up(e);\n            };\n        })(this));\n    };\n    UIEvents.prototype.register_tool = function (tool_view) {\n        var et, id, type;\n        et = tool_view.model.event_type;\n        id = tool_view.model.id;\n        type = tool_view.model.type;\n        if (et == null) {\n            logging_1.logger.debug(\"Button tool: \" + type);\n            return;\n        }\n        if (et === 'pan' || et === 'pinch' || et === 'rotate') {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event '\" + et + \"'\");\n            if (tool_view[\"_\" + et + \"_start\"] != null) {\n                tool_view.listenTo(this, et + \":start:\" + id, tool_view[\"_\" + et + \"_start\"]);\n            }\n            if (tool_view[\"_\" + et] != null) {\n                tool_view.listenTo(this, et + \":\" + id, tool_view[\"_\" + et]);\n            }\n            if (tool_view[\"_\" + et + \"_end\"] != null) {\n                tool_view.listenTo(this, et + \":end:\" + id, tool_view[\"_\" + et + \"_end\"]);\n            }\n        }\n        else if (et === \"move\") {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event '\" + et + \"'\");\n            if (tool_view._move_enter != null) {\n                tool_view.listenTo(this, \"move:enter\", tool_view._move_enter);\n            }\n            tool_view.listenTo(this, \"move\", tool_view[\"_move\"]);\n            if (tool_view._move_exit != null) {\n                tool_view.listenTo(this, \"move:exit\", tool_view._move_exit);\n            }\n        }\n        else {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event '\" + et + \"'\");\n            tool_view.listenTo(this, et + \":\" + id, tool_view[\"_\" + et]);\n        }\n        if (tool_view._keydown != null) {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event 'keydown'\");\n            tool_view.listenTo(this, \"keydown\", tool_view._keydown);\n        }\n        if (tool_view._keyup != null) {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event 'keyup'\");\n            tool_view.listenTo(this, \"keyup\", tool_view._keyup);\n        }\n        if (tool_view._doubletap != null) {\n            logging_1.logger.debug(\"Registering tool: \" + type + \" for event 'doubletap'\");\n            tool_view.listenTo(this, \"doubletap\", tool_view._doubletap);\n        }\n        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {\n            if (et === 'pinch') {\n                logging_1.logger.debug(\"Registering scroll on touch screen\");\n                return tool_view.listenTo(this, \"scroll:\" + id, tool_view[\"_scroll\"]);\n            }\n        }\n    };\n    UIEvents.prototype._hit_test_renderers = function (sx, sy) {\n        var i, ref, ref1, view;\n        ref = this.plot_view.get_renderer_views();\n        for (i = ref.length - 1; i >= 0; i += -1) {\n            view = ref[i];\n            if (((ref1 = view.model.level) === 'annotation' || ref1 === 'overlay') && (view.bbox != null)) {\n                if (view.bbox().contains(sx, sy)) {\n                    return view;\n                }\n            }\n        }\n        return null;\n    };\n    UIEvents.prototype._hit_test_frame = function (sx, sy) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(sx);\n        vy = canvas.sy_to_vy(sy);\n        return this.plot_view.frame.contains(vx, vy);\n    };\n    UIEvents.prototype._trigger = function (event_type, e) {\n        var active_gesture, base, base_type, cursor, has_active_inspectors, view;\n        base_type = event_type.split(\":\")[0];\n        view = this._hit_test_renderers(e.bokeh.sx, e.bokeh.sy);\n        switch (base_type) {\n            case \"move\":\n                has_active_inspectors = array_1.any(this.toolbar.inspectors, function (t) {\n                    return t.active;\n                });\n                cursor = \"default\";\n                if (view != null) {\n                    if (view.model.cursor != null) {\n                        cursor = view.model.cursor();\n                    }\n                    if (has_active_inspectors) {\n                        event_type = \"move:exit\";\n                    }\n                }\n                else if (this._hit_test_frame(e.bokeh.sx, e.bokeh.sy)) {\n                    if (has_active_inspectors) {\n                        cursor = \"crosshair\";\n                    }\n                }\n                this.plot_view.set_cursor(cursor);\n                return this.trigger(event_type, e);\n            case \"tap\":\n                if (view != null) {\n                    if (typeof view.on_hit === \"function\") {\n                        view.on_hit(e.bokeh.sx, e.bokeh.sy);\n                    }\n                }\n                active_gesture = this.toolbar.gestures[base_type].active;\n                if (active_gesture != null) {\n                    return this.trigger(event_type + \":\" + active_gesture.id, e);\n                }\n                break;\n            case \"scroll\":\n                base = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? \"pinch\" : \"scroll\";\n                active_gesture = this.toolbar.gestures[base].active;\n                if (active_gesture != null) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return this.trigger(event_type + \":\" + active_gesture.id, e);\n                }\n                break;\n            default:\n                active_gesture = this.toolbar.gestures[base_type].active;\n                if (active_gesture != null) {\n                    return this.trigger(event_type + \":\" + active_gesture.id, e);\n                }\n        }\n    };\n    UIEvents.prototype._bokify_hammer = function (e, extras) {\n        var event_cls, left, ref, top, x, y;\n        if (extras == null) {\n            extras = {};\n        }\n        if (e.pointerType === 'mouse') {\n            x = e.srcEvent.pageX;\n            y = e.srcEvent.pageY;\n        }\n        else {\n            x = e.pointers[0].pageX;\n            y = e.pointers[0].pageY;\n        }\n        ref = dom_1.offset(e.target), left = ref.left, top = ref.top;\n        e.bokeh = {\n            sx: x - left,\n            sy: y - top\n        };\n        e.bokeh = object_1.extend(e.bokeh, extras);\n        event_cls = bokeh_events_1.BokehEvent.event_class(e);\n        if (event_cls != null) {\n            return this.plot.trigger_event(event_cls.from_event(e));\n        }\n        else {\n            return logging_1.logger.debug('Unhandled event of type ' + e.type);\n        }\n    };\n    UIEvents.prototype._bokify_point_event = function (e, extras) {\n        var event_cls, left, ref, top;\n        if (extras == null) {\n            extras = {};\n        }\n        ref = dom_1.offset(e.currentTarget), left = ref.left, top = ref.top;\n        e.bokeh = {\n            sx: e.pageX - left,\n            sy: e.pageY - top\n        };\n        e.bokeh = object_1.extend(e.bokeh, extras);\n        event_cls = bokeh_events_1.BokehEvent.event_class(e);\n        if (event_cls != null) {\n            return this.plot.trigger_event(event_cls.from_event(e));\n        }\n        else {\n            return logging_1.logger.debug('Unhandled event of type ' + e.type);\n        }\n    };\n    UIEvents.prototype._tap = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('tap', e);\n    };\n    UIEvents.prototype._doubletap = function (e) {\n        this._bokify_hammer(e);\n        return this.trigger('doubletap', e);\n    };\n    UIEvents.prototype._press = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('press', e);\n    };\n    UIEvents.prototype._pan_start = function (e) {\n        this._bokify_hammer(e);\n        e.bokeh.sx -= e.deltaX;\n        e.bokeh.sy -= e.deltaY;\n        return this._trigger('pan:start', e);\n    };\n    UIEvents.prototype._pan = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('pan', e);\n    };\n    UIEvents.prototype._pan_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('pan:end', e);\n    };\n    UIEvents.prototype._pinch_start = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('pinch:start', e);\n    };\n    UIEvents.prototype._pinch = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('pinch', e);\n    };\n    UIEvents.prototype._pinch_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('pinch:end', e);\n    };\n    UIEvents.prototype._rotate_start = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('rotate:start', e);\n    };\n    UIEvents.prototype._rotate = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('rotate', e);\n    };\n    UIEvents.prototype._rotate_end = function (e) {\n        this._bokify_hammer(e);\n        return this._trigger('rotate:end', e);\n    };\n    UIEvents.prototype._mouse_enter = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger('move:enter', e);\n    };\n    UIEvents.prototype._mouse_move = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger('move', e);\n    };\n    UIEvents.prototype._mouse_exit = function (e) {\n        this._bokify_point_event(e);\n        return this._trigger('move:exit', e);\n    };\n    UIEvents.prototype._mouse_wheel = function (e) {\n        this._bokify_point_event(e, {\n            delta: wheel_1.getDeltaY(e)\n        });\n        return this._trigger('scroll', e);\n    };\n    UIEvents.prototype._key_down = function (e) {\n        return this.trigger('keydown', e);\n    };\n    UIEvents.prototype._key_up = function (e) {\n        return this.trigger('keyup', e);\n    };\n    return UIEvents;\n})();\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar slice = Array.prototype.slice;\nfunction copy(array /*| TypedArray*/) {\n    return slice.call(array);\n}\nexports.copy = copy;\nfunction concat(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.concat = concat;\nfunction contains(array, value) {\n    return array.indexOf(value) >= 0;\n}\nexports.contains = contains;\nfunction nth(array, index) {\n    return array[index >= 0 ? index : array.length + index];\n}\nexports.nth = nth;\nfunction zip(As, Bs) {\n    var n = Math.min(As.length, Bs.length);\n    var ABs = new Array(n);\n    for (var i = 0; i < n; i++) {\n        ABs[i] = [As[i], Bs[i]];\n    }\n    return ABs;\n}\nexports.zip = zip;\nfunction unzip(ABs) {\n    var n = ABs.length;\n    var As = new Array(n);\n    var Bs = new Array(n);\n    for (var i = 0; i < n; i++) {\n        _a = ABs[i], As[i] = _a[0], Bs[i] = _a[1];\n    }\n    return [As, Bs];\n    var _a;\n}\nexports.unzip = unzip;\nfunction range(start, stop, step) {\n    if (step === void 0) { step = 1; }\n    if (stop == null) {\n        stop = start;\n        start = 0;\n    }\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n    for (var i = 0; i < length; i++, start += step) {\n        range[i] = start;\n    }\n    return range;\n}\nexports.range = range;\nfunction linspace(start, stop, num) {\n    if (num === void 0) { num = 100; }\n    var step = (stop - start) / (num - 1);\n    var array = new Array(num);\n    for (var i = 0; i < num; i++) {\n        array[i] = start + step * i;\n    }\n    return array;\n}\nexports.linspace = linspace;\nfunction transpose(array) {\n    var rows = array.length;\n    var cols = array[0].length;\n    var transposed = [];\n    for (var j = 0; j < cols; j++) {\n        transposed[j] = [];\n        for (var i = 0; i < rows; i++) {\n            transposed[j][i] = array[i][j];\n        }\n    }\n    return transposed;\n}\nexports.transpose = transpose;\nfunction sum(array) {\n    return array.reduce(function (a, b) { return a + b; }, 0);\n}\nexports.sum = sum;\nfunction cumsum(array) {\n    var result = [];\n    array.reduce(function (a, b, i) { return result[i] = a + b; }, 0);\n    return result;\n}\nexports.cumsum = cumsum;\nfunction min(array) {\n    var value;\n    var result = Infinity;\n    for (var i = 0, length_1 = array.length; i < length_1; i++) {\n        value = array[i];\n        if (value < result) {\n            result = value;\n        }\n    }\n    return result;\n}\nexports.min = min;\nfunction minBy(array, key) {\n    var value;\n    var result;\n    var computed;\n    var resultComputed = Infinity;\n    for (var i = 0, length_2 = array.length; i < length_2; i++) {\n        value = array[i];\n        computed = key(value);\n        if (computed < resultComputed) {\n            result = value;\n            resultComputed = computed;\n        }\n    }\n    return result;\n}\nexports.minBy = minBy;\nfunction max(array) {\n    var value;\n    var result = -Infinity;\n    for (var i = 0, length_3 = array.length; i < length_3; i++) {\n        value = array[i];\n        if (value > result) {\n            result = value;\n        }\n    }\n    return result;\n}\nexports.max = max;\nfunction maxBy(array, key) {\n    var value;\n    var result;\n    var computed;\n    var resultComputed = -Infinity;\n    for (var i = 0, length_4 = array.length; i < length_4; i++) {\n        value = array[i];\n        computed = key(value);\n        if (computed > resultComputed) {\n            result = value;\n            resultComputed = computed;\n        }\n    }\n    return result;\n}\nexports.maxBy = maxBy;\nfunction argmin(array) {\n    return minBy(range(array.length), function (i) { return array[i]; });\n}\nexports.argmin = argmin;\nfunction argmax(array) {\n    return maxBy(range(array.length), function (i) { return array[i]; });\n}\nexports.argmax = argmax;\nfunction all(array, predicate) {\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n        var item = array_1[_i];\n        if (!predicate(item))\n            return false;\n    }\n    return true;\n}\nexports.all = all;\nfunction any(array, predicate) {\n    for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {\n        var item = array_2[_i];\n        if (predicate(item))\n            return true;\n    }\n    return false;\n}\nexports.any = any;\nfunction findIndexFactory(dir) {\n    return function (array, predicate) {\n        var length = array.length;\n        var index = dir > 0 ? 0 : length - 1;\n        for (; index >= 0 && index < length; index += dir) {\n            if (predicate(array[index]))\n                return index;\n        }\n        return -1;\n    };\n}\nexports.findIndex = findIndexFactory(1);\nexports.findLastIndex = findIndexFactory(-1);\nfunction sortedIndex(array, value) {\n    var low = 0;\n    var high = array.length;\n    while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (array[mid] < value)\n            low = mid + 1;\n        else\n            high = mid;\n    }\n    return low;\n}\nexports.sortedIndex = sortedIndex;\nfunction sortBy(array, key) {\n    var tmp = array.map(function (value, index) {\n        return { value: value, index: index, key: key(value) };\n    });\n    tmp.sort(function (left, right) {\n        var a = left.key;\n        var b = right.key;\n        if (a !== b) {\n            if (a > b || a === undefined)\n                return 1;\n            if (a < b || b === undefined)\n                return -1;\n        }\n        return left.index - right.index;\n    });\n    return tmp.map(function (item) { return item.value; });\n}\nexports.sortBy = sortBy;\nfunction uniq(array) {\n    var result = [];\n    for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {\n        var value = array_3[_i];\n        if (!contains(result, value)) {\n            result.push(value);\n        }\n    }\n    return result;\n}\nexports.uniq = uniq;\nfunction uniqBy(array, key) {\n    var result = [];\n    var seen = [];\n    for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {\n        var value = array_4[_i];\n        var computed = key(value);\n        if (!contains(seen, computed)) {\n            seen.push(computed);\n            result.push(value);\n        }\n    }\n    return result;\n}\nexports.uniqBy = uniqBy;\nfunction union() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    return uniq(concat(arrays));\n}\nexports.union = union;\nfunction intersection(array) {\n    var arrays = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        arrays[_i - 1] = arguments[_i];\n    }\n    var result = [];\n    top: for (var _a = 0, array_5 = array; _a < array_5.length; _a++) {\n        var item = array_5[_a];\n        if (contains(result, item))\n            continue;\n        for (var _b = 0, arrays_1 = arrays; _b < arrays_1.length; _b++) {\n            var other = arrays_1[_b];\n            if (!contains(other, item))\n                continue top;\n        }\n        result.push(item);\n    }\n    return result;\n}\nexports.intersection = intersection;\nfunction difference(array) {\n    var arrays = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        arrays[_i - 1] = arguments[_i];\n    }\n    var rest = concat(arrays);\n    return array.filter(function (value) { return !contains(rest, value); });\n}\nexports.difference = difference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction empty() {\n    return {\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity,\n    };\n}\nexports.empty = empty;\nfunction positive_x() {\n    return {\n        minX: Number.MIN_VALUE,\n        minY: -Infinity,\n        maxX: Infinity,\n        maxY: Infinity,\n    };\n}\nexports.positive_x = positive_x;\nfunction positive_y() {\n    return {\n        minX: -Infinity,\n        minY: Number.MIN_VALUE,\n        maxX: Infinity,\n        maxY: Infinity,\n    };\n}\nexports.positive_y = positive_y;\nfunction union(a, b) {\n    return {\n        minX: Math.min(a.minX, b.minX),\n        maxX: Math.max(a.maxX, b.maxX),\n        minY: Math.min(a.minY, b.minY),\n        maxY: Math.max(a.maxY, b.maxY),\n    };\n}\nexports.union = union;\nvar BBox = (function () {\n    function BBox(bbox) {\n        if (bbox == null) {\n            this.x0 = Infinity;\n            this.y0 = -Infinity;\n            this.x1 = Infinity;\n            this.y1 = -Infinity;\n        }\n        else {\n            this.x0 = bbox.x0;\n            this.y0 = bbox.y0;\n            this.x1 = bbox.x1;\n            this.y1 = bbox.y1;\n        }\n    }\n    Object.defineProperty(BBox.prototype, \"minX\", {\n        get: function () { return this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"minY\", {\n        get: function () { return this.y0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"maxX\", {\n        get: function () { return this.x1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"maxY\", {\n        get: function () { return this.y1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"pt0\", {\n        get: function () { return [this.x0, this.y0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"pt1\", {\n        get: function () { return [this.x1, this.y1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"x\", {\n        get: function () { return this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"y\", {\n        get: function () { return this.x1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"width\", {\n        get: function () { return this.x1 - this.x0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BBox.prototype, \"height\", {\n        get: function () { return this.y1 - this.y0; },\n        enumerable: true,\n        configurable: true\n    });\n    BBox.prototype.contains = function (x, y) {\n        return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;\n    };\n    BBox.prototype.union = function (that) {\n        return new BBox({\n            x0: Math.min(this.x0, that.x0),\n            y0: Math.min(this.y0, that.y0),\n            x1: Math.max(this.x1, that.x1),\n            y1: Math.max(this.y1, that.y1),\n        });\n    };\n    return BBox;\n}());\nexports.BBox = BBox;\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction delay(func, wait) {\n    return setTimeout(func, wait);\n}\nexports.delay = delay;\nfunction defer(func) {\n    return delay(func, 1);\n}\nexports.defer = defer;\nfunction throttle(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options)\n        options = {};\n    var later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout)\n            context = args = null;\n    };\n    return function () {\n        var now = Date.now();\n        if (!previous && options.leading === false)\n            previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout)\n                context = args = null;\n        }\n        else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\nexports.throttle = throttle;\nfunction once(func) {\n    var done = false;\n    var memo;\n    return function () {\n        if (!done) {\n            done = true;\n            memo = func();\n        }\n        return memo;\n    };\n}\nexports.once = once;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fixup_line_dash = function (ctx) {\n    if (!ctx.setLineDash) {\n        ctx.setLineDash = function (dash) {\n            ctx.mozDash = dash;\n            return ctx.webkitLineDash = dash;\n        };\n    }\n    if (!ctx.getLineDash) {\n        return ctx.getLineDash = function () {\n            return ctx.mozDash;\n        };\n    }\n};\nexports.fixup_line_dash_offset = function (ctx) {\n    ctx.setLineDashOffset = function (dash_offset) {\n        ctx.lineDashOffset = dash_offset;\n        ctx.mozDashOffset = dash_offset;\n        return ctx.webkitLineDashOffset = dash_offset;\n    };\n    return ctx.getLineDashOffset = function () {\n        return ctx.mozDashOffset;\n    };\n};\nexports.fixup_image_smoothing = function (ctx) {\n    ctx.setImageSmoothingEnabled = function (value) {\n        ctx.imageSmoothingEnabled = value;\n        ctx.mozImageSmoothingEnabled = value;\n        ctx.oImageSmoothingEnabled = value;\n        return ctx.webkitImageSmoothingEnabled = value;\n    };\n    return ctx.getImageSmoothingEnabled = function () {\n        var ref;\n        return (ref = ctx.imageSmoothingEnabled) != null ? ref : true;\n    };\n};\nexports.fixup_measure_text = function (ctx) {\n    if (ctx.measureText && (ctx.html5MeasureText == null)) {\n        ctx.html5MeasureText = ctx.measureText;\n        return ctx.measureText = function (text) {\n            var textMetrics;\n            textMetrics = ctx.html5MeasureText(text);\n            textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\n            return textMetrics;\n        };\n    }\n};\nexports.get_scale_ratio = function (ctx, hidpi) {\n    var backingStoreRatio, devicePixelRatio;\n    if (hidpi) {\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n        return devicePixelRatio / backingStoreRatio;\n    }\n    else {\n        return 1;\n    }\n};\nexports.fixup_ellipse = function (ctx) {\n    var ellipse_bezier;\n    ellipse_bezier = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n        var c, rx, ry;\n        if (anticlockwise == null) {\n            anticlockwise = false;\n        }\n        c = 0.551784;\n        ctx.translate(x, y);\n        ctx.rotate(rotation);\n        rx = radiusX;\n        ry = radiusY;\n        if (anticlockwise) {\n            rx = -radiusX;\n            ry = -radiusY;\n        }\n        ctx.moveTo(-rx, 0);\n        ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\n        ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\n        ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\n        ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\n        ctx.rotate(-rotation);\n        ctx.translate(-x, -y);\n    };\n    if (!ctx.ellipse) {\n        return ctx.ellipse = ellipse_bezier;\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _component2hex, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar svg_colors = require(\"./svg_colors\");\n_component2hex = function (v) {\n    var h;\n    h = Number(v).toString(16);\n    return h = h.length === 1 ? '0' + h : h;\n};\nexports.color2hex = function (color) {\n    var hex, rgb, v;\n    color = color + '';\n    if (color.indexOf('#') === 0) {\n        return color;\n    }\n    else if (svg_colors[color] != null) {\n        return svg_colors[color];\n    }\n    else if (color.indexOf('rgb') === 0) {\n        rgb = color.match(/\\d+/g);\n        hex = ((function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = rgb.length; j < len; j++) {\n                v = rgb[j];\n                results.push(_component2hex(v));\n            }\n            return results;\n        })()).join('');\n        return '#' + hex.slice(0, 8);\n    }\n    else {\n        return color;\n    }\n};\nexports.color2rgba = function (color, alpha) {\n    var hex, i, rgba;\n    if (alpha == null) {\n        alpha = 1;\n    }\n    if (!color) {\n        return [0, 0, 0, 0];\n    }\n    hex = exports.color2hex(color);\n    hex = hex.replace(/ |#/g, '');\n    if (hex.length <= 4) {\n        hex = hex.replace(/(.)/g, '$1$1');\n    }\n    hex = hex.match(/../g);\n    rgba = (function () {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = hex.length; j < len; j++) {\n            i = hex[j];\n            results.push(parseInt(i, 16) / 255);\n        }\n        return results;\n    })();\n    while (rgba.length < 3) {\n        rgba.push(0);\n    }\n    if (rgba.length < 4) {\n        rgba.push(alpha);\n    }\n    return rgba.slice(0, 4);\n};\nexports.valid_rgb = function (value) {\n    var contents, params, ref, rgb;\n    switch (value.substring(0, 4)) {\n        case \"rgba\":\n            params = {\n                start: \"rgba(\",\n                len: 4,\n                alpha: true\n            };\n            break;\n        case \"rgb(\":\n            params = {\n                start: \"rgb(\",\n                len: 3,\n                alpha: false\n            };\n            break;\n        default:\n            return false;\n    }\n    if (new RegExp(\".*?(\\\\.).*(,)\").test(value)) {\n        throw new Error(\"color expects integers for rgb in rgb/rgba tuple, received \" + value);\n    }\n    contents = value.replace(params.start, \"\").replace(\")\", \"\").split(',').map(parseFloat);\n    if (contents.length !== params.len) {\n        throw new Error(\"color expects rgba \" + expect_len + \"-tuple, received \" + value);\n    }\n    if (params.alpha && !((0 <= (ref = contents[3]) && ref <= 1))) {\n        throw new Error(\"color expects rgba 4-tuple to have alpha value between 0 and 1\");\n    }\n    if (indexOf.call((function () {\n        var j, len, ref1, results;\n        ref1 = contents.slice(0, 3);\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            rgb = ref1[j];\n            results.push((0 <= rgb && rgb <= 255));\n        }\n        return results;\n    })(), false) >= 0) {\n        throw new Error(\"color expects rgb to have value between 0 and 255\");\n    }\n    return true;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_1 = require(\"./array\");\nvar eq_1 = require(\"./eq\");\nvar types_1 = require(\"./types\");\nexports.MultiDict = (function () {\n    function MultiDict() {\n        this._dict = {};\n    }\n    MultiDict.prototype._existing = function (key) {\n        if (key in this._dict) {\n            return this._dict[key];\n        }\n        else {\n            return null;\n        }\n    };\n    MultiDict.prototype.add_value = function (key, value) {\n        var existing;\n        if (value === null) {\n            throw new Error(\"Can't put null in this dict\");\n        }\n        if (types_1.isArray(value)) {\n            throw new Error(\"Can't put arrays in this dict\");\n        }\n        existing = this._existing(key);\n        if (existing === null) {\n            return this._dict[key] = value;\n        }\n        else if (types_1.isArray(existing)) {\n            return existing.push(value);\n        }\n        else {\n            return this._dict[key] = [existing, value];\n        }\n    };\n    MultiDict.prototype.remove_value = function (key, value) {\n        var existing, new_array;\n        existing = this._existing(key);\n        if (types_1.isArray(existing)) {\n            new_array = array_1.difference(existing, [value]);\n            if (new_array.length > 0) {\n                return this._dict[key] = new_array;\n            }\n            else {\n                return delete this._dict[key];\n            }\n        }\n        else if (eq_1.isEqual(existing, value)) {\n            return delete this._dict[key];\n        }\n    };\n    MultiDict.prototype.get_one = function (key, duplicate_error) {\n        var existing;\n        existing = this._existing(key);\n        if (types_1.isArray(existing)) {\n            if (existing.length === 1) {\n                return existing[0];\n            }\n            else {\n                throw new Error(duplicate_error);\n            }\n        }\n        else {\n            return existing;\n        }\n    };\n    return MultiDict;\n})();\nexports.Set = (function () {\n    function Set(array) {\n        if (!array) {\n            this.values = [];\n        }\n        else {\n            if (array.constructor === Set) {\n                return new Set(array.values);\n            }\n            if (array.constructor === Array) {\n                this.values = Set.compact(array);\n            }\n            else {\n                this.values = [array];\n            }\n        }\n    }\n    Set.compact = function (array) {\n        var item, j, len, newArray;\n        newArray = [];\n        for (j = 0, len = array.length; j < len; j++) {\n            item = array[j];\n            if (newArray.indexOf(item) === -1) {\n                newArray.push(item);\n            }\n        }\n        return newArray;\n    };\n    Set.prototype.push = function (item) {\n        if (this.missing(item)) {\n            return this.values.push(item);\n        }\n    };\n    Set.prototype.remove = function (item) {\n        var i;\n        i = this.values.indexOf(item);\n        return this.values = this.values.slice(0, i).concat(this.values.slice(i + 1));\n    };\n    Set.prototype.length = function () {\n        return this.values.length;\n    };\n    Set.prototype.includes = function (item) {\n        return this.values.indexOf(item) !== -1;\n    };\n    Set.prototype.missing = function (item) {\n        return !this.includes(item);\n    };\n    Set.prototype.slice = function (from, to) {\n        return this.values.slice(from, to);\n    };\n    Set.prototype.join = function (str) {\n        return this.values.join(str);\n    };\n    Set.prototype.toString = function () {\n        return this.join(', ');\n    };\n    Set.prototype.includes = function (item) {\n        return this.values.indexOf(item) !== -1;\n    };\n    Set.prototype.union = function (set) {\n        set = new Set(set);\n        return new Set(this.values.concat(set.values));\n    };\n    Set.prototype.intersect = function (set) {\n        var item, j, len, newSet, ref;\n        set = new Set(set);\n        newSet = new Set;\n        ref = set.values;\n        for (j = 0, len = ref.length; j < len; j++) {\n            item = ref[j];\n            if (this.includes(item) && set.includes(item)) {\n                newSet.push(item);\n            }\n        }\n        return newSet;\n    };\n    Set.prototype.diff = function (set) {\n        var item, j, len, newSet, ref;\n        set = new Set(set);\n        newSet = new Set;\n        ref = this.values;\n        for (j = 0, len = ref.length; j < len; j++) {\n            item = ref[j];\n            if (set.missing(item)) {\n                newSet.push(item);\n            }\n        }\n        return newSet;\n    };\n    return Set;\n})();\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./types\");\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b)\n        return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null)\n        return a === b;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b))\n        return false;\n    switch (className) {\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case '[object String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return '' + a === '' + b;\n        case '[object Number]':\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN\n            if (+a !== +a)\n                return +b !== +b;\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case '[object Date]':\n        case '[object Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n    }\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n        if (typeof a != 'object' || typeof b != 'object')\n            return false;\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(types_1.isFunction(aCtor) && aCtor instanceof aCtor &&\n            types_1.isFunction(bCtor) && bCtor instanceof bCtor)\n            && ('constructor' in a && 'constructor' in b)) {\n            return false;\n        }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a)\n            return bStack[length] === b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length)\n            return false;\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (length--) {\n            if (!eq(a[length], b[length], aStack, bStack))\n                return false;\n        }\n    }\n    else {\n        // Deep compare objects.\n        var keys = Object.keys(a);\n        var key = void 0;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== length)\n            return false;\n        while (length--) {\n            // Deep compare each member\n            key = keys[length];\n            if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))\n                return false;\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\n// Perform a deep comparison to check if two objects are equal.\nfunction isEqual(a, b) {\n    return eq(a, b);\n}\nexports.isEqual = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction angle_norm(angle) {\n    while (angle < 0) {\n        angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n    }\n    return angle;\n}\nexports.angle_norm = angle_norm;\nfunction angle_dist(lhs, rhs) {\n    return Math.abs(angle_norm(lhs - rhs));\n}\nexports.angle_dist = angle_dist;\nfunction angle_between(mid, lhs, rhs, direction) {\n    var norm_mid = angle_norm(mid);\n    var d = angle_dist(lhs, rhs);\n    var cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\n    if (direction == \"anticlock\")\n        return cond;\n    else\n        return !cond;\n}\nexports.angle_between = angle_between;\nfunction random() {\n    return Math.random();\n}\nexports.random = random;\nfunction atan2(start, end) {\n    /*\n     * Calculate the angle between a line containing start and end points (composed\n     * of [x, y] arrays) and the positive x-axis.\n     */\n    return Math.atan2(end[1] - start[1], end[0] - start[0]);\n}\nexports.atan2 = atan2;\n// http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\nfunction rnorm(mu, sigma) {\n    // Generate a random normal with a mean of 0 and a sigma of 1\n    var r1;\n    var r2;\n    while (true) {\n        r1 = random();\n        r2 = random();\n        r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\n        if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)\n            break;\n    }\n    var rn = r2 / r1;\n    // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n    rn = mu + sigma * rn;\n    return rn;\n}\nexports.rnorm = rnorm;\nfunction clamp(val, min, max) {\n    if (val > max)\n        return max;\n    if (val < min)\n        return min;\n    return val;\n}\nexports.clamp = clamp;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.keys = Object.keys;\nfunction values(object) {\n    var keys = Object.keys(object);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n        values[i] = object[keys[i]];\n    }\n    return values;\n}\nexports.values = values;\nfunction extend(dest) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                dest[key] = source[key];\n            }\n        }\n    }\n    return dest;\n}\nexports.extend = extend;\nfunction clone(obj) {\n    return extend({}, obj);\n}\nexports.clone = clone;\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\nexports.isEmpty = isEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4 = require(\"proj4/lib/core\");\nexports.proj4 = proj4;\nvar Proj = require(\"proj4/lib/Proj\");\nvar toPoint = require(\"proj4/lib/common/toPoint\");\nvar defs = require(\"proj4/lib/defs\");\nvar transform = require(\"proj4/lib/transform\");\nproj4.defaultDatum = 'WGS84';\nproj4.WGS84 = new Proj('WGS84');\nproj4.Proj = Proj;\nproj4.toPoint = toPoint;\nproj4.defs = defs;\nproj4.transform = transform;\nexports.mercator = defs('GOOGLE');\nexports.wgs84 = defs('WGS84');\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4_1 = require(\"./proj4\");\nexports.project_xy = function (x, y) {\n    var i, j, merc_x, merc_x_s, merc_y, merc_y_s, ref, ref1;\n    merc_x_s = [];\n    merc_y_s = [];\n    for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        ref1 = proj4_1.proj4(proj4_1.mercator, [x[i], y[i]]), merc_x = ref1[0], merc_y = ref1[1];\n        merc_x_s[i] = merc_x;\n        merc_y_s[i] = merc_y;\n    }\n    return [merc_x_s, merc_y_s];\n};\nexports.project_xsys = function (xs, ys) {\n    var i, j, merc_x_s, merc_xs_s, merc_y_s, merc_ys_s, ref, ref1;\n    merc_xs_s = [];\n    merc_ys_s = [];\n    for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        ref1 = exports.project_xy(xs[i], ys[i]), merc_x_s = ref1[0], merc_y_s = ref1[1];\n        merc_xs_s[i] = merc_x_s;\n        merc_ys_s[i] = merc_y_s;\n    }\n    return [merc_xs_s, merc_ys_s];\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar has_props_1 = require(\"../has_props\");\nvar types_1 = require(\"./types\");\nexports.create_ref = function (obj) {\n    var ref;\n    if (!(obj instanceof has_props_1.HasProps)) {\n        throw new Error(\"can only create refs for HasProps subclasses\");\n    }\n    ref = {\n        'type': obj.type,\n        'id': obj.id\n    };\n    if (obj._subtype != null) {\n        ref['subtype'] = obj._subtype;\n    }\n    return ref;\n};\nexports.is_ref = function (arg) {\n    var keys;\n    if (types_1.isObject(arg)) {\n        keys = Object.keys(arg).sort();\n        if (keys.length === 2) {\n            return keys[0] === 'id' && keys[1] === 'type';\n        }\n        if (keys.length === 3) {\n            return keys[0] === 'id' && keys[1] === 'subtype' && keys[2] === 'type';\n        }\n    }\n    return false;\n};\nexports.convert_to_ref = function (value) {\n    if (types_1.isArray(value)) {\n        return value.map(exports.convert_to_ref);\n    }\n    else {\n        if (value instanceof has_props_1.HasProps) {\n            return value.ref();\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.get_indices = function (data_source) {\n    var selected;\n    selected = data_source.selected;\n    if (selected['0d'].glyph) {\n        return selected['0d'].indices;\n    }\n    else if (selected['1d'].indices.length > 0) {\n        return selected['1d'].indices;\n    }\n    else if (selected['2d'].indices.length > 0) {\n        return selected['2d'].indices;\n    }\n    else {\n        return [];\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARRAY_TYPES, DTYPES, _arrayBufferToBase64, _base64ToArrayBuffer, k, v;\nvar types_1 = require(\"./types\");\nARRAY_TYPES = {\n    float32: Float32Array,\n    float64: Float64Array,\n    uint8: Uint8Array,\n    int8: Int8Array,\n    uint16: Uint16Array,\n    int16: Int16Array,\n    uint32: Uint32Array,\n    int32: Int32Array\n};\nDTYPES = {};\nfor (k in ARRAY_TYPES) {\n    v = ARRAY_TYPES[k];\n    DTYPES[v.name] = k;\n}\n_arrayBufferToBase64 = function (buffer) {\n    var b, binary, bytes;\n    bytes = new Uint8Array(buffer);\n    binary = (function () {\n        var j, len1, results;\n        results = [];\n        for (j = 0, len1 = bytes.length; j < len1; j++) {\n            b = bytes[j];\n            results.push(String.fromCharCode(b));\n        }\n        return results;\n    })();\n    return btoa(binary.join(\"\"));\n};\n_base64ToArrayBuffer = function (base64) {\n    var binary_string, bytes, i, j, len, ref;\n    binary_string = atob(base64);\n    len = binary_string.length;\n    bytes = new Uint8Array(len);\n    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n};\nexports.decode_base64 = function (input) {\n    var array, bytes, dtype, shape;\n    bytes = _base64ToArrayBuffer(input['__ndarray__']);\n    dtype = input['dtype'];\n    if (dtype in ARRAY_TYPES) {\n        array = new ARRAY_TYPES[dtype](bytes);\n    }\n    shape = input['shape'];\n    return [array, shape];\n};\nexports.encode_base64 = function (array, shape) {\n    var b64, data, dtype;\n    b64 = _arrayBufferToBase64(array.buffer);\n    dtype = DTYPES[array.constructor.name];\n    data = {\n        __ndarray__: b64,\n        shape: shape,\n        dtype: dtype\n    };\n    return data;\n};\nexports.decode_column_data = function (data) {\n    var arr, arrays, data_shapes, j, len1, new_data, ref, ref1, shape, shapes;\n    new_data = {};\n    data_shapes = {};\n    for (k in data) {\n        v = data[k];\n        if (types_1.isArray(v)) {\n            arrays = [];\n            shapes = [];\n            for (j = 0, len1 = v.length; j < len1; j++) {\n                arr = v[j];\n                if (types_1.isObject(arr) && '__ndarray__' in arr) {\n                    ref = exports.decode_base64(arr), arr = ref[0], shape = ref[1];\n                    shapes.push(shape);\n                    arrays.push(arr);\n                }\n                else if (types_1.isArray(arr)) {\n                    shapes.push([]);\n                    arrays.push(arr);\n                }\n            }\n            if (shapes.length > 0) {\n                new_data[k] = arrays;\n                data_shapes[k] = shapes;\n            }\n            else {\n                new_data[k] = v;\n            }\n        }\n        else if (types_1.isObject(v) && '__ndarray__' in v) {\n            ref1 = exports.decode_base64(v), arr = ref1[0], shape = ref1[1];\n            new_data[k] = arr;\n            data_shapes[k] = shape;\n        }\n        else {\n            new_data[k] = v;\n            data_shapes[k] = [];\n        }\n    }\n    return [new_data, data_shapes];\n};\nexports.encode_column_data = function (data, shapes) {\n    var i, j, new_array, new_data, ref, ref1, ref2;\n    new_data = {};\n    for (k in data) {\n        v = data[k];\n        if ((v != null ? v.buffer : void 0) instanceof ArrayBuffer) {\n            v = exports.encode_base64(v, shapes != null ? shapes[k] : void 0);\n        }\n        else if (types_1.isArray(v)) {\n            new_array = [];\n            for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                if (((ref1 = v[i]) != null ? ref1.buffer : void 0) instanceof ArrayBuffer) {\n                    new_array.push(exports.encode_base64(v[i], shapes != null ? (ref2 = shapes[k]) != null ? ref2[i] : void 0 : void 0));\n                }\n                else {\n                    new_array.push(v[i]);\n                }\n            }\n            v = new_array;\n        }\n        new_data[k] = v;\n    }\n    return new_data;\n};\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"@types/rbush\" />\nvar rbush = require(\"rbush\");\nvar SpatialIndex = (function () {\n    function SpatialIndex() {\n    }\n    return SpatialIndex;\n}());\nexports.SpatialIndex = SpatialIndex;\nvar RBush = (function (_super) {\n    __extends(RBush, _super);\n    function RBush(points) {\n        var _this = _super.call(this) || this;\n        _this.index = rbush();\n        _this.index.load(points);\n        return _this;\n    }\n    Object.defineProperty(RBush.prototype, \"bbox\", {\n        get: function () {\n            var _a = this.index.toJSON(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n            return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RBush.prototype.search = function (rect) {\n        return this.index.search(rect);\n    };\n    RBush.prototype.indices = function (rect) {\n        var points = this.search(rect);\n        var n = points.length;\n        var indices = new Array(n);\n        for (var j = 0; j < n; j++) {\n            indices[j] = points[j].i;\n        }\n        return indices;\n    };\n    return RBush;\n}(SpatialIndex));\nexports.RBush = RBush;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction startsWith(str, searchString, position) {\n    if (position === void 0) { position = 0; }\n    return str.substr(position, searchString.length) == searchString;\n}\nexports.startsWith = startsWith;\nfunction uniqueId(prefix) {\n    // from ipython project\n    // http://www.ietf.org/rfc/rfc4122.txt\n    var s = new Array(32);\n    var hexDigits = \"0123456789ABCDEF\";\n    for (var i = 0; i < 32; i++) {\n        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n    }\n    s[12] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n    s[16] = hexDigits.substr((s[16].charCodeAt(0) & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n    var uuid = s.join(\"\");\n    if (prefix != null)\n        return prefix + \"-\" + uuid;\n    else\n        return uuid;\n}\nexports.uniqueId = uniqueId;\nfunction escape(s) {\n    return s.replace(/(?:[&<>\"'`])/g, function (ch) {\n        switch (ch) {\n            case '&': return '&amp;';\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '\"': return '&quot;';\n            case \"'\": return '&#x27;';\n            case '`': return '&#x60;';\n        }\n    });\n}\nexports.escape = escape;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indianred = \"#CD5C5C\";\nexports.lightcoral = \"#F08080\";\nexports.salmon = \"#FA8072\";\nexports.darksalmon = \"#E9967A\";\nexports.lightsalmon = \"#FFA07A\";\nexports.crimson = \"#DC143C\";\nexports.red = \"#FF0000\";\nexports.firebrick = \"#B22222\";\nexports.darkred = \"#8B0000\";\nexports.pink = \"#FFC0CB\";\nexports.lightpink = \"#FFB6C1\";\nexports.hotpink = \"#FF69B4\";\nexports.deeppink = \"#FF1493\";\nexports.mediumvioletred = \"#C71585\";\nexports.palevioletred = \"#DB7093\";\nexports.coral = \"#FF7F50\";\nexports.tomato = \"#FF6347\";\nexports.orangered = \"#FF4500\";\nexports.darkorange = \"#FF8C00\";\nexports.orange = \"#FFA500\";\nexports.gold = \"#FFD700\";\nexports.yellow = \"#FFFF00\";\nexports.lightyellow = \"#FFFFE0\";\nexports.lemonchiffon = \"#FFFACD\";\nexports.lightgoldenrodyellow = \"#FAFAD2\";\nexports.papayawhip = \"#FFEFD5\";\nexports.moccasin = \"#FFE4B5\";\nexports.peachpuff = \"#FFDAB9\";\nexports.palegoldenrod = \"#EEE8AA\";\nexports.khaki = \"#F0E68C\";\nexports.darkkhaki = \"#BDB76B\";\nexports.lavender = \"#E6E6FA\";\nexports.thistle = \"#D8BFD8\";\nexports.plum = \"#DDA0DD\";\nexports.violet = \"#EE82EE\";\nexports.orchid = \"#DA70D6\";\nexports.fuchsia = \"#FF00FF\";\nexports.magenta = \"#FF00FF\";\nexports.mediumorchid = \"#BA55D3\";\nexports.mediumpurple = \"#9370DB\";\nexports.blueviolet = \"#8A2BE2\";\nexports.darkviolet = \"#9400D3\";\nexports.darkorchid = \"#9932CC\";\nexports.darkmagenta = \"#8B008B\";\nexports.purple = \"#800080\";\nexports.indigo = \"#4B0082\";\nexports.slateblue = \"#6A5ACD\";\nexports.darkslateblue = \"#483D8B\";\nexports.mediumslateblue = \"#7B68EE\";\nexports.greenyellow = \"#ADFF2F\";\nexports.chartreuse = \"#7FFF00\";\nexports.lawngreen = \"#7CFC00\";\nexports.lime = \"#00FF00\";\nexports.limegreen = \"#32CD32\";\nexports.palegreen = \"#98FB98\";\nexports.lightgreen = \"#90EE90\";\nexports.mediumspringgreen = \"#00FA9A\";\nexports.springgreen = \"#00FF7F\";\nexports.mediumseagreen = \"#3CB371\";\nexports.seagreen = \"#2E8B57\";\nexports.forestgreen = \"#228B22\";\nexports.green = \"#008000\";\nexports.darkgreen = \"#006400\";\nexports.yellowgreen = \"#9ACD32\";\nexports.olivedrab = \"#6B8E23\";\nexports.olive = \"#808000\";\nexports.darkolivegreen = \"#556B2F\";\nexports.mediumaquamarine = \"#66CDAA\";\nexports.darkseagreen = \"#8FBC8F\";\nexports.lightseagreen = \"#20B2AA\";\nexports.darkcyan = \"#008B8B\";\nexports.teal = \"#008080\";\nexports.aqua = \"#00FFFF\";\nexports.cyan = \"#00FFFF\";\nexports.lightcyan = \"#E0FFFF\";\nexports.paleturquoise = \"#AFEEEE\";\nexports.aquamarine = \"#7FFFD4\";\nexports.turquoise = \"#40E0D0\";\nexports.mediumturquoise = \"#48D1CC\";\nexports.darkturquoise = \"#00CED1\";\nexports.cadetblue = \"#5F9EA0\";\nexports.steelblue = \"#4682B4\";\nexports.lightsteelblue = \"#B0C4DE\";\nexports.powderblue = \"#B0E0E6\";\nexports.lightblue = \"#ADD8E6\";\nexports.skyblue = \"#87CEEB\";\nexports.lightskyblue = \"#87CEFA\";\nexports.deepskyblue = \"#00BFFF\";\nexports.dodgerblue = \"#1E90FF\";\nexports.cornflowerblue = \"#6495ED\";\nexports.royalblue = \"#4169E1\";\nexports.blue = \"#0000FF\";\nexports.mediumblue = \"#0000CD\";\nexports.darkblue = \"#00008B\";\nexports.navy = \"#000080\";\nexports.midnightblue = \"#191970\";\nexports.cornsilk = \"#FFF8DC\";\nexports.blanchedalmond = \"#FFEBCD\";\nexports.bisque = \"#FFE4C4\";\nexports.navajowhite = \"#FFDEAD\";\nexports.wheat = \"#F5DEB3\";\nexports.burlywood = \"#DEB887\";\nexports.tan = \"#D2B48C\";\nexports.rosybrown = \"#BC8F8F\";\nexports.sandybrown = \"#F4A460\";\nexports.goldenrod = \"#DAA520\";\nexports.darkgoldenrod = \"#B8860B\";\nexports.peru = \"#CD853F\";\nexports.chocolate = \"#D2691E\";\nexports.saddlebrown = \"#8B4513\";\nexports.sienna = \"#A0522D\";\nexports.brown = \"#A52A2A\";\nexports.maroon = \"#800000\";\nexports.white = \"#FFFFFF\";\nexports.snow = \"#FFFAFA\";\nexports.honeydew = \"#F0FFF0\";\nexports.mintcream = \"#F5FFFA\";\nexports.azure = \"#F0FFFF\";\nexports.aliceblue = \"#F0F8FF\";\nexports.ghostwhite = \"#F8F8FF\";\nexports.whitesmoke = \"#F5F5F5\";\nexports.seashell = \"#FFF5EE\";\nexports.beige = \"#F5F5DC\";\nexports.oldlace = \"#FDF5E6\";\nexports.floralwhite = \"#FFFAF0\";\nexports.ivory = \"#FFFFF0\";\nexports.antiquewhite = \"#FAEBD7\";\nexports.linen = \"#FAF0E6\";\nexports.lavenderblush = \"#FFF0F5\";\nexports.mistyrose = \"#FFE4E1\";\nexports.gainsboro = \"#DCDCDC\";\nexports.lightgray = \"#D3D3D3\";\nexports.lightgrey = \"#D3D3D3\";\nexports.silver = \"#C0C0C0\";\nexports.darkgray = \"#A9A9A9\";\nexports.darkgrey = \"#A9A9A9\";\nexports.gray = \"#808080\";\nexports.grey = \"#808080\";\nexports.dimgray = \"#696969\";\nexports.dimgrey = \"#696969\";\nexports.lightslategray = \"#778899\";\nexports.lightslategrey = \"#778899\";\nexports.slategray = \"#708090\";\nexports.slategrey = \"#708090\";\nexports.darkslategray = \"#2F4F4F\";\nexports.darkslategrey = \"#2F4F4F\";\nexports.black = \"#000000\";\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _format_number;\nvar SPrintf = require(\"sprintf\");\nvar Numbro = require(\"numbro\");\nvar string_1 = require(\"./string\");\nvar types_1 = require(\"./types\");\n_format_number = function (number) {\n    var format;\n    if (types_1.isNumber(number)) {\n        format = (function () {\n            switch (false) {\n                case Math.floor(number) !== number:\n                    return \"%d\";\n                case !(Math.abs(number) > 0.1 && Math.abs(number) < 1000):\n                    return \"%0.3f\";\n                default:\n                    return \"%0.3e\";\n            }\n        })();\n        return SPrintf.sprintf(format, number);\n    }\n    else {\n        return \"\" + number;\n    }\n};\nexports.replace_placeholders = function (string, data_source, i, special_vars) {\n    if (special_vars == null) {\n        special_vars = {};\n    }\n    string = string.replace(/(^|[^\\$])\\$(\\w+)/g, (function (_this) {\n        return function (match, prefix, name) {\n            return prefix + \"@$\" + name;\n        };\n    })(this));\n    string = string.replace(/(^|[^@])@(?:(\\$?\\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, (function (_this) {\n        return function (match, prefix, name, long_name, format) {\n            var ref, replacement, value;\n            name = long_name != null ? long_name : name;\n            value = name[0] === \"$\" ? special_vars[name.substring(1)] : (ref = data_source.get_column(name)) != null ? ref[i] : void 0;\n            replacement = null;\n            if (value == null) {\n                replacement = \"???\";\n            }\n            else {\n                if (format === 'safe') {\n                    return \"\" + prefix + value;\n                }\n                else if (format != null) {\n                    replacement = Numbro.format(value, format);\n                }\n                else {\n                    replacement = _format_number(value);\n                }\n            }\n            return replacement = \"\" + prefix + (string_1.escape(replacement));\n        };\n    })(this));\n    return string;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cache;\nvar dom_1 = require(\"../dom\");\ncache = {};\nexports.get_text_height = function (font) {\n    var block, elem, result, text;\n    if (cache[font] != null) {\n        return cache[font];\n    }\n    text = dom_1.span({\n        style: {\n            font: font\n        }\n    }, \"Hg\");\n    block = dom_1.div({\n        style: {\n            display: \"inline-block\",\n            width: \"1px\",\n            height: \"0px\"\n        }\n    });\n    elem = dom_1.div({}, text, block);\n    document.body.appendChild(elem);\n    try {\n        result = {};\n        block.style.verticalAlign = \"baseline\";\n        result.ascent = dom_1.offset(block).top - dom_1.offset(text).top;\n        block.style.verticalAlign = \"bottom\";\n        result.height = dom_1.offset(block).top - dom_1.offset(text).top;\n        result.descent = result.height - result.ascent;\n    }\n    finally {\n        document.body.removeChild(elem);\n    }\n    cache[font] = result;\n    return result;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _delay_animation, delay_animation;\n_delay_animation = function (f) {\n    return f();\n};\ndelay_animation = (typeof window !== \"undefined\" && window !== null ? window.requestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.mozRequestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.webkitRequestAnimationFrame : void 0) || (typeof window !== \"undefined\" && window !== null ? window.msRequestAnimationFrame : void 0) || _delay_animation;\nexports.throttle = function (func, wait) {\n    var args, context, later, pending, previous, ref, result, timeout;\n    ref = [null, null, null, null], context = ref[0], args = ref[1], timeout = ref[2], result = ref[3];\n    previous = 0;\n    pending = false;\n    later = function () {\n        previous = new Date;\n        timeout = null;\n        pending = false;\n        return result = func.apply(context, args);\n    };\n    return function () {\n        var now, remaining;\n        now = new Date;\n        remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 && !pending) {\n            clearTimeout(timeout);\n            pending = true;\n            delay_animation(later);\n        }\n        else if (!timeout && !pending) {\n            timeout = setTimeout((function () {\n                return delay_animation(later);\n            }), remaining);\n        }\n        return result;\n    };\n};\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = Object.prototype.toString;\nfunction isBoolean(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n}\nexports.isBoolean = isBoolean;\nfunction isNumber(obj) {\n    return toString.call(obj) === \"[object Number]\";\n}\nexports.isNumber = isNumber;\nfunction isString(obj) {\n    return toString.call(obj) === \"[object String]\";\n}\nexports.isString = isString;\nfunction isStrictNaN(obj) {\n    return isNumber(obj) && obj !== +obj;\n}\nexports.isStrictNaN = isStrictNaN;\nfunction isFunction(obj) {\n    return toString.call(obj) === \"[object Function]\";\n}\nexports.isFunction = isFunction;\nfunction isArray(obj) {\n    return Array.isArray(obj);\n}\nexports.isArray = isArray;\nfunction isObject(obj) {\n    var tp = typeof obj;\n    return tp === 'function' || tp === 'object' && !!obj;\n}\nexports.isObject = isObject;\n","/*!\n * jQuery Mousewheel 3.1.13\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction fontSize(element) {\n    return parseInt(getComputedStyle(element).fontSize, 10) || null;\n}\nfunction lineHeight(element) {\n    var parent = element.offsetParent || document.body;\n    return fontSize(parent) || fontSize(element) || 16;\n}\nfunction pageHeight(element) {\n    return element.clientHeight; // XXX: should be content height?\n}\nfunction getDeltaY(event) {\n    var deltaY = -event.deltaY;\n    if (event.target instanceof HTMLElement) {\n        switch (event.deltaMode) {\n            case event.DOM_DELTA_LINE:\n                deltaY *= lineHeight(event.target);\n                break;\n            case event.DOM_DELTA_PAGE:\n                deltaY *= pageHeight(event.target);\n                break;\n        }\n    }\n    return deltaY;\n}\nexports.getDeltaY = getDeltaY;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = require(\"./math\");\nexports.scale_highlow = function (range, factor, center) {\n    var high, low, ref, x, x0, x1;\n    if (center == null) {\n        center = null;\n    }\n    ref = [range.start, range.end], low = ref[0], high = ref[1];\n    x = center != null ? center : (high + low) / 2.0;\n    x0 = low - (low - x) * factor;\n    x1 = high - (high - x) * factor;\n    return [x0, x1];\n};\nexports.get_info = function (mappers, arg) {\n    var end, info, mapper, name, ref, start, x0, x1;\n    x0 = arg[0], x1 = arg[1];\n    info = {};\n    for (name in mappers) {\n        mapper = mappers[name];\n        ref = mapper.v_map_from_target([x0, x1], true), start = ref[0], end = ref[1];\n        info[name] = {\n            start: start,\n            end: end\n        };\n    }\n    return info;\n};\nexports.scale_range = function (frame, factor, h_axis, v_axis, center) {\n    var hfactor, ref, ref1, vfactor, vx0, vx1, vy0, vy1, xrs, yrs;\n    if (h_axis == null) {\n        h_axis = true;\n    }\n    if (v_axis == null) {\n        v_axis = true;\n    }\n    if (center == null) {\n        center = null;\n    }\n    \"Utility function for zoom tools to calculate/create the zoom_info object\\nof the form required by ``PlotCanvasView.update_range``\\n\\nParameters:\\n  frame : CartesianFrame\\n  factor : Number\\n  h_axis : Boolean, optional\\n    whether to zoom the horizontal axis (default = true)\\n  v_axis : Boolean, optional\\n    whether to zoom the horizontal axis (default = true)\\n  center : object, optional\\n    of form {'x': Number, 'y', Number}\\n\\nReturns:\\n  object:\";\n    factor = math_1.clamp(factor, -0.9, 0.9);\n    hfactor = h_axis ? factor : 0;\n    ref = exports.scale_highlow(frame.h_range, hfactor, center != null ? center.x : void 0), vx0 = ref[0], vx1 = ref[1];\n    xrs = exports.get_info(frame.x_mappers, [vx0, vx1]);\n    vfactor = v_axis ? factor : 0;\n    ref1 = exports.scale_highlow(frame.v_range, vfactor, center != null ? center.y : void 0), vy0 = ref1[0], vy1 = ref1[1];\n    yrs = exports.get_info(frame.y_mappers, [vy0, vy1]);\n    return {\n        xrs: xrs,\n        yrs: yrs,\n        factor: factor\n    };\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ContextProperties, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mixins = require(\"./property_mixins\");\nvar color_1 = require(\"./util/color\");\nContextProperties = (function () {\n    function ContextProperties(obj, prefix) {\n        var attr, do_spec, j, len, ref;\n        if (prefix == null) {\n            prefix = \"\";\n        }\n        this.obj = obj;\n        this.prefix = prefix;\n        this.cache = {};\n        do_spec = obj.properties[prefix + this.do_attr].spec;\n        this.doit = do_spec.value !== null;\n        ref = this.attrs;\n        for (j = 0, len = ref.length; j < len; j++) {\n            attr = ref[j];\n            this[attr] = obj.properties[prefix + attr];\n        }\n    }\n    ContextProperties.prototype.warm_cache = function (source) {\n        var attr, j, len, prop, ref, results;\n        ref = this.attrs;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            attr = ref[j];\n            prop = this.obj.properties[this.prefix + attr];\n            if (prop.spec.value !== void 0) {\n                results.push(this.cache[attr] = prop.spec.value);\n            }\n            else {\n                results.push(this.cache[attr + \"_array\"] = prop.array(source));\n            }\n        }\n        return results;\n    };\n    ContextProperties.prototype.cache_select = function (attr, i) {\n        var prop;\n        prop = this.obj.properties[this.prefix + attr];\n        if (prop.spec.value !== void 0) {\n            return this.cache[attr] = prop.spec.value;\n        }\n        else {\n            return this.cache[attr] = this.cache[attr + \"_array\"][i];\n        }\n    };\n    return ContextProperties;\n})();\nexports.Line = (function (superClass) {\n    extend(Line, superClass);\n    function Line() {\n        return Line.__super__.constructor.apply(this, arguments);\n    }\n    Line.prototype.attrs = Object.keys(mixins.line());\n    Line.prototype.do_attr = \"line_color\";\n    Line.prototype.set_value = function (ctx) {\n        ctx.strokeStyle = this.line_color.value();\n        ctx.globalAlpha = this.line_alpha.value();\n        ctx.lineWidth = this.line_width.value();\n        ctx.lineJoin = this.line_join.value();\n        ctx.lineCap = this.line_cap.value();\n        ctx.setLineDash(this.line_dash.value());\n        return ctx.setLineDashOffset(this.line_dash_offset.value());\n    };\n    Line.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"line_color\", i);\n        if (ctx.strokeStyle !== this.cache.line_color) {\n            ctx.strokeStyle = this.cache.line_color;\n        }\n        this.cache_select(\"line_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.line_alpha) {\n            ctx.globalAlpha = this.cache.line_alpha;\n        }\n        this.cache_select(\"line_width\", i);\n        if (ctx.lineWidth !== this.cache.line_width) {\n            ctx.lineWidth = this.cache.line_width;\n        }\n        this.cache_select(\"line_join\", i);\n        if (ctx.lineJoin !== this.cache.line_join) {\n            ctx.lineJoin = this.cache.line_join;\n        }\n        this.cache_select(\"line_cap\", i);\n        if (ctx.lineCap !== this.cache.line_cap) {\n            ctx.lineCap = this.cache.line_cap;\n        }\n        this.cache_select(\"line_dash\", i);\n        if (ctx.getLineDash() !== this.cache.line_dash) {\n            ctx.setLineDash(this.cache.line_dash);\n        }\n        this.cache_select(\"line_dash_offset\", i);\n        if (ctx.getLineDashOffset() !== this.cache.line_dash_offset) {\n            return ctx.setLineDashOffset(this.cache.line_dash_offset);\n        }\n    };\n    Line.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.line_color.value(), this.line_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    return Line;\n})(ContextProperties);\nexports.Fill = (function (superClass) {\n    extend(Fill, superClass);\n    function Fill() {\n        return Fill.__super__.constructor.apply(this, arguments);\n    }\n    Fill.prototype.attrs = Object.keys(mixins.fill());\n    Fill.prototype.do_attr = \"fill_color\";\n    Fill.prototype.set_value = function (ctx) {\n        ctx.fillStyle = this.fill_color.value();\n        return ctx.globalAlpha = this.fill_alpha.value();\n    };\n    Fill.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"fill_color\", i);\n        if (ctx.fillStyle !== this.cache.fill_color) {\n            ctx.fillStyle = this.cache.fill_color;\n        }\n        this.cache_select(\"fill_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.fill_alpha) {\n            return ctx.globalAlpha = this.cache.fill_alpha;\n        }\n    };\n    Fill.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.fill_color.value(), this.fill_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    return Fill;\n})(ContextProperties);\nexports.Text = (function (superClass) {\n    extend(Text, superClass);\n    function Text() {\n        return Text.__super__.constructor.apply(this, arguments);\n    }\n    Text.prototype.attrs = Object.keys(mixins.text());\n    Text.prototype.do_attr = \"text_color\";\n    Text.prototype.cache_select = function (name, i) {\n        var val;\n        if (name === \"font\") {\n            val = Text.__super__.cache_select.call(this, \"text_font_style\", i) + \" \" + Text.__super__.cache_select.call(this, \"text_font_size\", i) + \" \" + Text.__super__.cache_select.call(this, \"text_font\", i);\n            return this.cache.font = val;\n        }\n        else {\n            return Text.__super__.cache_select.call(this, name, i);\n        }\n    };\n    Text.prototype.font_value = function () {\n        var font, font_size, font_style;\n        font = this.text_font.value();\n        font_size = this.text_font_size.value();\n        font_style = this.text_font_style.value();\n        return font_style + \" \" + font_size + \" \" + font;\n    };\n    Text.prototype.color_value = function () {\n        var color;\n        color = color_1.color2rgba(this.text_color.value(), this.text_alpha.value());\n        return \"rgba(\" + (color[0] * 255) + \",\" + (color[1] * 255) + \",\" + (color[2] * 255) + \",\" + color[3] + \")\";\n    };\n    Text.prototype.set_value = function (ctx) {\n        ctx.font = this.font_value();\n        ctx.fillStyle = this.text_color.value();\n        ctx.globalAlpha = this.text_alpha.value();\n        ctx.textAlign = this.text_align.value();\n        return ctx.textBaseline = this.text_baseline.value();\n    };\n    Text.prototype.set_vectorize = function (ctx, i) {\n        this.cache_select(\"font\", i);\n        if (ctx.font !== this.cache.font) {\n            ctx.font = this.cache.font;\n        }\n        this.cache_select(\"text_color\", i);\n        if (ctx.fillStyle !== this.cache.text_color) {\n            ctx.fillStyle = this.cache.text_color;\n        }\n        this.cache_select(\"text_alpha\", i);\n        if (ctx.globalAlpha !== this.cache.text_alpha) {\n            ctx.globalAlpha = this.cache.text_alpha;\n        }\n        this.cache_select(\"text_align\", i);\n        if (ctx.textAlign !== this.cache.text_align) {\n            ctx.textAlign = this.cache.text_align;\n        }\n        this.cache_select(\"text_baseline\", i);\n        if (ctx.textBaseline !== this.cache.text_baseline) {\n            return ctx.textBaseline = this.cache.text_baseline;\n        }\n    };\n    return Text;\n})(ContextProperties);\nexports.Visuals = (function () {\n    function Visuals(model) {\n        var cls, j, len, name, prefix, ref, ref1, ref2, spec;\n        ref = model.mixins;\n        for (j = 0, len = ref.length; j < len; j++) {\n            spec = ref[j];\n            ref1 = spec.split(\":\"), name = ref1[0], prefix = (ref2 = ref1[1]) != null ? ref2 : \"\";\n            cls = (function () {\n                switch (name) {\n                    case \"line\":\n                        return exports.Line;\n                    case \"fill\":\n                        return exports.Fill;\n                    case \"text\":\n                        return exports.Text;\n                }\n            })();\n            this[prefix + name] = new cls(model, prefix);\n        }\n    }\n    Visuals.prototype.warm_cache = function (source) {\n        var name, prop, ref, results;\n        ref = this;\n        results = [];\n        for (name in ref) {\n            if (!hasProp.call(ref, name))\n                continue;\n            prop = ref[name];\n            if (prop instanceof ContextProperties) {\n                results.push(prop.warm_cache(source));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    return Visuals;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventManager, extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar base_1 = require(\"./base\");\nvar version_1 = require(\"./version\");\nvar solver_1 = require(\"./core/layout/solver\");\nvar logging_1 = require(\"./core/logging\");\nvar has_props_1 = require(\"./core/has_props\");\nvar refs_1 = require(\"./core/util/refs\");\nvar serialization_1 = require(\"./core/util/serialization\");\nvar data_structures_1 = require(\"./core/util/data_structures\");\nvar array_1 = require(\"./core/util/array\");\nvar object_1 = require(\"./core/util/object\");\nvar eq_1 = require(\"./core/util/eq\");\nvar types_1 = require(\"./core/util/types\");\nvar column_data_source_1 = require(\"./models/sources/column_data_source\");\nEventManager = (function () {\n    function EventManager(document1) {\n        this.document = document1;\n        this.session = null;\n        this.subscribed_models = new data_structures_1.Set();\n    }\n    EventManager.prototype.send_event = function (event) {\n        var ref1;\n        return (ref1 = this.session) != null ? ref1.send_event(event) : void 0;\n    };\n    EventManager.prototype.trigger = function (event) {\n        var j, len, model, model_id, ref1, results;\n        ref1 = this.subscribed_models.values;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            model_id = ref1[j];\n            if (event.model_id !== null && event.model_id !== model_id) {\n                continue;\n            }\n            model = this.document._all_models[model_id];\n            results.push(model != null ? model._process_event(event) : void 0);\n        }\n        return results;\n    };\n    return EventManager;\n})();\nexports.DocumentChangedEvent = (function () {\n    function DocumentChangedEvent(document1) {\n        this.document = document1;\n    }\n    return DocumentChangedEvent;\n})();\nexports.ModelChangedEvent = (function (superClass) {\n    extend1(ModelChangedEvent, superClass);\n    function ModelChangedEvent(document1, model1, attr1, old1, new_1, setter_id1) {\n        this.document = document1;\n        this.model = model1;\n        this.attr = attr1;\n        this.old = old1;\n        this.new_ = new_1;\n        this.setter_id = setter_id1;\n        ModelChangedEvent.__super__.constructor.call(this, this.document);\n    }\n    ModelChangedEvent.prototype.json = function (references) {\n        var id, value, value_json, value_refs;\n        if (this.attr === 'id') {\n            logging_1.logger.warn(\"'id' field is immutable and should never be in a ModelChangedEvent \", this);\n            throw new Error(\"'id' field should never change, whatever code just set it is wrong\");\n        }\n        value = this.new_;\n        value_json = this.model.constructor._value_to_json(this.attr, value, this.model);\n        value_refs = {};\n        has_props_1.HasProps._value_record_references(value, value_refs, true);\n        if (this.model.id in value_refs && this.model !== value) {\n            delete value_refs[this.model.id];\n        }\n        for (id in value_refs) {\n            references[id] = value_refs[id];\n        }\n        return {\n            'kind': 'ModelChanged',\n            'model': this.model.ref(),\n            'attr': this.attr,\n            'new': value_json\n        };\n    };\n    return ModelChangedEvent;\n})(exports.DocumentChangedEvent);\nexports.TitleChangedEvent = (function (superClass) {\n    extend1(TitleChangedEvent, superClass);\n    function TitleChangedEvent(document1, title1, setter_id1) {\n        this.document = document1;\n        this.title = title1;\n        this.setter_id = setter_id1;\n        TitleChangedEvent.__super__.constructor.call(this, this.document);\n    }\n    TitleChangedEvent.prototype.json = function (references) {\n        return {\n            'kind': 'TitleChanged',\n            'title': this.title\n        };\n    };\n    return TitleChangedEvent;\n})(exports.DocumentChangedEvent);\nexports.RootAddedEvent = (function (superClass) {\n    extend1(RootAddedEvent, superClass);\n    function RootAddedEvent(document1, model1, setter_id1) {\n        this.document = document1;\n        this.model = model1;\n        this.setter_id = setter_id1;\n        RootAddedEvent.__super__.constructor.call(this, this.document);\n    }\n    RootAddedEvent.prototype.json = function (references) {\n        has_props_1.HasProps._value_record_references(this.model, references, true);\n        return {\n            'kind': 'RootAdded',\n            'model': this.model.ref()\n        };\n    };\n    return RootAddedEvent;\n})(exports.DocumentChangedEvent);\nexports.RootRemovedEvent = (function (superClass) {\n    extend1(RootRemovedEvent, superClass);\n    function RootRemovedEvent(document1, model1, setter_id1) {\n        this.document = document1;\n        this.model = model1;\n        this.setter_id = setter_id1;\n        RootRemovedEvent.__super__.constructor.call(this, this.document);\n    }\n    RootRemovedEvent.prototype.json = function (references) {\n        return {\n            'kind': 'RootRemoved',\n            'model': this.model.ref()\n        };\n    };\n    return RootRemovedEvent;\n})(exports.DocumentChangedEvent);\nexports.DEFAULT_TITLE = \"Bokeh Application\";\nexports.Document = (function () {\n    function Document() {\n        this._title = exports.DEFAULT_TITLE;\n        this._roots = [];\n        this._all_models = {};\n        this._all_models_by_name = new data_structures_1.MultiDict();\n        this._all_models_freeze_count = 0;\n        this._callbacks = [];\n        this._doc_width = new solver_1.Variable(\"document_width\");\n        this._doc_height = new solver_1.Variable(\"document_height\");\n        this._solver = new solver_1.Solver();\n        this._init_solver();\n        this.event_manager = new EventManager(this);\n        window.addEventListener(\"resize\", (function (_this) {\n            return function () {\n                return _this.resize();\n            };\n        })(this));\n    }\n    Document.prototype._init_solver = function () {\n        var j, len, model, ref1, results;\n        this._solver.clear();\n        this._solver.add_edit_variable(this._doc_width);\n        this._solver.add_edit_variable(this._doc_height);\n        ref1 = this._roots;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            model = ref1[j];\n            if (model.layoutable) {\n                results.push(this._add_layoutable(model));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    Document.prototype.solver = function () {\n        return this._solver;\n    };\n    Document.prototype.resize = function (width, height) {\n        if (width == null) {\n            width = null;\n        }\n        if (height == null) {\n            height = null;\n        }\n        this._resize(width, height);\n        return this._resize(width, height);\n    };\n    Document.prototype._resize = function (width, height) {\n        var j, len, measuring, ref1, ref2, root, root_div, vars;\n        if (width == null) {\n            width = null;\n        }\n        if (height == null) {\n            height = null;\n        }\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            root = ref1[j];\n            if (root.layoutable !== true) {\n                continue;\n            }\n            vars = root.get_constrained_variables();\n            if ((vars.width == null) && (vars.height == null)) {\n                continue;\n            }\n            root_div = document.getElementById(\"modelid_\" + root.id);\n            if ((root_div != null) && width === null) {\n                measuring = root_div;\n                while (true) {\n                    measuring = measuring.parentNode;\n                    ref2 = measuring.getBoundingClientRect(), width = ref2.width, height = ref2.height;\n                    if (height !== 0) {\n                        break;\n                    }\n                }\n            }\n            if (vars.width != null) {\n                logging_1.logger.debug(\"Suggest width on Document -- \" + width);\n                this._solver.suggest_value(this._doc_width, width);\n            }\n            if (vars.height != null) {\n                logging_1.logger.debug(\"Suggest height on Document -- \" + height);\n                this._solver.suggest_value(this._doc_height, height);\n            }\n        }\n        this._solver.update_variables(false);\n        return this._solver.trigger('resize');\n    };\n    Document.prototype.clear = function () {\n        var results;\n        this._push_all_models_freeze();\n        try {\n            results = [];\n            while (this._roots.length > 0) {\n                results.push(this.remove_root(this._roots[0]));\n            }\n            return results;\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n    };\n    Document.prototype.destructively_move = function (dest_doc) {\n        var j, l, len, len1, len2, n, r, ref1, roots;\n        if (dest_doc === this) {\n            throw new Error(\"Attempted to overwrite a document with itself\");\n        }\n        dest_doc.clear();\n        roots = [];\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            roots.push(r);\n        }\n        this.clear();\n        for (l = 0, len1 = roots.length; l < len1; l++) {\n            r = roots[l];\n            if (r.document !== null) {\n                throw new Error(\"Somehow we didn't detach \" + r);\n            }\n        }\n        if (Object.keys(this._all_models).length !== 0) {\n            throw new Error(\"@_all_models still had stuff in it: \" + this._all_models);\n        }\n        for (n = 0, len2 = roots.length; n < len2; n++) {\n            r = roots[n];\n            dest_doc.add_root(r);\n        }\n        return dest_doc.set_title(this._title);\n    };\n    Document.prototype._push_all_models_freeze = function () {\n        return this._all_models_freeze_count += 1;\n    };\n    Document.prototype._pop_all_models_freeze = function () {\n        this._all_models_freeze_count -= 1;\n        if (this._all_models_freeze_count === 0) {\n            return this._recompute_all_models();\n        }\n    };\n    Document.prototype._invalidate_all_models = function () {\n        logging_1.logger.debug(\"invalidating document models\");\n        if (this._all_models_freeze_count === 0) {\n            return this._recompute_all_models();\n        }\n    };\n    Document.prototype._recompute_all_models = function () {\n        var a, d, j, l, len, len1, len2, len3, m, n, name, new_all_models_set, o, old_all_models_set, r, recomputed, ref1, ref2, ref3, ref4, to_attach, to_detach;\n        new_all_models_set = new data_structures_1.Set();\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            new_all_models_set = new_all_models_set.union(r.references());\n        }\n        old_all_models_set = new data_structures_1.Set(object_1.values(this._all_models));\n        to_detach = old_all_models_set.diff(new_all_models_set);\n        to_attach = new_all_models_set.diff(old_all_models_set);\n        recomputed = {};\n        ref2 = new_all_models_set.values;\n        for (l = 0, len1 = ref2.length; l < len1; l++) {\n            m = ref2[l];\n            recomputed[m.id] = m;\n        }\n        ref3 = to_detach.values;\n        for (n = 0, len2 = ref3.length; n < len2; n++) {\n            d = ref3[n];\n            d.detach_document();\n            name = d.name;\n            if (name !== null) {\n                this._all_models_by_name.remove_value(name, d);\n            }\n        }\n        ref4 = to_attach.values;\n        for (o = 0, len3 = ref4.length; o < len3; o++) {\n            a = ref4[o];\n            a.attach_document(this);\n            name = a.name;\n            if (name !== null) {\n                this._all_models_by_name.add_value(name, a);\n            }\n        }\n        return this._all_models = recomputed;\n    };\n    Document.prototype.roots = function () {\n        return this._roots;\n    };\n    Document.prototype._add_layoutable = function (model) {\n        var constraint, constraints, edit_variable, editables, j, l, len, len1, ref1, strength, vars;\n        if (model.layoutable !== true) {\n            throw new Error(\"Cannot add non-layoutable - \" + model);\n        }\n        editables = model.get_edit_variables();\n        constraints = model.get_constraints();\n        vars = model.get_constrained_variables();\n        for (j = 0, len = editables.length; j < len; j++) {\n            ref1 = editables[j], edit_variable = ref1.edit_variable, strength = ref1.strength;\n            this._solver.add_edit_variable(edit_variable, strength);\n        }\n        for (l = 0, len1 = constraints.length; l < len1; l++) {\n            constraint = constraints[l];\n            this._solver.add_constraint(constraint);\n        }\n        if (vars.width != null) {\n            this._solver.add_constraint(solver_1.EQ(vars.width, this._doc_width));\n        }\n        if (vars.height != null) {\n            this._solver.add_constraint(solver_1.EQ(vars.height, this._doc_height));\n        }\n        return this._solver.update_variables();\n    };\n    Document.prototype.add_root = function (model, setter_id) {\n        logging_1.logger.debug(\"Adding root: \" + model);\n        if (indexOf.call(this._roots, model) >= 0) {\n            return;\n        }\n        this._push_all_models_freeze();\n        try {\n            this._roots.push(model);\n            model._is_root = true;\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        this._init_solver();\n        return this._trigger_on_change(new exports.RootAddedEvent(this, model, setter_id));\n    };\n    Document.prototype.remove_root = function (model, setter_id) {\n        var i;\n        i = this._roots.indexOf(model);\n        if (i < 0) {\n            return;\n        }\n        this._push_all_models_freeze();\n        try {\n            this._roots.splice(i, 1);\n            model._is_root = false;\n        }\n        finally {\n            this._pop_all_models_freeze();\n        }\n        this._init_solver();\n        return this._trigger_on_change(new exports.RootRemovedEvent(this, model, setter_id));\n    };\n    Document.prototype.title = function () {\n        return this._title;\n    };\n    Document.prototype.set_title = function (title, setter_id) {\n        if (title !== this._title) {\n            this._title = title;\n            return this._trigger_on_change(new exports.TitleChangedEvent(this, title, setter_id));\n        }\n    };\n    Document.prototype.get_model_by_id = function (model_id) {\n        if (model_id in this._all_models) {\n            return this._all_models[model_id];\n        }\n        else {\n            return null;\n        }\n    };\n    Document.prototype.get_model_by_name = function (name) {\n        return this._all_models_by_name.get_one(name, \"Multiple models are named '\" + name + \"'\");\n    };\n    Document.prototype.on_change = function (callback) {\n        if (indexOf.call(this._callbacks, callback) >= 0) {\n            return;\n        }\n        return this._callbacks.push(callback);\n    };\n    Document.prototype.remove_on_change = function (callback) {\n        var i;\n        i = this._callbacks.indexOf(callback);\n        if (i >= 0) {\n            return this._callbacks.splice(i, 1);\n        }\n    };\n    Document.prototype._trigger_on_change = function (event) {\n        var cb, j, len, ref1, results;\n        ref1 = this._callbacks;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            cb = ref1[j];\n            results.push(cb(event));\n        }\n        return results;\n    };\n    Document.prototype._notify_change = function (model, attr, old, new_, options) {\n        if (attr === 'name') {\n            this._all_models_by_name.remove_value(old, model);\n            if (new_ !== null) {\n                this._all_models_by_name.add_value(new_, model);\n            }\n        }\n        return this._trigger_on_change(new exports.ModelChangedEvent(this, model, attr, old, new_, options != null ? options.setter_id : void 0));\n    };\n    Document._references_json = function (references, include_defaults) {\n        var j, len, r, ref, references_json;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        references_json = [];\n        for (j = 0, len = references.length; j < len; j++) {\n            r = references[j];\n            ref = r.ref();\n            ref['attributes'] = r.attributes_as_json(include_defaults);\n            delete ref['attributes']['id'];\n            references_json.push(ref);\n        }\n        return references_json;\n    };\n    Document._instantiate_object = function (obj_id, obj_type, obj_attrs) {\n        var full_attrs, model;\n        full_attrs = object_1.extend({}, obj_attrs, {\n            id: obj_id\n        });\n        model = base_1.Models(obj_type);\n        return new model(full_attrs, {\n            silent: true,\n            defer_initialization: true\n        });\n    };\n    Document._instantiate_references_json = function (references_json, existing_models) {\n        var instance, j, len, obj, obj_attrs, obj_id, obj_type, references;\n        references = {};\n        for (j = 0, len = references_json.length; j < len; j++) {\n            obj = references_json[j];\n            obj_id = obj['id'];\n            obj_type = obj['type'];\n            obj_attrs = obj['attributes'];\n            if (obj_id in existing_models) {\n                instance = existing_models[obj_id];\n            }\n            else {\n                instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\n                if ('subtype' in obj) {\n                    instance.set_subtype(obj['subtype']);\n                }\n            }\n            references[instance.id] = instance;\n        }\n        return references;\n    };\n    Document._resolve_refs = function (value, old_references, new_references) {\n        var resolve_array, resolve_dict, resolve_ref;\n        resolve_ref = function (v) {\n            if (refs_1.is_ref(v)) {\n                if (v['id'] in old_references) {\n                    return old_references[v['id']];\n                }\n                else if (v['id'] in new_references) {\n                    return new_references[v['id']];\n                }\n                else {\n                    throw new Error(\"reference \" + (JSON.stringify(v)) + \" isn't known (not in Document?)\");\n                }\n            }\n            else if (types_1.isArray(v)) {\n                return resolve_array(v);\n            }\n            else if (types_1.isObject(v)) {\n                return resolve_dict(v);\n            }\n            else {\n                return v;\n            }\n        };\n        resolve_dict = function (dict) {\n            var k, resolved, v;\n            resolved = {};\n            for (k in dict) {\n                v = dict[k];\n                resolved[k] = resolve_ref(v);\n            }\n            return resolved;\n        };\n        resolve_array = function (array) {\n            var j, len, results, v;\n            results = [];\n            for (j = 0, len = array.length; j < len; j++) {\n                v = array[j];\n                results.push(resolve_ref(v));\n            }\n            return results;\n        };\n        return resolve_ref(value);\n    };\n    Document._initialize_references_json = function (references_json, old_references, new_references) {\n        var foreach_depth_first, instance, j, len, obj, obj_attrs, obj_id, to_update, was_new;\n        to_update = {};\n        for (j = 0, len = references_json.length; j < len; j++) {\n            obj = references_json[j];\n            obj_id = obj['id'];\n            obj_attrs = obj['attributes'];\n            was_new = false;\n            instance = obj_id in old_references ? old_references[obj_id] : (was_new = true, new_references[obj_id]);\n            obj_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);\n            to_update[instance.id] = [instance, obj_attrs, was_new];\n        }\n        foreach_depth_first = function (items, f) {\n            var already_started, foreach_value, k, results, v;\n            already_started = {};\n            foreach_value = function (v, f) {\n                var a, attrs, e, k, l, len1, ref1, results, results1, same_as_v;\n                if (v instanceof has_props_1.HasProps) {\n                    if (!(v.id in already_started) && v.id in items) {\n                        already_started[v.id] = true;\n                        ref1 = items[v.id], same_as_v = ref1[0], attrs = ref1[1], was_new = ref1[2];\n                        for (a in attrs) {\n                            e = attrs[a];\n                            foreach_value(e, f);\n                        }\n                        return f(v, attrs, was_new);\n                    }\n                }\n                else if (types_1.isArray(v)) {\n                    results = [];\n                    for (l = 0, len1 = v.length; l < len1; l++) {\n                        e = v[l];\n                        results.push(foreach_value(e, f));\n                    }\n                    return results;\n                }\n                else if (types_1.isObject(v)) {\n                    results1 = [];\n                    for (k in v) {\n                        e = v[k];\n                        results1.push(foreach_value(e, f));\n                    }\n                    return results1;\n                }\n            };\n            results = [];\n            for (k in items) {\n                v = items[k];\n                results.push(foreach_value(v[0], f));\n            }\n            return results;\n        };\n        foreach_depth_first(to_update, function (instance, attrs, was_new) {\n            if (was_new) {\n                return instance.setv(attrs);\n            }\n        });\n        return foreach_depth_first(to_update, function (instance, attrs, was_new) {\n            if (was_new) {\n                return instance.initialize(attrs);\n            }\n        });\n    };\n    Document._event_for_attribute_change = function (changed_obj, key, new_value, doc, value_refs) {\n        var changed_model, event;\n        changed_model = doc.get_model_by_id(changed_obj.id);\n        if (!changed_model.attribute_is_serializable(key)) {\n            return null;\n        }\n        event = {\n            'kind': 'ModelChanged',\n            'model': {\n                id: changed_obj.id,\n                type: changed_obj.type\n            },\n            'attr': key,\n            'new': new_value\n        };\n        has_props_1.HasProps._json_record_references(doc, new_value, value_refs, true);\n        return event;\n    };\n    Document._events_to_sync_objects = function (from_obj, to_obj, to_doc, value_refs) {\n        var added, events, from_keys, j, key, l, len, len1, len2, n, new_value, old_value, removed, shared, to_keys;\n        from_keys = Object.keys(from_obj.attributes);\n        to_keys = Object.keys(to_obj.attributes);\n        removed = array_1.difference(from_keys, to_keys);\n        added = array_1.difference(to_keys, from_keys);\n        shared = array_1.intersection(from_keys, to_keys);\n        events = [];\n        for (j = 0, len = removed.length; j < len; j++) {\n            key = removed[j];\n            logging_1.logger.warn(\"Server sent key \" + key + \" but we don't seem to have it in our JSON\");\n        }\n        for (l = 0, len1 = added.length; l < len1; l++) {\n            key = added[l];\n            new_value = to_obj.attributes[key];\n            events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n        }\n        for (n = 0, len2 = shared.length; n < len2; n++) {\n            key = shared[n];\n            old_value = from_obj.attributes[key];\n            new_value = to_obj.attributes[key];\n            if (old_value === null && new_value === null) {\n            }\n            else if (old_value === null || new_value === null) {\n                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n            }\n            else {\n                if (!eq_1.isEqual(old_value, new_value)) {\n                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n                }\n            }\n        }\n        return events.filter(function (e) {\n            return e !== null;\n        });\n    };\n    Document._compute_patch_since_json = function (from_json, to_doc) {\n        var events, from_references, from_root_ids, from_roots, id, include_defaults, j, l, len, len1, model, r, ref1, ref2, ref3, refs, to_json, to_references, to_root_ids, to_roots, update_model_events, value_refs;\n        to_json = to_doc.to_json(include_defaults = false);\n        refs = function (json) {\n            var j, len, obj, ref1, result;\n            result = {};\n            ref1 = json['roots']['references'];\n            for (j = 0, len = ref1.length; j < len; j++) {\n                obj = ref1[j];\n                result[obj.id] = obj;\n            }\n            return result;\n        };\n        from_references = refs(from_json);\n        from_roots = {};\n        from_root_ids = [];\n        ref1 = from_json['roots']['root_ids'];\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            from_roots[r] = from_references[r];\n            from_root_ids.push(r);\n        }\n        to_references = refs(to_json);\n        to_roots = {};\n        to_root_ids = [];\n        ref2 = to_json['roots']['root_ids'];\n        for (l = 0, len1 = ref2.length; l < len1; l++) {\n            r = ref2[l];\n            to_roots[r] = to_references[r];\n            to_root_ids.push(r);\n        }\n        from_root_ids.sort();\n        to_root_ids.sort();\n        if (array_1.difference(from_root_ids, to_root_ids).length > 0 || array_1.difference(to_root_ids, from_root_ids).length > 0) {\n            throw new Error(\"Not implemented: computing add/remove of document roots\");\n        }\n        value_refs = {};\n        events = [];\n        ref3 = to_doc._all_models;\n        for (id in ref3) {\n            model = ref3[id];\n            if (id in from_references) {\n                update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);\n                events = events.concat(update_model_events);\n            }\n        }\n        return {\n            'events': events,\n            'references': Document._references_json(object_1.values(value_refs), include_defaults = false)\n        };\n    };\n    Document.prototype.to_json_string = function (include_defaults) {\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        return JSON.stringify(this.to_json(include_defaults));\n    };\n    Document.prototype.to_json = function (include_defaults) {\n        var j, len, r, ref1, root_ids, root_references;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        root_ids = [];\n        ref1 = this._roots;\n        for (j = 0, len = ref1.length; j < len; j++) {\n            r = ref1[j];\n            root_ids.push(r.id);\n        }\n        root_references = object_1.values(this._all_models);\n        return {\n            'title': this._title,\n            'roots': {\n                'root_ids': root_ids,\n                'references': Document._references_json(root_references, include_defaults)\n            }\n        };\n    };\n    Document.from_json_string = function (s) {\n        var json;\n        if (s === null || (s == null)) {\n            throw new Error(\"JSON string is \" + (typeof s));\n        }\n        json = JSON.parse(s);\n        return Document.from_json(json);\n    };\n    Document.from_json = function (json) {\n        var doc, is_dev, j, len, py_version, r, references, references_json, root_ids, roots_json, versions_string;\n        logging_1.logger.debug(\"Creating Document from JSON\");\n        if (typeof json !== 'object') {\n            throw new Error(\"JSON object has wrong type \" + (typeof json));\n        }\n        py_version = json['version'];\n        is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\n        versions_string = \"Library versions: JS (\" + version_1.version + \")  /  Python (\" + py_version + \")\";\n        if (!is_dev && version_1.version !== py_version) {\n            logging_1.logger.warn(\"JS/Python version mismatch\");\n            logging_1.logger.warn(versions_string);\n        }\n        else {\n            logging_1.logger.debug(versions_string);\n        }\n        roots_json = json['roots'];\n        root_ids = roots_json['root_ids'];\n        references_json = roots_json['references'];\n        references = Document._instantiate_references_json(references_json, {});\n        Document._initialize_references_json(references_json, {}, references);\n        doc = new Document();\n        for (j = 0, len = root_ids.length; j < len; j++) {\n            r = root_ids[j];\n            doc.add_root(references[r]);\n        }\n        doc.set_title(json['title']);\n        return doc;\n    };\n    Document.prototype.replace_with_json = function (json) {\n        var replacement;\n        replacement = Document.from_json(json);\n        return replacement.destructively_move(this);\n    };\n    Document.prototype.create_json_patch_string = function (events) {\n        return JSON.stringify(this.create_json_patch(events));\n    };\n    Document.prototype.create_json_patch = function (events) {\n        var event, j, json_events, len, references, result;\n        references = {};\n        json_events = [];\n        for (j = 0, len = events.length; j < len; j++) {\n            event = events[j];\n            if (event.document !== this) {\n                logging_1.logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\n                throw new Error(\"Cannot create a patch using events from a different document\");\n            }\n            json_events.push(event.json(references));\n        }\n        return result = {\n            events: json_events,\n            references: Document._references_json(object_1.values(references))\n        };\n    };\n    Document.prototype.apply_json_patch_string = function (patch) {\n        return this.apply_json_patch(JSON.parse(patch));\n    };\n    Document.prototype.apply_json_patch = function (patch, setter_id) {\n        var attr, column_source, column_source_id, data, event_json, events_json, id, j, l, len, len1, model_id, model_type, new_references, obj1, old_references, patched_id, patched_obj, patches, ref1, references, references_json, results, rollover, root_id, root_obj, shapes, value;\n        references_json = patch['references'];\n        events_json = patch['events'];\n        references = Document._instantiate_references_json(references_json, this._all_models);\n        for (j = 0, len = events_json.length; j < len; j++) {\n            event_json = events_json[j];\n            if ('model' in event_json) {\n                model_id = event_json['model']['id'];\n                if (model_id in this._all_models) {\n                    references[model_id] = this._all_models[model_id];\n                }\n                else {\n                    if (!(model_id in references)) {\n                        logging_1.logger.warn(\"Got an event for unknown model \", event_json['model']);\n                        throw new Error(\"event model wasn't known\");\n                    }\n                }\n            }\n        }\n        old_references = {};\n        new_references = {};\n        for (id in references) {\n            value = references[id];\n            if (id in this._all_models) {\n                old_references[id] = value;\n            }\n            else {\n                new_references[id] = value;\n            }\n        }\n        Document._initialize_references_json(references_json, old_references, new_references);\n        results = [];\n        for (l = 0, len1 = events_json.length; l < len1; l++) {\n            event_json = events_json[l];\n            switch (event_json.kind) {\n                case 'ModelChanged':\n                    patched_id = event_json['model']['id'];\n                    if (!(patched_id in this._all_models)) {\n                        throw new Error(\"Cannot apply patch to \" + patched_id + \" which is not in the document\");\n                    }\n                    patched_obj = this._all_models[patched_id];\n                    attr = event_json['attr'];\n                    model_type = event_json['model']['type'];\n                    if (attr === 'data' && model_type === 'ColumnDataSource') {\n                        ref1 = serialization_1.decode_column_data(event_json['new']), data = ref1[0], shapes = ref1[1];\n                        results.push(patched_obj.setv({\n                            _shapes: shapes,\n                            data: data\n                        }, {\n                            setter_id: setter_id\n                        }));\n                    }\n                    else {\n                        value = Document._resolve_refs(event_json['new'], old_references, new_references);\n                        results.push(patched_obj.setv((obj1 = {},\n                            obj1[\"\" + attr] = value,\n                            obj1), {\n                            setter_id: setter_id\n                        }));\n                    }\n                    break;\n                case 'ColumnsStreamed':\n                    column_source_id = event_json['column_source']['id'];\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(\"Cannot stream to \" + column_source_id + \" which is not in the document\");\n                    }\n                    column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                        throw new Error(\"Cannot stream to non-ColumnDataSource\");\n                    }\n                    data = event_json['data'];\n                    rollover = event_json['rollover'];\n                    results.push(column_source.stream(data, rollover));\n                    break;\n                case 'ColumnsPatched':\n                    column_source_id = event_json['column_source']['id'];\n                    if (!(column_source_id in this._all_models)) {\n                        throw new Error(\"Cannot patch \" + column_source_id + \" which is not in the document\");\n                    }\n                    column_source = this._all_models[column_source_id];\n                    if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                        throw new Error(\"Cannot patch non-ColumnDataSource\");\n                    }\n                    patches = event_json['patches'];\n                    results.push(column_source.patch(patches));\n                    break;\n                case 'RootAdded':\n                    root_id = event_json['model']['id'];\n                    root_obj = references[root_id];\n                    results.push(this.add_root(root_obj, setter_id));\n                    break;\n                case 'RootRemoved':\n                    root_id = event_json['model']['id'];\n                    root_obj = references[root_id];\n                    results.push(this.remove_root(root_obj, setter_id));\n                    break;\n                case 'TitleChanged':\n                    results.push(this.set_title(event_json['title'], setter_id));\n                    break;\n                default:\n                    throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\n            }\n        }\n        return results;\n    };\n    return Document;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _create_view, _get_session, _handle_notebook_comms, _init_comms, _render_document_to_element, _sessions, _update_comms_callback, add_document_from_session, add_model_from_session, add_model_static, fill_render_item_from_script_tag;\nvar base = require(\"./base\");\nvar client_1 = require(\"./client\");\nvar logging_1 = require(\"./core/logging\");\nvar document_1 = require(\"./document\");\nvar dom_1 = require(\"./core/dom\");\nvar callback_1 = require(\"./core/util/callback\");\nexports.BOKEH_ROOT = \"bk-root\";\n_handle_notebook_comms = function (msg) {\n    var data;\n    logging_1.logger.debug(\"handling notebook comms\");\n    data = JSON.parse(msg.content.data);\n    if ('events' in data && 'references' in data) {\n        return this.apply_json_patch(data);\n    }\n    else if ('doc' in data) {\n        return this.replace_with_json(data['doc']);\n    }\n    else {\n        throw new Error(\"handling notebook comms message: \", msg);\n    }\n};\n_update_comms_callback = function (target, doc, comm) {\n    if (target === comm.target_name) {\n        return comm.on_msg(_handle_notebook_comms.bind(doc));\n    }\n};\n_init_comms = function (target, doc) {\n    var comm_manager, e, id, promise, ref, update_comms;\n    if ((typeof Jupyter !== \"undefined\" && Jupyter !== null) && (Jupyter.notebook.kernel != null)) {\n        logging_1.logger.info(\"Registering Jupyter comms for target \" + target);\n        comm_manager = Jupyter.notebook.kernel.comm_manager;\n        update_comms = function (comm) {\n            return _update_comms_callback(target, doc, comm);\n        };\n        ref = comm_manager.comms;\n        for (id in ref) {\n            promise = ref[id];\n            promise.then(update_comms);\n        }\n        try {\n            return comm_manager.register_target(target, function (comm, msg) {\n                logging_1.logger.info(\"Registering Jupyter comms for target \" + target);\n                return comm.on_msg(_handle_notebook_comms.bind(doc));\n            });\n        }\n        catch (error1) {\n            e = error1;\n            return logging_1.logger.warn(\"Jupyter comms failed to register. push_notebook() will not function. (exception reported: \" + e + \")\");\n        }\n    }\n    else {\n        return console.warn('Jupyter notebooks comms not available. push_notebook() will not function');\n    }\n};\n_create_view = function (model) {\n    var view;\n    view = new model.default_view({\n        model: model\n    });\n    base.index[model.id] = view;\n    return view;\n};\n_render_document_to_element = function (element, document, use_for_title) {\n    var i, len, model, ref, render_model, unrender_model, views;\n    views = {};\n    render_model = function (model) {\n        var view;\n        view = _create_view(model);\n        views[model.id] = view;\n        return element.appendChild(view.el);\n    };\n    unrender_model = function (model) {\n        var view;\n        if (model.id in views) {\n            view = views[model.id];\n            element.removeChild(view.el);\n            delete views[model.id];\n            return delete base.index[model.id];\n        }\n    };\n    ref = document.roots();\n    for (i = 0, len = ref.length; i < len; i++) {\n        model = ref[i];\n        render_model(model);\n    }\n    if (use_for_title) {\n        window.document.title = document.title();\n    }\n    document.on_change(function (event) {\n        if (event instanceof document_1.RootAddedEvent) {\n            return render_model(event.model);\n        }\n        else if (event instanceof document_1.RootRemovedEvent) {\n            return unrender_model(event.model);\n        }\n        else if (use_for_title && event instanceof document_1.TitleChangedEvent) {\n            return window.document.title = event.title;\n        }\n    });\n    return views;\n};\nadd_model_static = function (element, model_id, doc) {\n    var model, view;\n    model = doc.get_model_by_id(model_id);\n    if (model == null) {\n        throw new Error(\"Model \" + model_id + \" was not in document \" + doc);\n    }\n    view = _create_view(model);\n    return callback_1.delay(function () {\n        return dom_1.replaceWith(element, view.el);\n    });\n};\nexports.add_document_static = function (element, doc, use_for_title) {\n    return callback_1.delay(function () {\n        return _render_document_to_element(element, doc, use_for_title);\n    });\n};\nexports.add_document_standalone = function (document, element, use_for_title) {\n    if (use_for_title == null) {\n        use_for_title = false;\n    }\n    return _render_document_to_element(element, document, use_for_title);\n};\n_sessions = {};\n_get_session = function (websocket_url, session_id, args_string) {\n    var subsessions;\n    if ((websocket_url == null) || websocket_url === null) {\n        throw new Error(\"Missing websocket_url\");\n    }\n    if (!(websocket_url in _sessions)) {\n        _sessions[websocket_url] = {};\n    }\n    subsessions = _sessions[websocket_url];\n    if (!(session_id in subsessions)) {\n        subsessions[session_id] = client_1.pull_session(websocket_url, session_id, args_string);\n    }\n    return subsessions[session_id];\n};\nadd_document_from_session = function (element, websocket_url, session_id, use_for_title) {\n    var args_string, promise;\n    args_string = window.location.search.substr(1);\n    promise = _get_session(websocket_url, session_id, args_string);\n    return promise.then(function (session) {\n        return _render_document_to_element(element, session.document, use_for_title);\n    }, function (error) {\n        logging_1.logger.error(\"Failed to load Bokeh session \" + session_id + \": \" + error);\n        throw error;\n    });\n};\nadd_model_from_session = function (element, websocket_url, model_id, session_id) {\n    var args_string, promise;\n    args_string = window.location.search.substr(1);\n    promise = _get_session(websocket_url, session_id, args_string);\n    return promise.then(function (session) {\n        var model, view;\n        model = session.document.get_model_by_id(model_id);\n        if (model == null) {\n            throw new Error(\"Did not find model \" + model_id + \" in session\");\n        }\n        view = _create_view(model);\n        return dom_1.replaceWith(element, view.el);\n    }, function (error) {\n        logging_1.logger.error(\"Failed to load Bokeh session \" + session_id + \": \" + error);\n        throw error;\n    });\n};\nexports.inject_css = function (url) {\n    var element;\n    element = dom_1.link({\n        href: url,\n        rel: \"stylesheet\",\n        type: \"text/css\"\n    });\n    return document.body.appendChild(element);\n};\nexports.inject_raw_css = function (css) {\n    var element;\n    element = dom_1.style({}, css);\n    return document.body.appendChild(element);\n};\nfill_render_item_from_script_tag = function (script, item) {\n    var info;\n    info = script.dataset;\n    if ((info.bokehLogLevel != null) && info.bokehLogLevel.length > 0) {\n        logging_1.set_log_level(info.bokehLogLevel);\n    }\n    if ((info.bokehDocId != null) && info.bokehDocId.length > 0) {\n        item['docid'] = info.bokehDocId;\n    }\n    if ((info.bokehModelId != null) && info.bokehModelId.length > 0) {\n        item['modelid'] = info.bokehModelId;\n    }\n    if ((info.bokehSessionId != null) && info.bokehSessionId.length > 0) {\n        item['sessionid'] = info.bokehSessionId;\n    }\n    return logging_1.logger.info(\"Will inject Bokeh script tag with params \" + (JSON.stringify(item)));\n};\nexports.embed_items = function (docs_json, render_items, app_path, absolute_url) {\n    var child, container, docid, docs, elem, element_id, i, item, len, loc, promise, protocol, results, use_for_title, websocket_url;\n    protocol = 'ws:';\n    if (window.location.protocol === 'https:') {\n        protocol = 'wss:';\n    }\n    if (absolute_url != null) {\n        loc = new URL(absolute_url);\n    }\n    else {\n        loc = window.location;\n    }\n    if (app_path != null) {\n        if (app_path === \"/\") {\n            app_path = \"\";\n        }\n    }\n    else {\n        app_path = loc.pathname.replace(/\\/+$/, '');\n    }\n    websocket_url = protocol + '//' + loc.host + app_path + '/ws';\n    logging_1.logger.debug(\"embed: computed ws url: \" + websocket_url);\n    docs = {};\n    for (docid in docs_json) {\n        docs[docid] = document_1.Document.from_json(docs_json[docid]);\n    }\n    results = [];\n    for (i = 0, len = render_items.length; i < len; i++) {\n        item = render_items[i];\n        if (item.notebook_comms_target != null) {\n            _init_comms(item.notebook_comms_target, docs[docid]);\n        }\n        element_id = item['elementid'];\n        elem = document.getElementById(element_id);\n        if (elem == null) {\n            throw new Error(\"Error rendering Bokeh model: could not find tag with id: \" + element_id);\n        }\n        if (!document.body.contains(elem)) {\n            throw new Error(\"Error rendering Bokeh model: element with id '\" + element_id + \"' must be under <body>\");\n        }\n        if (elem.tagName === \"SCRIPT\") {\n            fill_render_item_from_script_tag(elem, item);\n            container = dom_1.div({\n                \"class\": exports.BOKEH_ROOT\n            });\n            dom_1.replaceWith(elem, container);\n            child = dom_1.div();\n            container.appendChild(child);\n            elem = child;\n        }\n        use_for_title = (item.use_for_title != null) && item.use_for_title;\n        promise = null;\n        if (item.modelid != null) {\n            if (item.docid != null) {\n                add_model_static(elem, item.modelid, docs[item.docid]);\n            }\n            else if (item.sessionid != null) {\n                promise = add_model_from_session(elem, websocket_url, item.modelid, item.sessionid);\n            }\n            else {\n                throw new Error(\"Error rendering Bokeh model \" + item['modelid'] + \" to element \" + element_id + \": no document ID or session ID specified\");\n            }\n        }\n        else {\n            if (item.docid != null) {\n                exports.add_document_static(elem, docs[item.docid], use_for_title);\n            }\n            else if (item.sessionid != null) {\n                promise = add_document_from_session(elem, websocket_url, item.sessionid, use_for_title);\n            }\n            else {\n                throw new Error(\"Error rendering Bokeh document to element \" + element_id + \": no document ID or session ID specified\");\n            }\n        }\n        if (promise !== null) {\n            results.push(promise.then(function (value) {\n                return console.log(\"Bokeh items were rendered successfully\");\n            }, function (error) {\n                return console.log(\"Error rendering Bokeh items \", error);\n            }));\n        }\n        else {\n            results.push(void 0);\n        }\n    }\n    return results;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar version_1 = require(\"./version\");\nexports.version = version_1.version;\nvar embed = require(\"./embed\");\nexports.embed = embed;\nvar logging_1 = require(\"./core/logging\");\nexports.logger = logging_1.logger;\nexports.set_log_level = logging_1.set_log_level;\nvar base_1 = require(\"./base\");\nexports.Models = base_1.Models;\nexports.index = base_1.index;\nvar safely_1 = require(\"./safely\");\nexports.safely = safely_1.safely;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar has_props_1 = require(\"./core/has_props\");\nvar p = require(\"./core/properties\");\nvar types_1 = require(\"./core/util/types\");\nvar object_1 = require(\"./core/util/object\");\nvar logging_1 = require(\"./core/logging\");\nexports.Model = (function (superClass) {\n    extend(Model, superClass);\n    function Model() {\n        return Model.__super__.constructor.apply(this, arguments);\n    }\n    Model.prototype.type = \"Model\";\n    Model.define({\n        tags: [p.Array, []],\n        name: [p.String],\n        js_property_callbacks: [p.Any, {}],\n        js_event_callbacks: [p.Any, {}],\n        subscribed_events: [p.Array, []]\n    });\n    Model.prototype.initialize = function (options) {\n        var callbacks, cb, evt, i, len, ref1;\n        Model.__super__.initialize.call(this, options);\n        ref1 = this.js_property_callbacks;\n        for (evt in ref1) {\n            callbacks = ref1[evt];\n            for (i = 0, len = callbacks.length; i < len; i++) {\n                cb = callbacks[i];\n                this.listenTo(this, evt, function () {\n                    return cb.execute(this);\n                });\n            }\n        }\n        this.listenTo(this, 'change:js_event_callbacks', function () {\n            return this._update_event_callbacks;\n        });\n        return this.listenTo(this, 'change:subscribed_events', function () {\n            return this._update_event_callbacks;\n        });\n    };\n    Model.prototype._process_event = function (event) {\n        var callback, i, len, ref1, ref2;\n        if (event.is_applicable_to(this)) {\n            event = event._customize_event(this);\n            ref2 = (ref1 = this.js_event_callbacks[event.event_name]) != null ? ref1 : [];\n            for (i = 0, len = ref2.length; i < len; i++) {\n                callback = ref2[i];\n                callback.execute(event, {});\n            }\n            if (this.subscribed_events.some(function (m) {\n                return m === event.event_name;\n            })) {\n                return this.document.event_manager.send_event(event);\n            }\n        }\n    };\n    Model.prototype.trigger_event = function (event) {\n        var ref1;\n        return (ref1 = this.document) != null ? ref1.event_manager.trigger(event.set_model_id(this.id)) : void 0;\n    };\n    Model.prototype._update_event_callbacks = function () {\n        if (this.document == null) {\n            logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');\n            return;\n        }\n        return this.document.event_manager.subscribed_models.push(this.id);\n    };\n    Model.prototype._doc_attached = function () {\n        if (!object_1.isEmpty(this.js_event_callbacks) || !object_1.isEmpty(this.subscribed_events)) {\n            return this._update_event_callbacks();\n        }\n    };\n    Model.prototype.select = function (selector) {\n        if (selector.prototype instanceof Model) {\n            return this.references().filter(function (ref) {\n                return ref instanceof selector;\n            });\n        }\n        else if (types_1.isString(selector)) {\n            return this.references().filter(function (ref) {\n                return ref.name === selector;\n            });\n        }\n        else {\n            throw new Error(\"invalid selector\");\n        }\n    };\n    Model.prototype.select_one = function (selector) {\n        var result;\n        result = this.select(selector);\n        switch (result.length) {\n            case 0:\n                return null;\n            case 1:\n                return result[0];\n            default:\n                throw new Error(\"found more than one object matching given selector\");\n        }\n    };\n    return Model;\n})(has_props_1.HasProps);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar side_panel_1 = require(\"core/layout/side_panel\");\nvar p = require(\"core/properties\");\nvar renderer_1 = require(\"../renderers/renderer\");\nexports.AnnotationView = (function (superClass) {\n    extend(AnnotationView, superClass);\n    function AnnotationView() {\n        return AnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    AnnotationView.prototype._get_panel_offset = function () {\n        var x, y;\n        x = this.model.panel._left._value;\n        y = this.model.panel._bottom._value;\n        return {\n            x: x,\n            y: -y\n        };\n    };\n    AnnotationView.prototype._get_size = function () {\n        return -1;\n    };\n    return AnnotationView;\n})(renderer_1.RendererView);\nexports.Annotation = (function (superClass) {\n    extend(Annotation, superClass);\n    function Annotation() {\n        return Annotation.__super__.constructor.apply(this, arguments);\n    }\n    Annotation.prototype.type = 'Annotation';\n    Annotation.prototype.default_view = exports.AnnotationView;\n    Annotation.define({\n        plot: [p.Instance]\n    });\n    Annotation.override({\n        level: 'annotation'\n    });\n    Annotation.prototype.add_panel = function (side) {\n        this.panel = new side_panel_1.SidePanel({\n            side: side\n        });\n        this.panel.attach_document(this.document);\n        return this.level = 'overlay';\n    };\n    return Annotation;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar arrow_head_1 = require(\"./arrow_head\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.ArrowView = (function (superClass) {\n    extend(ArrowView, superClass);\n    function ArrowView() {\n        return ArrowView.__super__.constructor.apply(this, arguments);\n    }\n    ArrowView.prototype.initialize = function (options) {\n        ArrowView.__super__.initialize.call(this, options);\n        if (this.model.source == null) {\n            this.model.source = new column_data_source_1.ColumnDataSource();\n        }\n        this.canvas = this.plot_model.canvas;\n        this.xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        this.ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        return this.set_data(this.model.source);\n    };\n    ArrowView.prototype.bind_bokeh_events = function () {\n        this.listenTo(this.model, 'change', this.plot_view.request_render);\n        return this.listenTo(this.model.source, 'change', function () {\n            this.set_data(this.model.source);\n            return this.plot_view.request_render();\n        });\n    };\n    ArrowView.prototype.set_data = function (source) {\n        ArrowView.__super__.set_data.call(this, source);\n        return this.visuals.warm_cache(source);\n    };\n    ArrowView.prototype._map_data = function () {\n        var end, start, x_name, y_name;\n        if (this.model.start_units === 'data') {\n            start = this.plot_view.map_to_screen(this._x_start, this._y_start, x_name = this.model.x_range_name, y_name = this.model.y_range_name);\n        }\n        else {\n            start = [this.canvas.v_vx_to_sx(this._x_start), this.canvas.v_vy_to_sy(this._y_start)];\n        }\n        if (this.model.end_units === 'data') {\n            end = this.plot_view.map_to_screen(this._x_end, this._y_end, x_name = this.model.x_range_name, y_name = this.model.y_range_name);\n        }\n        else {\n            end = [this.canvas.v_vx_to_sx(this._x_end), this.canvas.v_vy_to_sy(this._y_end)];\n        }\n        return [start, end];\n    };\n    ArrowView.prototype.render = function () {\n        var ctx, ref;\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        ref = this._map_data(), this.start = ref[0], this.end = ref[1];\n        if (this.model.end != null) {\n            this._arrow_head(ctx, \"render\", this.model.end, this.start, this.end);\n        }\n        if (this.model.start != null) {\n            this._arrow_head(ctx, \"render\", this.model.start, this.end, this.start);\n        }\n        ctx.beginPath();\n        ctx.rect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.model.end != null) {\n            this._arrow_head(ctx, \"clip\", this.model.end, this.start, this.end);\n        }\n        if (this.model.start != null) {\n            this._arrow_head(ctx, \"clip\", this.model.start, this.end, this.start);\n        }\n        ctx.closePath();\n        ctx.clip();\n        this._arrow_body(ctx);\n        return ctx.restore();\n    };\n    ArrowView.prototype._arrow_body = function (ctx) {\n        var i, j, ref, results;\n        if (!this.visuals.line.doit) {\n            return;\n        }\n        results = [];\n        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.beginPath();\n            ctx.moveTo(this.start[0][i], this.start[1][i]);\n            ctx.lineTo(this.end[0][i], this.end[1][i]);\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    ArrowView.prototype._arrow_head = function (ctx, action, head, start, end) {\n        var angle, i, j, ref, results;\n        results = [];\n        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            angle = Math.PI / 2 + math_1.atan2([start[0][i], start[1][i]], [end[0][i], end[1][i]]);\n            ctx.save();\n            ctx.translate(end[0][i], end[1][i]);\n            ctx.rotate(angle);\n            if (action === \"render\") {\n                head.render(ctx);\n            }\n            else if (action === \"clip\") {\n                head.clip(ctx);\n            }\n            results.push(ctx.restore());\n        }\n        return results;\n    };\n    return ArrowView;\n})(annotation_1.AnnotationView);\nexports.Arrow = (function (superClass) {\n    extend(Arrow, superClass);\n    function Arrow() {\n        return Arrow.__super__.constructor.apply(this, arguments);\n    }\n    Arrow.prototype.default_view = exports.ArrowView;\n    Arrow.prototype.type = 'Arrow';\n    Arrow.mixins(['line']);\n    Arrow.define({\n        x_start: [p.NumberSpec],\n        y_start: [p.NumberSpec],\n        start_units: [p.String, 'data'],\n        start: [p.Instance, null],\n        x_end: [p.NumberSpec],\n        y_end: [p.NumberSpec],\n        end_units: [p.String, 'data'],\n        end: [p.Instance, new arrow_head_1.OpenHead({})],\n        source: [p.Instance],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    return Arrow;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar visuals_1 = require(\"core/visuals\");\nvar p = require(\"core/properties\");\nexports.ArrowHead = (function (superClass) {\n    extend(ArrowHead, superClass);\n    function ArrowHead() {\n        return ArrowHead.__super__.constructor.apply(this, arguments);\n    }\n    ArrowHead.prototype.type = 'ArrowHead';\n    ArrowHead.prototype.initialize = function (options) {\n        ArrowHead.__super__.initialize.call(this, options);\n        return this.visuals = new visuals_1.Visuals(this);\n    };\n    ArrowHead.prototype.render = function (ctx, i) {\n        return null;\n    };\n    ArrowHead.prototype.clip = function (ctx, i) {\n        return null;\n    };\n    return ArrowHead;\n})(annotation_1.Annotation);\nexports.OpenHead = (function (superClass) {\n    extend(OpenHead, superClass);\n    function OpenHead() {\n        return OpenHead.__super__.constructor.apply(this, arguments);\n    }\n    OpenHead.prototype.type = 'OpenHead';\n    OpenHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    OpenHead.prototype.render = function (ctx, i) {\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.beginPath();\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            return ctx.stroke();\n        }\n    };\n    OpenHead.mixins(['line']);\n    OpenHead.define({\n        size: [p.Number, 25]\n    });\n    return OpenHead;\n})(exports.ArrowHead);\nexports.NormalHead = (function (superClass) {\n    extend(NormalHead, superClass);\n    function NormalHead() {\n        return NormalHead.__super__.constructor.apply(this, arguments);\n    }\n    NormalHead.prototype.type = 'NormalHead';\n    NormalHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    NormalHead.prototype.render = function (ctx, i) {\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, i);\n            this._normal(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            this._normal(ctx, i);\n            return ctx.stroke();\n        }\n    };\n    NormalHead.prototype._normal = function (ctx, i) {\n        ctx.beginPath();\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        return ctx.closePath();\n    };\n    NormalHead.mixins(['line', 'fill']);\n    NormalHead.define({\n        size: [p.Number, 25]\n    });\n    NormalHead.override({\n        fill_color: 'black'\n    });\n    return NormalHead;\n})(exports.ArrowHead);\nexports.VeeHead = (function (superClass) {\n    extend(VeeHead, superClass);\n    function VeeHead() {\n        return VeeHead.__super__.constructor.apply(this, arguments);\n    }\n    VeeHead.prototype.type = 'VeeHead';\n    VeeHead.prototype.clip = function (ctx, i) {\n        this.visuals.line.set_vectorize(ctx, i);\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, -2);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0.5 * this.size);\n        return ctx.lineTo(0.5 * this.size, this.size);\n    };\n    VeeHead.prototype.render = function (ctx, i) {\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, i);\n            this._vee(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, i);\n            this._vee(ctx, i);\n            return ctx.stroke();\n        }\n    };\n    VeeHead.prototype._vee = function (ctx, i) {\n        ctx.beginPath();\n        ctx.moveTo(0.5 * this.size, this.size);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-0.5 * this.size, this.size);\n        ctx.lineTo(0, 0.5 * this.size);\n        return ctx.closePath();\n    };\n    VeeHead.mixins(['line', 'fill']);\n    VeeHead.define({\n        size: [p.Number, 25]\n    });\n    VeeHead.override({\n        fill_color: 'black'\n    });\n    return VeeHead;\n})(exports.ArrowHead);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.BoxAnnotationView = (function (superClass) {\n    extend(BoxAnnotationView, superClass);\n    function BoxAnnotationView() {\n        return BoxAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    BoxAnnotationView.prototype.initialize = function (options) {\n        BoxAnnotationView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.classList.add(\"bk-shading\");\n        return dom_1.hide(this.el);\n    };\n    BoxAnnotationView.prototype.bind_bokeh_events = function () {\n        if (this.model.render_mode === 'css') {\n            this.listenTo(this.model, 'change', this.render);\n            return this.listenTo(this.model, 'data_update', this.render);\n        }\n        else {\n            this.listenTo(this.model, 'change', this.plot_view.request_render);\n            return this.listenTo(this.model, 'data_update', this.plot_view.request_render);\n        }\n    };\n    BoxAnnotationView.prototype.render = function () {\n        var sbottom, sleft, sright, stop;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        if ((this.model.left == null) && (this.model.right == null) && (this.model.top == null) && (this.model.bottom == null)) {\n            dom_1.hide(this.el);\n            return null;\n        }\n        this.frame = this.plot_model.frame;\n        this.canvas = this.plot_model.canvas;\n        this.xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        this.ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        sleft = this.canvas.vx_to_sx(this._calc_dim(this.model.left, this.model.left_units, this.xmapper, this.frame.h_range.start));\n        sright = this.canvas.vx_to_sx(this._calc_dim(this.model.right, this.model.right_units, this.xmapper, this.frame.h_range.end));\n        sbottom = this.canvas.vy_to_sy(this._calc_dim(this.model.bottom, this.model.bottom_units, this.ymapper, this.frame.v_range.start));\n        stop = this.canvas.vy_to_sy(this._calc_dim(this.model.top, this.model.top_units, this.ymapper, this.frame.v_range.end));\n        if (this.model.render_mode === 'css') {\n            return this._css_box(sleft, sright, sbottom, stop);\n        }\n        else {\n            return this._canvas_box(sleft, sright, sbottom, stop);\n        }\n    };\n    BoxAnnotationView.prototype._css_box = function (sleft, sright, sbottom, stop) {\n        var ld, sh, sw;\n        sw = Math.abs(sright - sleft);\n        sh = Math.abs(sbottom - stop);\n        this.el.style.left = sleft + \"px\";\n        this.el.style.width = sw + \"px\";\n        this.el.style.top = stop + \"px\";\n        this.el.style.height = sh + \"px\";\n        this.el.style.borderWidth = this.model.line_width.value + \"px\";\n        this.el.style.borderColor = this.model.line_color.value;\n        this.el.style.backgroundColor = this.model.fill_color.value;\n        this.el.style.opacity = this.model.fill_alpha.value;\n        ld = this.model.line_dash;\n        if (types_1.isArray(ld)) {\n            ld = ld.length < 2 ? \"solid\" : \"dashed\";\n        }\n        if (types_1.isString(ld)) {\n            this.el.style.borderStyle = ld;\n        }\n        return dom_1.show(this.el);\n    };\n    BoxAnnotationView.prototype._canvas_box = function (sleft, sright, sbottom, stop) {\n        var ctx;\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(sleft, stop, sright - sleft, sbottom - stop);\n        this.visuals.fill.set_value(ctx);\n        ctx.fill();\n        this.visuals.line.set_value(ctx);\n        ctx.stroke();\n        return ctx.restore();\n    };\n    BoxAnnotationView.prototype._calc_dim = function (dim, dim_units, mapper, frame_extrema) {\n        var vdim;\n        if (dim != null) {\n            if (dim_units === 'data') {\n                vdim = mapper.map_to_target(dim);\n            }\n            else {\n                vdim = dim;\n            }\n        }\n        else {\n            vdim = frame_extrema;\n        }\n        return vdim;\n    };\n    return BoxAnnotationView;\n})(annotation_1.AnnotationView);\nexports.BoxAnnotation = (function (superClass) {\n    extend(BoxAnnotation, superClass);\n    function BoxAnnotation() {\n        return BoxAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    BoxAnnotation.prototype.default_view = exports.BoxAnnotationView;\n    BoxAnnotation.prototype.type = 'BoxAnnotation';\n    BoxAnnotation.mixins(['line', 'fill']);\n    BoxAnnotation.define({\n        render_mode: [p.RenderMode, 'canvas'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        top: [p.Number, null],\n        top_units: [p.SpatialUnits, 'data'],\n        bottom: [p.Number, null],\n        bottom_units: [p.SpatialUnits, 'data'],\n        left: [p.Number, null],\n        left_units: [p.SpatialUnits, 'data'],\n        right: [p.Number, null],\n        right_units: [p.SpatialUnits, 'data']\n    });\n    BoxAnnotation.override({\n        fill_color: '#fff9ba',\n        fill_alpha: 0.4,\n        line_color: '#cccccc',\n        line_alpha: 0.3\n    });\n    BoxAnnotation.prototype.update = function (arg) {\n        var bottom, left, right, top;\n        left = arg.left, right = arg.right, top = arg.top, bottom = arg.bottom;\n        this.setv({\n            left: left,\n            right: right,\n            top: top,\n            bottom: bottom\n        }, {\n            silent: true\n        });\n        return this.trigger('data_update');\n    };\n    return BoxAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LONG_DIM_MAX_SCALAR, LONG_DIM_MIN_SCALAR, SHORT_DIM, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar basic_ticker_1 = require(\"../tickers/basic_ticker\");\nvar basic_tick_formatter_1 = require(\"../formatters/basic_tick_formatter\");\nvar linear_color_mapper_1 = require(\"../mappers/linear_color_mapper\");\nvar linear_mapper_1 = require(\"../mappers/linear_mapper\");\nvar log_mapper_1 = require(\"../mappers/log_mapper\");\nvar range1d_1 = require(\"../ranges/range1d\");\nvar p = require(\"core/properties\");\nvar text_util = require(\"core/util/text\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nSHORT_DIM = 25;\nLONG_DIM_MIN_SCALAR = 0.3;\nLONG_DIM_MAX_SCALAR = 0.8;\nexports.ColorBarView = (function (superClass) {\n    extend(ColorBarView, superClass);\n    function ColorBarView() {\n        return ColorBarView.__super__.constructor.apply(this, arguments);\n    }\n    ColorBarView.prototype.initialize = function (options) {\n        ColorBarView.__super__.initialize.call(this, options);\n        return this._set_canvas_image();\n    };\n    ColorBarView.prototype.bind_bokeh_events = function () {\n        this.listenTo(this.model, 'change:visible', this.plot_view.request_render);\n        this.listenTo(this.model.ticker, 'change', this.plot_view.request_render);\n        this.listenTo(this.model.formatter, 'change', this.plot_view.request_render);\n        return this.listenTo(this.model.color_mapper, 'change', function () {\n            this._set_canvas_image();\n            return this.plot_view.request_render();\n        });\n    };\n    ColorBarView.prototype._get_panel_offset = function () {\n        var x, y;\n        x = this.model.panel._left._value;\n        y = this.model.panel._top._value;\n        return {\n            x: x,\n            y: -y\n        };\n    };\n    ColorBarView.prototype._get_size = function () {\n        var bbox, side;\n        bbox = this.compute_legend_dimensions();\n        side = this.model.panel.side;\n        if (side === 'above' || side === 'below') {\n            return bbox.height;\n        }\n        if (side === 'left' || side === 'right') {\n            return bbox.width;\n        }\n    };\n    ColorBarView.prototype._set_canvas_image = function () {\n        var buf, buf8, canvas, cmap, h, image_ctx, image_data, k, palette, ref, ref1, ref2, ref3, results, w;\n        palette = this.model.color_mapper.palette;\n        if (this.model.orientation === 'vertical') {\n            palette = palette.slice(0).reverse();\n        }\n        switch (this.model.orientation) {\n            case \"vertical\":\n                ref = [1, palette.length], w = ref[0], h = ref[1];\n                break;\n            case \"horizontal\":\n                ref1 = [palette.length, 1], w = ref1[0], h = ref1[1];\n        }\n        canvas = document.createElement('canvas');\n        ref2 = [w, h], canvas.width = ref2[0], canvas.height = ref2[1];\n        image_ctx = canvas.getContext('2d');\n        image_data = image_ctx.getImageData(0, 0, w, h);\n        cmap = new linear_color_mapper_1.LinearColorMapper({\n            palette: palette\n        });\n        buf = cmap.v_map_screen((function () {\n            results = [];\n            for (var k = 0, ref3 = palette.length; 0 <= ref3 ? k < ref3 : k > ref3; 0 <= ref3 ? k++ : k--) {\n                results.push(k);\n            }\n            return results;\n        }).apply(this));\n        buf8 = new Uint8Array(buf);\n        image_data.data.set(buf8);\n        image_ctx.putImageData(image_data, 0, 0);\n        return this.image = canvas;\n    };\n    ColorBarView.prototype.compute_legend_dimensions = function () {\n        var image_dimensions, image_height, image_width, label_extent, legend_height, legend_width, padding, ref, tick_extent, title_extent;\n        image_dimensions = this.model._computed_image_dimensions();\n        ref = [image_dimensions.height, image_dimensions.width], image_height = ref[0], image_width = ref[1];\n        label_extent = this._get_label_extent();\n        title_extent = this.model._title_extent();\n        tick_extent = this.model._tick_extent();\n        padding = this.model.padding;\n        switch (this.model.orientation) {\n            case \"vertical\":\n                legend_height = image_height + title_extent + padding * 2;\n                legend_width = image_width + tick_extent + label_extent + padding * 2;\n                break;\n            case \"horizontal\":\n                legend_height = image_height + title_extent + tick_extent + label_extent + padding * 2;\n                legend_width = image_width + padding * 2;\n        }\n        return {\n            height: legend_height,\n            width: legend_width\n        };\n    };\n    ColorBarView.prototype.compute_legend_location = function () {\n        var h_range, legend_dimensions, legend_height, legend_margin, legend_width, location, ref, sx, sy, v_range, x, y;\n        legend_dimensions = this.compute_legend_dimensions();\n        ref = [legend_dimensions.height, legend_dimensions.width], legend_height = ref[0], legend_width = ref[1];\n        legend_margin = this.model.margin;\n        location = this.model.location;\n        h_range = this.plot_view.frame.h_range;\n        v_range = this.plot_view.frame.v_range;\n        if (types_1.isString(location)) {\n            switch (location) {\n                case 'top_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'center_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'bottom_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'center_left':\n                    x = h_range.start + legend_margin;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n            }\n        }\n        else if (types_1.isArray(location) && location.length === 2) {\n            x = location[0], y = location[1];\n        }\n        sx = this.plot_view.canvas.vx_to_sx(x);\n        sy = this.plot_view.canvas.vy_to_sy(y);\n        return {\n            sx: sx,\n            sy: sy\n        };\n    };\n    ColorBarView.prototype.render = function () {\n        var ctx, frame_offset, image_offset, location, panel_offset;\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        if (this.model.panel != null) {\n            panel_offset = this._get_panel_offset();\n            ctx.translate(panel_offset.x, panel_offset.y);\n            frame_offset = this._get_frame_offset();\n            ctx.translate(frame_offset.x, frame_offset.y);\n        }\n        location = this.compute_legend_location();\n        ctx.translate(location.sx, location.sy);\n        this._draw_bbox(ctx);\n        image_offset = this._get_image_offset();\n        ctx.translate(image_offset.x, image_offset.y);\n        this._draw_image(ctx);\n        if ((this.model.color_mapper.low != null) && (this.model.color_mapper.high != null)) {\n            this._draw_major_ticks(ctx);\n            this._draw_minor_ticks(ctx);\n            this._draw_major_labels(ctx);\n        }\n        if (this.model.title) {\n            this._draw_title(ctx);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_bbox = function (ctx) {\n        var bbox;\n        bbox = this.compute_legend_dimensions();\n        ctx.save();\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fillRect(0, 0, bbox.width, bbox.height);\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            ctx.strokeRect(0, 0, bbox.width, bbox.height);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_image = function (ctx) {\n        var image;\n        image = this.model._computed_image_dimensions();\n        ctx.save();\n        ctx.setImageSmoothingEnabled(false);\n        ctx.globalAlpha = this.model.scale_alpha;\n        ctx.drawImage(this.image, 0, 0, image.width, image.height);\n        if (this.visuals.bar_line.doit) {\n            this.visuals.bar_line.set_value(ctx);\n            ctx.strokeRect(0, 0, image.width, image.height);\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_major_ticks = function (ctx) {\n        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;\n        if (!this.visuals.major_tick_line.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        ref2 = this.model._tick_coordinates().major, sx = ref2[0], sy = ref2[1];\n        tin = this.model.major_tick_in;\n        tout = this.model.major_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.major_tick_line.set_value(ctx);\n        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_minor_ticks = function (ctx) {\n        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;\n        if (!this.visuals.minor_tick_line.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        ref2 = this.model._tick_coordinates().minor, sx = ref2[0], sy = ref2[1];\n        tin = this.model.minor_tick_in;\n        tout = this.model.minor_tick_out;\n        ctx.save();\n        ctx.translate(x_offset, y_offset);\n        this.visuals.minor_tick_line.set_value(ctx);\n        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_major_labels = function (ctx) {\n        var formatted_labels, i, image, k, labels, nx, ny, ref, ref1, ref2, ref3, ref4, standoff, sx, sy, x_offset, x_standoff, y_offset, y_standoff;\n        if (!this.visuals.major_label_text.doit) {\n            return;\n        }\n        ref = this.model._normals(), nx = ref[0], ny = ref[1];\n        image = this.model._computed_image_dimensions();\n        ref1 = [image.width * nx, image.height * ny], x_offset = ref1[0], y_offset = ref1[1];\n        standoff = this.model.label_standoff + this.model._tick_extent();\n        ref2 = [standoff * nx, standoff * ny], x_standoff = ref2[0], y_standoff = ref2[1];\n        ref3 = this.model._tick_coordinates().major, sx = ref3[0], sy = ref3[1];\n        labels = this.model._tick_coordinates().major_labels;\n        formatted_labels = this.model.formatter.doFormat(labels, null);\n        this.visuals.major_label_text.set_value(ctx);\n        ctx.save();\n        ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\n        }\n        return ctx.restore();\n    };\n    ColorBarView.prototype._draw_title = function (ctx) {\n        if (!this.visuals.title_text.doit) {\n            return;\n        }\n        ctx.save();\n        this.visuals.title_text.set_value(ctx);\n        ctx.fillText(this.model.title, 0, -this.model.title_standoff);\n        return ctx.restore();\n    };\n    ColorBarView.prototype._get_label_extent = function () {\n        var ctx, formatted_labels, label, label_extent;\n        if ((this.model.color_mapper.low != null) && (this.model.color_mapper.high != null)) {\n            ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            this.visuals.major_label_text.set_value(ctx);\n            switch (this.model.orientation) {\n                case \"vertical\":\n                    formatted_labels = this.model.formatter.doFormat(this.model._tick_coordinates().major_labels);\n                    label_extent = array_1.max((function () {\n                        var k, len, results;\n                        results = [];\n                        for (k = 0, len = formatted_labels.length; k < len; k++) {\n                            label = formatted_labels[k];\n                            results.push(ctx.measureText(label.toString()).width);\n                        }\n                        return results;\n                    })());\n                    break;\n                case \"horizontal\":\n                    label_extent = text_util.get_text_height(this.visuals.major_label_text.font_value()).height;\n            }\n            label_extent += this.model.label_standoff;\n            ctx.restore();\n        }\n        else {\n            label_extent = 0;\n        }\n        return label_extent;\n    };\n    ColorBarView.prototype._get_frame_offset = function () {\n        var frame, panel, ref, xoff, yoff;\n        ref = [0, 0], xoff = ref[0], yoff = ref[1];\n        panel = this.model.panel;\n        frame = this.plot_view.frame;\n        switch (panel.side) {\n            case \"left\":\n            case \"right\":\n                yoff = Math.abs(panel.top - frame.top);\n                break;\n            case \"above\":\n            case \"below\":\n                xoff = Math.abs(frame.left);\n        }\n        return {\n            x: xoff,\n            y: yoff\n        };\n    };\n    ColorBarView.prototype._get_image_offset = function () {\n        var x, y;\n        x = this.model.padding;\n        y = this.model.padding + this.model._title_extent();\n        return {\n            x: x,\n            y: y\n        };\n    };\n    return ColorBarView;\n})(annotation_1.AnnotationView);\nexports.ColorBar = (function (superClass) {\n    extend(ColorBar, superClass);\n    function ColorBar() {\n        return ColorBar.__super__.constructor.apply(this, arguments);\n    }\n    ColorBar.prototype.default_view = exports.ColorBarView;\n    ColorBar.prototype.type = 'ColorBar';\n    ColorBar.mixins(['text:major_label_', 'text:title_', 'line:major_tick_', 'line:minor_tick_', 'line:border_', 'line:bar_', 'fill:background_']);\n    ColorBar.define({\n        location: [p.Any, 'top_right'],\n        orientation: [p.Orientation, 'vertical'],\n        title: [p.String],\n        title_standoff: [p.Number, 2],\n        height: [p.Any, 'auto'],\n        width: [p.Any, 'auto'],\n        scale_alpha: [p.Number, 1.0],\n        ticker: [\n            p.Instance, function () {\n                return new basic_ticker_1.BasicTicker();\n            }\n        ],\n        formatter: [\n            p.Instance, function () {\n                return new basic_tick_formatter_1.BasicTickFormatter();\n            }\n        ],\n        color_mapper: [p.Instance],\n        label_standoff: [p.Number, 5],\n        margin: [p.Number, 30],\n        padding: [p.Number, 10],\n        major_tick_in: [p.Number, 5],\n        major_tick_out: [p.Number, 0],\n        minor_tick_in: [p.Number, 0],\n        minor_tick_out: [p.Number, 0]\n    });\n    ColorBar.override({\n        background_fill_color: \"#ffffff\",\n        background_fill_alpha: 0.95,\n        bar_line_color: null,\n        border_line_color: null,\n        major_label_text_align: \"center\",\n        major_label_text_baseline: \"middle\",\n        major_label_text_font_size: \"8pt\",\n        major_tick_line_color: \"#ffffff\",\n        minor_tick_line_color: null,\n        title_text_font_size: \"10pt\",\n        title_text_font_style: \"italic\"\n    });\n    ColorBar.prototype.initialize = function (attrs, options) {\n        return ColorBar.__super__.initialize.call(this, attrs, options);\n    };\n    ColorBar.prototype._normals = function () {\n        var i, j, ref, ref1;\n        if (this.orientation === 'vertical') {\n            ref = [1, 0], i = ref[0], j = ref[1];\n        }\n        else {\n            ref1 = [0, 1], i = ref1[0], j = ref1[1];\n        }\n        return [i, j];\n    };\n    ColorBar.prototype._title_extent = function () {\n        var font_value, title_extent;\n        font_value = this.title_text_font + \" \" + this.title_text_font_size + \" \" + this.title_text_font_style;\n        title_extent = this.title ? text_util.get_text_height(font_value).height + this.title_standoff : 0;\n        return title_extent;\n    };\n    ColorBar.prototype._tick_extent = function () {\n        var tick_extent;\n        if ((this.color_mapper.low != null) && (this.color_mapper.high != null)) {\n            tick_extent = array_1.max([this.major_tick_out, this.minor_tick_out]);\n        }\n        else {\n            tick_extent = 0;\n        }\n        return tick_extent;\n    };\n    ColorBar.prototype._computed_image_dimensions = function () {\n        /*\n        Heuristics to determine ColorBar image dimensions if set to \"auto\"\n        \n        Note: Returns the height/width values for the ColorBar's scale image, not\n        the dimensions of the entire ColorBar.\n        \n        If the short dimension (the width of a vertical bar or height of a\n        horizontal bar) is set to \"auto\", the resulting dimension will be set to\n        25 px.\n        \n        For a ColorBar in a side panel with the long dimension (the height of a\n        vertical bar or width of a horizontal bar) set to \"auto\", the\n        resulting dimension will be as long as the adjacent frame edge, so that the\n        bar \"fits\" to the plot.\n        \n        For a ColorBar in the plot frame with the long dimension set to \"auto\", the\n        resulting dimension will be the greater of:\n          * The length of the color palette * 25px\n          * The parallel frame dimension * 0.30\n            (i.e the frame height for a vertical ColorBar)\n        But not greater than:\n          * The parallel frame dimension * 0.80\n         */\n        var frame_height, frame_width, height, title_extent, width;\n        frame_height = this.plot.plot_canvas.frame.height;\n        frame_width = this.plot.plot_canvas.frame.width;\n        title_extent = this._title_extent();\n        switch (this.orientation) {\n            case \"vertical\":\n                if (this.height === 'auto') {\n                    if (this.panel != null) {\n                        height = frame_height - 2 * this.padding - title_extent;\n                    }\n                    else {\n                        height = array_1.max([this.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\n                        height = array_1.min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.padding - title_extent]);\n                    }\n                }\n                else {\n                    height = this.height;\n                }\n                width = this.width === 'auto' ? SHORT_DIM : this.width;\n                break;\n            case \"horizontal\":\n                height = this.height === 'auto' ? SHORT_DIM : this.height;\n                if (this.width === 'auto') {\n                    if (this.panel != null) {\n                        width = frame_width - 2 * this.padding;\n                    }\n                    else {\n                        width = array_1.max([this.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\n                        width = array_1.min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.padding]);\n                    }\n                }\n                else {\n                    width = this.width;\n                }\n        }\n        return {\n            \"height\": height,\n            \"width\": width\n        };\n    };\n    ColorBar.prototype._tick_coordinate_mapper = function (scale_length) {\n        /*\n        Creates and returns a mapper instance that maps the `color_mapper` range\n        (low to high) to a screen space range equal to the length of the ColorBar's\n        scale image. The mapper is used to calculate the tick coordinates in screen\n        coordinates for plotting purposes.\n        \n        Note: the type of color_mapper has to match the type of mapper (i.e.\n        a LinearColorMapper will require a corresponding LinearMapper instance).\n         */\n        var mapper, mapping;\n        mapping = {\n            'source_range': new range1d_1.Range1d({\n                start: this.color_mapper.low,\n                end: this.color_mapper.high\n            }),\n            'target_range': new range1d_1.Range1d({\n                start: 0,\n                end: scale_length\n            })\n        };\n        switch (this.color_mapper.type) {\n            case \"LinearColorMapper\":\n                mapper = new linear_mapper_1.LinearMapper(mapping);\n                break;\n            case \"LogColorMapper\":\n                mapper = new log_mapper_1.LogMapper(mapping);\n        }\n        return mapper;\n    };\n    ColorBar.prototype._tick_coordinates = function () {\n        var coord, end, i, ii, image_dimensions, j, k, l, major_coords, major_labels, majors, mapper, minor_coords, minors, ref, ref1, ref2, ref3, scale_length, start, ticks;\n        image_dimensions = this._computed_image_dimensions();\n        switch (this.orientation) {\n            case \"vertical\":\n                scale_length = image_dimensions.height;\n                break;\n            case \"horizontal\":\n                scale_length = image_dimensions.width;\n        }\n        mapper = this._tick_coordinate_mapper(scale_length);\n        ref = this._normals(), i = ref[0], j = ref[1];\n        ref1 = [this.color_mapper.low, this.color_mapper.high], start = ref1[0], end = ref1[1];\n        ticks = this.ticker.get_ticks(start, end, null, null, this.ticker.desired_num_ticks);\n        majors = ticks.major;\n        minors = ticks.minor;\n        major_coords = [[], []];\n        minor_coords = [[], []];\n        for (ii = k = 0, ref2 = majors.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n            if (majors[ii] < start || majors[ii] > end) {\n                continue;\n            }\n            major_coords[i].push(majors[ii]);\n            major_coords[j].push(0);\n        }\n        for (ii = l = 0, ref3 = minors.length; 0 <= ref3 ? l < ref3 : l > ref3; ii = 0 <= ref3 ? ++l : --l) {\n            if (minors[ii] < start || minors[ii] > end) {\n                continue;\n            }\n            minor_coords[i].push(minors[ii]);\n            minor_coords[j].push(0);\n        }\n        major_labels = major_coords[i].slice(0);\n        major_coords[i] = mapper.v_map_to_target(major_coords[i]);\n        minor_coords[i] = mapper.v_map_to_target(minor_coords[i]);\n        if (this.orientation === 'vertical') {\n            major_coords[i] = new Float64Array((function () {\n                var len, m, ref4, results;\n                ref4 = major_coords[i];\n                results = [];\n                for (m = 0, len = ref4.length; m < len; m++) {\n                    coord = ref4[m];\n                    results.push(scale_length - coord);\n                }\n                return results;\n            })());\n            minor_coords[i] = new Float64Array((function () {\n                var len, m, ref4, results;\n                ref4 = minor_coords[i];\n                results = [];\n                for (m = 0, len = ref4.length; m < len; m++) {\n                    coord = ref4[m];\n                    results.push(scale_length - coord);\n                }\n                return results;\n            })());\n        }\n        return {\n            \"major\": major_coords,\n            \"minor\": minor_coords,\n            \"major_labels\": major_labels\n        };\n    };\n    return ColorBar;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar annotation_1 = require(\"./annotation\");\nexports.Annotation = annotation_1.Annotation;\nvar arrow_1 = require(\"./arrow\");\nexports.Arrow = arrow_1.Arrow;\nvar arrow_head_1 = require(\"./arrow_head\");\nexports.ArrowHead = arrow_head_1.ArrowHead;\nvar arrow_head_2 = require(\"./arrow_head\");\nexports.OpenHead = arrow_head_2.OpenHead;\nvar arrow_head_3 = require(\"./arrow_head\");\nexports.NormalHead = arrow_head_3.NormalHead;\nvar arrow_head_4 = require(\"./arrow_head\");\nexports.VeeHead = arrow_head_4.VeeHead;\nvar box_annotation_1 = require(\"./box_annotation\");\nexports.BoxAnnotation = box_annotation_1.BoxAnnotation;\nvar color_bar_1 = require(\"./color_bar\");\nexports.ColorBar = color_bar_1.ColorBar;\nvar label_1 = require(\"./label\");\nexports.Label = label_1.Label;\nvar label_set_1 = require(\"./label_set\");\nexports.LabelSet = label_set_1.LabelSet;\nvar legend_1 = require(\"./legend\");\nexports.Legend = legend_1.Legend;\nvar legend_item_1 = require(\"./legend_item\");\nexports.LegendItem = legend_item_1.LegendItem;\nvar poly_annotation_1 = require(\"./poly_annotation\");\nexports.PolyAnnotation = poly_annotation_1.PolyAnnotation;\nvar span_1 = require(\"./span\");\nexports.Span = span_1.Span;\nvar text_annotation_1 = require(\"./text_annotation\");\nexports.TextAnnotation = text_annotation_1.TextAnnotation;\nvar title_1 = require(\"./title\");\nexports.Title = title_1.Title;\nvar tooltip_1 = require(\"./tooltip\");\nexports.Tooltip = tooltip_1.Tooltip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.LabelView = (function (superClass) {\n    extend(LabelView, superClass);\n    function LabelView() {\n        return LabelView.__super__.constructor.apply(this, arguments);\n    }\n    LabelView.prototype.initialize = function (options) {\n        LabelView.__super__.initialize.call(this, options);\n        this.canvas = this.plot_model.canvas;\n        this.xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        this.ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        return this.visuals.warm_cache(null);\n    };\n    LabelView.prototype._get_size = function () {\n        var ctx, height, side, width;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        side = this.model.panel.side;\n        if (side === \"above\" || side === \"below\") {\n            height = ctx.measureText(this.model.text).ascent;\n            return height;\n        }\n        if (side === 'left' || side === 'right') {\n            width = ctx.measureText(this.model.text).width;\n            return width;\n        }\n    };\n    LabelView.prototype.render = function () {\n        var angle, ctx, panel_offset, sx, sy, vx, vy;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        switch (this.model.angle_units) {\n            case \"rad\":\n                angle = -1 * this.model.angle;\n                break;\n            case \"deg\":\n                angle = -1 * this.model.angle * Math.PI / 180.0;\n        }\n        if (this.model.x_units === \"data\") {\n            vx = this.xmapper.map_to_target(this.model.x);\n        }\n        else {\n            vx = this.model.x;\n        }\n        sx = this.canvas.vx_to_sx(vx);\n        if (this.model.y_units === \"data\") {\n            vy = this.ymapper.map_to_target(this.model.y);\n        }\n        else {\n            vy = this.model.y;\n        }\n        sy = this.canvas.vy_to_sy(vy);\n        if (this.model.panel != null) {\n            panel_offset = this._get_panel_offset();\n            sx += panel_offset.x;\n            sy += panel_offset.y;\n        }\n        if (this.model.render_mode === 'canvas') {\n            return this._canvas_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);\n        }\n        else {\n            return this._css_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);\n        }\n    };\n    return LabelView;\n})(text_annotation_1.TextAnnotationView);\nexports.Label = (function (superClass) {\n    extend(Label, superClass);\n    function Label() {\n        return Label.__super__.constructor.apply(this, arguments);\n    }\n    Label.prototype.default_view = exports.LabelView;\n    Label.prototype.type = 'Label';\n    Label.mixins(['text', 'line:border_', 'fill:background_']);\n    Label.define({\n        x: [p.Number],\n        x_units: [p.SpatialUnits, 'data'],\n        y: [p.Number],\n        y_units: [p.SpatialUnits, 'data'],\n        text: [p.String],\n        angle: [p.Angle, 0],\n        angle_units: [p.AngleUnits, 'rad'],\n        x_offset: [p.Number, 0],\n        y_offset: [p.Number, 0],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    Label.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    return Label;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.LabelSetView = (function (superClass) {\n    extend(LabelSetView, superClass);\n    function LabelSetView() {\n        return LabelSetView.__super__.constructor.apply(this, arguments);\n    }\n    LabelSetView.prototype.initialize = function (options) {\n        var i, j, ref, results;\n        LabelSetView.__super__.initialize.call(this, options);\n        this.xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        this.ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        this.set_data(this.model.source);\n        if (this.model.render_mode === 'css') {\n            results = [];\n            for (i = j = 0, ref = this._text.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                this.title_div = dom_1.div({\n                    \"class\": 'bk-annotation-child',\n                    style: {\n                        display: \"none\"\n                    }\n                });\n                results.push(this.el.appendChild(this.title_div));\n            }\n            return results;\n        }\n    };\n    LabelSetView.prototype.bind_bokeh_events = function () {\n        if (this.model.render_mode === 'css') {\n            this.listenTo(this.model, 'change', function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n            return this.listenTo(this.model.source, 'change', function () {\n                this.set_data(this.model.source);\n                return this.render();\n            });\n        }\n        else {\n            this.listenTo(this.model, 'change', function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n            return this.listenTo(this.model.source, 'change', function () {\n                this.set_data(this.model.source);\n                return this.plot_view.request_render();\n            });\n        }\n    };\n    LabelSetView.prototype.set_data = function (source) {\n        LabelSetView.__super__.set_data.call(this, source);\n        return this.visuals.warm_cache(source);\n    };\n    LabelSetView.prototype._map_data = function () {\n        var sx, sy, vx, vy;\n        if (this.model.x_units === \"data\") {\n            vx = this.xmapper.v_map_to_target(this._x);\n        }\n        else {\n            vx = this._x.slice(0);\n        }\n        sx = this.canvas.v_vx_to_sx(vx);\n        if (this.model.y_units === \"data\") {\n            vy = this.ymapper.v_map_to_target(this._y);\n        }\n        else {\n            vy = this._y.slice(0);\n        }\n        sy = this.canvas.v_vy_to_sy(vy);\n        return [sx, sy];\n    };\n    LabelSetView.prototype.render = function () {\n        var ctx, i, j, k, ref, ref1, ref2, results, results1, sx, sy;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ref = this._map_data(), sx = ref[0], sy = ref[1];\n        if (this.model.render_mode === 'canvas') {\n            results = [];\n            for (i = j = 0, ref1 = this._text.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this._v_canvas_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));\n            }\n            return results;\n        }\n        else {\n            results1 = [];\n            for (i = k = 0, ref2 = this._text.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                results1.push(this._v_css_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));\n            }\n            return results1;\n        }\n    };\n    LabelSetView.prototype._get_size = function () {\n        var ctx, height, side, width;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        side = this.model.panel.side;\n        if (side === \"above\" || side === \"below\") {\n            height = ctx.measureText(this._text[0]).ascent;\n            return height;\n        }\n        if (side === 'left' || side === 'right') {\n            width = ctx.measureText(this._text[0]).width;\n            return width;\n        }\n    };\n    LabelSetView.prototype._v_canvas_text = function (ctx, i, text, sx, sy, angle) {\n        var bbox_dims;\n        this.visuals.text.set_vectorize(ctx, i);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(sx, sy);\n        ctx.rotate(angle);\n        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n        if (this.visuals.text.doit) {\n            this.visuals.text.set_vectorize(ctx, i);\n            ctx.fillText(text, 0, 0);\n        }\n        return ctx.restore();\n    };\n    LabelSetView.prototype._v_css_text = function (ctx, i, text, sx, sy, angle) {\n        var bbox_dims, el, ld, line_dash;\n        el = this.el.childNodes[i];\n        el.textContent = text;\n        this.visuals.text.set_vectorize(ctx, i);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ld = this.visuals.border_line.line_dash.value();\n        if (types_1.isArray(ld)) {\n            line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\n        }\n        if (types_1.isString(ld)) {\n            line_dash = ld;\n        }\n        this.visuals.border_line.set_vectorize(ctx, i);\n        this.visuals.background_fill.set_vectorize(ctx, i);\n        el.style.position = 'absolute';\n        el.style.left = (sx + bbox_dims[0]) + \"px\";\n        el.style.top = (sy + bbox_dims[1]) + \"px\";\n        el.style.color = \"\" + (this.visuals.text.text_color.value());\n        el.style.opacity = \"\" + (this.visuals.text.text_alpha.value());\n        el.style.font = \"\" + (this.visuals.text.font_value());\n        el.style.lineHeight = \"normal\";\n        if (angle) {\n            el.style.transform = \"rotate(\" + angle + \"rad)\";\n        }\n        if (this.visuals.background_fill.doit) {\n            el.style.backgroundColor = \"\" + (this.visuals.background_fill.color_value());\n        }\n        if (this.visuals.border_line.doit) {\n            el.style.borderStyle = \"\" + line_dash;\n            el.style.borderWidth = (this.visuals.border_line.line_width.value()) + \"px\";\n            el.style.borderColor = \"\" + (this.visuals.border_line.color_value());\n        }\n        return dom_1.show(el);\n    };\n    return LabelSetView;\n})(text_annotation_1.TextAnnotationView);\nexports.LabelSet = (function (superClass) {\n    extend(LabelSet, superClass);\n    function LabelSet() {\n        return LabelSet.__super__.constructor.apply(this, arguments);\n    }\n    LabelSet.prototype.default_view = exports.LabelSetView;\n    LabelSet.prototype.type = 'Label';\n    LabelSet.mixins(['text', 'line:border_', 'fill:background_']);\n    LabelSet.define({\n        x: [p.NumberSpec],\n        y: [p.NumberSpec],\n        x_units: [p.SpatialUnits, 'data'],\n        y_units: [p.SpatialUnits, 'data'],\n        text: [\n            p.StringSpec, {\n                field: \"text\"\n            }\n        ],\n        angle: [p.AngleSpec, 0],\n        x_offset: [\n            p.NumberSpec, {\n                value: 0\n            }\n        ],\n        y_offset: [\n            p.NumberSpec, {\n                value: 0\n            }\n        ],\n        source: [\n            p.Instance, function () {\n                return new column_data_source_1.ColumnDataSource();\n            }\n        ],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    LabelSet.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    return LabelSet;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar p = require(\"core/properties\");\nvar text_1 = require(\"core/util/text\");\nvar bbox_1 = require(\"core/util/bbox\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nexports.LegendView = (function (superClass) {\n    extend(LegendView, superClass);\n    function LegendView() {\n        return LegendView.__super__.constructor.apply(this, arguments);\n    }\n    LegendView.prototype.initialize = function (options) {\n        return LegendView.__super__.initialize.call(this, options);\n    };\n    LegendView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change:visible', this.plot_view.request_render);\n    };\n    LegendView.prototype.compute_legend_bbox = function () {\n        var ctx, glyph_height, glyph_width, h_range, i, label_height, label_standoff, label_width, legend_height, legend_margin, legend_names, legend_padding, legend_spacing, legend_width, len, location, max_label_width, name, panel, ref, ref1, v_range, width, x, y;\n        legend_names = this.model.get_legend_names();\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        label_height = this.model.label_height;\n        label_width = this.model.label_width;\n        this.max_label_height = array_1.max([text_1.get_text_height(this.visuals.label_text.font_value()).height, label_height, glyph_height]);\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this.visuals.label_text.set_value(ctx);\n        this.text_widths = {};\n        for (i = 0, len = legend_names.length; i < len; i++) {\n            name = legend_names[i];\n            this.text_widths[name] = array_1.max([ctx.measureText(name).width, label_width]);\n        }\n        ctx.restore();\n        max_label_width = array_1.max(object_1.values(this.text_widths));\n        legend_margin = this.model.margin;\n        legend_padding = this.model.padding;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        if (this.model.orientation === \"vertical\") {\n            legend_height = legend_names.length * this.max_label_height + (legend_names.length - 1) * legend_spacing + 2 * legend_padding;\n            legend_width = max_label_width + glyph_width + label_standoff + 2 * legend_padding;\n        }\n        else {\n            legend_width = 2 * legend_padding + (legend_names.length - 1) * legend_spacing;\n            ref = this.text_widths;\n            for (name in ref) {\n                width = ref[name];\n                legend_width += array_1.max([width, label_width]) + glyph_width + label_standoff;\n            }\n            legend_height = this.max_label_height + 2 * legend_padding;\n        }\n        panel = (ref1 = this.model.panel) != null ? ref1 : this.plot_view.frame;\n        h_range = {\n            start: panel.left,\n            end: panel.right\n        };\n        v_range = {\n            start: panel.bottom,\n            end: panel.top\n        };\n        location = this.model.location;\n        if (types_1.isString(location)) {\n            switch (location) {\n                case 'top_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'top_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.end - legend_margin;\n                    break;\n                case 'center_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'bottom_right':\n                    x = h_range.end - legend_margin - legend_width;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'bottom_left':\n                    x = h_range.start + legend_margin;\n                    y = v_range.start + legend_margin + legend_height;\n                    break;\n                case 'center_left':\n                    x = h_range.start + legend_margin;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n                    break;\n                case 'center':\n                    x = (h_range.end + h_range.start) / 2 - legend_width / 2;\n                    y = (v_range.end + v_range.start) / 2 + legend_height / 2;\n            }\n        }\n        else if (types_1.isArray(location) && location.length === 2) {\n            x = location[0], y = location[1];\n            x += h_range.start;\n            y += v_range.start + legend_height;\n        }\n        x = this.plot_view.canvas.vx_to_sx(x);\n        y = this.plot_view.canvas.vy_to_sy(y);\n        return {\n            x: x,\n            y: y,\n            width: legend_width,\n            height: legend_height\n        };\n    };\n    LegendView.prototype.bbox = function () {\n        var height, ref, width, x, y;\n        ref = this.compute_legend_bbox(), x = ref.x, y = ref.y, width = ref.width, height = ref.height;\n        return new bbox_1.BBox({\n            x0: x,\n            y0: y,\n            x1: x + width,\n            y1: y + height\n        });\n    };\n    LegendView.prototype.on_hit = function (sx, sy) {\n        var bbox, field, glyph_height, glyph_width, h, i, item, j, k, l, label, label_standoff, labels, legend_bbox, legend_spacing, len, len1, len2, len3, r, ref, ref1, ref2, ref3, ref4, vertical, w, x1, x2, xoffset, y1, y2, yoffset;\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        xoffset = yoffset = this.model.padding;\n        legend_bbox = this.compute_legend_bbox();\n        vertical = this.model.orientation === \"vertical\";\n        ref = this.model.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            field = item.get_field_from_label_prop();\n            for (j = 0, len1 = labels.length; j < len1; j++) {\n                label = labels[j];\n                x1 = legend_bbox.x + xoffset;\n                y1 = legend_bbox.y + yoffset;\n                x2 = x1 + glyph_width;\n                y2 = y1 + glyph_height;\n                if (vertical) {\n                    ref1 = [legend_bbox.width - 2 * this.model.padding, this.max_label_height], w = ref1[0], h = ref1[1];\n                }\n                else {\n                    ref2 = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height], w = ref2[0], h = ref2[1];\n                }\n                bbox = new bbox_1.BBox({\n                    x0: x1,\n                    y0: y1,\n                    x1: x1 + w,\n                    y1: y1 + h\n                });\n                if (bbox.contains(sx, sy)) {\n                    switch (this.model.click_policy) {\n                        case \"hide\":\n                            ref3 = item.renderers;\n                            for (k = 0, len2 = ref3.length; k < len2; k++) {\n                                r = ref3[k];\n                                r.visible = !r.visible;\n                            }\n                            break;\n                        case \"mute\":\n                            ref4 = item.renderers;\n                            for (l = 0, len3 = ref4.length; l < len3; l++) {\n                                r = ref4[l];\n                                r.muted = !r.muted;\n                            }\n                    }\n                    return true;\n                }\n                if (vertical) {\n                    yoffset += this.max_label_height + legend_spacing;\n                }\n                else {\n                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                }\n            }\n        }\n        return false;\n    };\n    LegendView.prototype.render = function () {\n        var bbox, ctx;\n        if (!this.model.visible) {\n            return;\n        }\n        if (this.model.items.length === 0) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        bbox = this.compute_legend_bbox();\n        ctx.save();\n        this._draw_legend_box(ctx, bbox);\n        this._draw_legend_items(ctx, bbox);\n        return ctx.restore();\n    };\n    LegendView.prototype._draw_legend_box = function (ctx, bbox) {\n        ctx.beginPath();\n        ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);\n        this.visuals.background_fill.set_value(ctx);\n        ctx.fill();\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            return ctx.stroke();\n        }\n    };\n    LegendView.prototype._draw_legend_items = function (ctx, bbox) {\n        var active, field, glyph_height, glyph_width, h, i, item, j, k, label, label_standoff, labels, legend_spacing, len, len1, len2, r, ref, ref1, ref2, ref3, vertical, view, w, x1, x2, xoffset, y1, y2, yoffset;\n        glyph_height = this.model.glyph_height;\n        glyph_width = this.model.glyph_width;\n        legend_spacing = this.model.spacing;\n        label_standoff = this.model.label_standoff;\n        xoffset = yoffset = this.model.padding;\n        vertical = this.model.orientation === \"vertical\";\n        ref = this.model.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            field = item.get_field_from_label_prop();\n            if (labels.length === 0) {\n                continue;\n            }\n            active = (function () {\n                switch (this.model.click_policy) {\n                    case \"none\":\n                        return true;\n                    case \"hide\":\n                        return array_1.all(item.renderers, function (r) {\n                            return r.visible;\n                        });\n                    case \"mute\":\n                        return array_1.all(item.renderers, function (r) {\n                            return !r.muted;\n                        });\n                }\n            }).call(this);\n            for (j = 0, len1 = labels.length; j < len1; j++) {\n                label = labels[j];\n                x1 = bbox.x + xoffset;\n                y1 = bbox.y + yoffset;\n                x2 = x1 + glyph_width;\n                y2 = y1 + glyph_height;\n                if (vertical) {\n                    yoffset += this.max_label_height + legend_spacing;\n                }\n                else {\n                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                }\n                this.visuals.label_text.set_value(ctx);\n                ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2.0);\n                ref1 = item.renderers;\n                for (k = 0, len2 = ref1.length; k < len2; k++) {\n                    r = ref1[k];\n                    view = this.plot_view.renderer_views[r.id];\n                    view.draw_legend(ctx, x1, x2, y1, y2, field, label);\n                }\n                if (!active) {\n                    if (vertical) {\n                        ref2 = [bbox.width - 2 * this.model.padding, this.max_label_height], w = ref2[0], h = ref2[1];\n                    }\n                    else {\n                        ref3 = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height], w = ref3[0], h = ref3[1];\n                    }\n                    ctx.beginPath();\n                    ctx.rect(x1, y1, w, h);\n                    this.visuals.inactive_fill.set_value(ctx);\n                    ctx.fill();\n                }\n            }\n        }\n        return null;\n    };\n    LegendView.prototype._get_size = function () {\n        var bbox, side;\n        bbox = this.compute_legend_bbox();\n        side = this.model.panel.side;\n        if (side === 'above' || side === 'below') {\n            return bbox.height;\n        }\n        if (side === 'left' || side === 'right') {\n            return bbox.width;\n        }\n    };\n    return LegendView;\n})(annotation_1.AnnotationView);\nexports.Legend = (function (superClass) {\n    extend(Legend, superClass);\n    function Legend() {\n        return Legend.__super__.constructor.apply(this, arguments);\n    }\n    Legend.prototype.default_view = exports.LegendView;\n    Legend.prototype.type = 'Legend';\n    Legend.prototype.cursor = function () {\n        if (this.click_policy === \"none\") {\n            return null;\n        }\n        else {\n            return \"pointer\";\n        }\n    };\n    Legend.prototype.get_legend_names = function () {\n        var i, item, labels, legend_names, len, ref;\n        legend_names = [];\n        ref = this.items;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            labels = item.get_labels_list_from_label_prop();\n            legend_names = legend_names.concat(labels);\n        }\n        return legend_names;\n    };\n    Legend.mixins(['text:label_', 'fill:inactive_', 'line:border_', 'fill:background_']);\n    Legend.define({\n        orientation: [p.Orientation, 'vertical'],\n        location: [p.Any, 'top_right'],\n        label_standoff: [p.Number, 5],\n        glyph_height: [p.Number, 20],\n        glyph_width: [p.Number, 20],\n        label_height: [p.Number, 20],\n        label_width: [p.Number, 20],\n        margin: [p.Number, 10],\n        padding: [p.Number, 10],\n        spacing: [p.Number, 3],\n        items: [p.Array, []],\n        click_policy: [p.Any, \"none\"]\n    });\n    Legend.override({\n        border_line_color: \"#e5e5e5\",\n        border_line_alpha: 0.5,\n        border_line_width: 1,\n        background_fill_color: \"#ffffff\",\n        background_fill_alpha: 0.95,\n        inactive_fill_color: \"white\",\n        inactive_fill_alpha: 0.9,\n        label_text_font_size: \"10pt\",\n        label_text_baseline: \"middle\"\n    });\n    return Legend;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nvar logging_1 = require(\"core/logging\");\nvar array_1 = require(\"core/util/array\");\nvar column_data_source_1 = require(\"../../models/sources/column_data_source\");\nexports.LegendItem = (function (superClass) {\n    extend(LegendItem, superClass);\n    function LegendItem() {\n        this.get_labels_list_from_label_prop = bind(this.get_labels_list_from_label_prop, this);\n        this.get_field_from_label_prop = bind(this.get_field_from_label_prop, this);\n        return LegendItem.__super__.constructor.apply(this, arguments);\n    }\n    LegendItem.prototype.type = \"LegendItem\";\n    LegendItem.prototype._check_data_sources_on_renderers = function () {\n        var field, i, len, r, ref, source;\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers.length < 1) {\n                return false;\n            }\n            source = this.renderers[0].data_source;\n            if (source != null) {\n                ref = this.renderers;\n                for (i = 0, len = ref.length; i < len; i++) {\n                    r = ref[i];\n                    if (r.data_source !== source) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    };\n    LegendItem.prototype._check_field_label_on_data_source = function () {\n        var field, source;\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers.length < 1) {\n                return false;\n            }\n            source = this.renderers[0].data_source;\n            if ((source != null) && indexOf.call(source.columns(), field) < 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    LegendItem.prototype.initialize = function (attrs, options) {\n        var data_source_validation, field_validation;\n        LegendItem.__super__.initialize.call(this, attrs, options);\n        data_source_validation = this._check_data_sources_on_renderers();\n        if (!data_source_validation) {\n            logging_1.logger.error(\"Non matching data sources on legend item renderers\");\n        }\n        field_validation = this._check_field_label_on_data_source();\n        if (!field_validation) {\n            return logging_1.logger.error(\"Bad column name on label: \" + this.label);\n        }\n    };\n    LegendItem.define({\n        label: [p.StringSpec, null],\n        renderers: [p.Array, []]\n    });\n    LegendItem.prototype.get_field_from_label_prop = function () {\n        if ((this.label != null) && (this.label.field != null)) {\n            return this.label.field;\n        }\n    };\n    LegendItem.prototype.get_labels_list_from_label_prop = function () {\n        var data, field, source;\n        if ((this.label != null) && (this.label.value != null)) {\n            return [this.label.value];\n        }\n        field = this.get_field_from_label_prop();\n        if (field != null) {\n            if (this.renderers[0] && (this.renderers[0].data_source != null)) {\n                source = this.renderers[0].data_source;\n            }\n            else {\n                return [\"No source found\"];\n            }\n            if (source instanceof column_data_source_1.ColumnDataSource) {\n                data = source.get_column(field);\n                if (data != null) {\n                    return array_1.uniq(data);\n                }\n                else {\n                    return [\"Invalid field\"];\n                }\n            }\n        }\n        return [];\n    };\n    return LegendItem;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar p = require(\"core/properties\");\nexports.PolyAnnotationView = (function (superClass) {\n    extend(PolyAnnotationView, superClass);\n    function PolyAnnotationView() {\n        return PolyAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    PolyAnnotationView.prototype.bind_bokeh_events = function () {\n        this.listenTo(this.model, 'change', this.plot_view.request_render);\n        return this.listenTo(this.model, 'data_update', this.plot_view.request_render);\n    };\n    PolyAnnotationView.prototype.render = function (ctx) {\n        var canvas, i, j, ref, sx, sy, vx, vy, xs, ys;\n        if (!this.model.visible) {\n            return;\n        }\n        xs = this.model.xs;\n        ys = this.model.ys;\n        if (xs.length !== ys.length) {\n            return null;\n        }\n        if (xs.length < 3 || ys.length < 3) {\n            return null;\n        }\n        canvas = this.plot_view.canvas;\n        ctx = this.plot_view.canvas_view.ctx;\n        for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (this.model.xs_units === 'screen') {\n                vx = xs[i];\n            }\n            if (this.model.ys_units === 'screen') {\n                vy = ys[i];\n            }\n            sx = canvas.vx_to_sx(vx);\n            sy = canvas.vy_to_sy(vy);\n            if (i === 0) {\n                ctx.beginPath();\n                ctx.moveTo(sx, sy);\n            }\n            else {\n                ctx.lineTo(sx, sy);\n            }\n        }\n        ctx.closePath();\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            ctx.stroke();\n        }\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_value(ctx);\n            return ctx.fill();\n        }\n    };\n    return PolyAnnotationView;\n})(annotation_1.AnnotationView);\nexports.PolyAnnotation = (function (superClass) {\n    extend(PolyAnnotation, superClass);\n    function PolyAnnotation() {\n        return PolyAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    PolyAnnotation.prototype.default_view = exports.PolyAnnotationView;\n    PolyAnnotation.prototype.type = \"PolyAnnotation\";\n    PolyAnnotation.mixins(['line', 'fill']);\n    PolyAnnotation.define({\n        xs: [p.Array, []],\n        xs_units: [p.SpatialUnits, 'data'],\n        ys: [p.Array, []],\n        ys_units: [p.SpatialUnits, 'data'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    PolyAnnotation.override({\n        fill_color: \"#fff9ba\",\n        fill_alpha: 0.4,\n        line_color: \"#cccccc\",\n        line_alpha: 0.3\n    });\n    PolyAnnotation.prototype.update = function (arg) {\n        var xs, ys;\n        xs = arg.xs, ys = arg.ys;\n        this.setv({\n            xs: xs,\n            ys: ys\n        }, {\n            silent: true\n        });\n        return this.trigger('data_update');\n    };\n    return PolyAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.SpanView = (function (superClass) {\n    extend(SpanView, superClass);\n    function SpanView() {\n        return SpanView.__super__.constructor.apply(this, arguments);\n    }\n    SpanView.prototype.initialize = function (options) {\n        SpanView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.style.position = \"absolute\";\n        return dom_1.hide(this.el);\n    };\n    SpanView.prototype.bind_bokeh_events = function () {\n        if (this.model.for_hover) {\n            return this.listenTo(this.model, 'change:computed_location', this._draw_span);\n        }\n        else {\n            if (this.model.render_mode === 'canvas') {\n                this.listenTo(this.model, 'change', this.plot_view.request_render);\n                return this.listenTo(this.model, 'change:location', this.plot_view.request_render);\n            }\n            else {\n                this.listenTo(this.model, 'change', this.render);\n                return this.listenTo(this.model, 'change:location', this._draw_span);\n            }\n        }\n    };\n    SpanView.prototype.render = function () {\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        return this._draw_span();\n    };\n    SpanView.prototype._draw_span = function () {\n        var canvas, ctx, frame, height, loc, sleft, stop, width, xmapper, ymapper;\n        if (this.model.for_hover) {\n            loc = this.model.computed_location;\n        }\n        else {\n            loc = this.model.location;\n        }\n        if (loc == null) {\n            dom_1.hide(this.el);\n            return;\n        }\n        frame = this.plot_model.frame;\n        canvas = this.plot_model.canvas;\n        xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        if (this.model.dimension === 'width') {\n            stop = canvas.vy_to_sy(this._calc_dim(loc, ymapper));\n            sleft = canvas.vx_to_sx(frame.left);\n            width = frame.width;\n            height = this.model.properties.line_width.value();\n        }\n        else {\n            stop = canvas.vy_to_sy(frame.top);\n            sleft = canvas.vx_to_sx(this._calc_dim(loc, xmapper));\n            width = this.model.properties.line_width.value();\n            height = frame.height;\n        }\n        if (this.model.render_mode === \"css\") {\n            this.el.style.top = stop + \"px\";\n            this.el.style.left = sleft + \"px\";\n            this.el.style.width = width + \"px\";\n            this.el.style.height = height + \"px\";\n            this.el.style.zIndex = 1000;\n            this.el.style.backgroundColor = this.model.properties.line_color.value();\n            this.el.style.opacity = this.model.properties.line_alpha.value();\n            return dom_1.show(this.el);\n        }\n        else if (this.model.render_mode === \"canvas\") {\n            ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            ctx.beginPath();\n            this.visuals.line.set_value(ctx);\n            ctx.moveTo(sleft, stop);\n            if (this.model.dimension === \"width\") {\n                ctx.lineTo(sleft + width, stop);\n            }\n            else {\n                ctx.lineTo(sleft, stop + height);\n            }\n            ctx.stroke();\n            return ctx.restore();\n        }\n    };\n    SpanView.prototype._calc_dim = function (location, mapper) {\n        var vdim;\n        if (this.model.location_units === 'data') {\n            vdim = mapper.map_to_target(location);\n        }\n        else {\n            vdim = location;\n        }\n        return vdim;\n    };\n    return SpanView;\n})(annotation_1.AnnotationView);\nexports.Span = (function (superClass) {\n    extend(Span, superClass);\n    function Span() {\n        return Span.__super__.constructor.apply(this, arguments);\n    }\n    Span.prototype.default_view = exports.SpanView;\n    Span.prototype.type = 'Span';\n    Span.mixins(['line']);\n    Span.define({\n        render_mode: [p.RenderMode, 'canvas'],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        location: [p.Number, null],\n        location_units: [p.SpatialUnits, 'data'],\n        dimension: [p.Dimension, 'width']\n    });\n    Span.override({\n        line_color: 'black'\n    });\n    Span.internal({\n        for_hover: [p.Boolean, false],\n        computed_location: [p.Number, null]\n    });\n    return Span;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar types_1 = require(\"core/util/types\");\nvar text_1 = require(\"core/util/text\");\nexports.TextAnnotationView = (function (superClass) {\n    extend(TextAnnotationView, superClass);\n    function TextAnnotationView() {\n        return TextAnnotationView.__super__.constructor.apply(this, arguments);\n    }\n    TextAnnotationView.prototype.initialize = function (options) {\n        TextAnnotationView.__super__.initialize.call(this, options);\n        this.canvas = this.plot_model.canvas;\n        this.frame = this.plot_model.frame;\n        if (this.model.render_mode === 'css') {\n            this.el.classList.add('bk-annotation');\n            return this.plot_view.canvas_overlays.appendChild(this.el);\n        }\n    };\n    TextAnnotationView.prototype.bind_bokeh_events = function () {\n        if (this.model.render_mode === 'css') {\n            return this.listenTo(this.model, 'change', this.render);\n        }\n        else {\n            return this.listenTo(this.model, 'change', this.plot_view.request_render);\n        }\n    };\n    TextAnnotationView.prototype._calculate_text_dimensions = function (ctx, text) {\n        var height, width;\n        width = ctx.measureText(text).width;\n        height = text_1.get_text_height(this.visuals.text.font_value()).height;\n        return [width, height];\n    };\n    TextAnnotationView.prototype._calculate_bounding_box_dimensions = function (ctx, text) {\n        var height, ref, width, x_offset, y_offset;\n        ref = this._calculate_text_dimensions(ctx, text), width = ref[0], height = ref[1];\n        switch (ctx.textAlign) {\n            case 'left':\n                x_offset = 0;\n                break;\n            case 'center':\n                x_offset = -width / 2;\n                break;\n            case 'right':\n                x_offset = -width;\n        }\n        switch (ctx.textBaseline) {\n            case 'top':\n                y_offset = 0.0;\n                break;\n            case 'middle':\n                y_offset = -0.5 * height;\n                break;\n            case 'bottom':\n                y_offset = -1.0 * height;\n                break;\n            case 'alphabetic':\n                y_offset = -0.8 * height;\n                break;\n            case 'hanging':\n                y_offset = -0.17 * height;\n                break;\n            case 'ideographic':\n                y_offset = -0.83 * height;\n        }\n        return [x_offset, y_offset, width, height];\n    };\n    TextAnnotationView.prototype._get_size = function () {\n        var ctx;\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.text.set_value(ctx);\n        return ctx.measureText(this.model.text).ascent;\n    };\n    TextAnnotationView.prototype.render = function () {\n        return null;\n    };\n    TextAnnotationView.prototype._canvas_text = function (ctx, text, sx, sy, angle) {\n        var bbox_dims;\n        this.visuals.text.set_value(ctx);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(sx, sy);\n        if (angle) {\n            ctx.rotate(angle);\n        }\n        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fill();\n        }\n        if (this.visuals.border_line.doit) {\n            this.visuals.border_line.set_value(ctx);\n            ctx.stroke();\n        }\n        if (this.visuals.text.doit) {\n            this.visuals.text.set_value(ctx);\n            ctx.fillText(text, 0, 0);\n        }\n        return ctx.restore();\n    };\n    TextAnnotationView.prototype._css_text = function (ctx, text, sx, sy, angle) {\n        var bbox_dims, ld, line_dash;\n        dom_1.hide(this.el);\n        this.visuals.text.set_value(ctx);\n        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n        ld = this.visuals.border_line.line_dash.value();\n        if (types_1.isArray(ld)) {\n            if (ld.length < 2) {\n                line_dash = \"solid\";\n            }\n            else {\n                line_dash = \"dashed\";\n            }\n        }\n        if (types_1.isString(ld)) {\n            line_dash = ld;\n        }\n        this.visuals.border_line.set_value(ctx);\n        this.visuals.background_fill.set_value(ctx);\n        this.el.style.position = 'absolute';\n        this.el.style.left = (sx + bbox_dims[0]) + \"px\";\n        this.el.style.top = (sy + bbox_dims[1]) + \"px\";\n        this.el.style.color = \"\" + (this.visuals.text.text_color.value());\n        this.el.style.opacity = \"\" + (this.visuals.text.text_alpha.value());\n        this.el.style.font = \"\" + (this.visuals.text.font_value());\n        this.el.style.lineHeight = \"normal\";\n        if (angle) {\n            this.el.style.transform = \"rotate(\" + angle + \"rad)\";\n        }\n        if (this.visuals.background_fill.doit) {\n            this.el.style.backgroundColor = \"\" + (this.visuals.background_fill.color_value());\n        }\n        if (this.visuals.border_line.doit) {\n            this.el.style.borderStyle = \"\" + line_dash;\n            this.el.style.borderWidth = (this.visuals.border_line.line_width.value()) + \"px\";\n            this.el.style.borderColor = \"\" + (this.visuals.border_line.color_value());\n        }\n        this.el.textContent = text;\n        return dom_1.show(this.el);\n    };\n    return TextAnnotationView;\n})(annotation_1.AnnotationView);\nexports.TextAnnotation = (function (superClass) {\n    extend(TextAnnotation, superClass);\n    function TextAnnotation() {\n        return TextAnnotation.__super__.constructor.apply(this, arguments);\n    }\n    TextAnnotation.prototype.type = 'TextAnnotation';\n    TextAnnotation.prototype.default_view = exports.TextAnnotationView;\n    return TextAnnotation;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar text_annotation_1 = require(\"./text_annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar Visuals = require(\"core/visuals\");\nexports.TitleView = (function (superClass) {\n    extend(TitleView, superClass);\n    function TitleView() {\n        return TitleView.__super__.constructor.apply(this, arguments);\n    }\n    TitleView.prototype.initialize = function (options) {\n        var ctx;\n        TitleView.__super__.initialize.call(this, options);\n        this.visuals.text = new Visuals.Text(this.model);\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this.model.panel.apply_label_text_heuristics(ctx, 'justified');\n        this.model.text_baseline = ctx.textBaseline;\n        this.model.text_align = this.model.align;\n        return ctx.restore();\n    };\n    TitleView.prototype._get_computed_location = function () {\n        var height, ref, sx, sy, vx, vy, width;\n        ref = this._calculate_text_dimensions(this.plot_view.canvas_view.ctx, this.text), width = ref[0], height = ref[1];\n        switch (this.model.panel.side) {\n            case 'left':\n                vx = 0;\n                vy = this._get_text_location(this.model.align, this.frame.v_range) + this.model.offset;\n                break;\n            case 'right':\n                vx = this.canvas.right - 1;\n                vy = this.canvas.height - this._get_text_location(this.model.align, this.frame.v_range) - this.model.offset;\n                break;\n            case 'above':\n                vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;\n                vy = this.canvas.top - 10;\n                break;\n            case 'below':\n                vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;\n                vy = 0;\n        }\n        sx = this.canvas.vx_to_sx(vx);\n        sy = this.canvas.vy_to_sy(vy);\n        return [sx, sy];\n    };\n    TitleView.prototype._get_text_location = function (alignment, range) {\n        var text_location;\n        switch (alignment) {\n            case 'left':\n                text_location = range.start;\n                break;\n            case 'center':\n                text_location = (range.end + range.start) / 2;\n                break;\n            case 'right':\n                text_location = range.end;\n        }\n        return text_location;\n    };\n    TitleView.prototype.render = function () {\n        var angle, ctx, ref, sx, sy;\n        if (!this.model.visible && this.model.render_mode === 'css') {\n            dom_1.hide(this.el);\n        }\n        if (!this.model.visible) {\n            return;\n        }\n        angle = this.model.panel.get_label_angle_heuristic('parallel');\n        ref = this._get_computed_location(), sx = ref[0], sy = ref[1];\n        ctx = this.plot_view.canvas_view.ctx;\n        if (this.model.text === \"\" || this.model.text === null) {\n            return;\n        }\n        if (this.model.render_mode === 'canvas') {\n            return this._canvas_text(ctx, this.model.text, sx, sy, angle);\n        }\n        else {\n            return this._css_text(ctx, this.model.text, sx, sy, angle);\n        }\n    };\n    TitleView.prototype._get_size = function () {\n        var ctx, text;\n        text = this.model.text;\n        if (text === \"\" || text === null) {\n            return 0;\n        }\n        else {\n            ctx = this.plot_view.canvas_view.ctx;\n            this.visuals.text.set_value(ctx);\n            return ctx.measureText(text).ascent + 10;\n        }\n    };\n    return TitleView;\n})(text_annotation_1.TextAnnotationView);\nexports.Title = (function (superClass) {\n    extend(Title, superClass);\n    function Title() {\n        return Title.__super__.constructor.apply(this, arguments);\n    }\n    Title.prototype.default_view = exports.TitleView;\n    Title.prototype.type = 'Title';\n    Title.mixins(['line:border_', 'fill:background_']);\n    Title.define({\n        text: [p.String],\n        text_font: [p.Font, 'helvetica'],\n        text_font_size: [p.FontSizeSpec, '10pt'],\n        text_font_style: [p.FontStyle, 'bold'],\n        text_color: [p.ColorSpec, '#444444'],\n        text_alpha: [p.NumberSpec, 1.0],\n        align: [p.TextAlign, 'left'],\n        offset: [p.Number, 0],\n        render_mode: [p.RenderMode, 'canvas']\n    });\n    Title.override({\n        background_fill_color: null,\n        border_line_color: null\n    });\n    Title.internal({\n        text_align: [p.TextAlign, 'left'],\n        text_baseline: [p.TextBaseline, 'bottom']\n    });\n    return Title;\n})(text_annotation_1.TextAnnotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar annotation_1 = require(\"./annotation\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.TooltipView = (function (superClass) {\n    extend(TooltipView, superClass);\n    function TooltipView() {\n        return TooltipView.__super__.constructor.apply(this, arguments);\n    }\n    TooltipView.prototype.className = \"bk-tooltip\";\n    TooltipView.prototype.initialize = function (options) {\n        TooltipView.__super__.initialize.call(this, options);\n        this.plot_view.canvas_overlays.appendChild(this.el);\n        this.el.style.zIndex = 1010;\n        return dom_1.hide(this.el);\n    };\n    TooltipView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change:data', this._draw_tips);\n    };\n    TooltipView.prototype.render = function () {\n        if (!this.model.visible) {\n            return;\n        }\n        return this._draw_tips();\n    };\n    TooltipView.prototype._draw_tips = function () {\n        var arrow_size, attachment, bottom, content, data, height, i, left, len, side, sx, sy, tip, top, val, vx, vy, width;\n        data = this.model.data;\n        dom_1.empty(this.el);\n        dom_1.hide(this.el);\n        if (this.model.custom) {\n            this.el.classList.add(\"bk-tooltip-custom\");\n        }\n        else {\n            this.el.classList.remove(\"bk-tooltip-custom\");\n        }\n        if (data.length === 0) {\n            return;\n        }\n        for (i = 0, len = data.length; i < len; i++) {\n            val = data[i];\n            vx = val[0], vy = val[1], content = val[2];\n            if (this.model.inner_only && !this.plot_view.frame.contains(vx, vy)) {\n                continue;\n            }\n            tip = dom_1.div({}, content);\n            this.el.appendChild(tip);\n        }\n        sx = this.plot_view.model.canvas.vx_to_sx(vx);\n        sy = this.plot_view.model.canvas.vy_to_sy(vy);\n        attachment = this.model.attachment;\n        switch (attachment) {\n            case \"horizontal\":\n                width = this.plot_view.frame.width;\n                left = this.plot_view.frame.left;\n                if (vx - left < width / 2) {\n                    side = 'right';\n                }\n                else {\n                    side = 'left';\n                }\n                break;\n            case \"vertical\":\n                height = this.plot_view.frame.height;\n                bottom = this.plot_view.frame.bottom;\n                if (vy - bottom < height / 2) {\n                    side = 'below';\n                }\n                else {\n                    side = 'above';\n                }\n                break;\n            default:\n                side = attachment;\n        }\n        this.el.classList.remove(\"bk-right\");\n        this.el.classList.remove(\"bk-left\");\n        this.el.classList.remove(\"bk-above\");\n        this.el.classList.remove(\"bk-below\");\n        arrow_size = 10;\n        dom_1.show(this.el);\n        switch (side) {\n            case \"right\":\n                this.el.classList.add(\"bk-left\");\n                left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;\n                top = sy - this.el.offsetHeight / 2;\n                break;\n            case \"left\":\n                this.el.classList.add(\"bk-right\");\n                left = sx - this.el.offsetWidth - arrow_size;\n                top = sy - this.el.offsetHeight / 2;\n                break;\n            case \"above\":\n                this.el.classList.add(\"bk-above\");\n                top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;\n                left = Math.round(sx - this.el.offsetWidth / 2);\n                break;\n            case \"below\":\n                this.el.classList.add(\"bk-below\");\n                top = sy - this.el.offsetHeight - arrow_size;\n                left = Math.round(sx - this.el.offsetWidth / 2);\n        }\n        if (this.model.show_arrow) {\n            this.el.classList.add(\"bk-tooltip-arrow\");\n        }\n        if (this.el.childNodes.length > 0) {\n            this.el.style.top = top + \"px\";\n            return this.el.style.left = left + \"px\";\n        }\n        else {\n            return dom_1.hide(this.el);\n        }\n    };\n    return TooltipView;\n})(annotation_1.AnnotationView);\nexports.Tooltip = (function (superClass) {\n    extend(Tooltip, superClass);\n    function Tooltip() {\n        return Tooltip.__super__.constructor.apply(this, arguments);\n    }\n    Tooltip.prototype.default_view = exports.TooltipView;\n    Tooltip.prototype.type = 'Tooltip';\n    Tooltip.define({\n        attachment: [p.String, 'horizontal'],\n        inner_only: [p.Bool, true],\n        show_arrow: [p.Bool, true]\n    });\n    Tooltip.override({\n        level: 'overlay'\n    });\n    Tooltip.internal({\n        data: [p.Any, []],\n        custom: [p.Any]\n    });\n    Tooltip.prototype.clear = function () {\n        return this.data = [];\n    };\n    Tooltip.prototype.add = function (vx, vy, content) {\n        var data;\n        data = this.data;\n        data.push([vx, vy, content]);\n        this.data = data;\n        return this.trigger('change:data');\n    };\n    return Tooltip;\n})(annotation_1.Annotation);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar side_panel_1 = require(\"core/layout/side_panel\");\nvar guide_renderer_1 = require(\"../renderers/guide_renderer\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.AxisView = (function (superClass) {\n    extend(AxisView, superClass);\n    function AxisView() {\n        return AxisView.__super__.constructor.apply(this, arguments);\n    }\n    AxisView.prototype.initialize = function (options) {\n        AxisView.__super__.initialize.call(this, options);\n        this._x_range_name = this.model.x_range_name;\n        return this._y_range_name = this.model.y_range_name;\n    };\n    AxisView.prototype.render = function () {\n        var ctx;\n        if (this.model.visible === false) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_rule(ctx);\n        this._draw_major_ticks(ctx);\n        this._draw_minor_ticks(ctx);\n        this._draw_major_labels(ctx);\n        this._draw_axis_label(ctx);\n        return ctx.restore();\n    };\n    AxisView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change', this.plot_view.request_render);\n    };\n    AxisView.prototype._get_size = function () {\n        return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\n    };\n    AxisView.prototype._draw_rule = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, sx, sy, x, xoff, y, yoff;\n        if (!this.visuals.axis_line.doit) {\n            return;\n        }\n        ref = coords = this.model.rule_coords, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        this.visuals.axis_line.set_value(ctx);\n        ctx.beginPath();\n        ctx.moveTo(Math.round(sx[0] + nx * xoff), Math.round(sy[0] + ny * yoff));\n        for (i = k = 1, ref4 = sx.length; 1 <= ref4 ? k < ref4 : k > ref4; i = 1 <= ref4 ? ++k : --k) {\n            ctx.lineTo(Math.round(sx[i] + nx * xoff), Math.round(sy[i] + ny * yoff));\n        }\n        return ctx.stroke();\n    };\n    AxisView.prototype._draw_major_ticks = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, results, sx, sy, tin, tout, x, xoff, y, yoff;\n        if (!this.visuals.major_tick_line.doit) {\n            return;\n        }\n        coords = this.model.tick_coords;\n        ref = coords.major, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        tin = this.model.major_tick_in;\n        tout = this.model.major_tick_out;\n        this.visuals.major_tick_line.set_value(ctx);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));\n            ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    AxisView.prototype._draw_minor_ticks = function (ctx) {\n        var coords, i, k, nx, ny, ref, ref1, ref2, ref3, ref4, results, sx, sy, tin, tout, x, xoff, y, yoff;\n        if (!this.visuals.minor_tick_line.doit) {\n            return;\n        }\n        coords = this.model.tick_coords;\n        ref = coords.minor, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        tin = this.model.minor_tick_in;\n        tout = this.model.minor_tick_out;\n        this.visuals.minor_tick_line.set_value(ctx);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));\n            ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    AxisView.prototype._draw_major_labels = function (ctx) {\n        var angle, coords, dim, i, k, labels, nx, ny, orient, ref, ref1, ref2, ref3, ref4, results, side, standoff, sx, sy, x, xoff, y, yoff;\n        coords = this.model.tick_coords;\n        ref = coords.major, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        dim = this.model.dimension;\n        side = this.model.panel_side;\n        orient = this.model.major_label_orientation;\n        if (types_1.isString(orient)) {\n            angle = this.model.panel.get_label_angle_heuristic(orient);\n        }\n        else {\n            angle = -orient;\n        }\n        standoff = this._tick_extent() + this.model.major_label_standoff;\n        labels = this.model.formatter.doFormat(coords.major[dim], this.model.loc);\n        this.visuals.major_label_text.set_value(ctx);\n        this.model.panel.apply_label_text_heuristics(ctx, orient);\n        results = [];\n        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {\n            if (angle) {\n                ctx.translate(sx[i] + nx * standoff + nx * xoff, sy[i] + ny * standoff + ny * yoff);\n                ctx.rotate(angle);\n                ctx.fillText(labels[i], 0, 0);\n                ctx.rotate(-angle);\n                results.push(ctx.translate(-sx[i] - nx * standoff + nx * xoff, -sy[i] - ny * standoff + ny * yoff));\n            }\n            else {\n                results.push(ctx.fillText(labels[i], Math.round(sx[i] + nx * standoff + nx * xoff), Math.round(sy[i] + ny * standoff + ny * yoff)));\n            }\n        }\n        return results;\n    };\n    AxisView.prototype._draw_axis_label = function (ctx) {\n        var angle, label, nx, ny, orient, ref, ref1, ref2, ref3, side, standoff, sx, sy, x, xoff, y, yoff;\n        label = this.model.axis_label;\n        if (label == null) {\n            return;\n        }\n        ref = this.model.rule_coords, x = ref[0], y = ref[1];\n        ref1 = this.plot_view.map_to_screen(x, y, this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];\n        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];\n        side = this.model.panel_side;\n        orient = 'parallel';\n        angle = this.model.panel.get_label_angle_heuristic(orient);\n        standoff = this._tick_extent() + this._tick_label_extent() + this.model.axis_label_standoff;\n        sx = (sx[0] + sx[sx.length - 1]) / 2;\n        sy = (sy[0] + sy[sy.length - 1]) / 2;\n        this.visuals.axis_label_text.set_value(ctx);\n        this.model.panel.apply_label_text_heuristics(ctx, orient);\n        x = sx + nx * standoff + nx * xoff;\n        y = sy + ny * standoff + ny * yoff;\n        if (isNaN(x) || isNaN(y)) {\n            return;\n        }\n        if (angle) {\n            ctx.translate(x, y);\n            ctx.rotate(angle);\n            ctx.fillText(label, 0, 0);\n            ctx.rotate(-angle);\n            return ctx.translate(-x, -y);\n        }\n        else {\n            return ctx.fillText(label, x, y);\n        }\n    };\n    AxisView.prototype._tick_extent = function () {\n        return this.model.major_tick_out;\n    };\n    AxisView.prototype._tick_label_extent = function () {\n        var angle, c, coords, ctx, dim, extent, h, hfactor, hscale, i, k, labels, orient, ref, s, side, val, w, wfactor;\n        extent = 0;\n        ctx = this.plot_view.canvas_view.ctx;\n        dim = this.model.dimension;\n        coords = this.model.tick_coords.major;\n        side = this.model.panel_side;\n        orient = this.model.major_label_orientation;\n        labels = this.model.formatter.doFormat(coords[dim], this.model.loc);\n        this.visuals.major_label_text.set_value(ctx);\n        if (types_1.isString(orient)) {\n            hscale = 1;\n            angle = this.model.panel.get_label_angle_heuristic(orient);\n        }\n        else {\n            hscale = 2;\n            angle = -orient;\n        }\n        angle = Math.abs(angle);\n        c = Math.cos(angle);\n        s = Math.sin(angle);\n        if (side === \"above\" || side === \"below\") {\n            wfactor = s;\n            hfactor = c;\n        }\n        else {\n            wfactor = c;\n            hfactor = s;\n        }\n        for (i = k = 0, ref = labels.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (labels[i] == null) {\n                continue;\n            }\n            w = ctx.measureText(labels[i]).width * 1.1;\n            h = ctx.measureText(labels[i]).ascent * 0.9;\n            val = w * wfactor + (h / hscale) * hfactor;\n            if (val > extent) {\n                extent = val;\n            }\n        }\n        if (extent > 0) {\n            extent += this.model.major_label_standoff;\n        }\n        return extent;\n    };\n    AxisView.prototype._axis_label_extent = function () {\n        var angle, axis_label, c, ctx, extent, h, orient, s, side, w;\n        extent = 0;\n        side = this.model.panel_side;\n        axis_label = this.model.axis_label;\n        orient = 'parallel';\n        ctx = this.plot_view.canvas_view.ctx;\n        this.visuals.axis_label_text.set_value(ctx);\n        angle = Math.abs(this.model.panel.get_label_angle_heuristic(orient));\n        c = Math.cos(angle);\n        s = Math.sin(angle);\n        if (axis_label) {\n            extent += this.model.axis_label_standoff;\n            this.visuals.axis_label_text.set_value(ctx);\n            w = ctx.measureText(axis_label).width * 1.1;\n            h = ctx.measureText(axis_label).ascent * 0.9;\n            if (side === \"above\" || side === \"below\") {\n                extent += w * s + h * c;\n            }\n            else {\n                extent += w * c + h * s;\n            }\n        }\n        return extent;\n    };\n    return AxisView;\n})(renderer_1.RendererView);\nexports.Axis = (function (superClass) {\n    extend(Axis, superClass);\n    function Axis() {\n        return Axis.__super__.constructor.apply(this, arguments);\n    }\n    Axis.prototype.default_view = exports.AxisView;\n    Axis.prototype.type = 'Axis';\n    Axis.mixins(['line:axis_', 'line:major_tick_', 'line:minor_tick_', 'text:major_label_', 'text:axis_label_']);\n    Axis.define({\n        bounds: [p.Any, 'auto'],\n        ticker: [p.Instance, null],\n        formatter: [p.Instance, null],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        axis_label: [p.String, ''],\n        axis_label_standoff: [p.Int, 5],\n        major_label_standoff: [p.Int, 5],\n        major_label_orientation: [p.Any, \"horizontal\"],\n        major_tick_in: [p.Number, 2],\n        major_tick_out: [p.Number, 6],\n        minor_tick_in: [p.Number, 0],\n        minor_tick_out: [p.Number, 4]\n    });\n    Axis.override({\n        axis_line_color: 'black',\n        major_tick_line_color: 'black',\n        minor_tick_line_color: 'black',\n        major_label_text_font_size: \"8pt\",\n        major_label_text_align: \"center\",\n        major_label_text_baseline: \"alphabetic\",\n        axis_label_text_font_size: \"10pt\",\n        axis_label_text_font_style: \"italic\"\n    });\n    Axis.internal({\n        panel_side: [p.Any]\n    });\n    Axis.prototype.initialize = function (attrs, options) {\n        Axis.__super__.initialize.call(this, attrs, options);\n        this.define_computed_property('computed_bounds', this._computed_bounds, false);\n        this.add_dependencies('computed_bounds', this, ['bounds']);\n        return this.add_dependencies('computed_bounds', this.plot, ['x_range', 'y_range']);\n    };\n    Axis.getters({\n        computed_bounds: function () {\n            return this._get_computed('computed_bounds');\n        },\n        rule_coords: function () {\n            return this._rule_coords();\n        },\n        tick_coords: function () {\n            return this._tick_coords();\n        },\n        ranges: function () {\n            return this._ranges();\n        },\n        normals: function () {\n            return this.panel._normals;\n        },\n        dimension: function () {\n            return this.panel._dim;\n        },\n        offsets: function () {\n            return this._offsets();\n        },\n        loc: function () {\n            return this._get_loc();\n        }\n    });\n    Axis.prototype.add_panel = function (side) {\n        this.panel = new side_panel_1.SidePanel({\n            side: side\n        });\n        this.panel.attach_document(this.document);\n        return this.panel_side = side;\n    };\n    Axis.prototype._offsets = function () {\n        var frame, ref, side, xoff, yoff;\n        side = this.panel_side;\n        ref = [0, 0], xoff = ref[0], yoff = ref[1];\n        frame = this.plot.plot_canvas.frame;\n        switch (side) {\n            case \"below\":\n                yoff = Math.abs(this.panel.top - frame.bottom);\n                break;\n            case \"above\":\n                yoff = Math.abs(this.panel.bottom - frame.top);\n                break;\n            case \"right\":\n                xoff = Math.abs(this.panel.left - frame.right);\n                break;\n            case \"left\":\n                xoff = Math.abs(this.panel.right - frame.left);\n        }\n        return [xoff, yoff];\n    };\n    Axis.prototype._ranges = function () {\n        var frame, i, j, ranges;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        frame = this.plot.plot_canvas.frame;\n        ranges = [frame.x_ranges[this.x_range_name], frame.y_ranges[this.y_range_name]];\n        return [ranges[i], ranges[j]];\n    };\n    Axis.prototype._computed_bounds = function () {\n        var cross_range, end, range, range_bounds, ref, ref1, start, user_bounds;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        user_bounds = (ref1 = this.bounds) != null ? ref1 : 'auto';\n        range_bounds = [range.min, range.max];\n        if (user_bounds === 'auto') {\n            return range_bounds;\n        }\n        if (types_1.isArray(user_bounds)) {\n            if (Math.abs(user_bounds[0] - user_bounds[1]) > Math.abs(range_bounds[0] - range_bounds[1])) {\n                start = Math.max(Math.min(user_bounds[0], user_bounds[1]), range_bounds[0]);\n                end = Math.min(Math.max(user_bounds[0], user_bounds[1]), range_bounds[1]);\n            }\n            else {\n                start = Math.min(user_bounds[0], user_bounds[1]);\n                end = Math.max(user_bounds[0], user_bounds[1]);\n            }\n            return [start, end];\n        }\n        logging_1.logger.error(\"user bounds '\" + user_bounds + \"' not understood\");\n        return null;\n    };\n    Axis.prototype._rule_coords = function () {\n        var coords, cross_range, end, i, j, range, ref, ref1, start, xs, ys;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];\n        xs = new Array(2);\n        ys = new Array(2);\n        coords = [xs, ys];\n        coords[i][0] = Math.max(start, range.min);\n        coords[i][1] = Math.min(end, range.max);\n        if (coords[i][0] > coords[i][1]) {\n            coords[i][0] = coords[i][1] = 0 / 0;\n        }\n        coords[j][0] = this.loc;\n        coords[j][1] = this.loc;\n        return coords;\n    };\n    Axis.prototype._tick_coords = function () {\n        var coords, cross_range, end, i, ii, j, k, l, m, majors, minor_coords, minor_xs, minor_ys, minors, range, range_max, range_min, ref, ref1, ref2, ref3, ref4, ref5, start, ticks, xs, ys;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];\n        ticks = this.ticker.get_ticks(start, end, range, this.loc, {});\n        majors = ticks.major;\n        minors = ticks.minor;\n        xs = [];\n        ys = [];\n        coords = [xs, ys];\n        minor_xs = [];\n        minor_ys = [];\n        minor_coords = [minor_xs, minor_ys];\n        if (range.type === \"FactorRange\") {\n            for (ii = k = 0, ref2 = majors.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n                coords[i].push(majors[ii]);\n                coords[j].push(this.loc);\n            }\n        }\n        else {\n            ref3 = [range.min, range.max], range_min = ref3[0], range_max = ref3[1];\n            for (ii = l = 0, ref4 = majors.length; 0 <= ref4 ? l < ref4 : l > ref4; ii = 0 <= ref4 ? ++l : --l) {\n                if (majors[ii] < range_min || majors[ii] > range_max) {\n                    continue;\n                }\n                coords[i].push(majors[ii]);\n                coords[j].push(this.loc);\n            }\n            for (ii = m = 0, ref5 = minors.length; 0 <= ref5 ? m < ref5 : m > ref5; ii = 0 <= ref5 ? ++m : --m) {\n                if (minors[ii] < range_min || minors[ii] > range_max) {\n                    continue;\n                }\n                minor_coords[i].push(minors[ii]);\n                minor_coords[j].push(this.loc);\n            }\n        }\n        return {\n            \"major\": coords,\n            \"minor\": minor_coords\n        };\n    };\n    Axis.prototype._get_loc = function () {\n        var cend, cross_range, cstart, range, ref, side;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        cstart = cross_range.start;\n        cend = cross_range.end;\n        side = this.panel_side;\n        switch (side) {\n            case 'left':\n            case 'below':\n                return cross_range.start;\n            case 'right':\n            case 'above':\n                return cross_range.end;\n        }\n    };\n    return Axis;\n})(guide_renderer_1.GuideRenderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar categorical_tick_formatter_1 = require(\"../formatters/categorical_tick_formatter\");\nvar categorical_ticker_1 = require(\"../tickers/categorical_ticker\");\nvar logging_1 = require(\"core/logging\");\nexports.CategoricalAxisView = (function (superClass) {\n    extend(CategoricalAxisView, superClass);\n    function CategoricalAxisView() {\n        return CategoricalAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return CategoricalAxisView;\n})(axis_1.AxisView);\nexports.CategoricalAxis = (function (superClass) {\n    extend(CategoricalAxis, superClass);\n    function CategoricalAxis() {\n        return CategoricalAxis.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalAxis.prototype.default_view = exports.CategoricalAxisView;\n    CategoricalAxis.prototype.type = 'CategoricalAxis';\n    CategoricalAxis.override({\n        ticker: function () {\n            return new categorical_ticker_1.CategoricalTicker();\n        },\n        formatter: function () {\n            return new categorical_tick_formatter_1.CategoricalTickFormatter();\n        }\n    });\n    CategoricalAxis.prototype._computed_bounds = function () {\n        var cross_range, range, range_bounds, ref, ref1, user_bounds;\n        ref = this.ranges, range = ref[0], cross_range = ref[1];\n        user_bounds = (ref1 = this.bounds) != null ? ref1 : 'auto';\n        range_bounds = [range.min, range.max];\n        if (user_bounds !== 'auto') {\n            logging_1.logger.warn(\"Categorical Axes only support user_bounds='auto', ignoring\");\n        }\n        return range_bounds;\n    };\n    return CategoricalAxis;\n})(axis_1.Axis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nexports.ContinuousAxis = (function (superClass) {\n    extend(ContinuousAxis, superClass);\n    function ContinuousAxis() {\n        return ContinuousAxis.__super__.constructor.apply(this, arguments);\n    }\n    ContinuousAxis.prototype.type = 'ContinuousAxis';\n    return ContinuousAxis;\n})(axis_1.Axis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar linear_axis_1 = require(\"./linear_axis\");\nvar datetime_tick_formatter_1 = require(\"../formatters/datetime_tick_formatter\");\nvar datetime_ticker_1 = require(\"../tickers/datetime_ticker\");\nexports.DatetimeAxisView = (function (superClass) {\n    extend(DatetimeAxisView, superClass);\n    function DatetimeAxisView() {\n        return DatetimeAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return DatetimeAxisView;\n})(linear_axis_1.LinearAxisView);\nexports.DatetimeAxis = (function (superClass) {\n    extend(DatetimeAxis, superClass);\n    function DatetimeAxis() {\n        return DatetimeAxis.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeAxis.prototype.default_view = exports.DatetimeAxisView;\n    DatetimeAxis.prototype.type = 'DatetimeAxis';\n    DatetimeAxis.override({\n        ticker: function () {\n            return new datetime_ticker_1.DatetimeTicker();\n        },\n        formatter: function () {\n            return new datetime_tick_formatter_1.DatetimeTickFormatter();\n        }\n    });\n    return DatetimeAxis;\n})(linear_axis_1.LinearAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar axis_1 = require(\"./axis\");\nexports.Axis = axis_1.Axis;\nvar categorical_axis_1 = require(\"./categorical_axis\");\nexports.CategoricalAxis = categorical_axis_1.CategoricalAxis;\nvar continuous_axis_1 = require(\"./continuous_axis\");\nexports.ContinuousAxis = continuous_axis_1.ContinuousAxis;\nvar datetime_axis_1 = require(\"./datetime_axis\");\nexports.DatetimeAxis = datetime_axis_1.DatetimeAxis;\nvar linear_axis_1 = require(\"./linear_axis\");\nexports.LinearAxis = linear_axis_1.LinearAxis;\nvar log_axis_1 = require(\"./log_axis\");\nexports.LogAxis = log_axis_1.LogAxis;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar continuous_axis_1 = require(\"./continuous_axis\");\nvar basic_tick_formatter_1 = require(\"../formatters/basic_tick_formatter\");\nvar basic_ticker_1 = require(\"../tickers/basic_ticker\");\nexports.LinearAxisView = (function (superClass) {\n    extend(LinearAxisView, superClass);\n    function LinearAxisView() {\n        return LinearAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return LinearAxisView;\n})(axis_1.AxisView);\nexports.LinearAxis = (function (superClass) {\n    extend(LinearAxis, superClass);\n    function LinearAxis() {\n        return LinearAxis.__super__.constructor.apply(this, arguments);\n    }\n    LinearAxis.prototype.default_view = exports.LinearAxisView;\n    LinearAxis.prototype.type = 'LinearAxis';\n    LinearAxis.override({\n        ticker: function () {\n            return new basic_ticker_1.BasicTicker();\n        },\n        formatter: function () {\n            return new basic_tick_formatter_1.BasicTickFormatter();\n        }\n    });\n    return LinearAxis;\n})(continuous_axis_1.ContinuousAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar axis_1 = require(\"./axis\");\nvar continuous_axis_1 = require(\"./continuous_axis\");\nvar log_tick_formatter_1 = require(\"../formatters/log_tick_formatter\");\nvar log_ticker_1 = require(\"../tickers/log_ticker\");\nexports.LogAxisView = (function (superClass) {\n    extend(LogAxisView, superClass);\n    function LogAxisView() {\n        return LogAxisView.__super__.constructor.apply(this, arguments);\n    }\n    return LogAxisView;\n})(axis_1.AxisView);\nexports.LogAxis = (function (superClass) {\n    extend(LogAxis, superClass);\n    function LogAxis() {\n        return LogAxis.__super__.constructor.apply(this, arguments);\n    }\n    LogAxis.prototype.default_view = exports.LogAxisView;\n    LogAxis.prototype.type = 'LogAxis';\n    LogAxis.override({\n        ticker: function () {\n            return new log_ticker_1.LogTicker();\n        },\n        formatter: function () {\n            return new log_tick_formatter_1.LogTickFormatter();\n        }\n    });\n    return LogAxis;\n})(continuous_axis_1.ContinuousAxis);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar model_1 = require(\"../../model\");\nexports.CustomJS = (function (superClass) {\n    extend(CustomJS, superClass);\n    function CustomJS() {\n        return CustomJS.__super__.constructor.apply(this, arguments);\n    }\n    CustomJS.prototype.type = 'CustomJS';\n    CustomJS.define({\n        args: [p.Any, {}],\n        code: [p.String, '']\n    });\n    CustomJS.getters({\n        values: function () {\n            return this._make_values();\n        },\n        func: function () {\n            return this._make_func();\n        }\n    });\n    CustomJS.prototype.execute = function (cb_obj, cb_data) {\n        return this.func.apply(this, slice.call(this.values).concat([cb_obj], [cb_data], [require], [{}]));\n    };\n    CustomJS.prototype._make_values = function () {\n        return object_1.values(this.args);\n    };\n    CustomJS.prototype._make_func = function () {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, slice.call(Object.keys(this.args)).concat([\"cb_obj\"], [\"cb_data\"], [\"require\"], [\"exports\"], [this.code]), function () { });\n    };\n    return CustomJS;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar customjs_1 = require(\"./customjs\");\nexports.CustomJS = customjs_1.CustomJS;\nvar open_url_1 = require(\"./open_url\");\nexports.OpenURL = open_url_1.OpenURL;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nvar selection_1 = require(\"core/util/selection\");\nvar templating_1 = require(\"core/util/templating\");\nexports.OpenURL = (function (superClass) {\n    extend(OpenURL, superClass);\n    function OpenURL() {\n        return OpenURL.__super__.constructor.apply(this, arguments);\n    }\n    OpenURL.prototype.type = 'OpenURL';\n    OpenURL.define({\n        url: [p.String, 'http://']\n    });\n    OpenURL.prototype.execute = function (data_source) {\n        var i, j, len, ref, url;\n        ref = selection_1.get_indices(data_source);\n        for (j = 0, len = ref.length; j < len; j++) {\n            i = ref[j];\n            url = templating_1.replace_placeholders(this.url, data_source, i);\n            window.open(url);\n        }\n        return null;\n    };\n    return OpenURL;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar canvas_template_1 = require(\"./canvas_template\");\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar eq_1 = require(\"core/util/eq\");\nvar canvas_1 = require(\"core/util/canvas\");\nexports.CanvasView = (function (superClass) {\n    extend(CanvasView, superClass);\n    function CanvasView() {\n        return CanvasView.__super__.constructor.apply(this, arguments);\n    }\n    CanvasView.prototype.className = \"bk-canvas-wrapper\";\n    CanvasView.prototype.template = canvas_template_1.default;\n    CanvasView.prototype.initialize = function (options) {\n        var html;\n        CanvasView.__super__.initialize.call(this, options);\n        html = this.template({\n            map: this.model.map\n        });\n        this.el.appendChild(html);\n        this.ctx = this.get_ctx();\n        canvas_1.fixup_line_dash(this.ctx);\n        canvas_1.fixup_line_dash_offset(this.ctx);\n        canvas_1.fixup_image_smoothing(this.ctx);\n        canvas_1.fixup_measure_text(this.ctx);\n        canvas_1.fixup_ellipse(this.ctx);\n        if (window.CanvasPixelArray != null) {\n            CanvasPixelArray.prototype.set = function (arr) {\n                var i, j, ref, results;\n                results = [];\n                for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(this[i] = arr[i]);\n                }\n                return results;\n            };\n        }\n        this.map_div = this.el.querySelector('div.bk-canvas-map');\n        this.set_dims([this.model.initial_width, this.model.initial_height]);\n        return logging_1.logger.debug(\"CanvasView initialized\");\n    };\n    CanvasView.prototype.get_canvas_element = function () {\n        return this.el.querySelector('canvas.bk-canvas');\n    };\n    CanvasView.prototype.get_ctx = function () {\n        return this.get_canvas_element().getContext('2d');\n    };\n    CanvasView.prototype.prepare_canvas = function (force) {\n        var canvas_el, dpr, height, ratio, width;\n        if (force == null) {\n            force = false;\n        }\n        width = this.model._width._value;\n        height = this.model._height._value;\n        dpr = window.devicePixelRatio;\n        if (!eq_1.isEqual(this.last_dims, [width, height, dpr]) || force) {\n            this.el.style.width = width + \"px\";\n            this.el.style.height = height + \"px\";\n            this.pixel_ratio = ratio = canvas_1.get_scale_ratio(this.ctx, this.model.use_hidpi);\n            canvas_el = this.get_canvas_element();\n            canvas_el.style.width = width + \"px\";\n            canvas_el.style.height = height + \"px\";\n            canvas_el.setAttribute('width', width * ratio);\n            canvas_el.setAttribute('height', height * ratio);\n            logging_1.logger.debug(\"Rendering CanvasView [force=\" + force + \"] with width: \" + width + \", height: \" + height + \", ratio: \" + ratio);\n            this.model.pixel_ratio = this.pixel_ratio;\n            return this.last_dims = [width, height, dpr];\n        }\n    };\n    CanvasView.prototype.set_dims = function (dims, trigger) {\n        if (trigger == null) {\n            trigger = true;\n        }\n        this.requested_width = dims[0];\n        this.requested_height = dims[1];\n        this.update_constraints(trigger);\n    };\n    CanvasView.prototype.update_constraints = function (trigger) {\n        var MIN_SIZE, requested_height, requested_width, s;\n        if (trigger == null) {\n            trigger = true;\n        }\n        requested_width = this.requested_width;\n        requested_height = this.requested_height;\n        if ((requested_width == null) || (requested_height == null)) {\n            return;\n        }\n        MIN_SIZE = 50;\n        if (requested_width < MIN_SIZE || requested_height < MIN_SIZE) {\n            return;\n        }\n        if (eq_1.isEqual(this.last_requested_dims, [requested_width, requested_height])) {\n            return;\n        }\n        s = this.model.document.solver();\n        if (this._width_constraint != null) {\n            s.remove_constraint(this._width_constraint, true);\n        }\n        this._width_constraint = solver_1.EQ(this.model._width, -requested_width);\n        s.add_constraint(this._width_constraint);\n        if (this._height_constraint != null) {\n            s.remove_constraint(this._height_constraint, true);\n        }\n        this._height_constraint = solver_1.EQ(this.model._height, -requested_height);\n        s.add_constraint(this._height_constraint);\n        this.last_requested_dims = [requested_width, requested_height];\n        return s.update_variables(trigger);\n    };\n    return CanvasView;\n})(bokeh_view_1.BokehView);\nexports.Canvas = (function (superClass) {\n    extend(Canvas, superClass);\n    function Canvas() {\n        return Canvas.__super__.constructor.apply(this, arguments);\n    }\n    Canvas.prototype.type = 'Canvas';\n    Canvas.prototype.default_view = exports.CanvasView;\n    Canvas.internal({\n        map: [p.Boolean, false],\n        initial_width: [p.Number],\n        initial_height: [p.Number],\n        use_hidpi: [p.Boolean, true],\n        pixel_ratio: [p.Number]\n    });\n    Canvas.prototype.initialize = function (attrs, options) {\n        Canvas.__super__.initialize.call(this, attrs, options);\n        return this.panel = this;\n    };\n    Canvas.prototype.vx_to_sx = function (x) {\n        return x;\n    };\n    Canvas.prototype.vy_to_sy = function (y) {\n        return this._height._value - (y + 1);\n    };\n    Canvas.prototype.v_vx_to_sx = function (xx) {\n        return new Float64Array(xx);\n    };\n    Canvas.prototype.v_vy_to_sy = function (yy) {\n        var _yy, height, idx, j, len, y;\n        _yy = new Float64Array(yy.length);\n        height = this._height._value;\n        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {\n            y = yy[idx];\n            _yy[idx] = height - (y + 1);\n        }\n        return _yy;\n    };\n    Canvas.prototype.sx_to_vx = function (x) {\n        return x;\n    };\n    Canvas.prototype.sy_to_vy = function (y) {\n        return this._height._value - (y + 1);\n    };\n    Canvas.prototype.v_sx_to_vx = function (xx) {\n        return new Float64Array(xx);\n    };\n    Canvas.prototype.v_sy_to_vy = function (yy) {\n        var _yy, height, idx, j, len, y;\n        _yy = new Float64Array(yy.length);\n        height = this._height._value;\n        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {\n            y = yy[idx];\n            _yy[idx] = height - (y + 1);\n        }\n        return _yy;\n    };\n    Canvas.prototype.get_constraints = function () {\n        var constraints;\n        constraints = Canvas.__super__.get_constraints.call(this);\n        constraints.push(solver_1.GE(this._top));\n        constraints.push(solver_1.GE(this._bottom));\n        constraints.push(solver_1.GE(this._left));\n        constraints.push(solver_1.GE(this._right));\n        constraints.push(solver_1.GE(this._width));\n        constraints.push(solver_1.GE(this._height));\n        constraints.push(solver_1.EQ(this._width, [-1, this._right]));\n        constraints.push(solver_1.EQ(this._height, [-1, this._top]));\n        return constraints;\n    };\n    return Canvas;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOM = require(\"core/dom\");\nexports.default = function (props) {\n    return (DOM.createElement(\"fragment\", null,\n        props.map && DOM.createElement(\"div\", { class: \"bk-canvas-map\" }),\n        DOM.createElement(\"div\", { class: \"bk-canvas-events\" }),\n        DOM.createElement(\"div\", { class: \"bk-canvas-overlays\" }),\n        DOM.createElement(\"canvas\", { class: 'bk-canvas' })));\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nvar linear_mapper_1 = require(\"../mappers/linear_mapper\");\nvar log_mapper_1 = require(\"../mappers/log_mapper\");\nvar range1d_1 = require(\"../ranges/range1d\");\nvar solver_1 = require(\"core/layout/solver\");\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.CartesianFrame = (function (superClass) {\n    extend(CartesianFrame, superClass);\n    function CartesianFrame() {\n        return CartesianFrame.__super__.constructor.apply(this, arguments);\n    }\n    CartesianFrame.prototype.type = 'CartesianFrame';\n    CartesianFrame.prototype.initialize = function (attrs, options) {\n        CartesianFrame.__super__.initialize.call(this, attrs, options);\n        this.panel = this;\n        this._configure_mappers();\n        this.listenTo(this, 'change', (function (_this) {\n            return function () {\n                return _this._configure_mappers();\n            };\n        })(this));\n        return null;\n    };\n    CartesianFrame.prototype._doc_attached = function () {\n        this.listenTo(this.document.solver(), 'layout_update', (function (_this) {\n            return function () {\n                return _this._update_mappers();\n            };\n        })(this));\n        return null;\n    };\n    CartesianFrame.prototype.contains = function (vx, vy) {\n        return vx >= this.left && vx <= this.right && vy >= this.bottom && vy <= this.top;\n    };\n    CartesianFrame.prototype.map_to_screen = function (x, y, canvas, x_name, y_name) {\n        var sx, sy, vx, vy;\n        if (x_name == null) {\n            x_name = 'default';\n        }\n        if (y_name == null) {\n            y_name = 'default';\n        }\n        vx = this.x_mappers[x_name].v_map_to_target(x);\n        sx = canvas.v_vx_to_sx(vx);\n        vy = this.y_mappers[y_name].v_map_to_target(y);\n        sy = canvas.v_vy_to_sy(vy);\n        return [sx, sy];\n    };\n    CartesianFrame.prototype._get_ranges = function (range, extra_ranges) {\n        var extra_range, name, ranges;\n        ranges = {};\n        ranges['default'] = range;\n        if (extra_ranges != null) {\n            for (name in extra_ranges) {\n                extra_range = extra_ranges[name];\n                ranges[name] = extra_range;\n            }\n        }\n        return ranges;\n    };\n    CartesianFrame.prototype._get_mappers = function (mapper_type, ranges, frame_range) {\n        var mapper_model, mappers, name, range;\n        mappers = {};\n        for (name in ranges) {\n            range = ranges[name];\n            if (range.type === \"Range1d\" || range.type === \"DataRange1d\") {\n                if (mapper_type === \"log\") {\n                    mapper_model = log_mapper_1.LogMapper;\n                }\n                else {\n                    mapper_model = linear_mapper_1.LinearMapper;\n                }\n                range.mapper_hint = mapper_type;\n            }\n            else if (range.type === \"FactorRange\") {\n                mapper_model = categorical_mapper_1.CategoricalMapper;\n            }\n            else {\n                logging_1.logger.warn(\"unknown range type for range '\" + name + \"': \" + range);\n                return null;\n            }\n            mappers[name] = new mapper_model({\n                source_range: range,\n                target_range: frame_range\n            });\n        }\n        return mappers;\n    };\n    CartesianFrame.prototype._configure_frame_ranges = function () {\n        this._h_range = new range1d_1.Range1d({\n            start: this.left,\n            end: this.left + this.width\n        });\n        return this._v_range = new range1d_1.Range1d({\n            start: this.bottom,\n            end: this.bottom + this.height\n        });\n    };\n    CartesianFrame.prototype._configure_mappers = function () {\n        this._configure_frame_ranges();\n        this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);\n        this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);\n        this._x_mappers = this._get_mappers(this.x_mapper_type, this._x_ranges, this._h_range);\n        return this._y_mappers = this._get_mappers(this.y_mapper_type, this._y_ranges, this._v_range);\n    };\n    CartesianFrame.prototype._update_mappers = function () {\n        var mapper, name, ref, ref1;\n        this._configure_frame_ranges();\n        ref = this._x_mappers;\n        for (name in ref) {\n            mapper = ref[name];\n            mapper.target_range = this._h_range;\n        }\n        ref1 = this._y_mappers;\n        for (name in ref1) {\n            mapper = ref1[name];\n            mapper.target_range = this._v_range;\n        }\n        return null;\n    };\n    CartesianFrame.getters({\n        h_range: function () {\n            return this._h_range;\n        },\n        v_range: function () {\n            return this._v_range;\n        },\n        x_ranges: function () {\n            return this._x_ranges;\n        },\n        y_ranges: function () {\n            return this._y_ranges;\n        },\n        x_mappers: function () {\n            return this._x_mappers;\n        },\n        y_mappers: function () {\n            return this._y_mappers;\n        }\n    });\n    CartesianFrame.internal({\n        extra_x_ranges: [p.Any, {}],\n        extra_y_ranges: [p.Any, {}],\n        x_range: [p.Instance],\n        y_range: [p.Instance],\n        x_mapper_type: [p.String, 'auto'],\n        y_mapper_type: [p.String, 'auto']\n    });\n    CartesianFrame.prototype.get_constraints = function () {\n        var constraints;\n        constraints = [];\n        constraints.push(solver_1.GE(this._top));\n        constraints.push(solver_1.GE(this._bottom));\n        constraints.push(solver_1.GE(this._left));\n        constraints.push(solver_1.GE(this._right));\n        constraints.push(solver_1.GE(this._width));\n        constraints.push(solver_1.GE(this._height));\n        constraints.push(solver_1.EQ(this._left, this._width, [-1, this._right]));\n        constraints.push(solver_1.EQ(this._bottom, this._height, [-1, this._top]));\n        return constraints;\n    };\n    return CartesianFrame;\n})(layout_canvas_1.LayoutCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar canvas_1 = require(\"./canvas\");\nexports.Canvas = canvas_1.Canvas;\nvar cartesian_frame_1 = require(\"./cartesian_frame\");\nexports.CartesianFrame = cartesian_frame_1.CartesianFrame;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.BasicTickFormatter = (function (superClass) {\n    extend(BasicTickFormatter, superClass);\n    function BasicTickFormatter() {\n        return BasicTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    BasicTickFormatter.prototype.type = 'BasicTickFormatter';\n    BasicTickFormatter.define({\n        precision: [p.Any, 'auto'],\n        use_scientific: [p.Bool, true],\n        power_limit_high: [p.Number, 5],\n        power_limit_low: [p.Number, -3]\n    });\n    BasicTickFormatter.getters({\n        scientific_limit_low: function () {\n            return Math.pow(10.0, this.power_limit_low);\n        },\n        scientific_limit_high: function () {\n            return Math.pow(10.0, this.power_limit_high);\n        }\n    });\n    BasicTickFormatter.prototype.initialize = function (attrs, options) {\n        BasicTickFormatter.__super__.initialize.call(this, attrs, options);\n        return this.last_precision = 3;\n    };\n    BasicTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var i, is_ok, j, k, l, labels, len, m, n, need_sci, o, precision, ref, ref1, ref2, ref3, ref4, tick, tick_abs, x, zero_eps;\n        if (ticks.length === 0) {\n            return [];\n        }\n        zero_eps = 0;\n        if (ticks.length >= 2) {\n            zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;\n        }\n        need_sci = false;\n        if (this.use_scientific) {\n            for (j = 0, len = ticks.length; j < len; j++) {\n                tick = ticks[j];\n                tick_abs = Math.abs(tick);\n                if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {\n                    need_sci = true;\n                    break;\n                }\n            }\n        }\n        precision = this.precision;\n        if ((precision == null) || types_1.isNumber(precision)) {\n            labels = new Array(ticks.length);\n            if (need_sci) {\n                for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    labels[i] = ticks[i].toExponential(precision || void 0);\n                }\n            }\n            else {\n                for (i = l = 0, ref1 = ticks.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {\n                    labels[i] = ticks[i].toFixed(precision || void 0).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                }\n            }\n            return labels;\n        }\n        else if (precision === 'auto') {\n            labels = new Array(ticks.length);\n            for (x = m = ref2 = this.last_precision; ref2 <= 15 ? m <= 15 : m >= 15; x = ref2 <= 15 ? ++m : --m) {\n                is_ok = true;\n                if (need_sci) {\n                    for (i = n = 0, ref3 = ticks.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {\n                        labels[i] = ticks[i].toExponential(x);\n                        if (i > 0) {\n                            if (labels[i] === labels[i - 1]) {\n                                is_ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (is_ok) {\n                        break;\n                    }\n                }\n                else {\n                    for (i = o = 0, ref4 = ticks.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {\n                        labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                        if (i > 0) {\n                            if (labels[i] === labels[i - 1]) {\n                                is_ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (is_ok) {\n                        break;\n                    }\n                }\n                if (is_ok) {\n                    this.last_precision = x;\n                    return labels;\n                }\n            }\n        }\n        return labels;\n    };\n    return BasicTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nexports.CategoricalTickFormatter = (function (superClass) {\n    extend(CategoricalTickFormatter, superClass);\n    function CategoricalTickFormatter() {\n        return CategoricalTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalTickFormatter.prototype.type = 'CategoricalTickFormatter';\n    CategoricalTickFormatter.prototype.doFormat = function (ticks, loc) {\n        return ticks;\n    };\n    return CategoricalTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _array, _strftime, _us, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar SPrintf = require(\"sprintf\");\nvar tz = require(\"timezone\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\n_us = function (t) {\n    return Math.round(((t / 1000) % 1) * 1000000);\n};\n_array = function (t) {\n    return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(function (e) {\n        return parseInt(e, 10);\n    });\n};\n_strftime = function (t, format) {\n    var microsecond_replacement_string;\n    if (types_1.isFunction(format)) {\n        return format(t);\n    }\n    else {\n        microsecond_replacement_string = SPrintf.sprintf(\"$1%06d\", _us(t));\n        format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\n        if (format.indexOf(\"%\") === -1) {\n            return format;\n        }\n        return tz(t, format);\n    }\n};\nexports.DatetimeTickFormatter = (function (superClass) {\n    extend(DatetimeTickFormatter, superClass);\n    function DatetimeTickFormatter() {\n        return DatetimeTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeTickFormatter.prototype.type = 'DatetimeTickFormatter';\n    DatetimeTickFormatter.define({\n        microseconds: [p.Array, ['%fus']],\n        milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\n        seconds: [p.Array, ['%Ss']],\n        minsec: [p.Array, [':%M:%S']],\n        minutes: [p.Array, [':%M', '%Mm']],\n        hourmin: [p.Array, ['%H:%M']],\n        hours: [p.Array, ['%Hh', '%H:%M']],\n        days: [p.Array, ['%m/%d', '%a%d']],\n        months: [p.Array, ['%m/%Y', '%b%y']],\n        years: [p.Array, ['%Y']]\n    });\n    DatetimeTickFormatter.prototype.format_order = ['microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years'];\n    DatetimeTickFormatter.prototype.strip_leading_zeros = true;\n    DatetimeTickFormatter.prototype.initialize = function (attrs, options) {\n        DatetimeTickFormatter.__super__.initialize.call(this, attrs, options);\n        return this._update_width_formats();\n    };\n    DatetimeTickFormatter.prototype._update_width_formats = function () {\n        var _widths, now;\n        now = tz(new Date());\n        _widths = function (fmt_strings) {\n            var fmt_string, sizes, sorted;\n            sizes = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = fmt_strings.length; j < len; j++) {\n                    fmt_string = fmt_strings[j];\n                    results.push(_strftime(now, fmt_string).length);\n                }\n                return results;\n            })();\n            sorted = array_1.sortBy(array_1.zip(sizes, fmt_strings), function (arg) {\n                var fmt, size;\n                size = arg[0], fmt = arg[1];\n                return size;\n            });\n            return array_1.unzip(sorted);\n        };\n        return this._width_formats = {\n            microseconds: _widths(this.microseconds),\n            milliseconds: _widths(this.milliseconds),\n            seconds: _widths(this.seconds),\n            minsec: _widths(this.minsec),\n            minutes: _widths(this.minutes),\n            hourmin: _widths(this.hourmin),\n            hours: _widths(this.hours),\n            days: _widths(this.days),\n            months: _widths(this.months),\n            years: _widths(this.years)\n        };\n    };\n    DatetimeTickFormatter.prototype._get_resolution_str = function (resolution_secs, span_secs) {\n        var adjusted_secs;\n        adjusted_secs = resolution_secs * 1.1;\n        switch (false) {\n            case !(adjusted_secs < 1e-3):\n                return \"microseconds\";\n            case !(adjusted_secs < 1.0):\n                return \"milliseconds\";\n            case !(adjusted_secs < 60):\n                if (span_secs >= 60) {\n                    return \"minsec\";\n                }\n                else {\n                    return \"seconds\";\n                }\n            case !(adjusted_secs < 3600):\n                if (span_secs >= 3600) {\n                    return \"hourmin\";\n                }\n                else {\n                    return \"minutes\";\n                }\n            case !(adjusted_secs < 24 * 3600):\n                return \"hours\";\n            case !(adjusted_secs < 31 * 24 * 3600):\n                return \"days\";\n            case !(adjusted_secs < 365 * 24 * 3600):\n                return \"months\";\n            default:\n                return \"years\";\n        }\n    };\n    DatetimeTickFormatter.prototype.doFormat = function (ticks, loc, num_labels, char_width, fill_ratio, ticker) {\n        var error, fmt, format, formats, good_formats, hybrid_handled, i, j, k, l, labels, len, len1, next_format, next_ndx, r, ref, ref1, ref2, resol, resol_ndx, s, span, ss, t, time_tuple_ndx_for_resol, tm, widths;\n        if (num_labels == null) {\n            num_labels = null;\n        }\n        if (char_width == null) {\n            char_width = null;\n        }\n        if (fill_ratio == null) {\n            fill_ratio = 0.3;\n        }\n        if (ticker == null) {\n            ticker = null;\n        }\n        if (ticks.length === 0) {\n            return [];\n        }\n        span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\n        if (ticker) {\n            r = ticker.resolution;\n        }\n        else {\n            r = span / (ticks.length - 1);\n        }\n        resol = this._get_resolution_str(r, span);\n        ref = this._width_formats[resol], widths = ref[0], formats = ref[1];\n        format = formats[0];\n        if (char_width) {\n            good_formats = [];\n            for (i = j = 0, ref1 = widths.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                if (widths[i] * ticks.length < fill_ratio * char_width) {\n                    good_formats.push(this._width_formats[i]);\n                }\n            }\n            if (good_formats.length > 0) {\n                format = good_formats[good_formats.length - 1];\n            }\n        }\n        labels = [];\n        resol_ndx = this.format_order.indexOf(resol);\n        time_tuple_ndx_for_resol = {};\n        ref2 = this.format_order;\n        for (k = 0, len = ref2.length; k < len; k++) {\n            fmt = ref2[k];\n            time_tuple_ndx_for_resol[fmt] = 0;\n        }\n        time_tuple_ndx_for_resol[\"seconds\"] = 5;\n        time_tuple_ndx_for_resol[\"minsec\"] = 4;\n        time_tuple_ndx_for_resol[\"minutes\"] = 4;\n        time_tuple_ndx_for_resol[\"hourmin\"] = 3;\n        time_tuple_ndx_for_resol[\"hours\"] = 3;\n        for (l = 0, len1 = ticks.length; l < len1; l++) {\n            t = ticks[l];\n            try {\n                tm = _array(t);\n                s = _strftime(t, format);\n            }\n            catch (error1) {\n                error = error1;\n                logging_1.logger.warn(\"unable to format tick for timestamp value \" + t);\n                logging_1.logger.warn(\" - \" + error);\n                labels.push(\"ERR\");\n                continue;\n            }\n            hybrid_handled = false;\n            next_ndx = resol_ndx;\n            while (tm[time_tuple_ndx_for_resol[this.format_order[next_ndx]]] === 0) {\n                next_ndx += 1;\n                if (next_ndx === this.format_order.length) {\n                    break;\n                }\n                if ((resol === \"minsec\" || resol === \"hourmin\") && !hybrid_handled) {\n                    if ((resol === \"minsec\" && tm[4] === 0 && tm[5] !== 0) || (resol === \"hourmin\" && tm[3] === 0 && tm[4] !== 0)) {\n                        next_format = this._width_formats[this.format_order[resol_ndx - 1]][1][0];\n                        s = _strftime(t, next_format);\n                        break;\n                    }\n                    else {\n                        hybrid_handled = true;\n                    }\n                }\n                next_format = this._width_formats[this.format_order[next_ndx]][1][0];\n                s = _strftime(t, next_format);\n            }\n            if (this.strip_leading_zeros) {\n                ss = s.replace(/^0+/g, \"\");\n                if (ss !== s && isNaN(parseInt(ss))) {\n                    ss = '0' + ss;\n                }\n                labels.push(ss);\n            }\n            else {\n                labels.push(s);\n            }\n        }\n        return labels;\n    };\n    return DatetimeTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.FuncTickFormatter = (function (superClass) {\n    extend(FuncTickFormatter, superClass);\n    function FuncTickFormatter() {\n        return FuncTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    FuncTickFormatter.prototype.type = 'FuncTickFormatter';\n    FuncTickFormatter.define({\n        args: [p.Any, {}],\n        code: [p.String, '']\n    });\n    FuncTickFormatter.prototype.initialize = function (attrs, options) {\n        return FuncTickFormatter.__super__.initialize.call(this, attrs, options);\n    };\n    FuncTickFormatter.prototype._make_func = function () {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, [\"tick\"].concat(slice.call(Object.keys(this.args)), [\"require\"], [this.code]), function () { });\n    };\n    FuncTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var func, tick;\n        func = this._make_func();\n        return (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(func.apply(null, [tick].concat(slice.call(object_1.values(this.args)), [require])));\n            }\n            return results;\n        }).call(this);\n    };\n    return FuncTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nexports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;\nvar categorical_tick_formatter_1 = require(\"./categorical_tick_formatter\");\nexports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;\nvar datetime_tick_formatter_1 = require(\"./datetime_tick_formatter\");\nexports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;\nvar func_tick_formatter_1 = require(\"./func_tick_formatter\");\nexports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;\nvar log_tick_formatter_1 = require(\"./log_tick_formatter\");\nexports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;\nvar mercator_tick_formatter_1 = require(\"./mercator_tick_formatter\");\nexports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;\nvar numeral_tick_formatter_1 = require(\"./numeral_tick_formatter\");\nexports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;\nvar printf_tick_formatter_1 = require(\"./printf_tick_formatter\");\nexports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;\nvar tick_formatter_1 = require(\"./tick_formatter\");\nexports.TickFormatter = tick_formatter_1.TickFormatter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.LogTickFormatter = (function (superClass) {\n    extend(LogTickFormatter, superClass);\n    function LogTickFormatter() {\n        return LogTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    LogTickFormatter.prototype.type = 'LogTickFormatter';\n    LogTickFormatter.define({\n        ticker: [p.Instance, null]\n    });\n    LogTickFormatter.prototype.initialize = function (attrs, options) {\n        LogTickFormatter.__super__.initialize.call(this, attrs, options);\n        this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();\n        if (this.ticker == null) {\n            return logging_1.logger.warn(\"LogTickFormatter not configured with a ticker, using default base of 10 (labels will be incorrect if ticker base is not 10)\");\n        }\n    };\n    LogTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var base, i, j, labels, ref, small_interval;\n        if (ticks.length === 0) {\n            return [];\n        }\n        if (this.ticker != null) {\n            base = this.ticker.base;\n        }\n        else {\n            base = 10;\n        }\n        small_interval = false;\n        labels = new Array(ticks.length);\n        for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            labels[i] = base + \"^\" + (Math.round(Math.log(ticks[i]) / Math.log(base)));\n            if ((i > 0) && (labels[i] === labels[i - 1])) {\n                small_interval = true;\n                break;\n            }\n        }\n        if (small_interval) {\n            labels = this.basic_formatter.doFormat(ticks);\n        }\n        return labels;\n    };\n    return LogTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_tick_formatter_1 = require(\"./basic_tick_formatter\");\nvar p = require(\"core/properties\");\nvar proj4_1 = require(\"core/util/proj4\");\nexports.MercatorTickFormatter = (function (superClass) {\n    extend(MercatorTickFormatter, superClass);\n    function MercatorTickFormatter() {\n        return MercatorTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTickFormatter.prototype.type = 'MercatorTickFormatter';\n    MercatorTickFormatter.define({\n        dimension: [p.LatLon]\n    });\n    MercatorTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var i, j, k, lat, lon, proj_ticks, ref, ref1, ref2, ref3;\n        if (this.dimension == null) {\n            throw new Error(\"MercatorTickFormatter.dimension not configured\");\n        }\n        if (ticks.length === 0) {\n            return [];\n        }\n        proj_ticks = new Array(ticks.length);\n        if (this.dimension === \"lon\") {\n            for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                ref1 = proj4_1.proj4(proj4_1.mercator).inverse([ticks[i], loc]), lon = ref1[0], lat = ref1[1];\n                proj_ticks[i] = lon;\n            }\n        }\n        else {\n            for (i = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                ref3 = proj4_1.proj4(proj4_1.mercator).inverse([loc, ticks[i]]), lon = ref3[0], lat = ref3[1];\n                proj_ticks[i] = lat;\n            }\n        }\n        return MercatorTickFormatter.__super__.doFormat.call(this, proj_ticks, loc);\n    };\n    return MercatorTickFormatter;\n})(basic_tick_formatter_1.BasicTickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar Numbro = require(\"numbro\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nexports.NumeralTickFormatter = (function (superClass) {\n    extend(NumeralTickFormatter, superClass);\n    function NumeralTickFormatter() {\n        return NumeralTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    NumeralTickFormatter.prototype.type = 'NumeralTickFormatter';\n    NumeralTickFormatter.define({\n        format: [p.String, '0,0'],\n        language: [p.String, 'en'],\n        rounding: [p.String, 'round']\n    });\n    NumeralTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var format, labels, language, rounding, tick;\n        format = this.format;\n        language = this.language;\n        rounding = (function () {\n            switch (this.rounding) {\n                case \"round\":\n                case \"nearest\":\n                    return Math.round;\n                case \"floor\":\n                case \"rounddown\":\n                    return Math.floor;\n                case \"ceil\":\n                case \"roundup\":\n                    return Math.ceil;\n            }\n        }).call(this);\n        labels = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(Numbro.format(tick, format, language, rounding));\n            }\n            return results;\n        })();\n        return labels;\n    };\n    return NumeralTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar SPrintf = require(\"sprintf\");\nvar tick_formatter_1 = require(\"./tick_formatter\");\nvar p = require(\"core/properties\");\nexports.PrintfTickFormatter = (function (superClass) {\n    extend(PrintfTickFormatter, superClass);\n    function PrintfTickFormatter() {\n        return PrintfTickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    PrintfTickFormatter.prototype.type = 'PrintfTickFormatter';\n    PrintfTickFormatter.define({\n        format: [p.String, '%s']\n    });\n    PrintfTickFormatter.prototype.doFormat = function (ticks, loc) {\n        var format, labels, tick;\n        format = this.format;\n        labels = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = ticks.length; i < len; i++) {\n                tick = ticks[i];\n                results.push(SPrintf.sprintf(format, tick));\n            }\n            return results;\n        })();\n        return labels;\n    };\n    return PrintfTickFormatter;\n})(tick_formatter_1.TickFormatter);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nexports.TickFormatter = (function (superClass) {\n    extend(TickFormatter, superClass);\n    function TickFormatter() {\n        return TickFormatter.__super__.constructor.apply(this, arguments);\n    }\n    TickFormatter.prototype.type = 'TickFormatter';\n    TickFormatter.prototype.doFormat = function (ticks, loc) { };\n    return TickFormatter;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.AnnularWedgeView = (function (superClass) {\n    extend(AnnularWedgeView, superClass);\n    function AnnularWedgeView() {\n        return AnnularWedgeView.__super__.constructor.apply(this, arguments);\n    }\n    AnnularWedgeView.prototype._map_data = function () {\n        var i, j, ref, results;\n        if (this.model.properties.inner_radius.units === \"data\") {\n            this.sinner_radius = this.sdist(this.renderer.xmapper, this._x, this._inner_radius);\n        }\n        else {\n            this.sinner_radius = this._inner_radius;\n        }\n        if (this.model.properties.outer_radius.units === \"data\") {\n            this.souter_radius = this.sdist(this.renderer.xmapper, this._x, this._outer_radius);\n        }\n        else {\n            this.souter_radius = this._outer_radius;\n        }\n        this._angle = new Float32Array(this._start_angle.length);\n        results = [];\n        for (i = j = 0, ref = this._start_angle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            results.push(this._angle[i] = this._end_angle[i] - this._start_angle[i]);\n        }\n        return results;\n    };\n    AnnularWedgeView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _start_angle, direction, i, j, len, results, sinner_radius, souter_radius, sx, sy;\n        sx = arg.sx, sy = arg.sy, _start_angle = arg._start_angle, _angle = arg._angle, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;\n        direction = this.model.properties.direction.value();\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i])) {\n                continue;\n            }\n            ctx.translate(sx[i], sy[i]);\n            ctx.rotate(_start_angle[i]);\n            ctx.moveTo(souter_radius[i], 0);\n            ctx.beginPath();\n            ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\n            ctx.rotate(_angle[i]);\n            ctx.lineTo(sinner_radius[i], 0);\n            ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\n            ctx.closePath();\n            ctx.rotate(-_angle[i] - _start_angle[i]);\n            ctx.translate(-sx[i], -sy[i]);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    AnnularWedgeView.prototype._hit_point = function (geometry) {\n        var angle, bbox, candidates, direction, dist, hits, i, ir2, j, k, len, len1, or2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        if (this.model.properties.outer_radius.units === \"data\") {\n            x0 = x - this.max_outer_radius;\n            x1 = x + this.max_outer_radius;\n            y0 = y - this.max_outer_radius;\n            y1 = y + this.max_outer_radius;\n        }\n        else {\n            vx0 = vx - this.max_outer_radius;\n            vx1 = vx + this.max_outer_radius;\n            ref1 = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            vy0 = vy - this.max_outer_radius;\n            vy1 = vy + this.max_outer_radius;\n            ref2 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        }\n        candidates = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref3 = this.index.indices(bbox);\n        for (j = 0, len = ref3.length; j < len; j++) {\n            i = ref3[j];\n            or2 = Math.pow(this.souter_radius[i], 2);\n            ir2 = Math.pow(this.sinner_radius[i], 2);\n            sx0 = this.renderer.xmapper.map_to_target(x, true);\n            sx1 = this.renderer.xmapper.map_to_target(this._x[i], true);\n            sy0 = this.renderer.ymapper.map_to_target(y, true);\n            sy1 = this.renderer.ymapper.map_to_target(this._y[i], true);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= or2 && dist >= ir2) {\n                candidates.push([i, dist]);\n            }\n        }\n        direction = this.model.properties.direction.value();\n        hits = [];\n        for (k = 0, len1 = candidates.length; k < len1; k++) {\n            ref4 = candidates[k], i = ref4[0], dist = ref4[1];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    AnnularWedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    AnnularWedgeView.prototype._scxy = function (i) {\n        var a, r;\n        r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\n        a = (this._start_angle[i] + this._end_angle[i]) / 2;\n        return {\n            x: this.sx[i] + r * Math.cos(a),\n            y: this.sy[i] + r * Math.sin(a)\n        };\n    };\n    AnnularWedgeView.prototype.scx = function (i) {\n        return this._scxy(i).x;\n    };\n    AnnularWedgeView.prototype.scy = function (i) {\n        return this._scxy(i).y;\n    };\n    return AnnularWedgeView;\n})(xy_glyph_1.XYGlyphView);\nexports.AnnularWedge = (function (superClass) {\n    extend(AnnularWedge, superClass);\n    function AnnularWedge() {\n        return AnnularWedge.__super__.constructor.apply(this, arguments);\n    }\n    AnnularWedge.prototype.default_view = exports.AnnularWedgeView;\n    AnnularWedge.prototype.type = 'AnnularWedge';\n    AnnularWedge.mixins(['line', 'fill']);\n    AnnularWedge.define({\n        direction: [p.Direction, 'anticlock'],\n        inner_radius: [p.DistanceSpec],\n        outer_radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return AnnularWedge;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.AnnulusView = (function (superClass) {\n    extend(AnnulusView, superClass);\n    function AnnulusView() {\n        return AnnulusView.__super__.constructor.apply(this, arguments);\n    }\n    AnnulusView.prototype._map_data = function () {\n        if (this.model.properties.inner_radius.units === \"data\") {\n            this.sinner_radius = this.sdist(this.renderer.xmapper, this._x, this._inner_radius);\n        }\n        else {\n            this.sinner_radius = this._inner_radius;\n        }\n        if (this.model.properties.outer_radius.units === \"data\") {\n            return this.souter_radius = this.sdist(this.renderer.xmapper, this._x, this._outer_radius);\n        }\n        else {\n            return this.souter_radius = this._outer_radius;\n        }\n    };\n    AnnulusView.prototype._render = function (ctx, indices, arg) {\n        var clockwise, i, isie, j, k, len, len1, ref, results, sinner_radius, souter_radius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i])) {\n                continue;\n            }\n            isie = navigator.userAgent.indexOf('MSIE') >= 0 || navigator.userAgent.indexOf('Trident') > 0 || navigator.userAgent.indexOf('Edge') > 0;\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.beginPath();\n                if (isie) {\n                    ref = [false, true];\n                    for (k = 0, len1 = ref.length; k < len1; k++) {\n                        clockwise = ref[k];\n                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);\n                        ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);\n                    }\n                }\n                else {\n                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);\n                    ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);\n                }\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);\n                ctx.moveTo(sx[i] + souter_radius[i], sy[i]);\n                ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    AnnulusView.prototype._hit_point = function (geometry) {\n        var bbox, dist, hits, i, ir2, j, len, or2, ref, ref1, sx0, sx1, sy0, sy1, vx, vy, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        x0 = x - this.max_radius;\n        x1 = x + this.max_radius;\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        y0 = y - this.max_radius;\n        y1 = y + this.max_radius;\n        hits = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref1 = this.index.indices(bbox);\n        for (j = 0, len = ref1.length; j < len; j++) {\n            i = ref1[j];\n            or2 = Math.pow(this.souter_radius[i], 2);\n            ir2 = Math.pow(this.sinner_radius[i], 2);\n            sx0 = this.renderer.xmapper.map_to_target(x);\n            sx1 = this.renderer.xmapper.map_to_target(this._x[i]);\n            sy0 = this.renderer.ymapper.map_to_target(y);\n            sy1 = this.renderer.ymapper.map_to_target(this._y[i]);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= or2 && dist >= ir2) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    AnnulusView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var data, indices, r, sinner_radius, souter_radius, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;\n        sinner_radius = {};\n        sinner_radius[index] = r * 0.4;\n        souter_radius = {};\n        souter_radius[index] = r * 0.8;\n        data = {\n            sx: sx,\n            sy: sy,\n            sinner_radius: sinner_radius,\n            souter_radius: souter_radius\n        };\n        return this._render(ctx, indices, data);\n    };\n    return AnnulusView;\n})(xy_glyph_1.XYGlyphView);\nexports.Annulus = (function (superClass) {\n    extend(Annulus, superClass);\n    function Annulus() {\n        return Annulus.__super__.constructor.apply(this, arguments);\n    }\n    Annulus.prototype.default_view = exports.AnnulusView;\n    Annulus.prototype.type = 'Annulus';\n    Annulus.mixins(['line', 'fill']);\n    Annulus.define({\n        inner_radius: [p.DistanceSpec],\n        outer_radius: [p.DistanceSpec]\n    });\n    return Annulus;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.ArcView = (function (superClass) {\n    extend(ArcView, superClass);\n    function ArcView() {\n        return ArcView.__super__.constructor.apply(this, arguments);\n    }\n    ArcView.prototype._map_data = function () {\n        if (this.model.properties.radius.units === \"data\") {\n            return this.sradius = this.sdist(this.renderer.xmapper, this._x, this._radius);\n        }\n        else {\n            return this.sradius = this._radius;\n        }\n    };\n    ArcView.prototype._render = function (ctx, indices, arg) {\n        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;\n        if (this.visuals.line.doit) {\n            direction = this.model.properties.direction.value();\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    ArcView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return ArcView;\n})(xy_glyph_1.XYGlyphView);\nexports.Arc = (function (superClass) {\n    extend(Arc, superClass);\n    function Arc() {\n        return Arc.__super__.constructor.apply(this, arguments);\n    }\n    Arc.prototype.default_view = exports.ArcView;\n    Arc.prototype.type = 'Arc';\n    Arc.mixins(['line']);\n    Arc.define({\n        direction: [p.Direction, 'anticlock'],\n        radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return Arc;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _cbb, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\n_cbb = function (x0, y0, x1, y1, x2, y2, x3, y3) {\n    var a, b, b2ac, bounds, c, i, j, jlen, k, mt, sqrtb2ac, t, t1, t2, tvalues, x, y;\n    tvalues = [];\n    bounds = [[], []];\n    for (i = k = 0; k <= 2; i = ++k) {\n        if (i === 0) {\n            b = 6 * x0 - 12 * x1 + 6 * x2;\n            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n            c = 3 * x1 - 3 * x0;\n        }\n        else {\n            b = 6 * y0 - 12 * y1 + 6 * y2;\n            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n            c = 3 * y1 - 3 * y0;\n        }\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) < 1e-12) {\n                continue;\n            }\n            t = -c / b;\n            if (0 < t && t < 1) {\n                tvalues.push(t);\n            }\n            continue;\n        }\n        b2ac = b * b - 4 * c * a;\n        sqrtb2ac = Math.sqrt(b2ac);\n        if (b2ac < 0) {\n            continue;\n        }\n        t1 = (-b + sqrtb2ac) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            tvalues.push(t1);\n        }\n        t2 = (-b - sqrtb2ac) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            tvalues.push(t2);\n        }\n    }\n    j = tvalues.length;\n    jlen = j;\n    while (j--) {\n        t = tvalues[j];\n        mt = 1 - t;\n        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n        bounds[0][j] = x;\n        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        bounds[1][j] = y;\n    }\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    return [Math.min.apply(null, bounds[0]), Math.max.apply(null, bounds[1]), Math.max.apply(null, bounds[0]), Math.min.apply(null, bounds[1])];\n};\nexports.BezierView = (function (superClass) {\n    extend(BezierView, superClass);\n    function BezierView() {\n        return BezierView.__super__.constructor.apply(this, arguments);\n    }\n    BezierView.prototype._index_data = function () {\n        var i, k, points, ref, ref1, x0, x1, y0, y1;\n        points = [];\n        for (i = k = 0, ref = this._x0.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i])) {\n                continue;\n            }\n            ref1 = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]), x0 = ref1[0], y0 = ref1[1], x1 = ref1[2], y1 = ref1[3];\n            points.push({\n                minX: x0,\n                minY: y0,\n                maxX: x1,\n                maxY: y1,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    BezierView.prototype._render = function (ctx, indices, arg) {\n        var i, k, len, results, scx, scx0, scx1, scy0, scy1, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scx0 = arg.scx0, scy0 = arg.scy0, scx1 = arg.scx1, scy1 = arg.scy1;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (k = 0, len = indices.length; k < len; k++) {\n                i = indices[k];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    BezierView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return BezierView;\n})(glyph_1.GlyphView);\nexports.Bezier = (function (superClass) {\n    extend(Bezier, superClass);\n    function Bezier() {\n        return Bezier.__super__.constructor.apply(this, arguments);\n    }\n    Bezier.prototype.default_view = exports.BezierView;\n    Bezier.prototype.type = 'Bezier';\n    Bezier.coords([['x0', 'y0'], ['x1', 'y1'], ['cx0', 'cy0'], ['cx1', 'cy1']]);\n    Bezier.mixins(['line']);\n    return Bezier;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.CircleView = (function (superClass) {\n    extend(CircleView, superClass);\n    function CircleView() {\n        return CircleView.__super__.constructor.apply(this, arguments);\n    }\n    CircleView.prototype._map_data = function () {\n        var rd, s;\n        if (this._radius != null) {\n            if (this.model.properties.radius.spec.units === \"data\") {\n                rd = this.model.properties.radius_dimension.spec.value;\n                return this.sradius = this.sdist(this.renderer[rd + \"mapper\"], this[\"_\" + rd], this._radius);\n            }\n            else {\n                this.sradius = this._radius;\n                return this.max_size = 2 * this.max_radius;\n            }\n        }\n        else {\n            return this.sradius = (function () {\n                var j, len, ref, results;\n                ref = this._size;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    s = ref[j];\n                    results.push(s / 2);\n                }\n                return results;\n            }).call(this);\n        }\n    };\n    CircleView.prototype._mask_data = function (all_indices) {\n        var bbox, hr, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, vr, x0, x1, y0, y1;\n        hr = this.renderer.plot_view.frame.h_range;\n        vr = this.renderer.plot_view.frame.v_range;\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            sx0 = hr.start;\n            sx1 = hr.end;\n            ref = this.renderer.xmapper.v_map_from_target([sx0, sx1], true), x0 = ref[0], x1 = ref[1];\n            x0 -= this.max_radius;\n            x1 += this.max_radius;\n            sy0 = vr.start;\n            sy1 = vr.end;\n            ref1 = this.renderer.ymapper.v_map_from_target([sy0, sy1], true), y0 = ref1[0], y1 = ref1[1];\n            y0 -= this.max_radius;\n            y1 += this.max_radius;\n        }\n        else {\n            sx0 = hr.start - this.max_size;\n            sx1 = hr.end + this.max_size;\n            ref2 = this.renderer.xmapper.v_map_from_target([sx0, sx1], true), x0 = ref2[0], x1 = ref2[1];\n            sy0 = vr.start - this.max_size;\n            sy1 = vr.end + this.max_size;\n            ref3 = this.renderer.ymapper.v_map_from_target([sy0, sy1], true), y0 = ref3[0], y1 = ref3[1];\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    CircleView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sradius[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    CircleView.prototype._hit_point = function (geometry) {\n        var bbox, candidates, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            x0 = x - this.max_radius;\n            x1 = x + this.max_radius;\n            y0 = y - this.max_radius;\n            y1 = y + this.max_radius;\n        }\n        else {\n            vx0 = vx - this.max_size;\n            vx1 = vx + this.max_size;\n            ref1 = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            ref2 = [Math.min(x0, x1), Math.max(x0, x1)], x0 = ref2[0], x1 = ref2[1];\n            vy0 = vy - this.max_size;\n            vy1 = vy + this.max_size;\n            ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref3[0], y1 = ref3[1];\n            ref4 = [Math.min(y0, y1), Math.max(y0, y1)], y0 = ref4[0], y1 = ref4[1];\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        candidates = this.index.indices(bbox);\n        hits = [];\n        if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n            for (j = 0, len = candidates.length; j < len; j++) {\n                i = candidates[j];\n                r2 = Math.pow(this.sradius[i], 2);\n                sx0 = this.renderer.xmapper.map_to_target(x, true);\n                sx1 = this.renderer.xmapper.map_to_target(this._x[i], true);\n                sy0 = this.renderer.ymapper.map_to_target(y, true);\n                sy1 = this.renderer.ymapper.map_to_target(this._y[i], true);\n                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        else {\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            for (k = 0, len1 = candidates.length; k < len1; k++) {\n                i = candidates[k];\n                r2 = Math.pow(this.sradius[i], 2);\n                dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);\n                if (dist <= r2) {\n                    hits.push([i, dist]);\n                }\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    CircleView.prototype._hit_span = function (geometry) {\n        var bbox, hits, maxX, maxY, minX, minY, ms, ref, ref1, ref2, ref3, ref4, ref5, result, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = this.bounds(), minX = ref1.minX, minY = ref1.minY, maxX = ref1.maxX, maxY = ref1.maxY;\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'h') {\n            y0 = minY;\n            y1 = maxY;\n            if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n                vx0 = vx - this.max_radius;\n                vx1 = vx + this.max_radius;\n                ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = ref2[0], x1 = ref2[1];\n            }\n            else {\n                ms = this.max_size / 2;\n                vx0 = vx - ms;\n                vx1 = vx + ms;\n                ref3 = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref3[0], x1 = ref3[1];\n            }\n        }\n        else {\n            x0 = minX;\n            x1 = maxX;\n            if ((this._radius != null) && this.model.properties.radius.units === \"data\") {\n                vy0 = vy - this.max_radius;\n                vy1 = vy + this.max_radius;\n                ref4 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = ref4[0], y1 = ref4[1];\n            }\n            else {\n                ms = this.max_size / 2;\n                vy0 = vy - ms;\n                vy1 = vy + ms;\n                ref5 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref5[0], y1 = ref5[1];\n            }\n        }\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        hits = this.index.indices(bbox);\n        result['1d'].indices = hits;\n        return result;\n    };\n    CircleView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    CircleView.prototype._hit_poly = function (geometry) {\n        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        candidates = (function () {\n            results = [];\n            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        hits = [];\n        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n            idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                hits.push(idx);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    CircleView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var data, indices, sradius, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        sradius = {};\n        sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\n        data = {\n            sx: sx,\n            sy: sy,\n            sradius: sradius\n        };\n        return this._render(ctx, indices, data);\n    };\n    return CircleView;\n})(xy_glyph_1.XYGlyphView);\nexports.Circle = (function (superClass) {\n    extend(Circle, superClass);\n    function Circle() {\n        return Circle.__super__.constructor.apply(this, arguments);\n    }\n    Circle.prototype.default_view = exports.CircleView;\n    Circle.prototype.type = 'Circle';\n    Circle.mixins(['line', 'fill']);\n    Circle.define({\n        angle: [p.AngleSpec, 0],\n        size: [\n            p.DistanceSpec, {\n                units: \"screen\",\n                value: 4\n            }\n        ],\n        radius: [p.DistanceSpec, null],\n        radius_dimension: [p.String, 'x']\n    });\n    Circle.prototype.initialize = function (attrs, options) {\n        Circle.__super__.initialize.call(this, attrs, options);\n        return this.properties.radius.optional = true;\n    };\n    return Circle;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.EllipseView = (function (superClass) {\n    extend(EllipseView, superClass);\n    function EllipseView() {\n        return EllipseView.__super__.constructor.apply(this, arguments);\n    }\n    EllipseView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    EllipseView.prototype._map_data = function () {\n        if (this.model.properties.width.units === \"data\") {\n            this.sw = this.sdist(this.renderer.xmapper, this._x, this._width, 'center');\n        }\n        else {\n            this.sw = this._width;\n        }\n        if (this.model.properties.height.units === \"data\") {\n            return this.sh = this.sdist(this.renderer.ymapper, this._y, this._height, 'center');\n        }\n        else {\n            return this.sh = this._height;\n        }\n    };\n    EllipseView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sh, sw, sx, sy;\n        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, this._angle[i], 0, 2 * Math.PI);\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    EllipseView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var d, data, indices, scale, sh, sw, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        scale = this.sw[index] / this.sh[index];\n        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n        sw = {};\n        sh = {};\n        if (scale > 1) {\n            sw[index] = d;\n            sh[index] = d / scale;\n        }\n        else {\n            sw[index] = d * scale;\n            sh[index] = d;\n        }\n        data = {\n            sx: sx,\n            sy: sy,\n            sw: sw,\n            sh: sh\n        };\n        return this._render(ctx, indices, data);\n    };\n    EllipseView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return EllipseView;\n})(xy_glyph_1.XYGlyphView);\nexports.Ellipse = (function (superClass) {\n    extend(Ellipse, superClass);\n    function Ellipse() {\n        return Ellipse.__super__.constructor.apply(this, arguments);\n    }\n    Ellipse.prototype.default_view = exports.EllipseView;\n    Ellipse.prototype.type = 'Ellipse';\n    Ellipse.mixins(['line', 'fill']);\n    Ellipse.define({\n        angle: [p.AngleSpec, 0.0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec]\n    });\n    return Ellipse;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar bbox = require(\"core/util/bbox\");\nvar proj = require(\"core/util/projections\");\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar model_1 = require(\"../../model\");\nvar visuals_1 = require(\"core/visuals\");\nvar logging_1 = require(\"core/logging\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nexports.GlyphView = (function (superClass) {\n    extend1(GlyphView, superClass);\n    function GlyphView() {\n        return GlyphView.__super__.constructor.apply(this, arguments);\n    }\n    GlyphView.prototype.initialize = function (options) {\n        var Cls, ctx, e, glglyphs;\n        GlyphView.__super__.initialize.call(this, options);\n        this._nohit_warned = {};\n        this.renderer = options.renderer;\n        this.visuals = new visuals_1.Visuals(this.model);\n        ctx = this.renderer.plot_view.canvas_view.ctx;\n        if (ctx.glcanvas != null) {\n            try {\n                glglyphs = require(\"models/glyphs/webgl/index\");\n            }\n            catch (error) {\n                e = error;\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    logging_1.logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');\n                    glglyphs = null;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (glglyphs != null) {\n                Cls = glglyphs[this.model.type + 'GLGlyph'];\n                if (Cls != null) {\n                    return this.glglyph = new Cls(ctx.glcanvas.gl, this);\n                }\n            }\n        }\n    };\n    GlyphView.prototype.set_visuals = function (source) {\n        this.visuals.warm_cache(source);\n        if (this.glglyph != null) {\n            return this.glglyph.set_visuals_changed();\n        }\n    };\n    GlyphView.prototype.render = function (ctx, indices, data) {\n        ctx.beginPath();\n        if (this.glglyph != null) {\n            if (this.glglyph.render(ctx, indices, data)) {\n                return;\n            }\n        }\n        return this._render(ctx, indices, data);\n    };\n    GlyphView.prototype.bounds = function () {\n        if (this.index == null) {\n            return bbox.empty();\n        }\n        else {\n            return this._bounds(this.index.bbox);\n        }\n    };\n    GlyphView.prototype.log_bounds = function () {\n        var bb, j, k, len, len1, positive_x_bbs, positive_y_bbs, x, y;\n        if (this.index == null) {\n            return bbox.empty();\n        }\n        bb = bbox.empty();\n        positive_x_bbs = this.index.search(bbox.positive_x());\n        positive_y_bbs = this.index.search(bbox.positive_y());\n        for (j = 0, len = positive_x_bbs.length; j < len; j++) {\n            x = positive_x_bbs[j];\n            if (x.minX < bb.minX) {\n                bb.minX = x.minX;\n            }\n            if (x.maxX > bb.maxX) {\n                bb.maxX = x.maxX;\n            }\n        }\n        for (k = 0, len1 = positive_y_bbs.length; k < len1; k++) {\n            y = positive_y_bbs[k];\n            if (y.minY < bb.minY) {\n                bb.minY = y.minY;\n            }\n            if (y.maxY > bb.maxY) {\n                bb.maxY = y.maxY;\n            }\n        }\n        return this._bounds(bb);\n    };\n    GlyphView.prototype.max_wh2_bounds = function (bds) {\n        return {\n            minX: bds.minX - this.max_w2,\n            maxX: bds.maxX + this.max_w2,\n            minY: bds.minY - this.max_h2,\n            maxY: bds.maxY + this.max_h2\n        };\n    };\n    GlyphView.prototype.get_anchor_point = function (anchor, i, arg) {\n        var sx, sy;\n        sx = arg[0], sy = arg[1];\n        switch (anchor) {\n            case \"center\":\n                return {\n                    x: this.scx(i, sx, sy),\n                    y: this.scy(i, sx, sy)\n                };\n            default:\n                return null;\n        }\n    };\n    GlyphView.prototype.scx = function (i) {\n        return this.sx[i];\n    };\n    GlyphView.prototype.scy = function (i) {\n        return this.sy[i];\n    };\n    GlyphView.prototype.sdist = function (mapper, pts, spans, pts_location, dilate) {\n        var d, halfspan, i, pt0, pt1, spt0, spt1;\n        if (pts_location == null) {\n            pts_location = \"edge\";\n        }\n        if (dilate == null) {\n            dilate = false;\n        }\n        if (types_1.isString(pts[0])) {\n            pts = mapper.v_map_to_target(pts);\n        }\n        if (pts_location === 'center') {\n            halfspan = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = spans.length; j < len; j++) {\n                    d = spans[j];\n                    results.push(d / 2);\n                }\n                return results;\n            })();\n            pt0 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pts[i] - halfspan[i]);\n                }\n                return results;\n            })();\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pts[i] + halfspan[i]);\n                }\n                return results;\n            })();\n        }\n        else {\n            pt0 = pts;\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(pt0[i] + spans[i]);\n                }\n                return results;\n            })();\n        }\n        spt0 = mapper.v_map_to_target(pt0);\n        spt1 = mapper.v_map_to_target(pt1);\n        if (dilate) {\n            return (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Math.ceil(Math.abs(spt1[i] - spt0[i])));\n                }\n                return results;\n            })();\n        }\n        else {\n            return (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Math.abs(spt1[i] - spt0[i]));\n                }\n                return results;\n            })();\n        }\n    };\n    GlyphView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return null;\n    };\n    GlyphView.prototype._generic_line_legend = function (ctx, x0, x1, y0, y1, index) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(x0, (y0 + y1) / 2);\n        ctx.lineTo(x1, (y0 + y1) / 2);\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_vectorize(ctx, index);\n            ctx.stroke();\n        }\n        return ctx.restore();\n    };\n    GlyphView.prototype._generic_area_legend = function (ctx, x0, x1, y0, y1, index) {\n        var dh, dw, h, indices, sx0, sx1, sy0, sy1, w;\n        indices = [index];\n        w = Math.abs(x1 - x0);\n        dw = w * 0.1;\n        h = Math.abs(y1 - y0);\n        dh = h * 0.1;\n        sx0 = x0 + dw;\n        sx1 = x1 - dw;\n        sy0 = y0 + dh;\n        sy1 = y1 - dh;\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_vectorize(ctx, index);\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n        }\n        if (this.visuals.line.doit) {\n            ctx.beginPath();\n            ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n            this.visuals.line.set_vectorize(ctx, index);\n            return ctx.stroke();\n        }\n    };\n    GlyphView.prototype.hit_test = function (geometry) {\n        var func, result;\n        result = null;\n        func = \"_hit_\" + geometry.type;\n        if (this[func] != null) {\n            result = this[func](geometry);\n        }\n        else if (this._nohit_warned[geometry.type] == null) {\n            logging_1.logger.debug(\"'\" + geometry.type + \"' selection not available for \" + this.model.type);\n            this._nohit_warned[geometry.type] = true;\n        }\n        return result;\n    };\n    GlyphView.prototype.set_data = function (source) {\n        var data, ref, ref1;\n        data = this.model.materialize_dataspecs(source);\n        object_1.extend(this, data);\n        if (this.renderer.plot_view.model.use_map) {\n            if (this._x != null) {\n                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];\n            }\n            if (this._xs != null) {\n                ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1];\n            }\n        }\n        if (this.glglyph != null) {\n            this.glglyph.set_data_changed(this._x.length);\n        }\n        this._set_data(source);\n        return this.index = this._index_data();\n    };\n    GlyphView.prototype._set_data = function () { };\n    GlyphView.prototype._index_data = function () { };\n    GlyphView.prototype.mask_data = function (indices) {\n        if (this.glglyph != null) {\n            return indices;\n        }\n        else {\n            return this._mask_data(indices);\n        }\n    };\n    GlyphView.prototype._mask_data = function (indices) {\n        return indices;\n    };\n    GlyphView.prototype._bounds = function (bounds) {\n        return bounds;\n    };\n    GlyphView.prototype.map_data = function () {\n        var i, j, k, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sx, sxname, sy, syname, xname, yname;\n        ref = this.model._coords;\n        for (j = 0, len = ref.length; j < len; j++) {\n            ref1 = ref[j], xname = ref1[0], yname = ref1[1];\n            sxname = \"s\" + xname;\n            syname = \"s\" + yname;\n            xname = \"_\" + xname;\n            yname = \"_\" + yname;\n            if (types_1.isArray((ref2 = this[xname]) != null ? ref2[0] : void 0) || ((ref3 = this[xname]) != null ? (ref4 = ref3[0]) != null ? ref4.buffer : void 0 : void 0) instanceof ArrayBuffer) {\n                ref5 = [[], []], this[sxname] = ref5[0], this[syname] = ref5[1];\n                for (i = k = 0, ref6 = this[xname].length; 0 <= ref6 ? k < ref6 : k > ref6; i = 0 <= ref6 ? ++k : --k) {\n                    ref7 = this.map_to_screen(this[xname][i], this[yname][i]), sx = ref7[0], sy = ref7[1];\n                    this[sxname].push(sx);\n                    this[syname].push(sy);\n                }\n            }\n            else {\n                ref8 = this.map_to_screen(this[xname], this[yname]), this[sxname] = ref8[0], this[syname] = ref8[1];\n            }\n        }\n        return this._map_data();\n    };\n    GlyphView.prototype._map_data = function () { };\n    GlyphView.prototype.map_to_screen = function (x, y) {\n        return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    return GlyphView;\n})(bokeh_view_1.BokehView);\nexports.Glyph = (function (superClass) {\n    extend1(Glyph, superClass);\n    function Glyph() {\n        return Glyph.__super__.constructor.apply(this, arguments);\n    }\n    Glyph.prototype._coords = [];\n    Glyph.coords = function (coords) {\n        var _coords, j, len, ref, result, x, y;\n        _coords = this.prototype._coords.concat(coords);\n        this.prototype._coords = _coords;\n        result = {};\n        for (j = 0, len = coords.length; j < len; j++) {\n            ref = coords[j], x = ref[0], y = ref[1];\n            result[x] = [p.NumberSpec];\n            result[y] = [p.NumberSpec];\n        }\n        return this.define(result);\n    };\n    Glyph.internal({\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    return Glyph;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.HBarView = (function (superClass) {\n    extend(HBarView, superClass);\n    function HBarView() {\n        return HBarView.__super__.constructor.apply(this, arguments);\n    }\n    HBarView.prototype._map_data = function () {\n        var i, j, ref, vleft, vright, vy;\n        vy = this.renderer.ymapper.v_map_to_target(this._y);\n        this.sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        vright = this.renderer.xmapper.v_map_to_target(this._right);\n        vleft = this.renderer.xmapper.v_map_to_target(this._left);\n        this.sright = this.renderer.plot_view.canvas.v_vx_to_sx(vright);\n        this.sleft = this.renderer.plot_view.canvas.v_vx_to_sx(vleft);\n        this.stop = [];\n        this.sbottom = [];\n        this.sh = this.sdist(this.renderer.ymapper, this._y, this._height, 'center');\n        for (i = j = 0, ref = this.sy.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.stop.push(this.sy[i] - this.sh[i] / 2);\n            this.sbottom.push(this.sy[i] + this.sh[i] / 2);\n        }\n        return null;\n    };\n    HBarView.prototype._index_data = function () {\n        var b, height, i, j, l, left, map_to_synthetic, points, r, ref, right, t, y;\n        map_to_synthetic = function (mapper, array) {\n            if (mapper instanceof categorical_mapper_1.CategoricalMapper) {\n                return mapper.v_map_to_target(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        left = map_to_synthetic(this.renderer.xmapper, this._left);\n        right = map_to_synthetic(this.renderer.xmapper, this._right);\n        y = map_to_synthetic(this.renderer.ymapper, this._y);\n        height = map_to_synthetic(this.renderer.ymapper, this._height);\n        points = [];\n        for (i = j = 0, ref = y.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = left[i];\n            r = right[i];\n            t = y[i] + 0.5 * height[i];\n            b = y[i] - 0.5 * height[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    HBarView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    HBarView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    HBarView.prototype.scx = function (i) {\n        return (this.sleft[i] + this.sright[i]) / 2;\n    };\n    HBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return HBarView;\n})(glyph_1.GlyphView);\nexports.HBar = (function (superClass) {\n    extend(HBar, superClass);\n    function HBar() {\n        return HBar.__super__.constructor.apply(this, arguments);\n    }\n    HBar.prototype.default_view = exports.HBarView;\n    HBar.prototype.type = 'HBar';\n    HBar.mixins(['line', 'fill']);\n    HBar.define({\n        y: [p.NumberSpec],\n        height: [p.DistanceSpec],\n        left: [p.NumberSpec, 0],\n        right: [p.NumberSpec]\n    });\n    return HBar;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Greys9, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar linear_color_mapper_1 = require(\"../mappers/linear_color_mapper\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ImageView = (function (superClass) {\n    extend(ImageView, superClass);\n    function ImageView() {\n        return ImageView.__super__.constructor.apply(this, arguments);\n    }\n    ImageView.prototype.initialize = function (options) {\n        ImageView.__super__.initialize.call(this, options);\n        return this.listenTo(this.model.color_mapper, 'change', this._update_image);\n    };\n    ImageView.prototype._update_image = function () {\n        if (this.image_data != null) {\n            this._set_data();\n            return this.renderer.plot_view.request_render();\n        }\n    };\n    ImageView.prototype._set_data = function () {\n        var buf, buf8, canvas, cmap, ctx, i, image_data, img, j, ref, results, shape;\n        if ((this.image_data == null) || this.image_data.length !== this._image.length) {\n            this.image_data = new Array(this._image.length);\n        }\n        if ((this._width == null) || this._width.length !== this._image.length) {\n            this._width = new Array(this._image.length);\n        }\n        if ((this._height == null) || this._height.length !== this._image.length) {\n            this._height = new Array(this._image.length);\n        }\n        results = [];\n        for (i = j = 0, ref = this._image.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            shape = [];\n            if (this._image_shape != null) {\n                shape = this._image_shape[i];\n            }\n            if (shape.length > 0) {\n                img = this._image[i];\n                this._height[i] = shape[0];\n                this._width[i] = shape[1];\n            }\n            else {\n                img = array_1.concat(this._image[i]);\n                this._height[i] = this._image[i].length;\n                this._width[i] = this._image[i][0].length;\n            }\n            if ((this.image_data[i] != null) && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {\n                canvas = this.image_data[i];\n            }\n            else {\n                canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n            }\n            ctx = canvas.getContext('2d');\n            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            cmap = this.model.color_mapper;\n            buf = cmap.v_map_screen(img, true);\n            buf8 = new Uint8Array(buf);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n            this.max_dw = 0;\n            if (this._dw.units === \"data\") {\n                this.max_dw = array_1.max(this._dw);\n            }\n            this.max_dh = 0;\n            if (this._dh.units === \"data\") {\n                results.push(this.max_dh = array_1.max(this._dh));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ImageView.prototype._map_data = function () {\n        switch (this.model.properties.dw.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xmapper, this._x, this._dw, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = this._dw;\n        }\n        switch (this.model.properties.dh.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.ymapper, this._y, this._dh, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = this._dh;\n        }\n    };\n    ImageView.prototype._render = function (ctx, indices, arg) {\n        var i, image_data, j, len, old_smoothing, sh, sw, sx, sy, y_offset;\n        image_data = arg.image_data, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        old_smoothing = ctx.getImageSmoothingEnabled();\n        ctx.setImageSmoothingEnabled(false);\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (image_data[i] == null) {\n                continue;\n            }\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {\n                continue;\n            }\n            y_offset = sy[i];\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n        }\n        return ctx.setImageSmoothingEnabled(old_smoothing);\n    };\n    ImageView.prototype.bounds = function () {\n        var bbox;\n        bbox = this.index.bbox;\n        bbox.maxX += this.max_dw;\n        bbox.maxY += this.max_dh;\n        return bbox;\n    };\n    return ImageView;\n})(xy_glyph_1.XYGlyphView);\nGreys9 = function () {\n    return [0x000000, 0x252525, 0x525252, 0x737373, 0x969696, 0xbdbdbd, 0xd9d9d9, 0xf0f0f0, 0xffffff];\n};\nexports.Image = (function (superClass) {\n    extend(Image, superClass);\n    function Image() {\n        return Image.__super__.constructor.apply(this, arguments);\n    }\n    Image.prototype.default_view = exports.ImageView;\n    Image.prototype.type = 'Image';\n    Image.define({\n        image: [p.NumberSpec],\n        dw: [p.DistanceSpec],\n        dh: [p.DistanceSpec],\n        dilate: [p.Bool, false],\n        color_mapper: [\n            p.Instance, function () {\n                return new linear_color_mapper_1.LinearColorMapper({\n                    palette: Greys9()\n                });\n            }\n        ]\n    });\n    return Image;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ImageRGBAView = (function (superClass) {\n    extend(ImageRGBAView, superClass);\n    function ImageRGBAView() {\n        return ImageRGBAView.__super__.constructor.apply(this, arguments);\n    }\n    ImageRGBAView.prototype._set_data = function (source, arg) {\n        var buf, buf8, canvas, color, ctx, flat, i, image_data, j, k, l, m, ref, ref1, ref2, results, shape;\n        if ((this.image_data == null) || this.image_data.length !== this._image.length) {\n            this.image_data = new Array(this._image.length);\n        }\n        if ((this._width == null) || this._width.length !== this._image.length) {\n            this._width = new Array(this._image.length);\n        }\n        if ((this._height == null) || this._height.length !== this._image.length) {\n            this._height = new Array(this._image.length);\n        }\n        results = [];\n        for (i = k = 0, ref = this._image.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            if (arg != null) {\n                if (i !== arg) {\n                    continue;\n                }\n            }\n            shape = [];\n            if (this._image_shape != null) {\n                shape = this._image_shape[i];\n            }\n            if (this._rows != null) {\n                this._height[i] = this._rows[i];\n                this._width[i] = this._cols[i];\n                if (shape.length > 0) {\n                    buf = this._image[i].buffer;\n                }\n                else {\n                    flat = this._image[i];\n                    buf = new ArrayBuffer(flat.length * 4);\n                    color = new Uint32Array(buf);\n                    for (j = l = 0, ref1 = flat.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                        color[j] = flat[j];\n                    }\n                }\n            }\n            else if (shape.length > 0) {\n                buf = this._image[i].buffer;\n                this._height[i] = shape[0];\n                this._width[i] = shape[1];\n            }\n            else {\n                flat = array_1.concat(this._image[i]);\n                buf = new ArrayBuffer(flat.length * 4);\n                color = new Uint32Array(buf);\n                for (j = m = 0, ref2 = flat.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {\n                    color[j] = flat[j];\n                }\n                this._height[i] = this._image[i].length;\n                this._width[i] = this._image[i][0].length;\n            }\n            if ((this.image_data[i] != null) && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {\n                canvas = this.image_data[i];\n            }\n            else {\n                canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n            }\n            ctx = canvas.getContext('2d');\n            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            buf8 = new Uint8Array(buf);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n            this.max_dw = 0;\n            if (this._dw.units === \"data\") {\n                this.max_dw = array_1.max(this._dw);\n            }\n            this.max_dh = 0;\n            if (this._dh.units === \"data\") {\n                results.push(this.max_dh = array_1.max(this._dh));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ImageRGBAView.prototype._map_data = function () {\n        switch (this.model.properties.dw.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xmapper, this._x, this._dw, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = this._dw;\n        }\n        switch (this.model.properties.dh.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.ymapper, this._y, this._dh, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = this._dh;\n        }\n    };\n    ImageRGBAView.prototype._render = function (ctx, indices, arg1) {\n        var i, image_data, k, len, old_smoothing, sh, sw, sx, sy, y_offset;\n        image_data = arg1.image_data, sx = arg1.sx, sy = arg1.sy, sw = arg1.sw, sh = arg1.sh;\n        old_smoothing = ctx.getImageSmoothingEnabled();\n        ctx.setImageSmoothingEnabled(false);\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {\n                continue;\n            }\n            y_offset = sy[i];\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n        }\n        return ctx.setImageSmoothingEnabled(old_smoothing);\n    };\n    ImageRGBAView.prototype.bounds = function () {\n        var bbox;\n        bbox = this.index.bbox;\n        bbox.maxX += this.max_dw;\n        bbox.maxY += this.max_dh;\n        return bbox;\n    };\n    return ImageRGBAView;\n})(xy_glyph_1.XYGlyphView);\nexports.ImageRGBA = (function (superClass) {\n    extend(ImageRGBA, superClass);\n    function ImageRGBA() {\n        return ImageRGBA.__super__.constructor.apply(this, arguments);\n    }\n    ImageRGBA.prototype.default_view = exports.ImageRGBAView;\n    ImageRGBA.prototype.type = 'ImageRGBA';\n    ImageRGBA.define({\n        image: [p.NumberSpec],\n        rows: [p.NumberSpec],\n        cols: [p.NumberSpec],\n        dw: [p.DistanceSpec],\n        dh: [p.DistanceSpec],\n        dilate: [p.Bool, false]\n    });\n    ImageRGBA.prototype.initialize = function (attrs, options) {\n        ImageRGBA.__super__.initialize.call(this, attrs, options);\n        this.properties.rows.optional = true;\n        return this.properties.cols.optional = true;\n    };\n    return ImageRGBA;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar glyph_1 = require(\"./glyph\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.ImageURLView = (function (superClass) {\n    extend(ImageURLView, superClass);\n    function ImageURLView() {\n        return ImageURLView.__super__.constructor.apply(this, arguments);\n    }\n    ImageURLView.prototype.initialize = function (options) {\n        ImageURLView.__super__.initialize.call(this, options);\n        return this.listenTo(this.model, 'change:global_alpha', this.renderer.request_render);\n    };\n    ImageURLView.prototype._index_data = function () { };\n    ImageURLView.prototype._set_data = function () {\n        var i, img, j, ref, results, retry_attempts, retry_timeout;\n        if ((this.image == null) || this.image.length !== this._url.length) {\n            this.image = (function () {\n                var j, len, ref, results;\n                ref = this._url;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    img = ref[j];\n                    results.push(null);\n                }\n                return results;\n            }).call(this);\n        }\n        retry_attempts = this.model.retry_attempts;\n        retry_timeout = this.model.retry_timeout;\n        this.retries = (function () {\n            var j, len, ref, results;\n            ref = this._url;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n                img = ref[j];\n                results.push(retry_attempts);\n            }\n            return results;\n        }).call(this);\n        results = [];\n        for (i = j = 0, ref = this._url.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (this._url[i] == null) {\n                continue;\n            }\n            img = new Image();\n            img.onerror = (function (_this) {\n                return function (i, img) {\n                    return function () {\n                        if (_this.retries[i] > 0) {\n                            logging_1.logger.trace(\"ImageURL failed to load \" + _this._url[i] + \" image, retrying in \" + retry_timeout + \" ms\");\n                            setTimeout((function () {\n                                return img.src = _this._url[i];\n                            }), retry_timeout);\n                        }\n                        else {\n                            logging_1.logger.warn(\"ImageURL unable to load \" + _this._url[i] + \" image after \" + retry_attempts + \" retries\");\n                        }\n                        return _this.retries[i] -= 1;\n                    };\n                };\n            })(this)(i, img);\n            img.onload = (function (_this) {\n                return function (img, i) {\n                    return function () {\n                        _this.image[i] = img;\n                        return _this.renderer.request_render();\n                    };\n                };\n            })(this)(img, i);\n            results.push(img.src = this._url[i]);\n        }\n        return results;\n    };\n    ImageURLView.prototype._map_data = function () {\n        var hs, ws, x;\n        ws = ((function () {\n            var j, len, ref, results;\n            if (this._w != null) {\n                return this._w;\n            }\n            else {\n                ref = this._x;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    x = ref[j];\n                    results.push(0 / 0);\n                }\n                return results;\n            }\n        }).call(this));\n        hs = ((function () {\n            var j, len, ref, results;\n            if (this._h != null) {\n                return this._h;\n            }\n            else {\n                ref = this._x;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    x = ref[j];\n                    results.push(0 / 0);\n                }\n                return results;\n            }\n        }).call(this));\n        switch (this.model.properties.w.units) {\n            case \"data\":\n                this.sw = this.sdist(this.renderer.xmapper, this._x, ws, 'edge', this.model.dilate);\n                break;\n            case \"screen\":\n                this.sw = ws;\n        }\n        switch (this.model.properties.h.units) {\n            case \"data\":\n                return this.sh = this.sdist(this.renderer.ymapper, this._y, hs, 'edge', this.model.dilate);\n            case \"screen\":\n                return this.sh = hs;\n        }\n    };\n    ImageURLView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _url, frame, i, image, j, len, results, sh, sw, sx, sy;\n        _url = arg._url, image = arg.image, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh, _angle = arg._angle;\n        frame = this.renderer.plot_view.frame;\n        ctx.rect(frame.left + 1, frame.bottom + 1, frame.width - 2, frame.height - 2);\n        ctx.clip();\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _angle[i])) {\n                continue;\n            }\n            if (this.retries[i] === -1) {\n                continue;\n            }\n            if (image[i] == null) {\n                continue;\n            }\n            results.push(this._render_image(ctx, i, image[i], sx, sy, sw, sh, _angle));\n        }\n        return results;\n    };\n    ImageURLView.prototype._final_sx_sy = function (anchor, sx, sy, sw, sh) {\n        switch (anchor) {\n            case 'top_left':\n                return [sx, sy];\n            case 'top_center':\n                return [sx - sw / 2, sy];\n            case 'top_right':\n                return [sx - sw, sy];\n            case 'center_right':\n                return [sx - sw, sy - sh / 2];\n            case 'bottom_right':\n                return [sx - sw, sy - sh];\n            case 'bottom_center':\n                return [sx - sw / 2, sy - sh];\n            case 'bottom_left':\n                return [sx, sy - sh];\n            case 'center_left':\n                return [sx, sy - sh / 2];\n            case 'center':\n                return [sx - sw / 2, sy - sh / 2];\n        }\n    };\n    ImageURLView.prototype._render_image = function (ctx, i, image, sx, sy, sw, sh, angle) {\n        var anchor, ref;\n        if (isNaN(sw[i])) {\n            sw[i] = image.width;\n        }\n        if (isNaN(sh[i])) {\n            sh[i] = image.height;\n        }\n        anchor = this.model.anchor;\n        ref = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]), sx = ref[0], sy = ref[1];\n        ctx.save();\n        ctx.globalAlpha = this.model.global_alpha;\n        if (angle[i]) {\n            ctx.translate(sx, sy);\n            ctx.rotate(angle[i]);\n            ctx.drawImage(image, 0, 0, sw[i], sh[i]);\n            ctx.rotate(-angle[i]);\n            ctx.translate(-sx, -sy);\n        }\n        else {\n            ctx.drawImage(image, sx, sy, sw[i], sh[i]);\n        }\n        return ctx.restore();\n    };\n    return ImageURLView;\n})(glyph_1.GlyphView);\nexports.ImageURL = (function (superClass) {\n    extend(ImageURL, superClass);\n    function ImageURL() {\n        return ImageURL.__super__.constructor.apply(this, arguments);\n    }\n    ImageURL.prototype.default_view = exports.ImageURLView;\n    ImageURL.prototype.type = 'ImageURL';\n    ImageURL.coords([['x', 'y']]);\n    ImageURL.mixins([]);\n    ImageURL.define({\n        url: [p.StringSpec],\n        anchor: [p.Anchor, 'top_left'],\n        global_alpha: [p.Number, 1.0],\n        angle: [p.AngleSpec, 0],\n        w: [p.DistanceSpec],\n        h: [p.DistanceSpec],\n        dilate: [p.Bool, false],\n        retry_attempts: [p.Number, 0],\n        retry_timeout: [p.Number, 0]\n    });\n    return ImageURL;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar annular_wedge_1 = require(\"./annular_wedge\");\nexports.AnnularWedge = annular_wedge_1.AnnularWedge;\nvar annulus_1 = require(\"./annulus\");\nexports.Annulus = annulus_1.Annulus;\nvar arc_1 = require(\"./arc\");\nexports.Arc = arc_1.Arc;\nvar bezier_1 = require(\"./bezier\");\nexports.Bezier = bezier_1.Bezier;\nvar circle_1 = require(\"./circle\");\nexports.Circle = circle_1.Circle;\nvar ellipse_1 = require(\"./ellipse\");\nexports.Ellipse = ellipse_1.Ellipse;\nvar glyph_1 = require(\"./glyph\");\nexports.Glyph = glyph_1.Glyph;\nvar hbar_1 = require(\"./hbar\");\nexports.HBar = hbar_1.HBar;\nvar image_1 = require(\"./image\");\nexports.Image = image_1.Image;\nvar image_rgba_1 = require(\"./image_rgba\");\nexports.ImageRGBA = image_rgba_1.ImageRGBA;\nvar image_url_1 = require(\"./image_url\");\nexports.ImageURL = image_url_1.ImageURL;\nvar line_1 = require(\"./line\");\nexports.Line = line_1.Line;\nvar multi_line_1 = require(\"./multi_line\");\nexports.MultiLine = multi_line_1.MultiLine;\nvar oval_1 = require(\"./oval\");\nexports.Oval = oval_1.Oval;\nvar patch_1 = require(\"./patch\");\nexports.Patch = patch_1.Patch;\nvar patches_1 = require(\"./patches\");\nexports.Patches = patches_1.Patches;\nvar quad_1 = require(\"./quad\");\nexports.Quad = quad_1.Quad;\nvar quadratic_1 = require(\"./quadratic\");\nexports.Quadratic = quadratic_1.Quadratic;\nvar ray_1 = require(\"./ray\");\nexports.Ray = ray_1.Ray;\nvar rect_1 = require(\"./rect\");\nexports.Rect = rect_1.Rect;\nvar segment_1 = require(\"./segment\");\nexports.Segment = segment_1.Segment;\nvar text_1 = require(\"./text\");\nexports.Text = text_1.Text;\nvar vbar_1 = require(\"./vbar\");\nexports.VBar = vbar_1.VBar;\nvar wedge_1 = require(\"./wedge\");\nexports.Wedge = wedge_1.Wedge;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nexports.XYGlyph = xy_glyph_1.XYGlyph;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nexports.LineView = (function (superClass) {\n    extend(LineView, superClass);\n    function LineView() {\n        return LineView.__super__.constructor.apply(this, arguments);\n    }\n    LineView.prototype._render = function (ctx, indices, arg) {\n        var drawing, i, j, len, sx, sy;\n        sx = arg.sx, sy = arg.sy;\n        drawing = false;\n        this.visuals.line.set_value(ctx);\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (!isFinite(sx[i] + sy[i]) && drawing) {\n                ctx.stroke();\n                ctx.beginPath();\n                drawing = false;\n                continue;\n            }\n            if (drawing) {\n                ctx.lineTo(sx[i], sy[i]);\n            }\n            else {\n                ctx.beginPath();\n                ctx.moveTo(sx[i], sy[i]);\n                drawing = true;\n            }\n        }\n        if (drawing) {\n            return ctx.stroke();\n        }\n    };\n    LineView.prototype._hit_point = function (geometry) {\n        /* Check if the point geometry hits this line glyph and return an object\n        that describes the hit result:\n          Args:\n            * geometry (object): object with the following keys\n              * vx (float): view x coordinate of the point\n              * vy (float): view y coordinate of the point\n              * type (str): type of geometry (in this case it's a point)\n          Output:\n            Object with the following keys:\n              * 0d (bool): whether the point hits the glyph or not\n              * 1d (array(int)): array with the indices hit by the point\n         */\n        var dist, i, j, p0, p1, point, ref, ref1, result, shortest, threshold;\n        result = hittest.create_hit_test_result();\n        point = {\n            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),\n            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)\n        };\n        shortest = 9999;\n        threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n        for (i = j = 0, ref = this.sx.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            ref1 = [\n                {\n                    x: this.sx[i],\n                    y: this.sy[i]\n                }, {\n                    x: this.sx[i + 1],\n                    y: this.sy[i + 1]\n                }\n            ], p0 = ref1[0], p1 = ref1[1];\n            dist = hittest.dist_to_segment(point, p0, p1);\n            if (dist < threshold && dist < shortest) {\n                shortest = dist;\n                result['0d'].glyph = this.model;\n                result['0d'].get_view = (function () {\n                    return this;\n                }).bind(this);\n                result['0d'].flag = true;\n                result['0d'].indices = [i];\n            }\n        }\n        return result;\n    };\n    LineView.prototype._hit_span = function (geometry) {\n        var i, j, ref, ref1, result, val, values, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'v') {\n            val = this.renderer.ymapper.map_from_target(vy);\n            values = this._y;\n        }\n        else {\n            val = this.renderer.xmapper.map_from_target(vx);\n            values = this._x;\n        }\n        for (i = j = 0, ref1 = values.length - 1; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n            if ((values[i] <= val && val <= values[i + 1])) {\n                result['0d'].glyph = this.model;\n                result['0d'].get_view = (function () {\n                    return this;\n                }).bind(this);\n                result['0d'].flag = true;\n                result['0d'].indices.push(i);\n            }\n        }\n        return result;\n    };\n    LineView.prototype.get_interpolation_hit = function (i, geometry) {\n        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];\n        if (geometry.type === 'point') {\n            ref2 = this.renderer.ymapper.v_map_from_target([vy - 1, vy + 1]), y0 = ref2[0], y1 = ref2[1];\n            ref3 = this.renderer.xmapper.v_map_from_target([vx - 1, vx + 1]), x0 = ref3[0], x1 = ref3[1];\n        }\n        else {\n            if (geometry.direction === 'v') {\n                ref4 = this.renderer.ymapper.v_map_from_target([vy, vy]), y0 = ref4[0], y1 = ref4[1];\n                ref5 = [x2, x3], x0 = ref5[0], x1 = ref5[1];\n            }\n            else {\n                ref6 = this.renderer.xmapper.v_map_from_target([vx, vx]), x0 = ref6[0], x1 = ref6[1];\n                ref7 = [y2, y3], y0 = ref7[0], y1 = ref7[1];\n            }\n        }\n        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n        return [res.x, res.y];\n    };\n    LineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return LineView;\n})(xy_glyph_1.XYGlyphView);\nexports.Line = (function (superClass) {\n    extend(Line, superClass);\n    function Line() {\n        return Line.__super__.constructor.apply(this, arguments);\n    }\n    Line.prototype.default_view = exports.LineView;\n    Line.prototype.type = 'Line';\n    Line.mixins(['line']);\n    return Line;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar hittest = require(\"core/hittest\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar glyph_1 = require(\"./glyph\");\nexports.MultiLineView = (function (superClass) {\n    extend(MultiLineView, superClass);\n    function MultiLineView() {\n        return MultiLineView.__super__.constructor.apply(this, arguments);\n    }\n    MultiLineView.prototype._index_data = function () {\n        var i, k, points, ref, x, xs, y, ys;\n        points = [];\n        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            xs = (function () {\n                var l, len, ref1, results;\n                ref1 = this._xs[i];\n                results = [];\n                for (l = 0, len = ref1.length; l < len; l++) {\n                    x = ref1[l];\n                    if (!types_1.isStrictNaN(x)) {\n                        results.push(x);\n                    }\n                }\n                return results;\n            }).call(this);\n            ys = (function () {\n                var l, len, ref1, results;\n                ref1 = this._ys[i];\n                results = [];\n                for (l = 0, len = ref1.length; l < len; l++) {\n                    y = ref1[l];\n                    if (!types_1.isStrictNaN(y)) {\n                        results.push(y);\n                    }\n                }\n                return results;\n            }).call(this);\n            if (xs.length === 0) {\n                continue;\n            }\n            points.push({\n                minX: array_1.min(xs),\n                minY: array_1.min(ys),\n                maxX: array_1.max(xs),\n                maxY: array_1.max(ys),\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    MultiLineView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, l, len, ref, ref1, results, sx, sxs, sy, sys;\n        sxs = arg.sxs, sys = arg.sys;\n        results = [];\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            ref = [sxs[i], sys[i]], sx = ref[0], sy = ref[1];\n            this.visuals.line.set_vectorize(ctx, i);\n            for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                if (j === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[j], sy[j]);\n                    continue;\n                }\n                else if (isNaN(sx[j]) || isNaN(sy[j])) {\n                    ctx.stroke();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[j], sy[j]);\n                }\n            }\n            results.push(ctx.stroke());\n        }\n        return results;\n    };\n    MultiLineView.prototype._hit_point = function (geometry) {\n        var dist, hits, i, j, k, l, p0, p1, point, points, ref, ref1, ref2, result, shortest, threshold;\n        result = hittest.create_hit_test_result();\n        point = {\n            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),\n            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)\n        };\n        shortest = 9999;\n        threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n        hits = {};\n        for (i = k = 0, ref = this.sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            points = null;\n            for (j = l = 0, ref1 = this.sxs[i].length - 1; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                ref2 = [\n                    {\n                        x: this.sxs[i][j],\n                        y: this.sys[i][j]\n                    }, {\n                        x: this.sxs[i][j + 1],\n                        y: this.sys[i][j + 1]\n                    }\n                ], p0 = ref2[0], p1 = ref2[1];\n                dist = hittest.dist_to_segment(point, p0, p1);\n                if (dist < threshold && dist < shortest) {\n                    shortest = dist;\n                    points = [j];\n                }\n            }\n            if (points) {\n                hits[i] = points;\n            }\n        }\n        result['1d'].indices = Object.keys(hits);\n        result['2d'].indices = hits;\n        return result;\n    };\n    MultiLineView.prototype._hit_span = function (geometry) {\n        var hits, i, j, k, l, points, ref, ref1, ref2, result, val, values, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        result = hittest.create_hit_test_result();\n        if (geometry.direction === 'v') {\n            val = this.renderer.ymapper.map_from_target(vy);\n            values = this._ys;\n        }\n        else {\n            val = this.renderer.xmapper.map_from_target(vx);\n            values = this._xs;\n        }\n        hits = {};\n        for (i = k = 0, ref1 = values.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            points = [];\n            for (j = l = 0, ref2 = values[i].length - 1; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {\n                if ((values[i][j] <= val && val <= values[i][j + 1])) {\n                    points.push(j);\n                }\n            }\n            if (points.length > 0) {\n                hits[i] = points;\n            }\n        }\n        result['1d'].indices = Object.keys(hits);\n        result['2d'].indices = hits;\n        return result;\n    };\n    MultiLineView.prototype.get_interpolation_hit = function (i, point_i, geometry) {\n        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        ref1 = [this._xs[i][point_i], this._ys[i][point_i], this._xs[i][point_i + 1], this._ys[i][point_i + 1]], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];\n        if (geometry.type === 'point') {\n            ref2 = this.renderer.ymapper.v_map_from_target([vy - 1, vy + 1]), y0 = ref2[0], y1 = ref2[1];\n            ref3 = this.renderer.xmapper.v_map_from_target([vx - 1, vx + 1]), x0 = ref3[0], x1 = ref3[1];\n        }\n        else {\n            if (geometry.direction === 'v') {\n                ref4 = this.renderer.ymapper.v_map_from_target([vy, vy]), y0 = ref4[0], y1 = ref4[1];\n                ref5 = [x2, x3], x0 = ref5[0], x1 = ref5[1];\n            }\n            else {\n                ref6 = this.renderer.xmapper.v_map_from_target([vx, vx]), x0 = ref6[0], x1 = ref6[1];\n                ref7 = [y2, y3], y0 = ref7[0], y1 = ref7[1];\n            }\n        }\n        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n        return [res.x, res.y];\n    };\n    MultiLineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return MultiLineView;\n})(glyph_1.GlyphView);\nexports.MultiLine = (function (superClass) {\n    extend(MultiLine, superClass);\n    function MultiLine() {\n        return MultiLine.__super__.constructor.apply(this, arguments);\n    }\n    MultiLine.prototype.default_view = exports.MultiLineView;\n    MultiLine.prototype.type = 'MultiLine';\n    MultiLine.coords([['xs', 'ys']]);\n    MultiLine.mixins(['line']);\n    return MultiLine;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.OvalView = (function (superClass) {\n    extend(OvalView, superClass);\n    function OvalView() {\n        return OvalView.__super__.constructor.apply(this, arguments);\n    }\n    OvalView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    OvalView.prototype._map_data = function () {\n        if (this.model.properties.width.units === \"data\") {\n            this.sw = this.sdist(this.renderer.xmapper, this._x, this._width, 'center');\n        }\n        else {\n            this.sw = this._width;\n        }\n        if (this.model.properties.height.units === \"data\") {\n            return this.sh = this.sdist(this.renderer.ymapper, this._y, this._height, 'center');\n        }\n        else {\n            return this.sh = this._height;\n        }\n    };\n    OvalView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sh, sw, sx, sy;\n        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {\n                continue;\n            }\n            ctx.translate(sx[i], sy[i]);\n            ctx.rotate(this._angle[i]);\n            ctx.beginPath();\n            ctx.moveTo(0, -sh[i] / 2);\n            ctx.bezierCurveTo(sw[i] / 2, -sh[i] / 2, sw[i] / 2, sh[i] / 2, 0, sh[i] / 2);\n            ctx.bezierCurveTo(-sw[i] / 2, sh[i] / 2, -sw[i] / 2, -sh[i] / 2, 0, -sh[i] / 2);\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n            ctx.rotate(-this._angle[i]);\n            results.push(ctx.translate(-sx[i], -sy[i]));\n        }\n        return results;\n    };\n    OvalView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var d, data, indices, scale, sh, sw, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        scale = this.sw[index] / this.sh[index];\n        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n        sw = {};\n        sh = {};\n        if (scale > 1) {\n            sw[index] = d;\n            sh[index] = d / scale;\n        }\n        else {\n            sw[index] = d * scale;\n            sh[index] = d;\n        }\n        data = {\n            sx: sx,\n            sy: sy,\n            sw: sw,\n            sh: sh\n        };\n        return this._render(ctx, indices, data);\n    };\n    OvalView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return OvalView;\n})(xy_glyph_1.XYGlyphView);\nexports.Oval = (function (superClass) {\n    extend(Oval, superClass);\n    function Oval() {\n        return Oval.__super__.constructor.apply(this, arguments);\n    }\n    Oval.prototype.default_view = exports.OvalView;\n    Oval.prototype.type = 'Oval';\n    Oval.mixins(['line', 'fill']);\n    Oval.define({\n        angle: [p.AngleSpec, 0.0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec]\n    });\n    return Oval;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nexports.PatchView = (function (superClass) {\n    extend(PatchView, superClass);\n    function PatchView() {\n        return PatchView.__super__.constructor.apply(this, arguments);\n    }\n    PatchView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, len, len1, sx, sy;\n        sx = arg.sx, sy = arg.sy;\n        if (this.visuals.fill.doit) {\n            this.visuals.fill.set_value(ctx);\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (i === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    continue;\n                }\n                else if (isNaN(sx[i] + sy[i])) {\n                    ctx.closePath();\n                    ctx.fill();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[i], sy[i]);\n                }\n            }\n            ctx.closePath();\n            ctx.fill();\n        }\n        if (this.visuals.line.doit) {\n            this.visuals.line.set_value(ctx);\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (i === 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    continue;\n                }\n                else if (isNaN(sx[i] + sy[i])) {\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.beginPath();\n                    continue;\n                }\n                else {\n                    ctx.lineTo(sx[i], sy[i]);\n                }\n            }\n            ctx.closePath();\n            return ctx.stroke();\n        }\n    };\n    PatchView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return PatchView;\n})(xy_glyph_1.XYGlyphView);\nexports.Patch = (function (superClass) {\n    extend(Patch, superClass);\n    function Patch() {\n        return Patch.__super__.constructor.apply(this, arguments);\n    }\n    Patch.prototype.default_view = exports.PatchView;\n    Patch.prototype.type = 'Patch';\n    Patch.mixins(['line', 'fill']);\n    return Patch;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar hittest = require(\"core/hittest\");\nexports.PatchesView = (function (superClass) {\n    extend(PatchesView, superClass);\n    function PatchesView() {\n        return PatchesView.__super__.constructor.apply(this, arguments);\n    }\n    PatchesView.prototype._build_discontinuous_object = function (nanned_qs) {\n        var denanned, ds, i, k, nan_index, q, qs, qs_part, ref;\n        ds = {};\n        for (i = k = 0, ref = nanned_qs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            ds[i] = [];\n            qs = array_1.copy(nanned_qs[i]);\n            while (qs.length > 0) {\n                nan_index = array_1.findLastIndex(qs, function (q) {\n                    return types_1.isStrictNaN(q);\n                });\n                if (nan_index >= 0) {\n                    qs_part = qs.splice(nan_index);\n                }\n                else {\n                    qs_part = qs;\n                    qs = [];\n                }\n                denanned = (function () {\n                    var l, len, results;\n                    results = [];\n                    for (l = 0, len = qs_part.length; l < len; l++) {\n                        q = qs_part[l];\n                        if (!types_1.isStrictNaN(q)) {\n                            results.push(q);\n                        }\n                    }\n                    return results;\n                })();\n                ds[i].push(denanned);\n            }\n        }\n        return ds;\n    };\n    PatchesView.prototype._index_data = function () {\n        var i, j, k, l, points, ref, ref1, xs, xss, ys, yss;\n        xss = this._build_discontinuous_object(this._xs);\n        yss = this._build_discontinuous_object(this._ys);\n        points = [];\n        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            for (j = l = 0, ref1 = xss[i].length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                xs = xss[i][j];\n                ys = yss[i][j];\n                if (xs.length === 0) {\n                    continue;\n                }\n                points.push({\n                    minX: array_1.min(xs),\n                    minY: array_1.min(ys),\n                    maxX: array_1.max(xs),\n                    maxY: array_1.max(ys),\n                    i: i\n                });\n            }\n        }\n        return new spatial_1.RBush(points);\n    };\n    PatchesView.prototype._mask_data = function (all_indices) {\n        var bbox, ref, ref1, x0, x1, xr, y0, y1, yr;\n        xr = this.renderer.plot_view.x_range;\n        ref = [xr.min, xr.max], x0 = ref[0], x1 = ref[1];\n        yr = this.renderer.plot_view.y_range;\n        ref1 = [yr.min, yr.max], y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    PatchesView.prototype._render = function (ctx, indices, arg) {\n        var i, j, k, l, len, m, ref, ref1, ref2, results, sx, sxs, sy, sys;\n        sxs = arg.sxs, sys = arg.sys;\n        this.renderer.sxss = this._build_discontinuous_object(sxs);\n        this.renderer.syss = this._build_discontinuous_object(sys);\n        results = [];\n        for (k = 0, len = indices.length; k < len; k++) {\n            i = indices[k];\n            ref = [sxs[i], sys[i]], sx = ref[0], sy = ref[1];\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                    if (j === 0) {\n                        ctx.beginPath();\n                        ctx.moveTo(sx[j], sy[j]);\n                        continue;\n                    }\n                    else if (isNaN(sx[j] + sy[j])) {\n                        ctx.closePath();\n                        ctx.fill();\n                        ctx.beginPath();\n                        continue;\n                    }\n                    else {\n                        ctx.lineTo(sx[j], sy[j]);\n                    }\n                }\n                ctx.closePath();\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                for (j = m = 0, ref2 = sx.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {\n                    if (j === 0) {\n                        ctx.beginPath();\n                        ctx.moveTo(sx[j], sy[j]);\n                        continue;\n                    }\n                    else if (isNaN(sx[j] + sy[j])) {\n                        ctx.closePath();\n                        ctx.stroke();\n                        ctx.beginPath();\n                        continue;\n                    }\n                    else {\n                        ctx.lineTo(sx[j], sy[j]);\n                    }\n                }\n                ctx.closePath();\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    PatchesView.prototype._hit_point = function (geometry) {\n        var candidates, hits, i, idx, j, k, l, ref, ref1, ref2, result, sx, sxs, sy, sys, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        candidates = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        hits = [];\n        for (i = k = 0, ref1 = candidates.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            idx = candidates[i];\n            sxs = this.renderer.sxss[idx];\n            sys = this.renderer.syss[idx];\n            for (j = l = 0, ref2 = sxs.length; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    hits.push(idx);\n                }\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    PatchesView.prototype._get_snap_coord = function (array) {\n        var k, len, s, sum;\n        sum = 0;\n        for (k = 0, len = array.length; k < len; k++) {\n            s = array[k];\n            sum += s;\n        }\n        return sum / array.length;\n    };\n    PatchesView.prototype.scx = function (i, sx, sy) {\n        var j, k, ref, sxs, sys;\n        if (this.renderer.sxss[i].length === 1) {\n            return this._get_snap_coord(this.sxs[i]);\n        }\n        else {\n            sxs = this.renderer.sxss[i];\n            sys = this.renderer.syss[i];\n            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    return this._get_snap_coord(sxs[j]);\n                }\n            }\n        }\n        return null;\n    };\n    PatchesView.prototype.scy = function (i, sx, sy) {\n        var j, k, ref, sxs, sys;\n        if (this.renderer.syss[i].length === 1) {\n            return this._get_snap_coord(this.sys[i]);\n        }\n        else {\n            sxs = this.renderer.sxss[i];\n            sys = this.renderer.syss[i];\n            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                    return this._get_snap_coord(sys[j]);\n                }\n            }\n        }\n    };\n    PatchesView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return PatchesView;\n})(glyph_1.GlyphView);\nexports.Patches = (function (superClass) {\n    extend(Patches, superClass);\n    function Patches() {\n        return Patches.__super__.constructor.apply(this, arguments);\n    }\n    Patches.prototype.default_view = exports.PatchesView;\n    Patches.prototype.type = 'Patches';\n    Patches.coords([['xs', 'ys']]);\n    Patches.mixins(['line', 'fill']);\n    return Patches;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nvar hittest = require(\"core/hittest\");\nexports.QuadView = (function (superClass) {\n    extend(QuadView, superClass);\n    function QuadView() {\n        return QuadView.__super__.constructor.apply(this, arguments);\n    }\n    QuadView.prototype._index_data = function () {\n        var b, bottom, i, j, l, left, map_to_synthetic, points, r, ref, right, t, top;\n        map_to_synthetic = function (mapper, array) {\n            if (mapper instanceof categorical_mapper_1.CategoricalMapper) {\n                return mapper.v_map_to_target(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        left = map_to_synthetic(this.renderer.xmapper, this._left);\n        right = map_to_synthetic(this.renderer.xmapper, this._right);\n        top = map_to_synthetic(this.renderer.ymapper, this._top);\n        bottom = map_to_synthetic(this.renderer.ymapper, this._bottom);\n        points = [];\n        for (i = j = 0, ref = left.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = left[i];\n            r = right[i];\n            t = top[i];\n            b = bottom[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    QuadView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    QuadView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    QuadView.prototype.get_anchor_point = function (anchor, i, spt) {\n        var bottom, left, right, top;\n        left = Math.min(this.sleft[i], this.sright[i]);\n        right = Math.max(this.sright[i], this.sleft[i]);\n        top = Math.min(this.stop[i], this.sbottom[i]);\n        bottom = Math.max(this.sbottom[i], this.stop[i]);\n        switch (anchor) {\n            case 'top_left':\n                return {\n                    x: left,\n                    y: top\n                };\n            case 'top_center':\n                return {\n                    x: (left + right) / 2,\n                    y: top\n                };\n            case 'top_right':\n                return {\n                    x: right,\n                    y: top\n                };\n            case 'center_right':\n                return {\n                    x: right,\n                    y: (top + bottom) / 2\n                };\n            case 'bottom_right':\n                return {\n                    x: right,\n                    y: bottom\n                };\n            case 'bottom_center':\n                return {\n                    x: (left + right) / 2,\n                    y: bottom\n                };\n            case 'bottom_left':\n                return {\n                    x: left,\n                    y: bottom\n                };\n            case 'center_left':\n                return {\n                    x: left,\n                    y: (top + bottom) / 2\n                };\n            case 'center':\n                return {\n                    x: (left + right) / 2,\n                    y: (top + bottom) / 2\n                };\n        }\n    };\n    QuadView.prototype.scx = function (i) {\n        return (this.sleft[i] + this.sright[i]) / 2;\n    };\n    QuadView.prototype.scy = function (i) {\n        return (this.stop[i] + this.sbottom[i]) / 2;\n    };\n    QuadView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return QuadView;\n})(glyph_1.GlyphView);\nexports.Quad = (function (superClass) {\n    extend(Quad, superClass);\n    function Quad() {\n        return Quad.__super__.constructor.apply(this, arguments);\n    }\n    Quad.prototype.default_view = exports.QuadView;\n    Quad.prototype.type = 'Quad';\n    Quad.coords([['right', 'bottom'], ['left', 'top']]);\n    Quad.mixins(['line', 'fill']);\n    return Quad;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _qbb, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\n_qbb = function (u, v, w) {\n    var bd, t;\n    if (v === (u + w) / 2) {\n        return [u, w];\n    }\n    else {\n        t = (u - v) / (u - 2 * v + w);\n        bd = u * Math.pow(1 - t, 2) + 2 * v * (1 - t) * t + w * Math.pow(t, 2);\n        return [Math.min(u, w, bd), Math.max(u, w, bd)];\n    }\n};\nexports.QuadraticView = (function (superClass) {\n    extend(QuadraticView, superClass);\n    function QuadraticView() {\n        return QuadraticView.__super__.constructor.apply(this, arguments);\n    }\n    QuadraticView.prototype._index_data = function () {\n        var i, j, points, ref, ref1, ref2, x0, x1, y0, y1;\n        points = [];\n        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i])) {\n                continue;\n            }\n            ref1 = _qbb(this._x0[i], this._cx[i], this._x1[i]), x0 = ref1[0], x1 = ref1[1];\n            ref2 = _qbb(this._y0[i], this._cy[i], this._y1[i]), y0 = ref2[0], y1 = ref2[1];\n            points.push({\n                minX: x0,\n                minY: y0,\n                maxX: x1,\n                maxY: y1,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    QuadraticView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, scx, scy, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scy = arg.scy;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    QuadraticView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return QuadraticView;\n})(glyph_1.GlyphView);\nexports.Quadratic = (function (superClass) {\n    extend(Quadratic, superClass);\n    function Quadratic() {\n        return Quadratic.__super__.constructor.apply(this, arguments);\n    }\n    Quadratic.prototype.default_view = exports.QuadraticView;\n    Quadratic.prototype.type = 'Quadratic';\n    Quadratic.coords([['x0', 'y0'], ['x1', 'y1'], ['cx', 'cy']]);\n    Quadratic.mixins(['line']);\n    return Quadratic;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.RayView = (function (superClass) {\n    extend(RayView, superClass);\n    function RayView() {\n        return RayView.__super__.constructor.apply(this, arguments);\n    }\n    RayView.prototype._map_data = function () {\n        return this.slength = this.sdist(this.renderer.xmapper, this._x, this._length);\n    };\n    RayView.prototype._render = function (ctx, indices, arg) {\n        var _angle, height, i, inf_len, j, k, len, ref, results, slength, sx, sy, width;\n        sx = arg.sx, sy = arg.sy, slength = arg.slength, _angle = arg._angle;\n        if (this.visuals.line.doit) {\n            width = this.renderer.plot_view.frame.width;\n            height = this.renderer.plot_view.frame.height;\n            inf_len = 2 * (width + height);\n            for (i = j = 0, ref = slength.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                if (slength[i] === 0) {\n                    slength[i] = inf_len;\n                }\n            }\n            results = [];\n            for (k = 0, len = indices.length; k < len; k++) {\n                i = indices[k];\n                if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i])) {\n                    continue;\n                }\n                ctx.translate(sx[i], sy[i]);\n                ctx.rotate(_angle[i]);\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(slength[i], 0);\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n                ctx.rotate(-_angle[i]);\n                results.push(ctx.translate(-sx[i], -sy[i]));\n            }\n            return results;\n        }\n    };\n    RayView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return RayView;\n})(xy_glyph_1.XYGlyphView);\nexports.Ray = (function (superClass) {\n    extend(Ray, superClass);\n    function Ray() {\n        return Ray.__super__.constructor.apply(this, arguments);\n    }\n    Ray.prototype.default_view = exports.RayView;\n    Ray.prototype.type = 'Ray';\n    Ray.mixins(['line']);\n    Ray.define({\n        length: [p.DistanceSpec],\n        angle: [p.AngleSpec]\n    });\n    return Ray;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nexports.RectView = (function (superClass) {\n    extend(RectView, superClass);\n    function RectView() {\n        return RectView.__super__.constructor.apply(this, arguments);\n    }\n    RectView.prototype._set_data = function () {\n        this.max_w2 = 0;\n        if (this.model.properties.width.units === \"data\") {\n            this.max_w2 = this.max_width / 2;\n        }\n        this.max_h2 = 0;\n        if (this.model.properties.height.units === \"data\") {\n            return this.max_h2 = this.max_height / 2;\n        }\n    };\n    RectView.prototype._map_data = function () {\n        var canvas, i, ref, ref1;\n        canvas = this.renderer.plot_view.canvas;\n        if (this.model.properties.width.units === \"data\") {\n            ref = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xmapper, canvas, 0), this.sw = ref[0], this.sx0 = ref[1];\n        }\n        else {\n            this.sw = this._width;\n            this.sx0 = (function () {\n                var j, ref1, results;\n                results = [];\n                for (i = j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                    results.push(this.sx[i] - this.sw[i] / 2);\n                }\n                return results;\n            }).call(this);\n        }\n        if (this.model.properties.height.units === \"data\") {\n            ref1 = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.ymapper, canvas, 1), this.sh = ref1[0], this.sy1 = ref1[1];\n        }\n        else {\n            this.sh = this._height;\n            this.sy1 = (function () {\n                var j, ref2, results;\n                results = [];\n                for (i = j = 0, ref2 = this.sy.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {\n                    results.push(this.sy[i] - this.sh[i] / 2);\n                }\n                return results;\n            }).call(this);\n        }\n        return this.ssemi_diag = (function () {\n            var j, ref2, results;\n            results = [];\n            for (i = j = 0, ref2 = this.sw.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {\n                results.push(Math.sqrt(this.sw[i] / 2 * this.sw[i] / 2 + this.sh[i] / 2 * this.sh[i] / 2));\n            }\n            return results;\n        }).call(this);\n    };\n    RectView.prototype._render = function (ctx, indices, arg) {\n        var _angle, i, j, k, len, len1, sh, sw, sx, sx0, sy, sy1;\n        sx = arg.sx, sy = arg.sy, sx0 = arg.sx0, sy1 = arg.sy1, sw = arg.sw, sh = arg.sh, _angle = arg._angle;\n        if (this.visuals.fill.doit) {\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {\n                    continue;\n                }\n                this.visuals.fill.set_vectorize(ctx, i);\n                if (_angle[i]) {\n                    ctx.translate(sx[i], sy[i]);\n                    ctx.rotate(_angle[i]);\n                    ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                    ctx.rotate(-_angle[i]);\n                    ctx.translate(-sx[i], -sy[i]);\n                }\n                else {\n                    ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);\n                }\n            }\n        }\n        if (this.visuals.line.doit) {\n            ctx.beginPath();\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {\n                    continue;\n                }\n                if (sw[i] === 0 || sh[i] === 0) {\n                    continue;\n                }\n                if (_angle[i]) {\n                    ctx.translate(sx[i], sy[i]);\n                    ctx.rotate(_angle[i]);\n                    ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                    ctx.rotate(-_angle[i]);\n                    ctx.translate(-sx[i], -sy[i]);\n                }\n                else {\n                    ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);\n                }\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.stroke();\n                ctx.beginPath();\n            }\n            return ctx.stroke();\n        }\n    };\n    RectView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    RectView.prototype._hit_point = function (geometry) {\n        var bbox, c, d, height_in, hits, i, j, len, max_x2_ddist, max_y2_ddist, px, py, ref, ref1, result, s, scenter_x, scenter_y, sx, sy, vx, vy, width_in, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        scenter_x = (function () {\n            var j, ref1, results;\n            results = [];\n            for (i = j = 0, ref1 = this.sx0.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this.sx0[i] + this.sw[i] / 2);\n            }\n            return results;\n        }).call(this);\n        scenter_y = (function () {\n            var j, ref1, results;\n            results = [];\n            for (i = j = 0, ref1 = this.sy1.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                results.push(this.sy1[i] + this.sh[i] / 2);\n            }\n            return results;\n        }).call(this);\n        max_x2_ddist = array_1.max(this._ddist(0, scenter_x, this.ssemi_diag));\n        max_y2_ddist = array_1.max(this._ddist(1, scenter_y, this.ssemi_diag));\n        x0 = x - max_x2_ddist;\n        x1 = x + max_x2_ddist;\n        y0 = y - max_y2_ddist;\n        y1 = y + max_y2_ddist;\n        hits = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref1 = this.index.indices(bbox);\n        for (j = 0, len = ref1.length; j < len; j++) {\n            i = ref1[j];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            if (this._angle[i]) {\n                d = Math.sqrt(Math.pow(sx - this.sx[i], 2) + Math.pow(sy - this.sy[i], 2));\n                s = Math.sin(-this._angle[i]);\n                c = Math.cos(-this._angle[i]);\n                px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];\n                py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];\n                sx = px;\n                sy = py;\n                width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;\n                height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;\n            }\n            else {\n                width_in = sx - this.sx0[i] <= this.sw[i] && sx - this.sx0[i] >= 0;\n                height_in = sy - this.sy1[i] <= this.sh[i] && sy - this.sy1[i] >= 0;\n            }\n            if (height_in && width_in) {\n                hits.push(i);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    RectView.prototype._map_dist_corner_for_data_side_length = function (coord, side_length, mapper, canvas, dim) {\n        var i, pt0, pt1, return_synthetic, sside_length, synthetic_pt, synthetic_pt_corner, vpt0, vpt1, vpt_corner;\n        if (types_1.isString(coord[0]) && mapper instanceof categorical_mapper_1.CategoricalMapper) {\n            return_synthetic = true;\n            synthetic_pt = mapper.v_map_to_target(coord, return_synthetic);\n            if (dim === 0) {\n                synthetic_pt_corner = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        results.push(synthetic_pt[i] - side_length[i] / 2);\n                    }\n                    return results;\n                })();\n            }\n            else if (dim === 1) {\n                synthetic_pt_corner = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        results.push(synthetic_pt[i] + side_length[i] / 2);\n                    }\n                    return results;\n                })();\n            }\n            vpt_corner = mapper.v_map_to_target(synthetic_pt_corner);\n            sside_length = this.sdist(mapper, coord, side_length, 'center', this.model.dilate);\n        }\n        else {\n            pt0 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Number(coord[i]) - side_length[i] / 2);\n                }\n                return results;\n            })();\n            pt1 = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    results.push(Number(coord[i]) + side_length[i] / 2);\n                }\n                return results;\n            })();\n            vpt0 = mapper.v_map_to_target(pt0);\n            vpt1 = mapper.v_map_to_target(pt1);\n            sside_length = this.sdist(mapper, pt0, side_length, 'edge', this.model.dilate);\n            if (dim === 0) {\n                vpt_corner = vpt0[0] < vpt1[0] ? vpt0 : vpt1;\n            }\n            else if (dim === 1) {\n                vpt_corner = vpt0[0] < vpt1[0] ? vpt1 : vpt0;\n            }\n        }\n        if (dim === 0) {\n            return [sside_length, canvas.v_vx_to_sx(vpt_corner)];\n        }\n        else if (dim === 1) {\n            return [sside_length, canvas.v_vy_to_sy(vpt_corner)];\n        }\n    };\n    RectView.prototype._ddist = function (dim, spts, spans) {\n        var i, mapper, pt0, pt1, vpt0, vpt1, vpts;\n        if (dim === 0) {\n            vpts = this.renderer.plot_view.canvas.v_sx_to_vx(spts);\n            mapper = this.renderer.xmapper;\n        }\n        else {\n            vpts = this.renderer.plot_view.canvas.v_vy_to_sy(spts);\n            mapper = this.renderer.ymapper;\n        }\n        vpt0 = vpts;\n        vpt1 = (function () {\n            var j, ref, results;\n            results = [];\n            for (i = j = 0, ref = vpt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                results.push(vpt0[i] + spans[i]);\n            }\n            return results;\n        })();\n        pt0 = mapper.v_map_from_target(vpt0);\n        pt1 = mapper.v_map_from_target(vpt1);\n        return (function () {\n            var j, ref, results;\n            results = [];\n            for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                results.push(Math.abs(pt1[i] - pt0[i]));\n            }\n            return results;\n        })();\n    };\n    RectView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    RectView.prototype._bounds = function (bds) {\n        return this.max_wh2_bounds(bds);\n    };\n    return RectView;\n})(xy_glyph_1.XYGlyphView);\nexports.Rect = (function (superClass) {\n    extend(Rect, superClass);\n    function Rect() {\n        return Rect.__super__.constructor.apply(this, arguments);\n    }\n    Rect.prototype.default_view = exports.RectView;\n    Rect.prototype.type = 'Rect';\n    Rect.mixins(['line', 'fill']);\n    Rect.define({\n        angle: [p.AngleSpec, 0],\n        width: [p.DistanceSpec],\n        height: [p.DistanceSpec],\n        dilate: [p.Bool, false]\n    });\n    return Rect;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nexports.SegmentView = (function (superClass) {\n    extend(SegmentView, superClass);\n    function SegmentView() {\n        return SegmentView.__super__.constructor.apply(this, arguments);\n    }\n    SegmentView.prototype._index_data = function () {\n        var i, j, points, ref;\n        points = [];\n        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (!isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i])) {\n                points.push({\n                    minX: Math.min(this._x0[i], this._x1[i]),\n                    minY: Math.min(this._y0[i], this._y1[i]),\n                    maxX: Math.max(this._x0[i], this._x1[i]),\n                    maxY: Math.max(this._y0[i], this._y1[i]),\n                    i: i\n                });\n            }\n        }\n        return new spatial_1.RBush(points);\n    };\n    SegmentView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sx0, sx1, sy0, sy1;\n        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1;\n        if (this.visuals.line.doit) {\n            results = [];\n            for (j = 0, len = indices.length; j < len; j++) {\n                i = indices[j];\n                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) {\n                    continue;\n                }\n                ctx.beginPath();\n                ctx.moveTo(sx0[i], sy0[i]);\n                ctx.lineTo(sx1[i], sy1[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            return results;\n        }\n    };\n    SegmentView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return SegmentView;\n})(glyph_1.GlyphView);\nexports.Segment = (function (superClass) {\n    extend(Segment, superClass);\n    function Segment() {\n        return Segment.__super__.constructor.apply(this, arguments);\n    }\n    Segment.prototype.default_view = exports.SegmentView;\n    Segment.prototype.type = 'Segment';\n    Segment.coords([['x0', 'y0'], ['x1', 'y1']]);\n    Segment.mixins(['line']);\n    return Segment;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar p = require(\"core/properties\");\nexports.TextView = (function (superClass) {\n    extend(TextView, superClass);\n    function TextView() {\n        return TextView.__super__.constructor.apply(this, arguments);\n    }\n    TextView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _text, _x_offset, _y_offset, i, j, len, results, sx, sy;\n        sx = arg.sx, sy = arg.sy, _x_offset = arg._x_offset, _y_offset = arg._y_offset, _angle = arg._angle, _text = arg._text;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || (_text[i] == null)) {\n                continue;\n            }\n            if (this.visuals.text.doit) {\n                ctx.save();\n                ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\n                ctx.rotate(_angle[i]);\n                this.visuals.text.set_vectorize(ctx, i);\n                ctx.fillText(_text[i], 0, 0);\n                results.push(ctx.restore());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    TextView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        ctx.save();\n        this.text_props.set_value(ctx);\n        ctx.font = this.text_props.font_value();\n        ctx.font = ctx.font.replace(/\\b[\\d\\.]+[\\w]+\\b/, '10pt');\n        ctx.textAlign = \"right\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"text\", x2, (y1 + y2) / 2);\n        return ctx.restore();\n    };\n    return TextView;\n})(xy_glyph_1.XYGlyphView);\nexports.Text = (function (superClass) {\n    extend(Text, superClass);\n    function Text() {\n        return Text.__super__.constructor.apply(this, arguments);\n    }\n    Text.prototype.default_view = exports.TextView;\n    Text.prototype.type = 'Text';\n    Text.mixins(['text']);\n    Text.define({\n        text: [\n            p.StringSpec, {\n                field: \"text\"\n            }\n        ],\n        angle: [p.AngleSpec, 0],\n        x_offset: [p.NumberSpec, 0],\n        y_offset: [p.NumberSpec, 0]\n    });\n    return Text;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.VBarView = (function (superClass) {\n    extend(VBarView, superClass);\n    function VBarView() {\n        return VBarView.__super__.constructor.apply(this, arguments);\n    }\n    VBarView.prototype._map_data = function () {\n        var i, j, ref, vbottom, vtop;\n        this.sx = this.renderer.xmapper.v_map_to_target(this._x);\n        vtop = this.renderer.ymapper.v_map_to_target(this._top);\n        vbottom = this.renderer.ymapper.v_map_to_target(this._bottom);\n        this.stop = this.renderer.plot_view.canvas.v_vy_to_sy(vtop);\n        this.sbottom = this.renderer.plot_view.canvas.v_vy_to_sy(vbottom);\n        this.sleft = [];\n        this.sright = [];\n        this.sw = this.sdist(this.renderer.xmapper, this._x, this._width, 'center');\n        for (i = j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            this.sleft.push(this.sx[i] - this.sw[i] / 2);\n            this.sright.push(this.sx[i] + this.sw[i] / 2);\n        }\n        return null;\n    };\n    VBarView.prototype._index_data = function () {\n        var b, bottom, i, j, l, map_to_synthetic, points, r, ref, t, top, width, x;\n        map_to_synthetic = function (mapper, array) {\n            if (mapper instanceof categorical_mapper_1.CategoricalMapper) {\n                return mapper.v_map_to_target(array, true);\n            }\n            else {\n                return array;\n            }\n        };\n        x = map_to_synthetic(this.renderer.xmapper, this._x);\n        width = map_to_synthetic(this.renderer.xmapper, this._width);\n        top = map_to_synthetic(this.renderer.ymapper, this._top);\n        bottom = map_to_synthetic(this.renderer.ymapper, this._bottom);\n        points = [];\n        for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            l = x[i] - width[i] / 2;\n            r = x[i] + width[i] / 2;\n            t = top[i];\n            b = bottom[i];\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                continue;\n            }\n            points.push({\n                minX: l,\n                minY: b,\n                maxX: r,\n                maxY: t,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    VBarView.prototype._render = function (ctx, indices, arg) {\n        var i, j, len, results, sbottom, sleft, sright, stop;\n        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {\n                continue;\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    VBarView.prototype._hit_point = function (geometry) {\n        var hits, ref, result, vx, vy, x, y;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        hits = this.index.indices({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y\n        });\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    VBarView.prototype.scy = function (i) {\n        return (this.stop[i] + this.sbottom[i]) / 2;\n    };\n    VBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return VBarView;\n})(glyph_1.GlyphView);\nexports.VBar = (function (superClass) {\n    extend(VBar, superClass);\n    function VBar() {\n        return VBar.__super__.constructor.apply(this, arguments);\n    }\n    VBar.prototype.default_view = exports.VBarView;\n    VBar.prototype.type = 'VBar';\n    VBar.mixins(['line', 'fill']);\n    VBar.define({\n        x: [p.NumberSpec],\n        width: [p.DistanceSpec],\n        top: [p.NumberSpec],\n        bottom: [p.NumberSpec, 0]\n    });\n    return VBar;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"./xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar math_1 = require(\"core/util/math\");\nexports.WedgeView = (function (superClass) {\n    extend(WedgeView, superClass);\n    function WedgeView() {\n        return WedgeView.__super__.constructor.apply(this, arguments);\n    }\n    WedgeView.prototype._map_data = function () {\n        if (this.model.properties.radius.units === \"data\") {\n            return this.sradius = this.sdist(this.renderer.xmapper, this._x, this._radius);\n        }\n        else {\n            return this.sradius = this._radius;\n        }\n    };\n    WedgeView.prototype._render = function (ctx, indices, arg) {\n        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;\n        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;\n        direction = this.model.properties.direction.value();\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {\n                continue;\n            }\n            ctx.beginPath();\n            ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n            ctx.lineTo(sx[i], sy[i]);\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                results.push(ctx.stroke());\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    WedgeView.prototype._hit_point = function (geometry) {\n        var angle, bbox, candidates, direction, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        x = this.renderer.xmapper.map_from_target(vx, true);\n        y = this.renderer.ymapper.map_from_target(vy, true);\n        if (this.model.properties.radius.units === \"data\") {\n            x0 = x - this.max_radius;\n            x1 = x + this.max_radius;\n            y0 = y - this.max_radius;\n            y1 = y + this.max_radius;\n        }\n        else {\n            vx0 = vx - this.max_radius;\n            vx1 = vx + this.max_radius;\n            ref1 = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n            vy0 = vy - this.max_radius;\n            vy1 = vy + this.max_radius;\n            ref2 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        }\n        candidates = [];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        ref3 = this.index.indices(bbox);\n        for (j = 0, len = ref3.length; j < len; j++) {\n            i = ref3[j];\n            r2 = Math.pow(this.sradius[i], 2);\n            sx0 = this.renderer.xmapper.map_to_target(x, true);\n            sx1 = this.renderer.xmapper.map_to_target(this._x[i], true);\n            sy0 = this.renderer.ymapper.map_to_target(y, true);\n            sy1 = this.renderer.ymapper.map_to_target(this._y[i], true);\n            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n            if (dist <= r2) {\n                candidates.push([i, dist]);\n            }\n        }\n        direction = this.model.properties.direction.value();\n        hits = [];\n        for (k = 0, len1 = candidates.length; k < len1; k++) {\n            ref4 = candidates[k], i = ref4[0], dist = ref4[1];\n            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    WedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);\n    };\n    return WedgeView;\n})(xy_glyph_1.XYGlyphView);\nexports.Wedge = (function (superClass) {\n    extend(Wedge, superClass);\n    function Wedge() {\n        return Wedge.__super__.constructor.apply(this, arguments);\n    }\n    Wedge.prototype.default_view = exports.WedgeView;\n    Wedge.prototype.type = 'Wedge';\n    Wedge.mixins(['line', 'fill']);\n    Wedge.define({\n        direction: [p.Direction, 'anticlock'],\n        radius: [p.DistanceSpec],\n        start_angle: [p.AngleSpec],\n        end_angle: [p.AngleSpec]\n    });\n    return Wedge;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar spatial_1 = require(\"core/util/spatial\");\nvar glyph_1 = require(\"./glyph\");\nvar categorical_mapper_1 = require(\"../mappers/categorical_mapper\");\nexports.XYGlyphView = (function (superClass) {\n    extend(XYGlyphView, superClass);\n    function XYGlyphView() {\n        return XYGlyphView.__super__.constructor.apply(this, arguments);\n    }\n    XYGlyphView.prototype._index_data = function () {\n        var i, j, points, ref, x, xx, y, yy;\n        if (this.renderer.xmapper instanceof categorical_mapper_1.CategoricalMapper) {\n            xx = this.renderer.xmapper.v_map_to_target(this._x, true);\n        }\n        else {\n            xx = this._x;\n        }\n        if (this.renderer.ymapper instanceof categorical_mapper_1.CategoricalMapper) {\n            yy = this.renderer.ymapper.v_map_to_target(this._y, true);\n        }\n        else {\n            yy = this._y;\n        }\n        points = [];\n        for (i = j = 0, ref = xx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x = xx[i];\n            if (isNaN(x) || !isFinite(x)) {\n                continue;\n            }\n            y = yy[i];\n            if (isNaN(y) || !isFinite(y)) {\n                continue;\n            }\n            points.push({\n                minX: x,\n                minY: y,\n                maxX: x,\n                maxY: y,\n                i: i\n            });\n        }\n        return new spatial_1.RBush(points);\n    };\n    return XYGlyphView;\n})(glyph_1.GlyphView);\nexports.XYGlyph = (function (superClass) {\n    extend(XYGlyph, superClass);\n    function XYGlyph() {\n        return XYGlyph.__super__.constructor.apply(this, arguments);\n    }\n    XYGlyph.prototype.type = \"XYGlyph\";\n    XYGlyph.prototype.default_view = exports.XYGlyphView;\n    XYGlyph.coords([['x', 'y']]);\n    return XYGlyph;\n})(glyph_1.Glyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar guide_renderer_1 = require(\"../renderers/guide_renderer\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.GridView = (function (superClass) {\n    extend(GridView, superClass);\n    function GridView() {\n        return GridView.__super__.constructor.apply(this, arguments);\n    }\n    GridView.prototype.initialize = function (attrs, options) {\n        GridView.__super__.initialize.call(this, attrs, options);\n        this._x_range_name = this.model.x_range_name;\n        return this._y_range_name = this.model.y_range_name;\n    };\n    GridView.prototype.render = function () {\n        var ctx;\n        if (this.model.visible === false) {\n            return;\n        }\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        this._draw_regions(ctx);\n        this._draw_minor_grids(ctx);\n        this._draw_grids(ctx);\n        return ctx.restore();\n    };\n    GridView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change', this.request_render);\n    };\n    GridView.prototype._draw_regions = function (ctx) {\n        var i, k, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, xs, ys;\n        if (!this.visuals.band_fill.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('major', false), xs = ref[0], ys = ref[1];\n        this.visuals.band_fill.set_value(ctx);\n        for (i = k = 0, ref1 = xs.length - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            if (i % 2 === 1) {\n                ref2 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx0 = ref2[0], sy0 = ref2[1];\n                ref3 = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this._x_range_name, this._y_range_name), sx1 = ref3[0], sy1 = ref3[1];\n                ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n                ctx.fill();\n            }\n        }\n    };\n    GridView.prototype._draw_grids = function (ctx) {\n        var ref, xs, ys;\n        if (!this.visuals.grid_line.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('major'), xs = ref[0], ys = ref[1];\n        return this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\n    };\n    GridView.prototype._draw_minor_grids = function (ctx) {\n        var ref, xs, ys;\n        if (!this.visuals.minor_grid_line.doit) {\n            return;\n        }\n        ref = this.model.grid_coords('minor'), xs = ref[0], ys = ref[1];\n        return this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\n    };\n    GridView.prototype._draw_grid_helper = function (ctx, props, xs, ys) {\n        var i, k, l, ref, ref1, ref2, sx, sy;\n        props.set_value(ctx);\n        for (i = k = 0, ref = xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            ref1 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\n            for (i = l = 1, ref2 = sx.length; 1 <= ref2 ? l < ref2 : l > ref2; i = 1 <= ref2 ? ++l : --l) {\n                ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\n            }\n            ctx.stroke();\n        }\n    };\n    return GridView;\n})(renderer_1.RendererView);\nexports.Grid = (function (superClass) {\n    extend(Grid, superClass);\n    function Grid() {\n        return Grid.__super__.constructor.apply(this, arguments);\n    }\n    Grid.prototype.default_view = exports.GridView;\n    Grid.prototype.type = 'Grid';\n    Grid.mixins(['line:grid_', 'line:minor_grid_', 'fill:band_']);\n    Grid.define({\n        bounds: [p.Any, 'auto'],\n        dimension: [p.Number, 0],\n        ticker: [p.Instance],\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default']\n    });\n    Grid.override({\n        level: \"underlay\",\n        band_fill_color: null,\n        band_fill_alpha: 0,\n        grid_line_color: '#e5e5e5',\n        minor_grid_line_color: null\n    });\n    Grid.prototype.ranges = function () {\n        var frame, i, j, ranges;\n        i = this.dimension;\n        j = (i + 1) % 2;\n        frame = this.plot.plot_canvas.frame;\n        ranges = [frame.x_ranges[this.x_range_name], frame.y_ranges[this.y_range_name]];\n        return [ranges[i], ranges[j]];\n    };\n    Grid.prototype.computed_bounds = function () {\n        var cross_range, end, range, range_bounds, ref, start, user_bounds;\n        ref = this.ranges(), range = ref[0], cross_range = ref[1];\n        user_bounds = this.bounds;\n        range_bounds = [range.min, range.max];\n        if (types_1.isArray(user_bounds)) {\n            start = Math.min(user_bounds[0], user_bounds[1]);\n            end = Math.max(user_bounds[0], user_bounds[1]);\n            if (start < range_bounds[0]) {\n                start = range_bounds[0];\n            }\n            else if (start > range_bounds[1]) {\n                start = null;\n            }\n            if (end > range_bounds[1]) {\n                end = range_bounds[1];\n            }\n            else if (end < range_bounds[0]) {\n                end = null;\n            }\n        }\n        else {\n            start = range_bounds[0], end = range_bounds[1];\n        }\n        return [start, end];\n    };\n    Grid.prototype.grid_coords = function (location, exclude_ends) {\n        var N, cmax, cmin, coords, cross_range, dim_i, dim_j, end, i, ii, j, k, l, loc, max, min, n, range, ref, ref1, ref2, ref3, start, ticks, tmp;\n        if (exclude_ends == null) {\n            exclude_ends = true;\n        }\n        i = this.dimension;\n        j = (i + 1) % 2;\n        ref = this.ranges(), range = ref[0], cross_range = ref[1];\n        ref1 = this.computed_bounds(), start = ref1[0], end = ref1[1];\n        tmp = Math.min(start, end);\n        end = Math.max(start, end);\n        start = tmp;\n        ticks = this.ticker.get_ticks(start, end, range, cross_range.min, {})[location];\n        min = range.min;\n        max = range.max;\n        cmin = cross_range.min;\n        cmax = cross_range.max;\n        coords = [[], []];\n        for (ii = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {\n            if ((ticks[ii] === min || ticks[ii] === max) && exclude_ends) {\n                continue;\n            }\n            dim_i = [];\n            dim_j = [];\n            N = 2;\n            for (n = l = 0, ref3 = N; 0 <= ref3 ? l < ref3 : l > ref3; n = 0 <= ref3 ? ++l : --l) {\n                loc = cmin + (cmax - cmin) / (N - 1) * n;\n                dim_i.push(ticks[ii]);\n                dim_j.push(loc);\n            }\n            coords[i].push(dim_i);\n            coords[j].push(dim_j);\n        }\n        return coords;\n    };\n    return Grid;\n})(guide_renderer_1.GuideRenderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar grid_1 = require(\"./grid\");\nexports.Grid = grid_1.Grid;\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./annotations\"));\n__export(require(\"./axes\"));\n__export(require(\"./callbacks\"));\n__export(require(\"./canvas\"));\n__export(require(\"./formatters\"));\n__export(require(\"./glyphs\"));\n__export(require(\"./grids\"));\n__export(require(\"./layouts\"));\n__export(require(\"./mappers\"));\n__export(require(\"./transforms\"));\n__export(require(\"./markers\"));\n__export(require(\"./plots\"));\n__export(require(\"./ranges\"));\n__export(require(\"./renderers\"));\n__export(require(\"./sources\"));\n__export(require(\"./tickers\"));\n__export(require(\"./tiles\"));\n__export(require(\"./tools\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar solver_1 = require(\"core/layout/solver\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar layout_dom_1 = require(\"./layout_dom\");\nexports.BoxView = (function (superClass) {\n    extend1(BoxView, superClass);\n    function BoxView() {\n        return BoxView.__super__.constructor.apply(this, arguments);\n    }\n    BoxView.prototype.className = \"bk-grid\";\n    BoxView.prototype.bind_bokeh_events = function () {\n        BoxView.__super__.bind_bokeh_events.call(this);\n        return this.listenTo(this.model, 'change:children', this.build_child_views);\n    };\n    BoxView.prototype.get_height = function () {\n        var child_heights, children, height;\n        children = this.model.get_layoutable_children();\n        child_heights = children.map(function (child) {\n            return child._height._value;\n        });\n        if (this.model._horizontal) {\n            height = array_1.max(child_heights);\n        }\n        else {\n            height = array_1.sum(child_heights);\n        }\n        return height;\n    };\n    BoxView.prototype.get_width = function () {\n        var child_widths, children, width;\n        children = this.model.get_layoutable_children();\n        child_widths = children.map(function (child) {\n            return child._width._value;\n        });\n        if (this.model._horizontal) {\n            width = array_1.sum(child_widths);\n        }\n        else {\n            width = array_1.max(child_widths);\n        }\n        return width;\n    };\n    return BoxView;\n})(layout_dom_1.LayoutDOMView);\nexports.Box = (function (superClass) {\n    extend1(Box, superClass);\n    Box.prototype.default_view = exports.BoxView;\n    function Box(attrs, options) {\n        Box.__super__.constructor.call(this, attrs, options);\n        this._child_equal_size_width = new solver_1.Variable();\n        this._child_equal_size_height = new solver_1.Variable();\n        this._box_equal_size_top = new solver_1.Variable();\n        this._box_equal_size_bottom = new solver_1.Variable();\n        this._box_equal_size_left = new solver_1.Variable();\n        this._box_equal_size_right = new solver_1.Variable();\n        this._box_cell_align_top = new solver_1.Variable();\n        this._box_cell_align_bottom = new solver_1.Variable();\n        this._box_cell_align_left = new solver_1.Variable();\n        this._box_cell_align_right = new solver_1.Variable();\n    }\n    Box.define({\n        children: [p.Array, []]\n    });\n    Box.internal({\n        spacing: [p.Number, 6]\n    });\n    Box.prototype.get_layoutable_children = function () {\n        return this.children;\n    };\n    Box.prototype.variables_updated = function () {\n        var child, j, len, ref;\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            child.trigger('change');\n        }\n        return this.trigger('change');\n    };\n    Box.prototype.get_edit_variables = function () {\n        var child, edit_variables, j, len, ref;\n        edit_variables = Box.__super__.get_edit_variables.call(this);\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    Box.prototype.get_constrained_variables = function () {\n        var constrained_variables;\n        constrained_variables = Box.__super__.get_constrained_variables.call(this);\n        constrained_variables = object_1.extend(constrained_variables, {\n            'box-equal-size-top': this._box_equal_size_top,\n            'box-equal-size-bottom': this._box_equal_size_bottom,\n            'box-equal-size-left': this._box_equal_size_left,\n            'box-equal-size-right': this._box_equal_size_right,\n            'box-cell-align-top': this._box_cell_align_top,\n            'box-cell-align-bottom': this._box_cell_align_bottom,\n            'box-cell-align-left': this._box_cell_align_left,\n            'box-cell-align-right': this._box_cell_align_right\n        });\n        return constrained_variables;\n    };\n    Box.prototype.get_constraints = function () {\n        var child, children, constraints, i, j, k, last, len, next, rect, ref, var_keys, vars;\n        constraints = [];\n        children = this.get_layoutable_children();\n        if (children.length === 0) {\n            return constraints;\n        }\n        for (j = 0, len = children.length; j < len; j++) {\n            child = children[j];\n            this._test_layoutable(child);\n            vars = child.get_constrained_variables();\n            var_keys = Object.keys(vars);\n            rect = this._child_rect(vars);\n            if (this._horizontal) {\n                if (this._has_var('height', var_keys)) {\n                    constraints.push(solver_1.EQ(rect.height, [-1, this._height]));\n                }\n            }\n            else {\n                if (this._has_var('width', var_keys)) {\n                    constraints.push(solver_1.EQ(rect.width, [-1, this._width]));\n                }\n            }\n            if (this._horizontal) {\n                if (this._has_var(['box-equal-size-left', 'box-equal-size-right', 'width'], var_keys)) {\n                    constraints.push(solver_1.EQ([-1, vars['box-equal-size-left']], [-1, vars['box-equal-size-right']], vars['width'], this._child_equal_size_width));\n                }\n            }\n            else {\n                if (this._has_var(['box-equal-size-top', 'box-equal-size-bottom', 'height'], var_keys)) {\n                    constraints.push(solver_1.EQ([-1, vars['box-equal-size-top']], [-1, vars['box-equal-size-bottom']], vars['height'], this._child_equal_size_height));\n                }\n            }\n            constraints = constraints.concat(child.get_constraints());\n        }\n        last = this._info(children[0].get_constrained_variables());\n        constraints.push(solver_1.EQ(last.span.start, 0));\n        for (i = k = 1, ref = children.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {\n            next = this._info(children[i].get_constrained_variables());\n            if (last.span.size) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, next.span.start]));\n            }\n            constraints.push(solver_1.WEAK_EQ(last.whitespace.after, next.whitespace.before, 0 - this.spacing));\n            constraints.push(solver_1.GE(last.whitespace.after, next.whitespace.before, 0 - this.spacing));\n            last = next;\n        }\n        if (this._horizontal) {\n            if (this._has_var('width', var_keys)) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, this._width]));\n            }\n        }\n        else {\n            if (this._has_var('height', var_keys)) {\n                constraints.push(solver_1.EQ(last.span.start, last.span.size, [-1, this._height]));\n            }\n        }\n        constraints = constraints.concat(this._align_outer_edges_constraints(true));\n        constraints = constraints.concat(this._align_outer_edges_constraints(false));\n        constraints = constraints.concat(this._align_inner_cell_edges_constraints());\n        constraints = constraints.concat(this._box_equal_size_bounds(true));\n        constraints = constraints.concat(this._box_equal_size_bounds(false));\n        constraints = constraints.concat(this._box_cell_align_bounds(true));\n        constraints = constraints.concat(this._box_cell_align_bounds(false));\n        constraints = constraints.concat(this._box_whitespace(true));\n        constraints = constraints.concat(this._box_whitespace(false));\n        return constraints;\n    };\n    Box.prototype._has_var = function (look_up, var_keys) {\n        var look_up_list;\n        look_up_list = types_1.isString(look_up) ? [look_up] : look_up;\n        return array_1.all(look_up_list, function (x) {\n            return indexOf.call(var_keys, x) >= 0;\n        });\n    };\n    Box.prototype._test_layoutable = function (child) {\n        var j, key, len, required_constrained_variables, vars;\n        required_constrained_variables = ['origin-x', 'origin-y', 'whitespace-top', 'whitespace-right', 'whitespace-bottom', 'whitespace-left'];\n        if (child.get_constrained_variables == null) {\n            throw new Error(child + \" is missing get_constrained_variables method\");\n        }\n        vars = child.get_constrained_variables();\n        for (j = 0, len = required_constrained_variables.length; j < len; j++) {\n            key = required_constrained_variables[j];\n            if (indexOf.call(Object.keys(vars), key) < 0) {\n                throw new Error(child + \" is missing constrained_variable \" + key);\n            }\n            if (!vars[key] instanceof solver_1.Variable) {\n                throw new Error(child + \" \" + key + \" is not a solver Variable\");\n            }\n        }\n        return true;\n    };\n    Box.prototype._child_rect = function (vars) {\n        var height, ref, width, x, y;\n        width = vars['width'];\n        height = vars['height'];\n        ref = [vars['origin-x'], vars['origin-y']], x = ref[0], y = ref[1];\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    };\n    Box.prototype._span = function (rect) {\n        if (this._horizontal) {\n            return {\n                start: rect.x,\n                size: rect.width\n            };\n        }\n        else {\n            return {\n                start: rect.y,\n                size: rect.height\n            };\n        }\n    };\n    Box.prototype._info = function (vars) {\n        var span, whitespace;\n        if (this._horizontal) {\n            whitespace = {\n                before: vars['whitespace-left'],\n                after: vars['whitespace-right']\n            };\n        }\n        else {\n            whitespace = {\n                before: vars['whitespace-top'],\n                after: vars['whitespace-bottom']\n            };\n        }\n        span = this._span(this._child_rect(vars));\n        return {\n            span: span,\n            whitespace: whitespace\n        };\n    };\n    Box.prototype._flatten_cell_edge_variables = function (horizontal) {\n        var add_path, all_vars, arity, cell, cell_vars, child, children, direction, flattened, j, k, key, kind, len, len1, name, new_key, parsed, path, relevant_edges, variables;\n        if (horizontal) {\n            relevant_edges = Box._top_bottom_inner_cell_edge_variables;\n        }\n        else {\n            relevant_edges = Box._left_right_inner_cell_edge_variables;\n        }\n        add_path = horizontal !== this._horizontal;\n        children = this.get_layoutable_children();\n        arity = children.length;\n        flattened = {};\n        cell = 0;\n        for (j = 0, len = children.length; j < len; j++) {\n            child = children[j];\n            if (child instanceof Box) {\n                cell_vars = child._flatten_cell_edge_variables(horizontal);\n            }\n            else {\n                cell_vars = {};\n            }\n            all_vars = child.get_constrained_variables();\n            for (k = 0, len1 = relevant_edges.length; k < len1; k++) {\n                name = relevant_edges[k];\n                if (name in all_vars) {\n                    cell_vars[name] = [all_vars[name]];\n                }\n            }\n            for (key in cell_vars) {\n                variables = cell_vars[key];\n                if (add_path) {\n                    parsed = key.split(\" \");\n                    kind = parsed[0];\n                    if (parsed.length > 1) {\n                        path = parsed[1];\n                    }\n                    else {\n                        path = \"\";\n                    }\n                    if (this._horizontal) {\n                        direction = \"row\";\n                    }\n                    else {\n                        direction = \"col\";\n                    }\n                    new_key = kind + \" \" + direction + \"-\" + arity + \"-\" + cell + \"-\" + path;\n                }\n                else {\n                    new_key = key;\n                }\n                if (new_key in flattened) {\n                    flattened[new_key] = flattened[new_key].concat(variables);\n                }\n                else {\n                    flattened[new_key] = variables;\n                }\n            }\n            cell = cell + 1;\n        }\n        return flattened;\n    };\n    Box.prototype._align_inner_cell_edges_constraints = function () {\n        var constraints, flattened, i, j, key, last, ref, variables;\n        constraints = [];\n        if (this._is_root) {\n            flattened = this._flatten_cell_edge_variables(this._horizontal);\n            for (key in flattened) {\n                variables = flattened[key];\n                if (variables.length > 1) {\n                    last = variables[0];\n                    for (i = j = 1, ref = variables.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n                        constraints.push(solver_1.EQ(variables[i], [-1, last]));\n                    }\n                }\n            }\n        }\n        return constraints;\n    };\n    Box.prototype._find_edge_leaves = function (horizontal) {\n        var child, child_leaves, children, end, j, leaves, len, start;\n        children = this.get_layoutable_children();\n        leaves = [[], []];\n        if (children.length > 0) {\n            if (this._horizontal === horizontal) {\n                start = children[0];\n                end = children[children.length - 1];\n                if (start instanceof Box) {\n                    leaves[0] = leaves[0].concat(start._find_edge_leaves(horizontal)[0]);\n                }\n                else {\n                    leaves[0].push(start);\n                }\n                if (end instanceof Box) {\n                    leaves[1] = leaves[1].concat(end._find_edge_leaves(horizontal)[1]);\n                }\n                else {\n                    leaves[1].push(end);\n                }\n            }\n            else {\n                for (j = 0, len = children.length; j < len; j++) {\n                    child = children[j];\n                    if (child instanceof Box) {\n                        child_leaves = child._find_edge_leaves(horizontal);\n                        leaves[0] = leaves[0].concat(child_leaves[0]);\n                        leaves[1] = leaves[1].concat(child_leaves[1]);\n                    }\n                    else {\n                        leaves[0].push(child);\n                        leaves[1].push(child);\n                    }\n                }\n            }\n        }\n        return leaves;\n    };\n    Box.prototype._align_outer_edges_constraints = function (horizontal) {\n        var add_all_equal, collect_vars, end_edges, end_leaves, end_variable, ref, result, start_edges, start_leaves, start_variable;\n        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];\n        if (horizontal) {\n            start_variable = 'on-edge-align-left';\n            end_variable = 'on-edge-align-right';\n        }\n        else {\n            start_variable = 'on-edge-align-top';\n            end_variable = 'on-edge-align-bottom';\n        }\n        collect_vars = function (leaves, name) {\n            var edges, j, leaf, len, vars;\n            edges = [];\n            for (j = 0, len = leaves.length; j < len; j++) {\n                leaf = leaves[j];\n                vars = leaf.get_constrained_variables();\n                if (name in vars) {\n                    edges.push(vars[name]);\n                }\n            }\n            return edges;\n        };\n        start_edges = collect_vars(start_leaves, start_variable);\n        end_edges = collect_vars(end_leaves, end_variable);\n        result = [];\n        add_all_equal = function (edges) {\n            var edge, first, i, j, ref1;\n            if (edges.length > 1) {\n                first = edges[0];\n                for (i = j = 1, ref1 = edges.length; 1 <= ref1 ? j < ref1 : j > ref1; i = 1 <= ref1 ? ++j : --j) {\n                    edge = edges[i];\n                    result.push(solver_1.EQ([-1, first], edge));\n                }\n                return null;\n            }\n        };\n        add_all_equal(start_edges);\n        add_all_equal(end_edges);\n        return result;\n    };\n    Box.prototype._box_insets_from_child_insets = function (horizontal, child_variable_prefix, our_variable_prefix, minimum) {\n        var add_constraints, end_leaves, end_variable, our_end, our_start, ref, result, start_leaves, start_variable;\n        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];\n        if (horizontal) {\n            start_variable = child_variable_prefix + \"-left\";\n            end_variable = child_variable_prefix + \"-right\";\n            our_start = this[our_variable_prefix + \"_left\"];\n            our_end = this[our_variable_prefix + \"_right\"];\n        }\n        else {\n            start_variable = child_variable_prefix + \"-top\";\n            end_variable = child_variable_prefix + \"-bottom\";\n            our_start = this[our_variable_prefix + \"_top\"];\n            our_end = this[our_variable_prefix + \"_bottom\"];\n        }\n        result = [];\n        add_constraints = function (ours, leaves, name) {\n            var edges, j, leaf, len, vars;\n            edges = [];\n            for (j = 0, len = leaves.length; j < len; j++) {\n                leaf = leaves[j];\n                vars = leaf.get_constrained_variables();\n                if (name in vars) {\n                    if (minimum) {\n                        result.push(solver_1.GE([-1, ours], vars[name]));\n                    }\n                    else {\n                        result.push(solver_1.EQ([-1, ours], vars[name]));\n                    }\n                }\n            }\n            return null;\n        };\n        add_constraints(our_start, start_leaves, start_variable);\n        add_constraints(our_end, end_leaves, end_variable);\n        return result;\n    };\n    Box.prototype._box_equal_size_bounds = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'box-equal-size', '_box_equal_size', false);\n    };\n    Box.prototype._box_cell_align_bounds = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'box-cell-align', '_box_cell_align', false);\n    };\n    Box.prototype._box_whitespace = function (horizontal) {\n        return this._box_insets_from_child_insets(horizontal, 'whitespace', '_whitespace', true);\n    };\n    Box._left_right_inner_cell_edge_variables = ['box-cell-align-left', 'box-cell-align-right'];\n    Box._top_bottom_inner_cell_edge_variables = ['box-cell-align-top', 'box-cell-align-bottom'];\n    return Box;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar box_1 = require(\"./box\");\nexports.ColumnView = (function (superClass) {\n    extend(ColumnView, superClass);\n    function ColumnView() {\n        return ColumnView.__super__.constructor.apply(this, arguments);\n    }\n    ColumnView.prototype.className = \"bk-grid-column\";\n    return ColumnView;\n})(box_1.BoxView);\nexports.Column = (function (superClass) {\n    extend(Column, superClass);\n    Column.prototype.type = 'Column';\n    Column.prototype.default_view = exports.ColumnView;\n    function Column(attrs, options) {\n        Column.__super__.constructor.call(this, attrs, options);\n        this._horizontal = false;\n    }\n    return Column;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar box_1 = require(\"./box\");\nexports.Box = box_1.Box;\nvar column_1 = require(\"./column\");\nexports.Column = column_1.Column;\nvar layout_dom_1 = require(\"./layout_dom\");\nexports.LayoutDOM = layout_dom_1.LayoutDOM;\nvar row_1 = require(\"./row\");\nexports.Row = row_1.Row;\nvar spacer_1 = require(\"./spacer\");\nexports.Spacer = spacer_1.Spacer;\nvar widget_box_1 = require(\"./widget_box\");\nexports.WidgetBox = widget_box_1.WidgetBox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar solver_1 = require(\"core/layout/solver\");\nvar build_views_1 = require(\"core/build_views\");\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar logging_1 = require(\"core/logging\");\nvar object_1 = require(\"core/util/object\");\nexports.LayoutDOMView = (function (superClass) {\n    extend1(LayoutDOMView, superClass);\n    function LayoutDOMView() {\n        return LayoutDOMView.__super__.constructor.apply(this, arguments);\n    }\n    LayoutDOMView.prototype.initialize = function (options) {\n        var cls, i, len, ref;\n        LayoutDOMView.__super__.initialize.call(this, options);\n        this.el.setAttribute(\"id\", \"modelid_\" + this.model.id);\n        this.el.classList.add(\"bk-layout-\" + this.model.sizing_mode);\n        if (this.model.css_classes != null) {\n            ref = this.model.css_classes;\n            for (i = 0, len = ref.length; i < len; i++) {\n                cls = ref[i];\n                this.el.classList.add(cls);\n            }\n        }\n        this.child_views = {};\n        return this.build_child_views(false);\n    };\n    LayoutDOMView.prototype.build_child_views = function (init_solver) {\n        var child, child_view, children, i, len;\n        if (init_solver == null) {\n            init_solver = true;\n        }\n        this.unbind_bokeh_events();\n        if (init_solver) {\n            this.model.document._invalidate_all_models();\n            this.model.document._init_solver();\n        }\n        children = this.model.get_layoutable_children();\n        this.child_views = {};\n        build_views_1.build_views(this.child_views, children);\n        dom_1.empty(this.el);\n        for (i = 0, len = children.length; i < len; i++) {\n            child = children[i];\n            child_view = this.child_views[child.id];\n            this.el.appendChild(child_view.el);\n        }\n        return this.bind_bokeh_events();\n    };\n    LayoutDOMView.prototype.unbind_bokeh_events = function () {\n        var id, ref, results, view;\n        this.stopListening();\n        ref = this.child_views;\n        results = [];\n        for (id in ref) {\n            view = ref[id];\n            view.stopListening();\n            results.push(typeof view.unbind_bokeh_events === \"function\" ? view.unbind_bokeh_events() : void 0);\n        }\n        return results;\n    };\n    LayoutDOMView.prototype.bind_bokeh_events = function () {\n        var sizing_mode_msg;\n        this.listenTo(this.model, 'change', this.render);\n        if (this.model.sizing_mode === 'fixed') {\n            this.listenToOnce(this.model.document.solver(), 'resize', (function (_this) {\n                return function () {\n                    return _this.render();\n                };\n            })(this));\n        }\n        else {\n            this.listenTo(this.model.document.solver(), 'resize', (function (_this) {\n                return function () {\n                    return _this.render();\n                };\n            })(this));\n        }\n        sizing_mode_msg = \"Changing sizing_mode after initialization is not currently supported.\";\n        return this.listenTo(this.model, 'change:sizing_mode', function () {\n            return logging_1.logger.warn(sizing_mode_msg);\n        });\n    };\n    LayoutDOMView.prototype.render = function () {\n        var height, s, width;\n        s = this.model.document.solver();\n        if (this.model.sizing_mode === 'fixed') {\n            if (this.model.width != null) {\n                width = this.model.width;\n            }\n            else {\n                width = this.get_width();\n                this.model.width = width;\n            }\n            if (this.model.height != null) {\n                height = this.model.height;\n            }\n            else {\n                height = this.get_height();\n                this.model.height = height;\n            }\n            s.suggest_value(this.model._width, width);\n            s.suggest_value(this.model._height, height);\n            s.update_variables();\n            this.el.style.width = width + \"px\";\n            this.el.style.height = height + \"px\";\n        }\n        if (this.model.sizing_mode === 'scale_width') {\n            height = this.get_height();\n            s.suggest_value(this.model._height, height);\n            s.update_variables();\n            this.el.style.width = this.model._width._value + \"px\";\n            this.el.style.height = this.model._height._value + \"px\";\n        }\n        if (this.model.sizing_mode === 'scale_height') {\n            width = this.get_width();\n            s.suggest_value(this.model._width, width);\n            s.update_variables();\n            this.el.style.width = this.model._width._value + \"px\";\n            this.el.style.height = this.model._height._value + \"px\";\n        }\n        if (this.model.sizing_mode === 'stretch_both') {\n            this.el.style.position = 'absolute';\n            this.el.style.left = this.model._dom_left._value + \"px\";\n            this.el.style.top = this.model._dom_top._value + \"px\";\n            this.el.style.width = this.model._width._value + \"px\";\n            return this.el.style.height = this.model._height._value + \"px\";\n        }\n    };\n    LayoutDOMView.prototype.get_height = function () {\n        return null;\n    };\n    LayoutDOMView.prototype.get_width = function () {\n        return null;\n    };\n    return LayoutDOMView;\n})(bokeh_view_1.BokehView);\nexports.LayoutDOM = (function (superClass) {\n    extend1(LayoutDOM, superClass);\n    function LayoutDOM() {\n        return LayoutDOM.__super__.constructor.apply(this, arguments);\n    }\n    LayoutDOM.prototype.type = \"LayoutDOM\";\n    LayoutDOM.prototype.initialize = function (attrs, options) {\n        LayoutDOM.__super__.initialize.call(this, attrs, options);\n        this._width = new solver_1.Variable(\"_width \" + this.id);\n        this._height = new solver_1.Variable(\"_height \" + this.id);\n        this._left = new solver_1.Variable(\"_left \" + this.id);\n        this._right = new solver_1.Variable(\"_right \" + this.id);\n        this._top = new solver_1.Variable(\"_top \" + this.id);\n        this._bottom = new solver_1.Variable(\"_bottom \" + this.id);\n        this._dom_top = new solver_1.Variable(\"_dom_top \" + this.id);\n        this._dom_left = new solver_1.Variable(\"_dom_left \" + this.id);\n        this._width_minus_right = new solver_1.Variable(\"_width_minus_right \" + this.id);\n        this._height_minus_bottom = new solver_1.Variable(\"_height_minus_bottom \" + this.id);\n        this._whitespace_top = new solver_1.Variable();\n        this._whitespace_bottom = new solver_1.Variable();\n        this._whitespace_left = new solver_1.Variable();\n        return this._whitespace_right = new solver_1.Variable();\n    };\n    LayoutDOM.prototype.get_constraints = function () {\n        var constraints;\n        constraints = [];\n        constraints.push(solver_1.GE(this._dom_left));\n        constraints.push(solver_1.GE(this._dom_top));\n        constraints.push(solver_1.GE(this._left));\n        constraints.push(solver_1.GE(this._width, [-1, this._right]));\n        constraints.push(solver_1.GE(this._top));\n        constraints.push(solver_1.GE(this._height, [-1, this._bottom]));\n        constraints.push(solver_1.EQ(this._width_minus_right, [-1, this._width], this._right));\n        constraints.push(solver_1.EQ(this._height_minus_bottom, [-1, this._height], this._bottom));\n        return constraints;\n    };\n    LayoutDOM.prototype.get_layoutable_children = function () {\n        return [];\n    };\n    LayoutDOM.prototype.get_edit_variables = function () {\n        var edit_variables;\n        edit_variables = [];\n        if (this.sizing_mode === 'fixed') {\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n        }\n        if (this.sizing_mode === 'scale_width') {\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n        }\n        if (this.sizing_mode === 'scale_height') {\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n        }\n        return edit_variables;\n    };\n    LayoutDOM.prototype.get_constrained_variables = function () {\n        var constrained_variables;\n        constrained_variables = {\n            'origin-x': this._dom_left,\n            'origin-y': this._dom_top,\n            'whitespace-top': this._whitespace_top,\n            'whitespace-bottom': this._whitespace_bottom,\n            'whitespace-left': this._whitespace_left,\n            'whitespace-right': this._whitespace_right\n        };\n        if (this.sizing_mode === 'stretch_both') {\n            constrained_variables = object_1.extend(constrained_variables, {\n                'width': this._width,\n                'height': this._height\n            });\n        }\n        if (this.sizing_mode === 'scale_width') {\n            constrained_variables = object_1.extend(constrained_variables, {\n                'width': this._width\n            });\n        }\n        if (this.sizing_mode === 'scale_height') {\n            constrained_variables = object_1.extend(constrained_variables, {\n                'height': this._height\n            });\n        }\n        return constrained_variables;\n    };\n    LayoutDOM.define({\n        height: [p.Number],\n        width: [p.Number],\n        disabled: [p.Bool, false],\n        sizing_mode: [p.SizingMode, \"fixed\"],\n        css_classes: [p.Array]\n    });\n    LayoutDOM.internal({\n        layoutable: [p.Bool, true]\n    });\n    return LayoutDOM;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar box_1 = require(\"./box\");\nexports.RowView = (function (superClass) {\n    extend(RowView, superClass);\n    function RowView() {\n        return RowView.__super__.constructor.apply(this, arguments);\n    }\n    RowView.prototype.className = \"bk-grid-row\";\n    return RowView;\n})(box_1.BoxView);\nexports.Row = (function (superClass) {\n    extend(Row, superClass);\n    Row.prototype.type = 'Row';\n    Row.prototype.default_view = exports.RowView;\n    function Row(attrs, options) {\n        Row.__super__.constructor.call(this, attrs, options);\n        this._horizontal = true;\n    }\n    return Row;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar layout_dom_1 = require(\"./layout_dom\");\nvar object_1 = require(\"core/util/object\");\nexports.SpacerView = (function (superClass) {\n    extend1(SpacerView, superClass);\n    function SpacerView() {\n        return SpacerView.__super__.constructor.apply(this, arguments);\n    }\n    SpacerView.prototype.className = \"bk-spacer-box\";\n    SpacerView.prototype.render = function () {\n        SpacerView.__super__.render.call(this);\n        if (this.sizing_mode === 'fixed') {\n            this.el.style.width = this.model.width + \"px\";\n            return this.el.style.height = this.model.height + \"px\";\n        }\n    };\n    SpacerView.prototype.get_height = function () {\n        return 1;\n    };\n    return SpacerView;\n})(layout_dom_1.LayoutDOMView);\nexports.Spacer = (function (superClass) {\n    extend1(Spacer, superClass);\n    function Spacer() {\n        return Spacer.__super__.constructor.apply(this, arguments);\n    }\n    Spacer.prototype.type = 'Spacer';\n    Spacer.prototype.default_view = exports.SpacerView;\n    Spacer.prototype.get_constrained_variables = function () {\n        var constrained_variables;\n        constrained_variables = Spacer.__super__.get_constrained_variables.call(this);\n        constrained_variables = object_1.extend(constrained_variables, {\n            'on-edge-align-top': this._top,\n            'on-edge-align-bottom': this._height_minus_bottom,\n            'on-edge-align-left': this._left,\n            'on-edge-align-right': this._width_minus_right,\n            'box-cell-align-top': this._top,\n            'box-cell-align-bottom': this._height_minus_bottom,\n            'box-cell-align-left': this._left,\n            'box-cell-align-right': this._width_minus_right,\n            'box-equal-size-top': this._top,\n            'box-equal-size-bottom': this._height_minus_bottom,\n            'box-equal-size-left': this._left,\n            'box-equal-size-right': this._width_minus_right\n        });\n        return constrained_variables;\n    };\n    return Spacer;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nexports.WidgetBoxView = (function (superClass) {\n    extend1(WidgetBoxView, superClass);\n    function WidgetBoxView() {\n        return WidgetBoxView.__super__.constructor.apply(this, arguments);\n    }\n    WidgetBoxView.prototype.className = \"bk-widget-box\";\n    WidgetBoxView.prototype.initialize = function (options) {\n        WidgetBoxView.__super__.initialize.call(this, options);\n        return this.render();\n    };\n    WidgetBoxView.prototype.bind_bokeh_events = function () {\n        WidgetBoxView.__super__.bind_bokeh_events.call(this);\n        return this.listenTo(this.model, 'change:children', (function (_this) {\n            return function () {\n                return _this.build_child_views();\n            };\n        })(this));\n    };\n    WidgetBoxView.prototype.render = function () {\n        var css_width, height, s, width;\n        s = this.model.document.solver();\n        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_height') {\n            width = this.get_width();\n            if (this.model._width._value !== width) {\n                s.suggest_value(this.model._width, width);\n                s.update_variables();\n            }\n        }\n        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_width') {\n            height = this.get_height();\n            if (this.model._height._value !== height) {\n                s.suggest_value(this.model._height, height);\n                s.update_variables();\n            }\n        }\n        if (this.model._width._value - 20 > 0) {\n            css_width = (this.model._width._value - 20) + \"px\";\n        }\n        else {\n            css_width = \"100%\";\n        }\n        if (this.model.sizing_mode === 'stretch_both') {\n            this.el.style.position = 'absolute';\n            this.el.style.left = this.model._dom_left._value + \"px\";\n            this.el.style.top = this.model._dom_top._value + \"px\";\n            this.el.style.width = this.model._width._value + \"px\";\n            return this.el.style.height = this.model._height._value + \"px\";\n        }\n        else {\n            return this.el.style.width = css_width;\n        }\n    };\n    WidgetBoxView.prototype.get_height = function () {\n        var child_view, height, key, ref;\n        height = 0;\n        ref = this.child_views;\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            child_view = ref[key];\n            height += child_view.el.scrollHeight;\n        }\n        return height + 20;\n    };\n    WidgetBoxView.prototype.get_width = function () {\n        var child_view, child_width, key, ref, width;\n        if (this.model.width != null) {\n            return this.model.width;\n        }\n        else {\n            width = this.el.scrollWidth + 20;\n            ref = this.child_views;\n            for (key in ref) {\n                if (!hasProp.call(ref, key))\n                    continue;\n                child_view = ref[key];\n                child_width = child_view.el.scrollWidth;\n                if (child_width > width) {\n                    width = child_width;\n                }\n            }\n            return width;\n        }\n    };\n    return WidgetBoxView;\n})(layout_dom_1.LayoutDOMView);\nexports.WidgetBox = (function (superClass) {\n    extend1(WidgetBox, superClass);\n    function WidgetBox() {\n        return WidgetBox.__super__.constructor.apply(this, arguments);\n    }\n    WidgetBox.prototype.type = 'WidgetBox';\n    WidgetBox.prototype.default_view = exports.WidgetBoxView;\n    WidgetBox.prototype.initialize = function (options) {\n        WidgetBox.__super__.initialize.call(this, options);\n        if (this.sizing_mode === 'fixed' && this.width === null) {\n            this.width = 300;\n            logging_1.logger.info(\"WidgetBox mode is fixed, but no width specified. Using default of 300.\");\n        }\n        if (this.sizing_mode === 'scale_height') {\n            return logging_1.logger.warn(\"sizing_mode `scale_height` is not experimental for WidgetBox. Please report your results to the bokeh dev team so we can improve.\");\n        }\n    };\n    WidgetBox.prototype.get_edit_variables = function () {\n        var child, edit_variables, i, len, ref;\n        edit_variables = WidgetBox.__super__.get_edit_variables.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    WidgetBox.prototype.get_constraints = function () {\n        var child, constraints, i, len, ref;\n        constraints = WidgetBox.__super__.get_constraints.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    WidgetBox.prototype.get_constrained_variables = function () {\n        var constrained_variables;\n        constrained_variables = WidgetBox.__super__.get_constrained_variables.call(this);\n        constrained_variables = object_1.extend(constrained_variables, {\n            'on-edge-align-top': this._top,\n            'on-edge-align-bottom': this._height_minus_bottom,\n            'on-edge-align-left': this._left,\n            'on-edge-align-right': this._width_minus_right,\n            'box-cell-align-top': this._top,\n            'box-cell-align-bottom': this._height_minus_bottom,\n            'box-cell-align-left': this._left,\n            'box-cell-align-right': this._width_minus_right,\n            'box-equal-size-top': this._top,\n            'box-equal-size-bottom': this._height_minus_bottom\n        });\n        if (this.sizing_mode !== 'fixed') {\n            constrained_variables = object_1.extend(constrained_variables, {\n                'box-equal-size-left': this._left,\n                'box-equal-size-right': this._width_minus_right\n            });\n        }\n        return constrained_variables;\n    };\n    WidgetBox.prototype.get_layoutable_children = function () {\n        return this.children;\n    };\n    WidgetBox.define({\n        'children': [p.Array, []]\n    });\n    return WidgetBox;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.CategoricalColorMapper = (function (superClass) {\n    extend(CategoricalColorMapper, superClass);\n    function CategoricalColorMapper() {\n        return CategoricalColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalColorMapper.prototype.type = \"CategoricalColorMapper\";\n    CategoricalColorMapper.define({\n        factors: [p.Array]\n    });\n    CategoricalColorMapper.prototype._get_values = function (data, palette) {\n        var color, d, i, key, len, values;\n        values = [];\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            key = this.factors.indexOf(d);\n            if (key < 0 || key >= palette.length) {\n                color = this.nan_color;\n            }\n            else {\n                color = palette[key];\n            }\n            values.push(color);\n        }\n        return values;\n    };\n    return CategoricalColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar linear_mapper_1 = require(\"./linear_mapper\");\nvar types_1 = require(\"core/util/types\");\nexports.CategoricalMapper = (function (superClass) {\n    extend(CategoricalMapper, superClass);\n    function CategoricalMapper() {\n        return CategoricalMapper.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalMapper.prototype.map_to_target = function (x, return_synthetic) {\n        var factor, factors, percent, range, ref, result;\n        if (return_synthetic == null) {\n            return_synthetic = false;\n        }\n        if (types_1.isNumber(x)) {\n            if (return_synthetic) {\n                return x;\n            }\n            else {\n                return CategoricalMapper.__super__.map_to_target.call(this, x);\n            }\n        }\n        range = this.source_range;\n        factors = range.factors;\n        if (x.indexOf(':') >= 0) {\n            ref = x.split(':'), factor = ref[0], percent = ref[1];\n            percent = parseFloat(percent);\n            result = factors.indexOf(factor) + 0.5 + range.offset + percent;\n        }\n        else {\n            result = factors.indexOf(x) + 1 + range.offset;\n        }\n        if (return_synthetic) {\n            return result;\n        }\n        else {\n            return CategoricalMapper.__super__.map_to_target.call(this, result);\n        }\n    };\n    CategoricalMapper.prototype.v_map_to_target = function (xs, return_synthetic) {\n        var factor, factors, i, j, percent, range, ref, ref1, results, x;\n        if (return_synthetic == null) {\n            return_synthetic = false;\n        }\n        if (types_1.isNumber(xs[0])) {\n            if (return_synthetic) {\n                return xs;\n            }\n            else {\n                return CategoricalMapper.__super__.v_map_to_target.call(this, xs);\n            }\n        }\n        range = this.source_range;\n        factors = range.factors;\n        results = Array(xs.length);\n        for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x = xs[i];\n            if (x.indexOf(':') >= 0) {\n                ref1 = x.split(':'), factor = ref1[0], percent = ref1[1];\n                percent = parseFloat(percent);\n                results[i] = factors.indexOf(factor) + 0.5 + range.offset + percent;\n            }\n            else {\n                results[i] = factors.indexOf(x) + 1 + range.offset;\n            }\n        }\n        if (return_synthetic) {\n            return results;\n        }\n        else {\n            return CategoricalMapper.__super__.v_map_to_target.call(this, results);\n        }\n    };\n    CategoricalMapper.prototype.map_from_target = function (xprime, skip_cat) {\n        var factors, range;\n        if (skip_cat == null) {\n            skip_cat = false;\n        }\n        xprime = CategoricalMapper.__super__.map_from_target.call(this, xprime);\n        if (skip_cat) {\n            return xprime;\n        }\n        range = this.source_range;\n        factors = range.factors;\n        return factors[Math.floor(xprime - 0.5 - range.offset)];\n    };\n    CategoricalMapper.prototype.v_map_from_target = function (xprimes, skip_cat) {\n        var factors, i, j, k, range, ref, ref1, result, x;\n        if (skip_cat == null) {\n            skip_cat = false;\n        }\n        x = CategoricalMapper.__super__.v_map_from_target.call(this, xprimes);\n        for (i = j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            x[i] = x[i];\n        }\n        if (skip_cat) {\n            return x;\n        }\n        result = Array(x);\n        range = this.source_range;\n        factors = range.factors;\n        for (i = k = 0, ref1 = xprimes.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n            result[i] = factors[Math.floor(x[i] - 0.5 - range.offset)];\n        }\n        return result;\n    };\n    return CategoricalMapper;\n})(linear_mapper_1.LinearMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nvar types_1 = require(\"core/util/types\");\nexports.ColorMapper = (function (superClass) {\n    extend(ColorMapper, superClass);\n    function ColorMapper() {\n        return ColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    ColorMapper.prototype.type = \"ColorMapper\";\n    ColorMapper.define({\n        palette: [p.Any],\n        nan_color: [p.Color, \"gray\"]\n    });\n    ColorMapper.prototype.initialize = function (attrs, options) {\n        ColorMapper.__super__.initialize.call(this, attrs, options);\n        this._little_endian = this._is_little_endian();\n        this._palette = this._build_palette(this.palette);\n        return this.listenTo(this, 'change', function () {\n            return this._palette = this._build_palette(this.palette);\n        });\n    };\n    ColorMapper.prototype.v_map_screen = function (data, image_glyph) {\n        var buf, color, i, j, k, ref, ref1, value, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        values = this._get_values(data, this._palette, image_glyph);\n        buf = new ArrayBuffer(data.length * 4);\n        color = new Uint32Array(buf);\n        if (this._little_endian) {\n            for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                value = values[i];\n                color[i] = (0xff << 24) | ((value & 0xff0000) >> 16) | (value & 0xff00) | ((value & 0xff) << 16);\n            }\n        }\n        else {\n            for (i = k = 0, ref1 = data.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                value = values[i];\n                color[i] = (value << 8) | 0xff;\n            }\n        }\n        return buf;\n    };\n    ColorMapper.prototype.compute = function (x) {\n        return null;\n    };\n    ColorMapper.prototype.v_compute = function (xs) {\n        var values;\n        values = this._get_values(xs, this.palette);\n        return values;\n    };\n    ColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        return [];\n    };\n    ColorMapper.prototype._is_little_endian = function () {\n        var buf, buf32, buf8, little_endian;\n        buf = new ArrayBuffer(4);\n        buf8 = new Uint8Array(buf);\n        buf32 = new Uint32Array(buf);\n        buf32[1] = 0x0a0b0c0d;\n        little_endian = true;\n        if (buf8[4] === 0x0a && buf8[5] === 0x0b && buf8[6] === 0x0c && buf8[7] === 0x0d) {\n            little_endian = false;\n        }\n        return little_endian;\n    };\n    ColorMapper.prototype._build_palette = function (palette) {\n        var _convert, i, j, new_palette, ref;\n        new_palette = new Uint32Array(palette.length);\n        _convert = function (value) {\n            if (types_1.isNumber(value)) {\n                return value;\n            }\n            else {\n                return parseInt(value.slice(1), 16);\n            }\n        };\n        for (i = j = 0, ref = palette.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            new_palette[i] = _convert(palette[i]);\n        }\n        return new_palette;\n    };\n    return ColorMapper;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nexports.GridMapper = (function (superClass) {\n    extend(GridMapper, superClass);\n    function GridMapper() {\n        return GridMapper.__super__.constructor.apply(this, arguments);\n    }\n    GridMapper.prototype.map_to_target = function (x, y) {\n        var xprime, yprime;\n        xprime = this.domain_mapper.map_to_target(x);\n        yprime = this.codomain_mapper.map_to_target(y);\n        return [xprime, yprime];\n    };\n    GridMapper.prototype.v_map_to_target = function (xs, ys) {\n        var xprimes, yprimes;\n        xprimes = this.domain_mapper.v_map_to_target(xs);\n        yprimes = this.codomain_mapper.v_map_to_target(ys);\n        return [xprimes, yprimes];\n    };\n    GridMapper.prototype.map_from_target = function (xprime, yprime) {\n        var x, y;\n        x = this.domain_mapper.map_from_target(xprime);\n        y = this.codomain_mapper.map_from_target(yprime);\n        return [x, y];\n    };\n    GridMapper.prototype.v_map_from_target = function (xprimes, yprimes) {\n        var xs, ys;\n        xs = this.domain_mapper.v_map_from_target(xprimes);\n        ys = this.codomain_mapper.v_map_from_target(yprimes);\n        return [xs, ys];\n    };\n    return GridMapper;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar categorical_color_mapper_1 = require(\"./categorical_color_mapper\");\nexports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;\nvar categorical_mapper_1 = require(\"./categorical_mapper\");\nexports.CategoricalMapper = categorical_mapper_1.CategoricalMapper;\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.ColorMapper = color_mapper_1.ColorMapper;\nvar grid_mapper_1 = require(\"./grid_mapper\");\nexports.GridMapper = grid_mapper_1.GridMapper;\nvar linear_color_mapper_1 = require(\"./linear_color_mapper\");\nexports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;\nvar linear_mapper_1 = require(\"./linear_mapper\");\nexports.LinearMapper = linear_mapper_1.LinearMapper;\nvar log_color_mapper_1 = require(\"./log_color_mapper\");\nexports.LogColorMapper = log_color_mapper_1.LogColorMapper;\nvar log_mapper_1 = require(\"./log_mapper\");\nexports.LogMapper = log_mapper_1.LogMapper;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_1 = require(\"core/util/color\");\nvar array_1 = require(\"core/util/array\");\nvar color_mapper_1 = require(\"./color_mapper\");\nexports.LinearColorMapper = (function (superClass) {\n    extend(LinearColorMapper, superClass);\n    function LinearColorMapper() {\n        return LinearColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    LinearColorMapper.prototype.type = \"LinearColorMapper\";\n    LinearColorMapper.define({\n        high: [p.Number],\n        low: [p.Number],\n        high_color: [p.Color],\n        low_color: [p.Color]\n    });\n    LinearColorMapper.prototype.initialize = function (attrs, options) {\n        LinearColorMapper.__super__.initialize.call(this, attrs, options);\n        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];\n        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;\n        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;\n    };\n    LinearColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        var d, high, high_color, i, key, len, low, low_color, max_key, nan_color, norm_factor, normed_d, normed_interval, ref, ref1, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        low = (ref = this.low) != null ? ref : array_1.min(data);\n        high = (ref1 = this.high) != null ? ref1 : array_1.max(data);\n        max_key = palette.length - 1;\n        values = [];\n        nan_color = image_glyph ? this._nan_color : this.nan_color;\n        low_color = image_glyph ? this._low_color : this.low_color;\n        high_color = image_glyph ? this._high_color : this.high_color;\n        norm_factor = 1 / (high - low);\n        normed_interval = 1 / palette.length;\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            if (isNaN(d)) {\n                values.push(nan_color);\n                continue;\n            }\n            if (d === high) {\n                values.push(palette[max_key]);\n                continue;\n            }\n            normed_d = (d - low) * norm_factor;\n            key = Math.floor(normed_d / normed_interval);\n            if (key < 0) {\n                if (this.low_color != null) {\n                    values.push(low_color);\n                }\n                else {\n                    values.push(palette[0]);\n                }\n            }\n            else if (key > max_key) {\n                if (this.high_color != null) {\n                    values.push(high_color);\n                }\n                else {\n                    values.push(palette[max_key]);\n                }\n            }\n            else {\n                values.push(palette[key]);\n            }\n        }\n        return values;\n    };\n    return LinearColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.LinearMapper = (function (superClass) {\n    extend(LinearMapper, superClass);\n    function LinearMapper() {\n        return LinearMapper.__super__.constructor.apply(this, arguments);\n    }\n    LinearMapper.prototype.initialize = function (attrs, options) {\n        LinearMapper.__super__.initialize.call(this, attrs, options);\n        this.define_computed_property('mapper_state', this._mapper_state, true);\n        this.add_dependencies('mapper_state', this, ['source_range', 'target_range']);\n        this.add_dependencies('mapper_state', this.source_range, ['start', 'end']);\n        return this.add_dependencies('mapper_state', this.target_range, ['start', 'end']);\n    };\n    LinearMapper.getters({\n        mapper_state: function () {\n            return this._get_computed('mapper_state');\n        }\n    });\n    LinearMapper.prototype.map_to_target = function (x) {\n        var offset, ref, scale;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1];\n        return scale * x + offset;\n    };\n    LinearMapper.prototype.v_map_to_target = function (xs) {\n        var i, idx, len, offset, ref, result, scale, x;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1];\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = scale * x + offset;\n        }\n        return result;\n    };\n    LinearMapper.prototype.map_from_target = function (xprime) {\n        var offset, ref, scale;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1];\n        return (xprime - offset) / scale;\n    };\n    LinearMapper.prototype.v_map_from_target = function (xprimes) {\n        var i, idx, len, offset, ref, result, scale, xprime;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1];\n        result = new Float64Array(xprimes.length);\n        for (idx = i = 0, len = xprimes.length; i < len; idx = ++i) {\n            xprime = xprimes[idx];\n            result[idx] = (xprime - offset) / scale;\n        }\n        return result;\n    };\n    LinearMapper.prototype._mapper_state = function () {\n        var offset, scale, source_end, source_start, target_end, target_start;\n        source_start = this.source_range.start;\n        source_end = this.source_range.end;\n        target_start = this.target_range.start;\n        target_end = this.target_range.end;\n        scale = (target_end - target_start) / (source_end - source_start);\n        offset = -(scale * source_start) + target_start;\n        return [scale, offset];\n    };\n    LinearMapper.internal({\n        source_range: [p.Any],\n        target_range: [p.Any]\n    });\n    return LinearMapper;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log1p, ref, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar color_1 = require(\"core/util/color\");\nvar array_1 = require(\"core/util/array\");\nvar color_mapper_1 = require(\"./color_mapper\");\nlog1p = (ref = Math.log1p) != null ? ref : function (x) {\n    return Math.log(1 + x);\n};\nexports.LogColorMapper = (function (superClass) {\n    extend(LogColorMapper, superClass);\n    function LogColorMapper() {\n        return LogColorMapper.__super__.constructor.apply(this, arguments);\n    }\n    LogColorMapper.prototype.type = \"LogColorMapper\";\n    LogColorMapper.define({\n        high: [p.Number],\n        low: [p.Number],\n        high_color: [p.Color],\n        low_color: [p.Color]\n    });\n    LogColorMapper.prototype.initialize = function (attrs, options) {\n        LogColorMapper.__super__.initialize.call(this, attrs, options);\n        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];\n        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;\n        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;\n    };\n    LogColorMapper.prototype._get_values = function (data, palette, image_glyph) {\n        var d, high, high_color, i, key, len, log, low, low_color, max_key, n, nan_color, ref1, ref2, scale, values;\n        if (image_glyph == null) {\n            image_glyph = false;\n        }\n        n = palette.length;\n        low = (ref1 = this.low) != null ? ref1 : array_1.min(data);\n        high = (ref2 = this.high) != null ? ref2 : array_1.max(data);\n        scale = n / (log1p(high) - log1p(low));\n        max_key = palette.length - 1;\n        values = [];\n        nan_color = image_glyph ? this._nan_color : this.nan_color;\n        high_color = image_glyph ? this._high_color : this.high_color;\n        low_color = image_glyph ? this._low_color : this.low_color;\n        for (i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n            if (isNaN(d)) {\n                values.push(nan_color);\n                continue;\n            }\n            if (d > high) {\n                if (this.high_color != null) {\n                    values.push(high_color);\n                }\n                else {\n                    values.push(palette[max_key]);\n                }\n                continue;\n            }\n            if (d === high) {\n                values.push(palette[max_key]);\n                continue;\n            }\n            if (d < low) {\n                if (this.low_color != null) {\n                    values.push(low_color);\n                }\n                else {\n                    values.push(palette[0]);\n                }\n                continue;\n            }\n            log = log1p(d) - log1p(low);\n            key = Math.floor(log * scale);\n            if (key > max_key) {\n                key = max_key;\n            }\n            values.push(palette[key]);\n        }\n        return values;\n    };\n    return LogColorMapper;\n})(color_mapper_1.ColorMapper);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.LogMapper = (function (superClass) {\n    extend(LogMapper, superClass);\n    function LogMapper() {\n        return LogMapper.__super__.constructor.apply(this, arguments);\n    }\n    LogMapper.prototype.initialize = function (attrs, options) {\n        LogMapper.__super__.initialize.call(this, attrs, options);\n        this.define_computed_property('mapper_state', this._mapper_state, true);\n        this.add_dependencies('mapper_state', this, ['source_range', 'target_range']);\n        this.add_dependencies('mapper_state', this.source_range, ['start', 'end']);\n        return this.add_dependencies('mapper_state', this.target_range, ['start', 'end']);\n    };\n    LogMapper.getters({\n        mapper_state: function () {\n            return this._get_computed('mapper_state');\n        }\n    });\n    LogMapper.prototype.map_to_target = function (x) {\n        var inter_offset, inter_scale, offset, ref, scale, value;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1], inter_scale = ref[2], inter_offset = ref[3];\n        if (inter_scale === 0) {\n            value = 0;\n        }\n        else {\n            value = (Math.log(x) - inter_offset) / inter_scale;\n            if (isNaN(value) || !isFinite(value)) {\n                value = 0;\n            }\n        }\n        return value * scale + offset;\n    };\n    LogMapper.prototype.v_map_to_target = function (xs) {\n        var i, inter_offset, inter_scale, j, k, l, offset, ref, ref1, ref2, ref3, result, scale, value;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1], inter_scale = ref[2], inter_offset = ref[3];\n        result = new Float64Array(xs.length);\n        if (inter_scale === 0) {\n            for (i = j = 0, ref1 = xs.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n                result[i] = 0;\n            }\n        }\n        else {\n            for (i = k = 0, ref2 = xs.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n                value = (Math.log(xs[i]) - inter_offset) / inter_scale;\n                if (isNaN(value) || !isFinite(value)) {\n                    result[i] = 0;\n                }\n                else {\n                    result[i] = value;\n                }\n            }\n        }\n        for (i = l = 0, ref3 = xs.length; 0 <= ref3 ? l < ref3 : l > ref3; i = 0 <= ref3 ? ++l : --l) {\n            result[i] = result[i] * scale + offset;\n        }\n        return result;\n    };\n    LogMapper.prototype.map_from_target = function (xprime) {\n        var inter_offset, inter_scale, offset, ref, scale, value;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1], inter_scale = ref[2], inter_offset = ref[3];\n        value = (xprime - offset) / scale;\n        return Math.exp(inter_scale * value + inter_offset);\n    };\n    LogMapper.prototype.v_map_from_target = function (xprimes) {\n        var i, inter_offset, inter_scale, j, offset, ref, ref1, result, scale, value;\n        ref = this.mapper_state, scale = ref[0], offset = ref[1], inter_scale = ref[2], inter_offset = ref[3];\n        result = new Float64Array(xprimes.length);\n        for (i = j = 0, ref1 = xprimes.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {\n            value = (xprimes[i] - offset) / scale;\n            result[i] = Math.exp(inter_scale * value + inter_offset);\n        }\n        return result;\n    };\n    LogMapper.prototype._get_safe_scale = function (orig_start, orig_end) {\n        var end, log_val, ref, start;\n        if (orig_start < 0) {\n            start = 0;\n        }\n        else {\n            start = orig_start;\n        }\n        if (orig_end < 0) {\n            end = 0;\n        }\n        else {\n            end = orig_end;\n        }\n        if (start === end) {\n            if (start === 0) {\n                ref = [1, 10], start = ref[0], end = ref[1];\n            }\n            else {\n                log_val = Math.log(start) / Math.log(10);\n                start = Math.pow(10, Math.floor(log_val));\n                if (Math.ceil(log_val) !== Math.floor(log_val)) {\n                    end = Math.pow(10, Math.ceil(log_val));\n                }\n                else {\n                    end = Math.pow(10, Math.ceil(log_val) + 1);\n                }\n            }\n        }\n        return [start, end];\n    };\n    LogMapper.prototype._mapper_state = function () {\n        var end, inter_offset, inter_scale, offset, ref, scale, screen_range, source_end, source_start, start, target_end, target_start;\n        source_start = this.source_range.start;\n        source_end = this.source_range.end;\n        target_start = this.target_range.start;\n        target_end = this.target_range.end;\n        screen_range = target_end - target_start;\n        ref = this._get_safe_scale(source_start, source_end), start = ref[0], end = ref[1];\n        if (start === 0) {\n            inter_scale = Math.log(end);\n            inter_offset = 0;\n        }\n        else {\n            inter_scale = Math.log(end) - Math.log(start);\n            inter_offset = Math.log(start);\n        }\n        scale = screen_range;\n        offset = target_start;\n        return [scale, offset, inter_scale, inter_offset];\n    };\n    LogMapper.internal({\n        source_range: [p.Any],\n        target_range: [p.Any]\n    });\n    return LogMapper;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SQ3, _mk_model, _one_cross, _one_diamond, _one_tri, _one_x, asterisk, circle_cross, circle_x, cross, diamond, diamond_cross, inverted_triangle, square, square_cross, square_x, triangle, x, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar marker_1 = require(\"./marker\");\nSQ3 = Math.sqrt(3);\n_one_x = function (ctx, r) {\n    ctx.moveTo(-r, r);\n    ctx.lineTo(r, -r);\n    ctx.moveTo(-r, -r);\n    return ctx.lineTo(r, r);\n};\n_one_cross = function (ctx, r) {\n    ctx.moveTo(0, r);\n    ctx.lineTo(0, -r);\n    ctx.moveTo(-r, 0);\n    return ctx.lineTo(r, 0);\n};\n_one_diamond = function (ctx, r) {\n    ctx.moveTo(0, r);\n    ctx.lineTo(r / 1.5, 0);\n    ctx.lineTo(0, -r);\n    ctx.lineTo(-r / 1.5, 0);\n    return ctx.closePath();\n};\n_one_tri = function (ctx, r) {\n    var a, h;\n    h = r * SQ3;\n    a = h / 3;\n    ctx.moveTo(-r, a);\n    ctx.lineTo(r, a);\n    ctx.lineTo(0, a - h);\n    return ctx.closePath();\n};\nasterisk = function (ctx, i, sx, sy, r, line, fill) {\n    var r2;\n    r2 = r * 0.65;\n    _one_cross(ctx, r);\n    _one_x(ctx, r2);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ncircle_cross = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\ncircle_x = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_x(ctx, r);\n        ctx.stroke();\n    }\n};\ncross = function (ctx, i, sx, sy, r, line, fill) {\n    _one_cross(ctx, r);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ndiamond = function (ctx, i, sx, sy, r, line, fill) {\n    _one_diamond(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\ndiamond_cross = function (ctx, i, sx, sy, r, line, fill) {\n    _one_diamond(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\ninverted_triangle = function (ctx, i, sx, sy, r, line, fill) {\n    ctx.rotate(Math.PI);\n    _one_tri(ctx, r);\n    ctx.rotate(-Math.PI);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nsquare = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nsquare_cross = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_cross(ctx, r);\n        ctx.stroke();\n    }\n};\nsquare_x = function (ctx, i, sx, sy, r, line, fill) {\n    var size;\n    size = 2 * r;\n    ctx.rect(-r, -r, size, size);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        _one_x(ctx, r);\n        ctx.stroke();\n    }\n};\ntriangle = function (ctx, i, sx, sy, r, line, fill) {\n    _one_tri(ctx, r);\n    if (fill.doit) {\n        fill.set_vectorize(ctx, i);\n        ctx.fill();\n    }\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\nx = function (ctx, i, sx, sy, r, line, fill) {\n    _one_x(ctx, r);\n    if (line.doit) {\n        line.set_vectorize(ctx, i);\n        ctx.stroke();\n    }\n};\n_mk_model = function (type, f) {\n    var model, view;\n    view = (function (superClass) {\n        extend(view, superClass);\n        function view() {\n            return view.__super__.constructor.apply(this, arguments);\n        }\n        view.prototype._render_one = f;\n        return view;\n    })(marker_1.MarkerView);\n    model = (function (superClass) {\n        extend(model, superClass);\n        function model() {\n            return model.__super__.constructor.apply(this, arguments);\n        }\n        model.prototype.default_view = view;\n        model.prototype.type = type;\n        return model;\n    })(marker_1.Marker);\n    return model;\n};\nexports.Asterisk = _mk_model('Asterisk', asterisk);\nexports.CircleCross = _mk_model('CircleCross', circle_cross);\nexports.CircleX = _mk_model('CircleX', circle_x);\nexports.Cross = _mk_model('Cross', cross);\nexports.Diamond = _mk_model('Diamond', diamond);\nexports.DiamondCross = _mk_model('DiamondCross', diamond_cross);\nexports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle);\nexports.Square = _mk_model('Square', square);\nexports.SquareCross = _mk_model('SquareCross', square_cross);\nexports.SquareX = _mk_model('SquareX', square_x);\nexports.Triangle = _mk_model('Triangle', triangle);\nexports.X = _mk_model('X', x);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar xy_glyph_1 = require(\"../glyphs/xy_glyph\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nexports.MarkerView = (function (superClass) {\n    extend(MarkerView, superClass);\n    function MarkerView() {\n        return MarkerView.__super__.constructor.apply(this, arguments);\n    }\n    MarkerView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {\n        var angle, data, indices, size, sx, sy;\n        indices = [index];\n        sx = {};\n        sx[index] = (x0 + x1) / 2;\n        sy = {};\n        sy[index] = (y0 + y1) / 2;\n        size = {};\n        size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n        angle = {};\n        angle[index] = this._angle[index];\n        data = {\n            sx: sx,\n            sy: sy,\n            _size: size,\n            _angle: angle\n        };\n        return this._render(ctx, indices, data);\n    };\n    MarkerView.prototype._render = function (ctx, indices, arg) {\n        var _angle, _size, i, j, len, r, results, sx, sy;\n        sx = arg.sx, sy = arg.sy, _size = arg._size, _angle = arg._angle;\n        results = [];\n        for (j = 0, len = indices.length; j < len; j++) {\n            i = indices[j];\n            if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i])) {\n                continue;\n            }\n            r = _size[i] / 2;\n            ctx.beginPath();\n            ctx.translate(sx[i], sy[i]);\n            if (_angle[i]) {\n                ctx.rotate(_angle[i]);\n            }\n            this._render_one(ctx, i, sx[i], sy[i], r, this.visuals.line, this.visuals.fill);\n            if (_angle[i]) {\n                ctx.rotate(-_angle[i]);\n            }\n            results.push(ctx.translate(-sx[i], -sy[i]));\n        }\n        return results;\n    };\n    MarkerView.prototype._mask_data = function (all_indices) {\n        var bbox, hr, ref, ref1, vr, vx0, vx1, vy0, vy1, x0, x1, y0, y1;\n        hr = this.renderer.plot_view.frame.h_range;\n        vx0 = hr.start - this.max_size;\n        vx1 = hr.end + this.max_size;\n        ref = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref[0], x1 = ref[1];\n        vr = this.renderer.plot_view.frame.v_range;\n        vy0 = vr.start - this.max_size;\n        vy1 = vr.end + this.max_size;\n        ref1 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        return this.index.indices(bbox);\n    };\n    MarkerView.prototype._hit_point = function (geometry) {\n        var bbox, candidates, dist, hits, i, j, len, ref, ref1, ref2, s2, sx, sy, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);\n        vx0 = vx - this.max_size;\n        vx1 = vx + this.max_size;\n        ref1 = this.renderer.xmapper.v_map_from_target([vx0, vx1], true), x0 = ref1[0], x1 = ref1[1];\n        vy0 = vy - this.max_size;\n        vy1 = vy + this.max_size;\n        ref2 = this.renderer.ymapper.v_map_from_target([vy0, vy1], true), y0 = ref2[0], y1 = ref2[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        candidates = this.index.indices(bbox);\n        hits = [];\n        for (j = 0, len = candidates.length; j < len; j++) {\n            i = candidates[j];\n            s2 = this._size[i] / 2;\n            dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);\n            if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\n                hits.push([i, dist]);\n            }\n        }\n        return hittest.create_1d_hit_test_result(hits);\n    };\n    MarkerView.prototype._hit_rect = function (geometry) {\n        var bbox, ref, ref1, result, x0, x1, y0, y1;\n        ref = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1], true), x0 = ref[0], x1 = ref[1];\n        ref1 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1], true), y0 = ref1[0], y1 = ref1[1];\n        bbox = hittest.validate_bbox_coords([x0, x1], [y0, y1]);\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = this.index.indices(bbox);\n        return result;\n    };\n    MarkerView.prototype._hit_poly = function (geometry) {\n        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;\n        ref = [geometry.vx, geometry.vy], vx = ref[0], vy = ref[1];\n        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);\n        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);\n        candidates = (function () {\n            results = [];\n            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        hits = [];\n        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {\n            idx = candidates[i];\n            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                hits.push(idx);\n            }\n        }\n        result = hittest.create_hit_test_result();\n        result['1d'].indices = hits;\n        return result;\n    };\n    return MarkerView;\n})(xy_glyph_1.XYGlyphView);\nexports.Marker = (function (superClass) {\n    extend(Marker, superClass);\n    function Marker() {\n        return Marker.__super__.constructor.apply(this, arguments);\n    }\n    Marker.mixins(['line', 'fill']);\n    Marker.define({\n        size: [\n            p.DistanceSpec, {\n                units: \"screen\",\n                value: 4\n            }\n        ],\n        angle: [p.AngleSpec, 0]\n    });\n    return Marker;\n})(xy_glyph_1.XYGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"core/logging\");\nvar gmap_plot_canvas_1 = require(\"./gmap_plot_canvas\");\nvar plot_1 = require(\"./plot\");\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.MapOptions = (function (superClass) {\n    extend(MapOptions, superClass);\n    function MapOptions() {\n        return MapOptions.__super__.constructor.apply(this, arguments);\n    }\n    MapOptions.prototype.type = 'MapOptions';\n    MapOptions.define({\n        lat: [p.Number],\n        lng: [p.Number],\n        zoom: [p.Number, 12]\n    });\n    return MapOptions;\n})(model_1.Model);\nexports.GMapOptions = (function (superClass) {\n    extend(GMapOptions, superClass);\n    function GMapOptions() {\n        return GMapOptions.__super__.constructor.apply(this, arguments);\n    }\n    GMapOptions.prototype.type = 'GMapOptions';\n    GMapOptions.define({\n        map_type: [p.String, \"roadmap\"],\n        scale_control: [p.Bool, false],\n        styles: [p.String]\n    });\n    return GMapOptions;\n})(exports.MapOptions);\nexports.GMapPlotView = (function (superClass) {\n    extend(GMapPlotView, superClass);\n    function GMapPlotView() {\n        return GMapPlotView.__super__.constructor.apply(this, arguments);\n    }\n    return GMapPlotView;\n})(plot_1.PlotView);\nexports.GMapPlot = (function (superClass) {\n    extend(GMapPlot, superClass);\n    function GMapPlot() {\n        return GMapPlot.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlot.prototype.type = 'GMapPlot';\n    GMapPlot.prototype.default_view = exports.GMapPlotView;\n    GMapPlot.prototype.initialize = function (options) {\n        GMapPlot.__super__.initialize.call(this, options);\n        if (!this.api_key) {\n            logging_1.logger.error(\"api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.\");\n        }\n        this._plot_canvas = new gmap_plot_canvas_1.GMapPlotCanvas({\n            plot: this\n        });\n        return this.plot_canvas.toolbar = this.toolbar;\n    };\n    GMapPlot.define({\n        map_options: [p.Instance],\n        api_key: [p.String]\n    });\n    return GMapPlot;\n})(plot_1.Plot);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar load_google_api, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar proj4_1 = require(\"core/util/proj4\");\nvar plot_canvas_1 = require(\"./plot_canvas\");\nload_google_api = function (callback, api_key) {\n    var ref, script;\n    if (((ref = window.google) != null ? ref.maps : void 0) == null) {\n        window._bokeh_gmap_callback = function () {\n            return callback();\n        };\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = \"https://maps.googleapis.com/maps/api/js?key=\" + api_key + \"&callback=_bokeh_gmap_callback\";\n        return document.body.appendChild(script);\n    }\n};\nexports.GMapPlotCanvasView = (function (superClass) {\n    extend(GMapPlotCanvasView, superClass);\n    function GMapPlotCanvasView() {\n        this._set_bokeh_ranges = bind(this._set_bokeh_ranges, this);\n        this._get_projected_bounds = bind(this._get_projected_bounds, this);\n        this._get_latlon_bounds = bind(this._get_latlon_bounds, this);\n        return GMapPlotCanvasView.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlotCanvasView.prototype.initialize = function (options) {\n        var mo;\n        GMapPlotCanvasView.__super__.initialize.call(this, options);\n        this.zoom_count = 0;\n        mo = this.model.plot.map_options;\n        this.initial_zoom = mo.zoom;\n        this.initial_lat = mo.lat;\n        this.initial_lng = mo.lng;\n        this.canvas_view.map_div.style.position = \"absolute\";\n        return load_google_api(this.request_render, this.model.plot.api_key);\n    };\n    GMapPlotCanvasView.prototype.update_range = function (range_info) {\n        var mo, new_map_zoom, old_map_zoom, proj_xend, proj_xstart, proj_yend, proj_ystart, ref, zoom_change;\n        if (range_info == null) {\n            mo = this.model.plot.map_options;\n            this.map.setCenter({\n                lat: this.initial_lat,\n                lng: this.initial_lng\n            });\n            this.map.setOptions({\n                zoom: this.initial_zoom\n            });\n            GMapPlotCanvasView.__super__.update_range.call(this, null);\n        }\n        else if ((range_info.sdx != null) || (range_info.sdy != null)) {\n            this.map.panBy(range_info.sdx, range_info.sdy);\n            GMapPlotCanvasView.__super__.update_range.call(this, range_info);\n        }\n        else if (range_info.factor != null) {\n            this.pause();\n            if (this.zoom_count !== 10) {\n                this.zoom_count += 1;\n                return;\n            }\n            this.zoom_count = 0;\n            GMapPlotCanvasView.__super__.update_range.call(this, range_info);\n            if (range_info.factor < 0) {\n                zoom_change = -1;\n            }\n            else {\n                zoom_change = 1;\n            }\n            old_map_zoom = this.map.getZoom();\n            new_map_zoom = old_map_zoom + zoom_change;\n            if (new_map_zoom >= 2) {\n                this.map.setZoom(new_map_zoom);\n                ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];\n                if ((proj_xend - proj_xstart) < 0) {\n                    this.map.setZoom(old_map_zoom);\n                }\n            }\n            this.unpause();\n        }\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._build_map = function () {\n        var map_options, maps, mo;\n        maps = window.google.maps;\n        this.map_types = {\n            satellite: maps.MapTypeId.SATELLITE,\n            terrain: maps.MapTypeId.TERRAIN,\n            roadmap: maps.MapTypeId.ROADMAP,\n            hybrid: maps.MapTypeId.HYBRID\n        };\n        mo = this.model.plot.map_options;\n        map_options = {\n            center: new maps.LatLng(mo.lat, mo.lng),\n            zoom: mo.zoom,\n            disableDefaultUI: true,\n            mapTypeId: this.map_types[mo.map_type],\n            scaleControl: mo.scale_control\n        };\n        if (mo.styles != null) {\n            map_options.styles = JSON.parse(mo.styles);\n        }\n        this.map = new maps.Map(this.canvas_view.map_div, map_options);\n        maps.event.addListenerOnce(this.map, 'idle', this._set_bokeh_ranges);\n        this.listenTo(this.model.plot, 'change:map_options', (function (_this) {\n            return function () {\n                return _this._update_options();\n            };\n        })(this));\n        this.listenTo(this.model.plot.map_options, 'change:styles', (function (_this) {\n            return function () {\n                return _this._update_styles();\n            };\n        })(this));\n        this.listenTo(this.model.plot.map_options, 'change:lat', (function (_this) {\n            return function () {\n                return _this._update_center('lat');\n            };\n        })(this));\n        this.listenTo(this.model.plot.map_options, 'change:lng', (function (_this) {\n            return function () {\n                return _this._update_center('lng');\n            };\n        })(this));\n        this.listenTo(this.model.plot.map_options, 'change:zoom', (function (_this) {\n            return function () {\n                return _this._update_zoom();\n            };\n        })(this));\n        this.listenTo(this.model.plot.map_options, 'change:map_type', (function (_this) {\n            return function () {\n                return _this._update_map_type();\n            };\n        })(this));\n        return this.listenTo(this.model.plot.map_options, 'change:scale_control', (function (_this) {\n            return function () {\n                return _this._update_scale_control();\n            };\n        })(this));\n    };\n    GMapPlotCanvasView.prototype._get_latlon_bounds = function () {\n        var bottom_left, bounds, top_right, xend, xstart, yend, ystart;\n        bounds = this.map.getBounds();\n        top_right = bounds.getNorthEast();\n        bottom_left = bounds.getSouthWest();\n        xstart = bottom_left.lng();\n        xend = top_right.lng();\n        ystart = bottom_left.lat();\n        yend = top_right.lat();\n        return [xstart, xend, ystart, yend];\n    };\n    GMapPlotCanvasView.prototype._get_projected_bounds = function () {\n        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref, ref1, ref2, xend, xstart, yend, ystart;\n        ref = this._get_latlon_bounds(), xstart = ref[0], xend = ref[1], ystart = ref[2], yend = ref[3];\n        ref1 = proj4_1.proj4(proj4_1.mercator, [xstart, ystart]), proj_xstart = ref1[0], proj_ystart = ref1[1];\n        ref2 = proj4_1.proj4(proj4_1.mercator, [xend, yend]), proj_xend = ref2[0], proj_yend = ref2[1];\n        return [proj_xstart, proj_xend, proj_ystart, proj_yend];\n    };\n    GMapPlotCanvasView.prototype._set_bokeh_ranges = function () {\n        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref;\n        ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];\n        this.x_range.setv({\n            start: proj_xstart,\n            end: proj_xend\n        });\n        return this.y_range.setv({\n            start: proj_ystart,\n            end: proj_yend\n        });\n    };\n    GMapPlotCanvasView.prototype._update_center = function (fld) {\n        var c;\n        c = this.map.getCenter().toJSON();\n        c[fld] = this.model.plot.map_options[fld];\n        this.map.setCenter(c);\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._update_map_type = function () {\n        var maps;\n        maps = window.google.maps;\n        return this.map.setOptions({\n            mapTypeId: this.map_types[this.model.plot.map_options.map_type]\n        });\n    };\n    GMapPlotCanvasView.prototype._update_scale_control = function () {\n        var maps;\n        maps = window.google.maps;\n        return this.map.setOptions({\n            scaleControl: this.model.plot.map_options.scale_control\n        });\n    };\n    GMapPlotCanvasView.prototype._update_options = function () {\n        this._update_styles();\n        this._update_center('lat');\n        this._update_center('lng');\n        this._update_zoom();\n        return this._update_map_type();\n    };\n    GMapPlotCanvasView.prototype._update_styles = function () {\n        return this.map.setOptions({\n            styles: JSON.parse(this.model.plot.map_options.styles)\n        });\n    };\n    GMapPlotCanvasView.prototype._update_zoom = function () {\n        this.map.setOptions({\n            zoom: this.model.plot.map_options.zoom\n        });\n        return this._set_bokeh_ranges();\n    };\n    GMapPlotCanvasView.prototype._map_hook = function (ctx, frame_box) {\n        var height, left, top, width;\n        left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];\n        this.canvas_view.map_div.style.top = top + \"px\";\n        this.canvas_view.map_div.style.left = left + \"px\";\n        this.canvas_view.map_div.style.width = width + \"px\";\n        this.canvas_view.map_div.style.height = height + \"px\";\n        if (this.map == null) {\n            return this._build_map();\n        }\n    };\n    GMapPlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {\n        var ih, iw, left, oh, ow, top;\n        ow = this.canvas.width;\n        oh = this.canvas.height;\n        left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];\n        ctx.clearRect(0, 0, ow, oh);\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, oh);\n        ctx.lineTo(ow, oh);\n        ctx.lineTo(ow, 0);\n        ctx.lineTo(0, 0);\n        ctx.moveTo(left, top);\n        ctx.lineTo(left + iw, top);\n        ctx.lineTo(left + iw, top + ih);\n        ctx.lineTo(left, top + ih);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.fillStyle = this.model.plot.border_fill_color;\n        return ctx.fill();\n    };\n    return GMapPlotCanvasView;\n})(plot_canvas_1.PlotCanvasView);\nexports.GMapPlotCanvas = (function (superClass) {\n    extend(GMapPlotCanvas, superClass);\n    function GMapPlotCanvas() {\n        return GMapPlotCanvas.__super__.constructor.apply(this, arguments);\n    }\n    GMapPlotCanvas.prototype.type = 'GMapPlotCanvas';\n    GMapPlotCanvas.prototype.default_view = exports.GMapPlotCanvasView;\n    GMapPlotCanvas.prototype.initialize = function (attrs, options) {\n        this.use_map = true;\n        return GMapPlotCanvas.__super__.initialize.call(this, attrs, options);\n    };\n    return GMapPlotCanvas;\n})(plot_canvas_1.PlotCanvas);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gmap_plot_1 = require(\"./gmap_plot\");\nexports.MapOptions = gmap_plot_1.MapOptions;\nvar gmap_plot_2 = require(\"./gmap_plot\");\nexports.GMapOptions = gmap_plot_2.GMapOptions;\nvar gmap_plot_3 = require(\"./gmap_plot\");\nexports.GMapPlot = gmap_plot_3.GMapPlot;\nvar gmap_plot_canvas_1 = require(\"./gmap_plot_canvas\");\nexports.GMapPlotCanvas = gmap_plot_canvas_1.GMapPlotCanvas;\nvar plot_1 = require(\"./plot\");\nexports.Plot = plot_1.Plot;\nvar plot_canvas_1 = require(\"./plot_canvas\");\nexports.PlotCanvas = plot_canvas_1.PlotCanvas;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar title_1 = require(\"../annotations/title\");\nvar toolbar_1 = require(\"../tools/toolbar\");\nvar tool_events_1 = require(\"../tools/tool_events\");\nvar plot_canvas_1 = require(\"./plot_canvas\");\nvar column_data_source_1 = require(\"../sources/column_data_source\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar bokeh_events_1 = require(\"core/bokeh_events\");\nexports.PlotView = (function (superClass) {\n    extend1(PlotView, superClass);\n    function PlotView() {\n        return PlotView.__super__.constructor.apply(this, arguments);\n    }\n    PlotView.prototype.className = \"bk-plot-layout\";\n    PlotView.prototype.bind_bokeh_events = function () {\n        var title_msg;\n        PlotView.__super__.bind_bokeh_events.call(this);\n        title_msg = \"Title object cannot be replaced. Try changing properties on title to update it after initialization.\";\n        return this.listenTo(this.model, 'change:title', (function (_this) {\n            return function () {\n                return logging_1.logger.warn(title_msg);\n            };\n        })(this));\n    };\n    PlotView.prototype.render = function () {\n        var height, ref, s, width;\n        PlotView.__super__.render.call(this);\n        if (this.model.sizing_mode === 'scale_both') {\n            ref = this.get_width_height(), width = ref[0], height = ref[1];\n            s = this.model.document.solver();\n            s.suggest_value(this.model._width, width);\n            s.suggest_value(this.model._height, height);\n            this.el.style.position = 'absolute';\n            this.el.style.left = this.model._dom_left._value + \"px\";\n            this.el.style.top = this.model._dom_top._value + \"px\";\n            this.el.style.width = (this.model._width.value()) + \"px\";\n            return this.el.style.height = (this.model._height.value()) + \"px\";\n        }\n    };\n    PlotView.prototype.get_width_height = function () {\n        var ar, height, new_height_1, new_height_2, new_width_1, new_width_2, parent_height, parent_width, width;\n        parent_height = this.el.parentNode.clientHeight;\n        parent_width = this.el.parentNode.clientWidth;\n        ar = this.model.get_aspect_ratio();\n        new_width_1 = parent_width;\n        new_height_1 = parent_width / ar;\n        new_width_2 = parent_height * ar;\n        new_height_2 = parent_height;\n        if (new_width_1 < new_width_2) {\n            width = new_width_1;\n            height = new_height_1;\n        }\n        else {\n            width = new_width_2;\n            height = new_height_2;\n        }\n        return [width, height];\n    };\n    PlotView.prototype.get_height = function () {\n        return this.model._width._value / this.model.get_aspect_ratio();\n    };\n    PlotView.prototype.get_width = function () {\n        return this.model._height._value * this.model.get_aspect_ratio();\n    };\n    PlotView.prototype.save = function (name) {\n        var view;\n        return ((function () {\n            var i, len, ref, results;\n            ref = object_1.values(this.child_views);\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                view = ref[i];\n                if (view instanceof plot_canvas_1.PlotCanvasView) {\n                    results.push(view);\n                }\n            }\n            return results;\n        }).call(this))[0].save(name);\n    };\n    return PlotView;\n})(layout_dom_1.LayoutDOMView);\nexports.Plot = (function (superClass) {\n    extend1(Plot, superClass);\n    function Plot() {\n        return Plot.__super__.constructor.apply(this, arguments);\n    }\n    Plot.prototype.type = 'Plot';\n    Plot.prototype.default_view = exports.PlotView;\n    Plot.prototype.initialize = function (options) {\n        var i, j, len, len1, plots, ref, ref1, ref2, title, xr, yr;\n        Plot.__super__.initialize.call(this, options);\n        ref = object_1.values(this.extra_x_ranges).concat(this.x_range);\n        for (i = 0, len = ref.length; i < len; i++) {\n            xr = ref[i];\n            plots = xr.plots;\n            if (types_1.isArray(plots)) {\n                plots = plots.concat(this);\n                xr.setv('plots', plots, {\n                    silent: true\n                });\n            }\n        }\n        ref1 = object_1.values(this.extra_y_ranges).concat(this.y_range);\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n            yr = ref1[j];\n            plots = yr.plots;\n            if (types_1.isArray(plots)) {\n                plots = plots.concat(this);\n                yr.setv('plots', plots, {\n                    silent: true\n                });\n            }\n        }\n        this._horizontal = false;\n        if ((ref2 = this.toolbar_location) === 'left' || ref2 === 'right') {\n            this._horizontal = true;\n        }\n        if (this.min_border != null) {\n            if (this.min_border_top == null) {\n                this.min_border_top = this.min_border;\n            }\n            if (this.min_border_bottom == null) {\n                this.min_border_bottom = this.min_border;\n            }\n            if (this.min_border_left == null) {\n                this.min_border_left = this.min_border;\n            }\n            if (this.min_border_right == null) {\n                this.min_border_right = this.min_border;\n            }\n        }\n        if (this.title != null) {\n            title = types_1.isString(this.title) ? new title_1.Title({\n                text: this.title\n            }) : this.title;\n            this.add_layout(title, this.title_location);\n        }\n        this._plot_canvas = new plot_canvas_1.PlotCanvas({\n            plot: this\n        });\n        this.toolbar.toolbar_location = this.toolbar_location;\n        this.toolbar.toolbar_sticky = this.toolbar_sticky;\n        this.plot_canvas.toolbar = this.toolbar;\n        if (this.width == null) {\n            this.width = this.plot_width;\n        }\n        if (this.height == null) {\n            return this.height = this.plot_height;\n        }\n    };\n    Plot.getter(\"plot_canvas\", function () {\n        return this._plot_canvas;\n    });\n    Plot.prototype._doc_attached = function () {\n        var i, j, layout_renderers, len, len1, r, ref, side;\n        ref = ['above', 'below', 'left', 'right'];\n        for (i = 0, len = ref.length; i < len; i++) {\n            side = ref[i];\n            layout_renderers = this.getv(side);\n            for (j = 0, len1 = layout_renderers.length; j < len1; j++) {\n                r = layout_renderers[j];\n                this.plot_canvas.add_renderer_to_canvas_side(r, side);\n            }\n        }\n        this.plot_canvas.attach_document(this.document);\n        this._set_orientation_variables(this);\n        this._set_orientation_variables(this.toolbar);\n        this._set_orientation_variables(this.plot_canvas);\n        return Plot.__super__._doc_attached.call(this);\n    };\n    Plot.prototype.add_renderers = function () {\n        var new_renderers, renderers;\n        new_renderers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        renderers = this.renderers;\n        renderers = renderers.concat(new_renderers);\n        return this.renderers = renderers;\n    };\n    Plot.prototype.add_layout = function (renderer, side) {\n        var side_renderers;\n        if (side == null) {\n            side = \"center\";\n        }\n        if (renderer.props.plot != null) {\n            renderer.plot = this;\n        }\n        this.add_renderers(renderer);\n        if (side !== 'center') {\n            side_renderers = this.getv(side);\n            return side_renderers.push(renderer);\n        }\n    };\n    Plot.prototype.add_glyph = function (glyph, source, attrs) {\n        var renderer;\n        if (attrs == null) {\n            attrs = {};\n        }\n        if (source == null) {\n            source = new column_data_source_1.ColumnDataSource();\n        }\n        attrs = object_1.extend({}, attrs, {\n            data_source: source,\n            glyph: glyph\n        });\n        renderer = new glyph_renderer_1.GlyphRenderer(attrs);\n        this.add_renderers(renderer);\n        return renderer;\n    };\n    Plot.prototype.add_tools = function () {\n        var attrs, new_tools, tool, tools;\n        tools = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        new_tools = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = tools.length; i < len; i++) {\n                tool = tools[i];\n                if (tool.overlay != null) {\n                    this.add_renderers(tool.overlay);\n                }\n                if (tool.plot != null) {\n                    results.push(tool);\n                }\n                else {\n                    attrs = object_1.clone(tool.attributes);\n                    attrs.plot = this;\n                    results.push(new tool.constructor(attrs));\n                }\n            }\n            return results;\n        }).call(this);\n        return this.toolbar.tools = this.toolbar.tools.concat(new_tools);\n    };\n    Plot.prototype.get_aspect_ratio = function () {\n        return this.width / this.height;\n    };\n    Plot.prototype.get_layoutable_children = function () {\n        var children;\n        children = [this.plot_canvas];\n        if (this.toolbar_location != null) {\n            children = [this.toolbar, this.plot_canvas];\n        }\n        return children;\n    };\n    Plot.prototype.get_edit_variables = function () {\n        var child, edit_variables, i, len, ref;\n        edit_variables = Plot.__super__.get_edit_variables.call(this);\n        if (this.sizing_mode === 'scale_both') {\n            edit_variables.push({\n                edit_variable: this._width,\n                strength: solver_1.Strength.strong\n            });\n            edit_variables.push({\n                edit_variable: this._height,\n                strength: solver_1.Strength.strong\n            });\n        }\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    Plot.prototype.get_constraints = function () {\n        var child, constraints, i, len, ref, ref1, ref2, sticky_edge;\n        constraints = Plot.__super__.get_constraints.call(this);\n        if (this.toolbar_location != null) {\n            if (this.toolbar_sticky === true) {\n                constraints.push(solver_1.EQ(this._sizeable, [-1, this.plot_canvas._sizeable]));\n            }\n            else {\n                constraints.push(solver_1.EQ(this._sizeable, [-1, this.plot_canvas._sizeable], [-1, this.toolbar._sizeable]));\n            }\n            constraints.push(solver_1.EQ(this._full, [-1, this.plot_canvas._full]));\n            if (this.toolbar_location === 'above') {\n                sticky_edge = this.toolbar_sticky === true ? this.plot_canvas._top : this.plot_canvas._dom_top;\n                constraints.push(solver_1.EQ(sticky_edge, [-1, this.toolbar._dom_top], [-1, this.toolbar._height]));\n            }\n            if (this.toolbar_location === 'below') {\n                if (this.toolbar_sticky === false) {\n                    constraints.push(solver_1.EQ(this.toolbar._dom_top, [-1, this.plot_canvas._height], this.toolbar._bottom, [-1, this.toolbar._height]));\n                }\n                if (this.toolbar_sticky === true) {\n                    constraints.push(solver_1.GE(this.plot_canvas.below_panel._height, [-1, this.toolbar._height]));\n                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_top, [-1, this.plot_canvas._height], this.plot_canvas.below_panel._height));\n                }\n            }\n            if (this.toolbar_location === 'left') {\n                sticky_edge = this.toolbar_sticky === true ? this.plot_canvas._left : this.plot_canvas._dom_left;\n                constraints.push(solver_1.EQ(sticky_edge, [-1, this.toolbar._dom_left], [-1, this.toolbar._width]));\n            }\n            if (this.toolbar_location === 'right') {\n                if (this.toolbar_sticky === false) {\n                    constraints.push(solver_1.EQ(this.toolbar._dom_left, [-1, this.plot_canvas._width], this.toolbar._right, [-1, this.toolbar._width]));\n                }\n                if (this.toolbar_sticky === true) {\n                    constraints.push(solver_1.GE(this.plot_canvas.right_panel._width, [-1, this.toolbar._width]));\n                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_left, [-1, this.plot_canvas._width], this.plot_canvas.right_panel._width));\n                }\n            }\n            if ((ref = this.toolbar_location) === 'above' || ref === 'below') {\n                constraints.push(solver_1.EQ(this._width, [-1, this.toolbar._width], [-1, this.plot_canvas._width_minus_right]));\n            }\n            if ((ref1 = this.toolbar_location) === 'left' || ref1 === 'right') {\n                constraints.push(solver_1.EQ(this._height, [-1, this.toolbar._height], [-1, this.plot_canvas.above_panel._height]));\n                constraints.push(solver_1.EQ(this.toolbar._dom_top, [-1, this.plot_canvas.above_panel._height]));\n            }\n        }\n        if (this.toolbar_location == null) {\n            constraints.push(solver_1.EQ(this._width, [-1, this.plot_canvas._width]));\n            constraints.push(solver_1.EQ(this._height, [-1, this.plot_canvas._height]));\n        }\n        ref2 = this.get_layoutable_children();\n        for (i = 0, len = ref2.length; i < len; i++) {\n            child = ref2[i];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    Plot.prototype.get_constrained_variables = function () {\n        var constrained_variables;\n        constrained_variables = Plot.__super__.get_constrained_variables.call(this);\n        constrained_variables = object_1.extend(constrained_variables, {\n            'on-edge-align-top': this.plot_canvas._top,\n            'on-edge-align-bottom': this.plot_canvas._height_minus_bottom,\n            'on-edge-align-left': this.plot_canvas._left,\n            'on-edge-align-right': this.plot_canvas._width_minus_right,\n            'box-cell-align-top': this.plot_canvas._top,\n            'box-cell-align-bottom': this.plot_canvas._height_minus_bottom,\n            'box-cell-align-left': this.plot_canvas._left,\n            'box-cell-align-right': this.plot_canvas._width_minus_right,\n            'box-equal-size-top': this.plot_canvas._top,\n            'box-equal-size-bottom': this.plot_canvas._height_minus_bottom\n        });\n        if (this.sizing_mode !== 'fixed') {\n            constrained_variables = object_1.extend(constrained_variables, {\n                'box-equal-size-left': this.plot_canvas._left,\n                'box-equal-size-right': this.plot_canvas._width_minus_right\n            });\n        }\n        return constrained_variables;\n    };\n    Plot.prototype._set_orientation_variables = function (model) {\n        if (this._horizontal === false) {\n            model._sizeable = model._height;\n            model._full = model._width;\n        }\n        if (this._horizontal === true) {\n            model._sizeable = model._width;\n            return model._full = model._height;\n        }\n    };\n    Plot.mixins(['line:outline_', 'fill:background_', 'fill:border_']);\n    Plot.define({\n        toolbar: [\n            p.Instance, function () {\n                return new toolbar_1.Toolbar();\n            }\n        ],\n        toolbar_location: [p.Location, 'right'],\n        toolbar_sticky: [p.Bool, true],\n        plot_width: [p.Number, 600],\n        plot_height: [p.Number, 600],\n        title: [\n            p.Any, function () {\n                return new title_1.Title({\n                    text: \"\"\n                });\n            }\n        ],\n        title_location: [p.Location, 'above'],\n        h_symmetry: [p.Bool, true],\n        v_symmetry: [p.Bool, false],\n        above: [p.Array, []],\n        below: [p.Array, []],\n        left: [p.Array, []],\n        right: [p.Array, []],\n        renderers: [p.Array, []],\n        x_range: [p.Instance],\n        extra_x_ranges: [p.Any, {}],\n        y_range: [p.Instance],\n        extra_y_ranges: [p.Any, {}],\n        x_mapper_type: [p.String, 'auto'],\n        y_mapper_type: [p.String, 'auto'],\n        tool_events: [\n            p.Instance, function () {\n                return new tool_events_1.ToolEvents();\n            }\n        ],\n        lod_factor: [p.Number, 10],\n        lod_interval: [p.Number, 300],\n        lod_threshold: [p.Number, 2000],\n        lod_timeout: [p.Number, 500],\n        webgl: [p.Bool, false],\n        hidpi: [p.Bool, true],\n        min_border: [p.Number, 5],\n        min_border_top: [p.Number, null],\n        min_border_left: [p.Number, null],\n        min_border_bottom: [p.Number, null],\n        min_border_right: [p.Number, null],\n        inner_width: [p.Number],\n        inner_height: [p.Number],\n        layout_width: [p.Number],\n        layout_height: [p.Number]\n    });\n    Plot.override({\n        outline_line_color: '#e5e5e5',\n        border_fill_color: \"#ffffff\",\n        background_fill_color: \"#ffffff\"\n    });\n    Plot.getters({\n        all_renderers: function () {\n            var i, len, ref, renderers, tool;\n            renderers = this.renderers;\n            ref = this.toolbar.tools;\n            for (i = 0, len = ref.length; i < len; i++) {\n                tool = ref[i];\n                renderers = renderers.concat(tool.synthetic_renderers);\n            }\n            return renderers;\n        }\n    });\n    return Plot;\n})(layout_dom_1.LayoutDOM);\nbokeh_events_1.register_with_event(bokeh_events_1.UIEvent, exports.Plot);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar global_glcanvas, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar canvas_1 = require(\"../canvas/canvas\");\nvar cartesian_frame_1 = require(\"../canvas/cartesian_frame\");\nvar data_range1d_1 = require(\"../ranges/data_range1d\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar build_views_1 = require(\"core/build_views\");\nvar ui_events_1 = require(\"core/ui_events\");\nvar bokeh_events_1 = require(\"core/bokeh_events\");\nvar layout_canvas_1 = require(\"core/layout/layout_canvas\");\nvar visuals_1 = require(\"core/visuals\");\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar solver_1 = require(\"core/layout/solver\");\nvar logging_1 = require(\"core/logging\");\nvar enums = require(\"core/enums\");\nvar p = require(\"core/properties\");\nvar throttle_1 = require(\"core/util/throttle\");\nvar types_1 = require(\"core/util/types\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nvar callback_1 = require(\"core/util/callback\");\nvar side_panel_1 = require(\"core/layout/side_panel\");\nglobal_glcanvas = null;\nexports.PlotCanvasView = (function (superClass) {\n    extend1(PlotCanvasView, superClass);\n    function PlotCanvasView() {\n        this.remove = bind(this.remove, this);\n        this.request_render = bind(this.request_render, this);\n        return PlotCanvasView.__super__.constructor.apply(this, arguments);\n    }\n    PlotCanvasView.prototype.className = \"bk-plot-wrapper\";\n    PlotCanvasView.prototype.state = {\n        history: [],\n        index: -1\n    };\n    PlotCanvasView.prototype.view_options = function () {\n        return object_1.extend({\n            plot_view: this\n        }, this.options);\n    };\n    PlotCanvasView.prototype.pause = function () {\n        return this.is_paused = true;\n    };\n    PlotCanvasView.prototype.unpause = function () {\n        this.is_paused = false;\n        return this.request_render();\n    };\n    PlotCanvasView.prototype.request_render = function () {\n        if (!this.is_paused) {\n            this.throttled_render();\n        }\n    };\n    PlotCanvasView.prototype.remove = function () {\n        var id, ref, results, tool_view;\n        PlotCanvasView.__super__.remove.call(this);\n        ref = this.tool_views;\n        results = [];\n        for (id in ref) {\n            tool_view = ref[id];\n            results.push(tool_view.remove());\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.initialize = function (options) {\n        var j, len, level, ref;\n        PlotCanvasView.__super__.initialize.call(this, options);\n        this.pause();\n        this.lod_started = false;\n        this.visuals = new visuals_1.Visuals(this.model.plot);\n        this._initial_state_info = {\n            range: null,\n            selection: {},\n            dimensions: {\n                width: this.model.canvas.width,\n                height: this.model.canvas.height\n            }\n        };\n        this.frame = this.model.frame;\n        this.x_range = this.frame.x_ranges['default'];\n        this.y_range = this.frame.y_ranges['default'];\n        this.xmapper = this.frame.x_mappers['default'];\n        this.ymapper = this.frame.y_mappers['default'];\n        this.canvas = this.model.canvas;\n        this.canvas_view = new this.canvas.default_view({\n            'model': this.canvas\n        });\n        this.el.appendChild(this.canvas_view.el);\n        this.canvas_view.render(true);\n        if (this.model.plot.webgl) {\n            this.init_webgl();\n        }\n        this.throttled_render = throttle_1.throttle(this.render, 15);\n        if (this.model.document._unrendered_plots == null) {\n            this.model.document._unrendered_plots = {};\n        }\n        this.model.document._unrendered_plots[this.id] = true;\n        this.ui_event_bus = new ui_events_1.UIEvents(this, this.model.toolbar, this.canvas_view.el, this.model.plot);\n        this.levels = {};\n        ref = enums.RenderLevel;\n        for (j = 0, len = ref.length; j < len; j++) {\n            level = ref[j];\n            this.levels[level] = {};\n        }\n        this.renderer_views = {};\n        this.tool_views = {};\n        this.build_levels();\n        this.build_tools();\n        this.bind_bokeh_events();\n        this.update_dataranges();\n        this.unpause();\n        logging_1.logger.debug(\"PlotView initialized\");\n        return this;\n    };\n    PlotCanvasView.prototype.get_canvas_element = function () {\n        return this.canvas_view.ctx.canvas;\n    };\n    PlotCanvasView.prototype.set_cursor = function (cursor) {\n        if (cursor == null) {\n            cursor = \"default\";\n        }\n        return this.canvas_view.el.style.cursor = cursor;\n    };\n    PlotCanvasView.getters({\n        canvas_overlays: function () {\n            return this.el.querySelector('.bk-canvas-overlays');\n        }\n    });\n    PlotCanvasView.prototype.init_webgl = function () {\n        var ctx, glcanvas, opts;\n        ctx = this.canvas_view.ctx;\n        glcanvas = global_glcanvas;\n        if (glcanvas == null) {\n            global_glcanvas = glcanvas = document.createElement('canvas');\n            opts = {\n                'premultipliedAlpha': true\n            };\n            glcanvas.gl = glcanvas.getContext(\"webgl\", opts) || glcanvas.getContext(\"experimental-webgl\", opts);\n        }\n        if (glcanvas.gl != null) {\n            return ctx.glcanvas = glcanvas;\n        }\n        else {\n            return logging_1.logger.warn('WebGL is not supported, falling back to 2D canvas.');\n        }\n    };\n    PlotCanvasView.prototype.prepare_webgl = function (ratio, frame_box) {\n        var canvas, ctx, flipped_top, gl;\n        ctx = this.canvas_view.ctx;\n        canvas = this.canvas_view.get_canvas_element();\n        if (ctx.glcanvas) {\n            ctx.glcanvas.width = canvas.width;\n            ctx.glcanvas.height = canvas.height;\n            gl = ctx.glcanvas.gl;\n            gl.viewport(0, 0, ctx.glcanvas.width, ctx.glcanvas.height);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\n            gl.enable(gl.SCISSOR_TEST);\n            flipped_top = ctx.glcanvas.height - ratio * (frame_box[1] + frame_box[3]);\n            gl.scissor(ratio * frame_box[0], flipped_top, ratio * frame_box[2], ratio * frame_box[3]);\n            gl.enable(gl.BLEND);\n            return gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE);\n        }\n    };\n    PlotCanvasView.prototype.blit_webgl = function (ratio) {\n        var ctx;\n        ctx = this.canvas_view.ctx;\n        if (ctx.glcanvas) {\n            logging_1.logger.debug('drawing with WebGL');\n            ctx.restore();\n            ctx.drawImage(ctx.glcanvas, 0, 0);\n            ctx.save();\n            ctx.scale(ratio, ratio);\n            return ctx.translate(0.5, 0.5);\n        }\n    };\n    PlotCanvasView.prototype.update_dataranges = function () {\n        var bds, bounds, bounds_to_use, calculate_log_bounds, follow_enabled, frame, has_bounds, j, k, l, len, len1, len2, len3, len4, log_bds, log_bounds, m, n, o, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, v, xr, yr;\n        frame = this.model.frame;\n        bounds = {};\n        log_bounds = {};\n        calculate_log_bounds = false;\n        ref = object_1.values(frame.x_ranges).concat(object_1.values(frame.y_ranges));\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            if (r instanceof data_range1d_1.DataRange1d) {\n                if (r.mapper_hint === \"log\") {\n                    calculate_log_bounds = true;\n                }\n            }\n        }\n        ref1 = this.renderer_views;\n        for (k in ref1) {\n            v = ref1[k];\n            bds = (ref2 = v.glyph) != null ? typeof ref2.bounds === \"function\" ? ref2.bounds() : void 0 : void 0;\n            if (bds != null) {\n                bounds[k] = bds;\n            }\n            if (calculate_log_bounds) {\n                log_bds = (ref3 = v.glyph) != null ? typeof ref3.log_bounds === \"function\" ? ref3.log_bounds() : void 0 : void 0;\n                if (log_bds != null) {\n                    log_bounds[k] = log_bds;\n                }\n            }\n        }\n        follow_enabled = false;\n        has_bounds = false;\n        ref4 = object_1.values(frame.x_ranges);\n        for (l = 0, len1 = ref4.length; l < len1; l++) {\n            xr = ref4[l];\n            if (xr instanceof data_range1d_1.DataRange1d) {\n                bounds_to_use = xr.mapper_hint === \"log\" ? log_bounds : bounds;\n                xr.update(bounds_to_use, 0, this.model.id);\n                if (xr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (xr.bounds != null) {\n                has_bounds = true;\n            }\n        }\n        ref5 = object_1.values(frame.y_ranges);\n        for (m = 0, len2 = ref5.length; m < len2; m++) {\n            yr = ref5[m];\n            if (yr instanceof data_range1d_1.DataRange1d) {\n                bounds_to_use = yr.mapper_hint === \"log\" ? log_bounds : bounds;\n                yr.update(bounds_to_use, 1, this.model.id);\n                if (yr.follow) {\n                    follow_enabled = true;\n                }\n            }\n            if (yr.bounds != null) {\n                has_bounds = true;\n            }\n        }\n        if (follow_enabled && has_bounds) {\n            logging_1.logger.warn('Follow enabled so bounds are unset.');\n            ref6 = object_1.values(frame.x_ranges);\n            for (n = 0, len3 = ref6.length; n < len3; n++) {\n                xr = ref6[n];\n                xr.bounds = null;\n            }\n            ref7 = object_1.values(frame.y_ranges);\n            for (o = 0, len4 = ref7.length; o < len4; o++) {\n                yr = ref7[o];\n                yr.bounds = null;\n            }\n        }\n        return this.range_update_timestamp = Date.now();\n    };\n    PlotCanvasView.prototype.map_to_screen = function (x, y, x_name, y_name) {\n        if (x_name == null) {\n            x_name = 'default';\n        }\n        if (y_name == null) {\n            y_name = 'default';\n        }\n        return this.frame.map_to_screen(x, y, this.canvas, x_name, y_name);\n    };\n    PlotCanvasView.prototype.push_state = function (type, info) {\n        var prev_info, ref;\n        prev_info = ((ref = this.state.history[this.state.index]) != null ? ref.info : void 0) || {};\n        info = object_1.extend({}, this._initial_state_info, prev_info, info);\n        this.state.history.slice(0, this.state.index + 1);\n        this.state.history.push({\n            type: type,\n            info: info\n        });\n        this.state.index = this.state.history.length - 1;\n        return this.trigger(\"state_changed\");\n    };\n    PlotCanvasView.prototype.clear_state = function () {\n        this.state = {\n            history: [],\n            index: -1\n        };\n        return this.trigger(\"state_changed\");\n    };\n    PlotCanvasView.prototype.can_undo = function () {\n        return this.state.index >= 0;\n    };\n    PlotCanvasView.prototype.can_redo = function () {\n        return this.state.index < this.state.history.length - 1;\n    };\n    PlotCanvasView.prototype.undo = function () {\n        if (this.can_undo()) {\n            this.state.index -= 1;\n            this._do_state_change(this.state.index);\n            return this.trigger(\"state_changed\");\n        }\n    };\n    PlotCanvasView.prototype.redo = function () {\n        if (this.can_redo()) {\n            this.state.index += 1;\n            this._do_state_change(this.state.index);\n            return this.trigger(\"state_changed\");\n        }\n    };\n    PlotCanvasView.prototype._do_state_change = function (index) {\n        var info, ref;\n        info = ((ref = this.state.history[index]) != null ? ref.info : void 0) || this._initial_state_info;\n        if (info.range != null) {\n            this.update_range(info.range);\n        }\n        if (info.selection != null) {\n            this.update_selection(info.selection);\n        }\n        if (info.dimensions != null) {\n            return this.canvas_view.set_dims([info.dimensions.width, info.dimensions.height]);\n        }\n    };\n    PlotCanvasView.prototype.reset_dimensions = function () {\n        return this.update_dimensions(this.canvas.initial_width, this.canvas.initial_height);\n    };\n    PlotCanvasView.prototype.update_dimensions = function (width, height) {\n        this.pause();\n        this.model.plot.width = width;\n        this.model.plot.height = height;\n        this.model.document.resize();\n        return this.unpause();\n    };\n    PlotCanvasView.prototype.get_selection = function () {\n        var j, len, ref, renderer, selected, selection;\n        selection = [];\n        ref = this.model.plot.renderers;\n        for (j = 0, len = ref.length; j < len; j++) {\n            renderer = ref[j];\n            if (renderer instanceof glyph_renderer_1.GlyphRenderer) {\n                selected = renderer.data_source.selected;\n                selection[renderer.id] = selected;\n            }\n        }\n        return selection;\n    };\n    PlotCanvasView.prototype.update_selection = function (selection) {\n        var ds, j, len, ref, ref1, renderer, results;\n        ref = this.model.plot.renderers;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            renderer = ref[j];\n            if (!(renderer instanceof glyph_renderer_1.GlyphRenderer)) {\n                continue;\n            }\n            ds = renderer.data_source;\n            if (selection != null) {\n                if (ref1 = renderer.id, indexOf.call(selection, ref1) >= 0) {\n                    results.push(ds.selected = selection[renderer.id]);\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else {\n                results.push(ds.selection_manager.clear());\n            }\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.reset_selection = function () {\n        return this.update_selection(null);\n    };\n    PlotCanvasView.prototype._update_ranges_together = function (range_info_iter) {\n        var j, l, len, len1, range_info, ref, ref1, results, rng, weight;\n        weight = 1.0;\n        for (j = 0, len = range_info_iter.length; j < len; j++) {\n            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];\n            weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\n        }\n        if (weight < 1) {\n            results = [];\n            for (l = 0, len1 = range_info_iter.length; l < len1; l++) {\n                ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];\n                range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;\n                results.push(range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end);\n            }\n            return results;\n        }\n    };\n    PlotCanvasView.prototype._update_ranges_individually = function (range_info_iter, is_panning, is_scrolling) {\n        var hit_bound, j, l, len, len1, max, min, new_interval, range_info, ref, ref1, results, reversed, rng, weight;\n        hit_bound = false;\n        for (j = 0, len = range_info_iter.length; j < len; j++) {\n            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];\n            reversed = rng.start > rng.end;\n            if (!is_scrolling) {\n                weight = this._get_weight_to_constrain_interval(rng, range_info);\n                if (weight < 1) {\n                    range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;\n                    range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end;\n                }\n            }\n            if (rng.bounds != null) {\n                min = rng.bounds[0];\n                max = rng.bounds[1];\n                new_interval = Math.abs(range_info['end'] - range_info['start']);\n                if (reversed) {\n                    if (min != null) {\n                        if (min >= range_info['end']) {\n                            hit_bound = true;\n                            range_info['end'] = min;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['start'] = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info['start']) {\n                            hit_bound = true;\n                            range_info['start'] = max;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['end'] = max - new_interval;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (min != null) {\n                        if (min >= range_info['start']) {\n                            hit_bound = true;\n                            range_info['start'] = min;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['end'] = min + new_interval;\n                            }\n                        }\n                    }\n                    if (max != null) {\n                        if (max <= range_info['end']) {\n                            hit_bound = true;\n                            range_info['end'] = max;\n                            if ((is_panning != null) || (is_scrolling != null)) {\n                                range_info['start'] = max - new_interval;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (is_scrolling && hit_bound) {\n            return;\n        }\n        results = [];\n        for (l = 0, len1 = range_info_iter.length; l < len1; l++) {\n            ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];\n            rng.have_updated_interactively = true;\n            if (rng.start !== range_info['start'] || rng.end !== range_info['end']) {\n                results.push(rng.setv(range_info));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    PlotCanvasView.prototype._get_weight_to_constrain_interval = function (rng, range_info) {\n        var max, max_interval, max_interval2, min, min_interval, new_interval, old_interval, ref, weight;\n        min_interval = rng.min_interval;\n        max_interval = rng.max_interval;\n        weight = 1.0;\n        if (rng.bounds != null) {\n            ref = rng.bounds, min = ref[0], max = ref[1];\n            if ((min != null) && (max != null)) {\n                max_interval2 = Math.abs(max - min);\n                max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\n            }\n        }\n        if ((min_interval != null) || (max_interval != null)) {\n            old_interval = Math.abs(rng.end - rng.start);\n            new_interval = Math.abs(range_info['end'] - range_info['start']);\n            if (min_interval > 0 && new_interval < min_interval) {\n                weight = (old_interval - min_interval) / (old_interval - new_interval);\n            }\n            if (max_interval > 0 && new_interval > max_interval) {\n                weight = (max_interval - old_interval) / (new_interval - old_interval);\n            }\n            weight = Math.max(0.0, Math.min(1.0, weight));\n        }\n        return weight;\n    };\n    PlotCanvasView.prototype.update_range = function (range_info, is_panning, is_scrolling) {\n        var name, range_info_iter, ref, ref1, ref2, ref3, rng;\n        this.pause;\n        if (range_info == null) {\n            ref = this.frame.x_ranges;\n            for (name in ref) {\n                rng = ref[name];\n                rng.reset();\n            }\n            ref1 = this.frame.y_ranges;\n            for (name in ref1) {\n                rng = ref1[name];\n                rng.reset();\n            }\n            this.update_dataranges();\n        }\n        else {\n            range_info_iter = [];\n            ref2 = this.frame.x_ranges;\n            for (name in ref2) {\n                rng = ref2[name];\n                range_info_iter.push([rng, range_info.xrs[name]]);\n            }\n            ref3 = this.frame.y_ranges;\n            for (name in ref3) {\n                rng = ref3[name];\n                range_info_iter.push([rng, range_info.yrs[name]]);\n            }\n            if (is_scrolling) {\n                this._update_ranges_together(range_info_iter);\n            }\n            this._update_ranges_individually(range_info_iter, is_panning, is_scrolling);\n        }\n        return this.unpause();\n    };\n    PlotCanvasView.prototype.reset_range = function () {\n        return this.update_range(null);\n    };\n    PlotCanvasView.prototype.build_levels = function () {\n        var id_, j, l, len, len1, model, new_renderer_views, old_renderers, renderer_models, renderers_to_remove, view;\n        renderer_models = this.model.plot.all_renderers;\n        old_renderers = Object.keys(this.renderer_views);\n        new_renderer_views = build_views_1.build_views(this.renderer_views, renderer_models, this.view_options());\n        renderers_to_remove = array_1.difference(old_renderers, (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = renderer_models.length; j < len; j++) {\n                model = renderer_models[j];\n                results.push(model.id);\n            }\n            return results;\n        })());\n        for (j = 0, len = renderers_to_remove.length; j < len; j++) {\n            id_ = renderers_to_remove[j];\n            delete this.levels.glyph[id_];\n        }\n        for (l = 0, len1 = new_renderer_views.length; l < len1; l++) {\n            view = new_renderer_views[l];\n            this.levels[view.model.level][view.model.id] = view;\n            view.bind_bokeh_events();\n        }\n        return this;\n    };\n    PlotCanvasView.prototype.get_renderer_views = function () {\n        var j, len, r, ref, results;\n        ref = this.model.plot.renderers;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            results.push(this.levels[r.level][r.id]);\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.build_tools = function () {\n        var j, len, new_tool_views, results, tool_models, tool_view;\n        tool_models = this.model.plot.toolbar.tools;\n        new_tool_views = build_views_1.build_views(this.tool_views, tool_models, this.view_options());\n        results = [];\n        for (j = 0, len = new_tool_views.length; j < len; j++) {\n            tool_view = new_tool_views[j];\n            tool_view.bind_bokeh_events();\n            results.push(this.ui_event_bus.register_tool(tool_view));\n        }\n        return results;\n    };\n    PlotCanvasView.prototype.bind_bokeh_events = function () {\n        var name, ref, ref1, rng;\n        ref = this.model.frame.x_ranges;\n        for (name in ref) {\n            rng = ref[name];\n            this.listenTo(rng, 'change', this.request_render);\n        }\n        ref1 = this.model.frame.y_ranges;\n        for (name in ref1) {\n            rng = ref1[name];\n            this.listenTo(rng, 'change', this.request_render);\n        }\n        this.listenTo(this.model.plot, 'change:renderers', (function (_this) {\n            return function () {\n                return _this.build_levels();\n            };\n        })(this));\n        this.listenTo(this.model.plot.toolbar, 'change:tools', (function (_this) {\n            return function () {\n                _this.build_levels();\n                return _this.build_tools();\n            };\n        })(this));\n        this.listenTo(this.model.plot, 'change', this.request_render);\n        this.listenTo(this.model.plot, 'destroy', (function (_this) {\n            return function () {\n                return _this.remove();\n            };\n        })(this));\n        this.listenTo(this.model.plot.document.solver(), 'layout_update', (function (_this) {\n            return function () {\n                return _this.request_render();\n            };\n        })(this));\n        this.listenTo(this.model.plot.document.solver(), 'layout_update', (function (_this) {\n            return function () {\n                return _this.model.plot.setv({\n                    inner_width: Math.round(_this.frame.width),\n                    inner_height: Math.round(_this.frame.height),\n                    layout_width: Math.round(_this.canvas.width),\n                    layout_height: Math.round(_this.canvas.height)\n                });\n            };\n        })(this));\n        this.listenTo(this.model.plot.document.solver(), 'resize', (function (_this) {\n            return function () {\n                return _this.resize();\n            };\n        })(this));\n        return this.listenTo(this.canvas, 'change:pixel_ratio', (function (_this) {\n            return function () {\n                return _this.request_render();\n            };\n        })(this));\n    };\n    PlotCanvasView.prototype.set_initial_range = function () {\n        var good_vals, name, ref, ref1, rng, xrs, yrs;\n        good_vals = true;\n        xrs = {};\n        ref = this.frame.x_ranges;\n        for (name in ref) {\n            rng = ref[name];\n            if ((rng.start == null) || (rng.end == null) || types_1.isStrictNaN(rng.start + rng.end)) {\n                good_vals = false;\n                break;\n            }\n            xrs[name] = {\n                start: rng.start,\n                end: rng.end\n            };\n        }\n        if (good_vals) {\n            yrs = {};\n            ref1 = this.frame.y_ranges;\n            for (name in ref1) {\n                rng = ref1[name];\n                if ((rng.start == null) || (rng.end == null) || types_1.isStrictNaN(rng.start + rng.end)) {\n                    good_vals = false;\n                    break;\n                }\n                yrs[name] = {\n                    start: rng.start,\n                    end: rng.end\n                };\n            }\n        }\n        if (good_vals) {\n            this._initial_state_info.range = this.initial_range_info = {\n                xrs: xrs,\n                yrs: yrs\n            };\n            return logging_1.logger.debug(\"initial ranges set\");\n        }\n        else {\n            return logging_1.logger.warn('could not set initial ranges');\n        }\n    };\n    PlotCanvasView.prototype.render = function (force_canvas) {\n        var ctx, event, frame_box, k, lod_timeout, ratio, ref, v;\n        if (force_canvas == null) {\n            force_canvas = false;\n        }\n        logging_1.logger.trace(\"PlotCanvas.render(force_canvas=\" + force_canvas + \") for \" + this.model.id);\n        if (this.model.document == null) {\n            return;\n        }\n        if (Date.now() - this.interactive_timestamp < this.model.plot.lod_interval) {\n            if (!this.lod_started) {\n                this.model.plot.trigger_event(new bokeh_events_1.LODStart({}));\n                this.lod_started = true;\n            }\n            this.interactive = true;\n            lod_timeout = this.model.plot.lod_timeout;\n            setTimeout((function (_this) {\n                return function () {\n                    if (_this.interactive && (Date.now() - _this.interactive_timestamp) > lod_timeout) {\n                        _this.interactive = false;\n                    }\n                    return _this.request_render();\n                };\n            })(this), lod_timeout);\n        }\n        else {\n            this.interactive = false;\n            if (this.lod_started) {\n                this.model.plot.trigger_event(new bokeh_events_1.LODEnd({}));\n                this.lod_started = false;\n            }\n        }\n        ref = this.renderer_views;\n        for (k in ref) {\n            v = ref[k];\n            if ((this.range_update_timestamp == null) || v.set_data_timestamp > this.range_update_timestamp) {\n                this.update_dataranges();\n                break;\n            }\n        }\n        this.update_constraints();\n        this.model.frame._update_mappers();\n        ctx = this.canvas_view.ctx;\n        ctx.pixel_ratio = ratio = this.canvas_view.pixel_ratio;\n        ctx.save();\n        ctx.scale(ratio, ratio);\n        ctx.translate(0.5, 0.5);\n        frame_box = [this.canvas.vx_to_sx(this.frame.left), this.canvas.vy_to_sy(this.frame.top), this.frame.width, this.frame.height];\n        this._map_hook(ctx, frame_box);\n        this._paint_empty(ctx, frame_box);\n        this.prepare_webgl(ratio, frame_box);\n        ctx.save();\n        if (this.visuals.outline_line.doit) {\n            this.visuals.outline_line.set_value(ctx);\n            ctx.strokeRect.apply(ctx, frame_box);\n        }\n        ctx.restore();\n        this._render_levels(ctx, ['image', 'underlay', 'glyph'], frame_box);\n        this.blit_webgl(ratio);\n        this._render_levels(ctx, ['annotation'], frame_box);\n        this._render_levels(ctx, ['overlay']);\n        if (this.initial_range_info == null) {\n            this.set_initial_range();\n        }\n        ctx.restore();\n        if (this.model.document._unrendered_plots != null) {\n            delete this.model.document._unrendered_plots[this.id];\n            if (object_1.isEmpty(this.model.document._unrendered_plots)) {\n                this.model.document._unrendered_plots = null;\n                callback_1.defer(this.model.document.resize.bind(this.model.document));\n            }\n        }\n        event = new Event(\"bokeh:rendered\", {\n            detail: this\n        });\n        return window.dispatchEvent(event);\n    };\n    PlotCanvasView.prototype.resize = function () {\n        var height, width;\n        width = this.model._width._value;\n        height = this.model._height._value;\n        this.canvas_view.set_dims([width, height], true);\n        this.canvas_view.prepare_canvas();\n        this.update_constraints();\n        this.el.style.position = 'absolute';\n        this.el.style.left = this.model._dom_left._value + \"px\";\n        this.el.style.top = this.model._dom_top._value + \"px\";\n        this.el.style.width = this.model._width._value + \"px\";\n        return this.el.style.height = this.model._height._value + \"px\";\n    };\n    PlotCanvasView.prototype.update_constraints = function () {\n        var model_id, ref, s, view;\n        s = this.model.document.solver();\n        s.suggest_value(this.frame._width, this.canvas.width - 1);\n        s.suggest_value(this.frame._height, this.canvas.height - 1);\n        ref = this.renderer_views;\n        for (model_id in ref) {\n            view = ref[model_id];\n            if (view.model.panel != null) {\n                side_panel_1.update_constraints(view);\n            }\n        }\n        return s.update_variables(false);\n    };\n    PlotCanvasView.prototype._render_levels = function (ctx, levels, clip_region) {\n        var i, indices, j, l, len, len1, len2, level, m, ref, renderer, renderer_view, renderer_views, sortKey;\n        ctx.save();\n        if (clip_region != null) {\n            ctx.beginPath();\n            ctx.rect.apply(ctx, clip_region);\n            ctx.clip();\n            ctx.beginPath();\n        }\n        indices = {};\n        ref = this.model.plot.renderers;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            renderer = ref[i];\n            indices[renderer.id] = i;\n        }\n        sortKey = function (renderer_view) {\n            return indices[renderer_view.model.id];\n        };\n        for (l = 0, len1 = levels.length; l < len1; l++) {\n            level = levels[l];\n            renderer_views = array_1.sortBy(object_1.values(this.levels[level]), sortKey);\n            for (m = 0, len2 = renderer_views.length; m < len2; m++) {\n                renderer_view = renderer_views[m];\n                renderer_view.render();\n            }\n        }\n        return ctx.restore();\n    };\n    PlotCanvasView.prototype._map_hook = function (ctx, frame_box) { };\n    PlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {\n        ctx.clearRect(0, 0, this.canvas_view.model.width, this.canvas_view.model.height);\n        if (this.visuals.border_fill.doit) {\n            this.visuals.border_fill.set_value(ctx);\n            ctx.fillRect(0, 0, this.canvas_view.model.width, this.canvas_view.model.height);\n            ctx.clearRect.apply(ctx, frame_box);\n        }\n        if (this.visuals.background_fill.doit) {\n            this.visuals.background_fill.set_value(ctx);\n            return ctx.fillRect.apply(ctx, frame_box);\n        }\n    };\n    PlotCanvasView.prototype.save = function (name) {\n        var blob, canvas, link;\n        canvas = this.get_canvas_element();\n        if (canvas.msToBlob != null) {\n            blob = canvas.msToBlob();\n            return window.navigator.msSaveBlob(blob, name);\n        }\n        else {\n            link = document.createElement('a');\n            link.href = canvas.toDataURL('image/png');\n            link.download = name;\n            link.target = \"_blank\";\n            return link.dispatchEvent(new MouseEvent('click'));\n        }\n    };\n    return PlotCanvasView;\n})(bokeh_view_1.BokehView);\nexports.PlotCanvas = (function (superClass) {\n    extend1(PlotCanvas, superClass);\n    function PlotCanvas() {\n        return PlotCanvas.__super__.constructor.apply(this, arguments);\n    }\n    PlotCanvas.prototype.type = 'PlotCanvas';\n    PlotCanvas.prototype.default_view = exports.PlotCanvasView;\n    PlotCanvas.prototype.initialize = function (attrs, options) {\n        var ref;\n        PlotCanvas.__super__.initialize.call(this, attrs, options);\n        this.canvas = new canvas_1.Canvas({\n            map: (ref = this.use_map) != null ? ref : false,\n            initial_width: this.plot.plot_width,\n            initial_height: this.plot.plot_height,\n            use_hidpi: this.plot.hidpi\n        });\n        this.frame = new cartesian_frame_1.CartesianFrame({\n            x_range: this.plot.x_range,\n            extra_x_ranges: this.plot.extra_x_ranges,\n            x_mapper_type: this.plot.x_mapper_type,\n            y_range: this.plot.y_range,\n            extra_y_ranges: this.plot.extra_y_ranges,\n            y_mapper_type: this.plot.y_mapper_type\n        });\n        this.above_panel = new layout_canvas_1.LayoutCanvas();\n        this.below_panel = new layout_canvas_1.LayoutCanvas();\n        this.left_panel = new layout_canvas_1.LayoutCanvas();\n        this.right_panel = new layout_canvas_1.LayoutCanvas();\n        return logging_1.logger.debug(\"PlotCanvas initialized\");\n    };\n    PlotCanvas.prototype.add_renderer_to_canvas_side = function (renderer, side) {\n        if (side !== 'center') {\n            return renderer.add_panel(side);\n        }\n    };\n    PlotCanvas.prototype._doc_attached = function () {\n        this.canvas.attach_document(this.document);\n        this.frame.attach_document(this.document);\n        this.above_panel.attach_document(this.document);\n        this.below_panel.attach_document(this.document);\n        this.left_panel.attach_document(this.document);\n        this.right_panel.attach_document(this.document);\n        return logging_1.logger.debug(\"PlotCanvas attached to document\");\n    };\n    PlotCanvas.override({\n        sizing_mode: 'stretch_both'\n    });\n    PlotCanvas.internal({\n        plot: [p.Instance],\n        toolbar: [p.Instance],\n        canvas: [p.Instance],\n        frame: [p.Instance]\n    });\n    PlotCanvas.prototype.get_layoutable_children = function () {\n        var children, collect_panels;\n        children = [this.above_panel, this.below_panel, this.left_panel, this.right_panel, this.canvas, this.frame];\n        collect_panels = function (layout_renderers) {\n            var j, len, r, results;\n            results = [];\n            for (j = 0, len = layout_renderers.length; j < len; j++) {\n                r = layout_renderers[j];\n                if (r.panel != null) {\n                    results.push(children.push(r.panel));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            return results;\n        };\n        collect_panels(this.plot.above);\n        collect_panels(this.plot.below);\n        collect_panels(this.plot.left);\n        collect_panels(this.plot.right);\n        return children;\n    };\n    PlotCanvas.prototype.get_edit_variables = function () {\n        var child, edit_variables, j, len, ref;\n        edit_variables = [];\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    PlotCanvas.prototype.get_constraints = function () {\n        var child, constraints, j, len, ref;\n        constraints = PlotCanvas.__super__.get_constraints.call(this);\n        constraints = constraints.concat(this._get_constant_constraints());\n        constraints = constraints.concat(this._get_side_constraints());\n        ref = this.get_layoutable_children();\n        for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    PlotCanvas.prototype._get_constant_constraints = function () {\n        var constraints, min_border_bottom, min_border_left, min_border_right, min_border_top;\n        min_border_top = this.plot.min_border_top;\n        min_border_bottom = this.plot.min_border_bottom;\n        min_border_left = this.plot.min_border_left;\n        min_border_right = this.plot.min_border_right;\n        constraints = [];\n        constraints.push(solver_1.GE(this.above_panel._height, -min_border_top));\n        constraints.push(solver_1.GE(this.below_panel._height, -min_border_bottom));\n        constraints.push(solver_1.GE(this.left_panel._width, -min_border_left));\n        constraints.push(solver_1.GE(this.right_panel._width, -min_border_right));\n        constraints.push(solver_1.EQ(this.above_panel._top, [-1, this.canvas._top]));\n        constraints.push(solver_1.EQ(this.above_panel._bottom, [-1, this.frame._top]));\n        constraints.push(solver_1.EQ(this.below_panel._bottom, [-1, this.canvas._bottom]));\n        constraints.push(solver_1.EQ(this.below_panel._top, [-1, this.frame._bottom]));\n        constraints.push(solver_1.EQ(this.left_panel._left, [-1, this.canvas._left]));\n        constraints.push(solver_1.EQ(this.left_panel._right, [-1, this.frame._left]));\n        constraints.push(solver_1.EQ(this.right_panel._right, [-1, this.canvas._right]));\n        constraints.push(solver_1.EQ(this.right_panel._left, [-1, this.frame._right]));\n        constraints.push(solver_1.EQ(this.above_panel._height, [-1, this._top]));\n        constraints.push(solver_1.EQ(this.above_panel._height, [-1, this.canvas._top], this.frame._top));\n        constraints.push(solver_1.EQ(this.below_panel._height, [-1, this._height], this._bottom));\n        constraints.push(solver_1.EQ(this.below_panel._height, [-1, this.frame._bottom]));\n        constraints.push(solver_1.EQ(this.left_panel._width, [-1, this._left]));\n        constraints.push(solver_1.EQ(this.left_panel._width, [-1, this.frame._left]));\n        constraints.push(solver_1.EQ(this.right_panel._width, [-1, this._width], this._right));\n        constraints.push(solver_1.EQ(this.right_panel._width, [-1, this.canvas._right], this.frame._right));\n        return constraints;\n    };\n    PlotCanvas.prototype._get_side_constraints = function () {\n        var constraint, constraints, j, l, last, layout_renderers, len, len1, r, ref, side, sides;\n        constraints = [];\n        sides = [['above', this.plot.above], ['below', this.plot.below], ['left', this.plot.left], ['right', this.plot.right]];\n        for (j = 0, len = sides.length; j < len; j++) {\n            ref = sides[j], side = ref[0], layout_renderers = ref[1];\n            last = this.frame;\n            for (l = 0, len1 = layout_renderers.length; l < len1; l++) {\n                r = layout_renderers[l];\n                constraint = (function () {\n                    switch (side) {\n                        case \"above\":\n                            return solver_1.EQ(last.panel._top, [-1, r.panel._bottom]);\n                        case \"below\":\n                            return solver_1.EQ(last.panel._bottom, [-1, r.panel._top]);\n                        case \"left\":\n                            return solver_1.EQ(last.panel._left, [-1, r.panel._right]);\n                        case \"right\":\n                            return solver_1.EQ(last.panel._right, [-1, r.panel._left]);\n                    }\n                })();\n                constraints.push(constraint);\n                last = r;\n            }\n            if (layout_renderers.length !== 0) {\n                constraint = (function () {\n                    switch (side) {\n                        case \"above\":\n                            return solver_1.EQ(last.panel._top, [-1, this.above_panel._top]);\n                        case \"below\":\n                            return solver_1.EQ(last.panel._bottom, [-1, this.below_panel._bottom]);\n                        case \"left\":\n                            return solver_1.EQ(last.panel._left, [-1, this.left_panel._left]);\n                        case \"right\":\n                            return solver_1.EQ(last.panel._right, [-1, this.right_panel._right]);\n                    }\n                }).call(this);\n                constraints.push(constraint);\n            }\n        }\n        return constraints;\n    };\n    PlotCanvas.prototype.plot_canvas = function () {\n        return this;\n    };\n    return PlotCanvas;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.DataRange = (function (superClass) {\n    extend(DataRange, superClass);\n    function DataRange() {\n        return DataRange.__super__.constructor.apply(this, arguments);\n    }\n    DataRange.prototype.type = 'DataRange';\n    DataRange.define({\n        names: [p.Array, []],\n        renderers: [p.Array, []]\n    });\n    return DataRange;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar data_range_1 = require(\"./data_range\");\nvar glyph_renderer_1 = require(\"../renderers/glyph_renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar bbox = require(\"core/util/bbox\");\nexports.DataRange1d = (function (superClass) {\n    extend(DataRange1d, superClass);\n    function DataRange1d() {\n        return DataRange1d.__super__.constructor.apply(this, arguments);\n    }\n    DataRange1d.prototype.type = 'DataRange1d';\n    DataRange1d.define({\n        start: [p.Number],\n        end: [p.Number],\n        range_padding: [p.Number, 0.1],\n        flipped: [p.Bool, false],\n        follow: [p.String],\n        follow_interval: [p.Number],\n        default_span: [p.Number, 2],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    DataRange1d.internal({\n        mapper_hint: [p.String, 'auto']\n    });\n    DataRange1d.prototype.initialize = function (attrs, options) {\n        DataRange1d.__super__.initialize.call(this, attrs, options);\n        this.plot_bounds = {};\n        this.have_updated_interactively = false;\n        this._initial_start = this.start;\n        this._initial_end = this.end;\n        this._initial_range_padding = this.range_padding;\n        this._initial_follow = this.follow;\n        this._initial_follow_interval = this.follow_interval;\n        return this._initial_default_span = this.default_span;\n    };\n    DataRange1d.getters({\n        min: function () {\n            return Math.min(this.start, this.end);\n        },\n        max: function () {\n            return Math.max(this.start, this.end);\n        }\n    });\n    DataRange1d.prototype.computed_renderers = function () {\n        var all_renderers, i, j, len, len1, names, plot, r, ref, renderers, rs;\n        names = this.names;\n        renderers = this.renderers;\n        if (renderers.length === 0) {\n            ref = this.plots;\n            for (i = 0, len = ref.length; i < len; i++) {\n                plot = ref[i];\n                all_renderers = plot.renderers;\n                rs = (function () {\n                    var j, len1, results;\n                    results = [];\n                    for (j = 0, len1 = all_renderers.length; j < len1; j++) {\n                        r = all_renderers[j];\n                        if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n                renderers = renderers.concat(rs);\n            }\n        }\n        if (names.length > 0) {\n            renderers = (function () {\n                var j, len1, results;\n                results = [];\n                for (j = 0, len1 = renderers.length; j < len1; j++) {\n                    r = renderers[j];\n                    if (names.indexOf(r.name) >= 0) {\n                        results.push(r);\n                    }\n                }\n                return results;\n            })();\n        }\n        logging_1.logger.debug(\"computed \" + renderers.length + \" renderers for DataRange1d \" + this.id);\n        for (j = 0, len1 = renderers.length; j < len1; j++) {\n            r = renderers[j];\n            logging_1.logger.trace(\" - \" + r.type + \" \" + r.id);\n        }\n        return renderers;\n    };\n    DataRange1d.prototype._compute_plot_bounds = function (renderers, bounds) {\n        var i, len, r, result;\n        result = bbox.empty();\n        for (i = 0, len = renderers.length; i < len; i++) {\n            r = renderers[i];\n            if (bounds[r.id] != null) {\n                result = bbox.union(result, bounds[r.id]);\n            }\n        }\n        return result;\n    };\n    DataRange1d.prototype._compute_min_max = function (plot_bounds, dimension) {\n        var k, max, min, overall, ref, ref1, v;\n        overall = bbox.empty();\n        for (k in plot_bounds) {\n            v = plot_bounds[k];\n            overall = bbox.union(overall, v);\n        }\n        if (dimension === 0) {\n            ref = [overall.minX, overall.maxX], min = ref[0], max = ref[1];\n        }\n        else {\n            ref1 = [overall.minY, overall.maxY], min = ref1[0], max = ref1[1];\n        }\n        return [min, max];\n    };\n    DataRange1d.prototype._compute_range = function (min, max) {\n        var center, end, follow_interval, follow_sign, log_max, log_min, range_padding, ref, ref1, ref2, ref3, span, start;\n        range_padding = this.range_padding;\n        if ((range_padding != null) && range_padding > 0) {\n            if (this.mapper_hint === \"log\") {\n                if (isNaN(min) || !isFinite(min) || min <= 0) {\n                    if (isNaN(max) || !isFinite(max) || max <= 0) {\n                        min = 0.1;\n                    }\n                    else {\n                        min = max / 100;\n                    }\n                    logging_1.logger.warn(\"could not determine minimum data value for log axis, DataRange1d using value \" + min);\n                }\n                if (isNaN(max) || !isFinite(max) || max <= 0) {\n                    if (isNaN(min) || !isFinite(min) || min <= 0) {\n                        max = 10;\n                    }\n                    else {\n                        max = min * 100;\n                    }\n                    logging_1.logger.warn(\"could not determine maximum data value for log axis, DataRange1d using value \" + max);\n                }\n                log_min = Math.log(min) / Math.log(10);\n                log_max = Math.log(max) / Math.log(10);\n                if (max === min) {\n                    span = this.default_span + 0.001;\n                }\n                else {\n                    span = (log_max - log_min) * (1 + range_padding);\n                }\n                center = (log_min + log_max) / 2.0;\n                ref = [Math.pow(10, center - span / 2.0), Math.pow(10, center + span / 2.0)], start = ref[0], end = ref[1];\n            }\n            else {\n                if (max === min) {\n                    span = this.default_span;\n                }\n                else {\n                    span = (max - min) * (1 + range_padding);\n                }\n                center = (max + min) / 2.0;\n                ref1 = [center - span / 2.0, center + span / 2.0], start = ref1[0], end = ref1[1];\n            }\n        }\n        else {\n            ref2 = [min, max], start = ref2[0], end = ref2[1];\n        }\n        follow_sign = +1;\n        if (this.flipped) {\n            ref3 = [end, start], start = ref3[0], end = ref3[1];\n            follow_sign = -1;\n        }\n        follow_interval = this.follow_interval;\n        if ((follow_interval != null) && Math.abs(start - end) > follow_interval) {\n            if (this.follow === 'start') {\n                end = start + follow_sign * follow_interval;\n            }\n            else if (this.follow === 'end') {\n                start = end - follow_sign * follow_interval;\n            }\n        }\n        return [start, end];\n    };\n    DataRange1d.prototype.update = function (bounds, dimension, bounds_id) {\n        var _end, _start, end, max, min, new_range, ref, ref1, ref2, renderers, start;\n        if (this.have_updated_interactively) {\n            return;\n        }\n        renderers = this.computed_renderers();\n        this.plot_bounds[bounds_id] = this._compute_plot_bounds(renderers, bounds);\n        ref = this._compute_min_max(this.plot_bounds, dimension), min = ref[0], max = ref[1];\n        ref1 = this._compute_range(min, max), start = ref1[0], end = ref1[1];\n        if (this._initial_start != null) {\n            if (this.mapper_hint === \"log\") {\n                if (this._initial_start > 0) {\n                    start = this._initial_start;\n                }\n            }\n            else {\n                start = this._initial_start;\n            }\n        }\n        if (this._initial_end != null) {\n            if (this.mapper_hint === \"log\") {\n                if (this._initial_end > 0) {\n                    end = this._initial_end;\n                }\n            }\n            else {\n                end = this._initial_end;\n            }\n        }\n        ref2 = [this.start, this.end], _start = ref2[0], _end = ref2[1];\n        if (start !== _start || end !== _end) {\n            new_range = {};\n            if (start !== _start) {\n                new_range.start = start;\n            }\n            if (end !== _end) {\n                new_range.end = end;\n            }\n            this.setv(new_range);\n        }\n        if (this.bounds === 'auto') {\n            this.setv({\n                bounds: [start, end]\n            }, {\n                silent: true\n            });\n        }\n        return this.trigger('change');\n    };\n    DataRange1d.prototype.reset = function () {\n        this.have_updated_interactively = false;\n        this.setv({\n            range_padding: this._initial_range_padding,\n            follow: this._initial_follow,\n            follow_interval: this._initial_follow_interval,\n            default_span: this._initial_default_span\n        }, {\n            silent: true\n        });\n        return this.trigger('change');\n    };\n    return DataRange1d;\n})(data_range_1.DataRange);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.FactorRange = (function (superClass) {\n    extend(FactorRange, superClass);\n    function FactorRange() {\n        return FactorRange.__super__.constructor.apply(this, arguments);\n    }\n    FactorRange.prototype.type = 'FactorRange';\n    FactorRange.define({\n        offset: [p.Number, 0],\n        factors: [p.Array, []],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    FactorRange.internal({\n        _bounds_as_factors: [p.Any],\n        start: [p.Number],\n        end: [p.Number]\n    });\n    FactorRange.prototype.initialize = function (attrs, options) {\n        FactorRange.__super__.initialize.call(this, attrs, options);\n        if ((this.bounds != null) && this.bounds !== 'auto') {\n            this.setv({\n                _bounds_as_factors: this.bounds\n            }, {\n                silent: true\n            });\n        }\n        else {\n            this.setv({\n                _bounds_as_factors: this.factors\n            }, {\n                silent: true\n            });\n        }\n        this._init();\n        this.listenTo(this, 'change:factors', this._update_factors);\n        return this.listenTo(this, 'change:offset', this._init);\n    };\n    FactorRange.getters({\n        min: function () {\n            return this.start;\n        },\n        max: function () {\n            return this.end;\n        }\n    });\n    FactorRange.prototype.reset = function () {\n        this._init();\n        return this.trigger('change');\n    };\n    FactorRange.prototype._update_factors = function () {\n        this.setv('_bounds_as_factors', this.factors, {\n            silent: true\n        });\n        return this._init();\n    };\n    FactorRange.prototype._init = function () {\n        var end, factors, start;\n        factors = this.factors;\n        if ((this.bounds != null) && this.bounds !== 'auto') {\n            factors = this._bounds_as_factors;\n            this.setv({\n                factors: factors\n            }, {\n                silent: true\n            });\n        }\n        start = 0.5 + this.offset;\n        end = factors.length + start;\n        this.setv({\n            start: start,\n            end: end\n        }, {\n            silent: true\n        });\n        if (this.bounds != null) {\n            return this.setv({\n                bounds: [start, end]\n            }, {\n                silent: true\n            });\n        }\n    };\n    return FactorRange;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_range_1 = require(\"./data_range\");\nexports.DataRange = data_range_1.DataRange;\nvar data_range1d_1 = require(\"./data_range1d\");\nexports.DataRange1d = data_range1d_1.DataRange1d;\nvar factor_range_1 = require(\"./factor_range\");\nexports.FactorRange = factor_range_1.FactorRange;\nvar range_1 = require(\"./range\");\nexports.Range = range_1.Range;\nvar range1d_1 = require(\"./range1d\");\nexports.Range1d = range1d_1.Range1d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.Range = (function (superClass) {\n    extend(Range, superClass);\n    function Range() {\n        return Range.__super__.constructor.apply(this, arguments);\n    }\n    Range.prototype.type = 'Range';\n    Range.prototype.initialize = function (options) {\n        Range.__super__.initialize.call(this, options);\n        return this.listenTo(this, 'change', function () {\n            var ref;\n            return (ref = this.callback) != null ? ref.execute(this) : void 0;\n        });\n    };\n    Range.define({\n        callback: [p.Instance]\n    });\n    Range.internal({\n        plots: [p.Array, []]\n    });\n    Range.prototype.reset = function () {\n        \"This method should be reimplemented by subclasses and ensure that\\nthe callback, if exists, is executed at completion.\";\n        return this.trigger('change');\n    };\n    return Range;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar range_1 = require(\"./range\");\nvar p = require(\"core/properties\");\nexports.Range1d = (function (superClass) {\n    extend(Range1d, superClass);\n    Range1d.prototype.type = 'Range1d';\n    Range1d.define({\n        start: [p.Number, 0],\n        end: [p.Number, 1],\n        bounds: [p.Any],\n        min_interval: [p.Any],\n        max_interval: [p.Any]\n    });\n    Range1d.prototype._set_auto_bounds = function () {\n        var max, min;\n        if (this.bounds === 'auto') {\n            min = Math.min(this._initial_start, this._initial_end);\n            max = Math.max(this._initial_start, this._initial_end);\n            return this.setv({\n                bounds: [min, max]\n            }, {\n                silent: true\n            });\n        }\n    };\n    function Range1d() {\n        var end, start;\n        if (this instanceof Range1d) {\n            return Range1d.__super__.constructor.apply(this, arguments);\n        }\n        else {\n            start = arguments[0], end = arguments[1];\n            return new Range1d({\n                start: start,\n                end: end\n            });\n        }\n    }\n    Range1d.prototype.initialize = function (attrs, options) {\n        Range1d.__super__.initialize.call(this, attrs, options);\n        this._initial_start = this.start;\n        this._initial_end = this.end;\n        return this._set_auto_bounds();\n    };\n    Range1d.getters({\n        min: function () {\n            return Math.min(this.start, this.end);\n        },\n        max: function () {\n            return Math.max(this.start, this.end);\n        }\n    });\n    Range1d.prototype.reset = function () {\n        this._set_auto_bounds();\n        if (this.start !== this._initial_start || this.end !== this._initial_end) {\n            return this.setv({\n                start: this._initial_start,\n                end: this._initial_end\n            });\n        }\n        else {\n            return this.trigger('change');\n        }\n    };\n    return Range1d;\n})(range_1.Range);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar renderer_1 = require(\"./renderer\");\nvar remote_data_source_1 = require(\"../sources/remote_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar object_1 = require(\"core/util/object\");\nexports.GlyphRendererView = (function (superClass) {\n    extend1(GlyphRendererView, superClass);\n    function GlyphRendererView() {\n        return GlyphRendererView.__super__.constructor.apply(this, arguments);\n    }\n    GlyphRendererView.prototype.initialize = function (options) {\n        var base_glyph, decimated_glyph, glyph_attrs, has_fill, has_line, hover_glyph, mk_glyph, muted_glyph, nonselection_glyph, selection_glyph;\n        GlyphRendererView.__super__.initialize.call(this, options);\n        base_glyph = this.model.glyph;\n        has_fill = indexOf.call(base_glyph.mixins, \"fill\") >= 0;\n        has_line = indexOf.call(base_glyph.mixins, \"line\") >= 0;\n        glyph_attrs = object_1.clone(base_glyph.attributes);\n        delete glyph_attrs.id;\n        mk_glyph = function (defaults) {\n            var attrs;\n            attrs = object_1.clone(glyph_attrs);\n            if (has_fill) {\n                object_1.extend(attrs, defaults.fill);\n            }\n            if (has_line) {\n                object_1.extend(attrs, defaults.line);\n            }\n            return new base_glyph.constructor(attrs);\n        };\n        this.glyph = this.build_glyph_view(base_glyph);\n        selection_glyph = this.model.selection_glyph;\n        if (selection_glyph == null) {\n            selection_glyph = mk_glyph({\n                fill: {},\n                line: {}\n            });\n        }\n        else if (selection_glyph === \"auto\") {\n            selection_glyph = mk_glyph(this.model.selection_defaults);\n        }\n        this.selection_glyph = this.build_glyph_view(selection_glyph);\n        nonselection_glyph = this.model.nonselection_glyph;\n        if (nonselection_glyph == null) {\n            nonselection_glyph = mk_glyph({\n                fill: {},\n                line: {}\n            });\n        }\n        else if (nonselection_glyph === \"auto\") {\n            nonselection_glyph = mk_glyph(this.model.nonselection_defaults);\n        }\n        this.nonselection_glyph = this.build_glyph_view(nonselection_glyph);\n        hover_glyph = this.model.hover_glyph;\n        if (hover_glyph != null) {\n            this.hover_glyph = this.build_glyph_view(hover_glyph);\n        }\n        muted_glyph = this.model.muted_glyph;\n        if (muted_glyph != null) {\n            this.muted_glyph = this.build_glyph_view(muted_glyph);\n        }\n        decimated_glyph = mk_glyph(this.model.decimated_defaults);\n        this.decimated_glyph = this.build_glyph_view(decimated_glyph);\n        this.xmapper = this.plot_view.frame.x_mappers[this.model.x_range_name];\n        this.ymapper = this.plot_view.frame.y_mappers[this.model.y_range_name];\n        this.set_data(false);\n        if (this.model.data_source instanceof remote_data_source_1.RemoteDataSource) {\n            return this.model.data_source.setup(this.plot_view, this.glyph);\n        }\n    };\n    GlyphRendererView.prototype.build_glyph_view = function (model) {\n        return new model.default_view({\n            model: model,\n            renderer: this,\n            plot_view: this.plot_view\n        });\n    };\n    GlyphRendererView.prototype.bind_bokeh_events = function () {\n        this.listenTo(this.model, 'change', this.request_render);\n        this.listenTo(this.model.data_source, 'change', this.set_data);\n        this.listenTo(this.model.data_source, 'patch', this.set_data);\n        this.listenTo(this.model.data_source, 'stream', this.set_data);\n        this.listenTo(this.model.data_source, 'select', this.request_render);\n        if (this.hover_glyph != null) {\n            this.listenTo(this.model.data_source, 'inspect', this.request_render);\n        }\n        this.listenTo(this.model.glyph, 'transformchange', function () {\n            return this.set_data();\n        });\n        return this.listenTo(this.model.glyph, 'propchange', function () {\n            this.glyph.set_visuals(this.model.data_source);\n            return this.request_render();\n        });\n    };\n    GlyphRendererView.prototype.have_selection_glyphs = function () {\n        return (this.selection_glyph != null) && (this.nonselection_glyph != null);\n    };\n    GlyphRendererView.prototype.set_data = function (request_render, arg) {\n        var dt, i, j, k, length, lod_factor, ref, results, source, t0;\n        if (request_render == null) {\n            request_render = true;\n        }\n        t0 = Date.now();\n        source = this.model.data_source;\n        this.glyph.model.setv({\n            x_range_name: this.model.x_range_name,\n            y_range_name: this.model.y_range_name\n        }, {\n            silent: true\n        });\n        this.glyph.set_data(source, arg);\n        this.glyph.set_visuals(source);\n        this.decimated_glyph.set_visuals(source);\n        if (this.have_selection_glyphs()) {\n            this.selection_glyph.set_visuals(source);\n            this.nonselection_glyph.set_visuals(source);\n        }\n        if (this.hover_glyph != null) {\n            this.hover_glyph.set_visuals(source);\n        }\n        if (this.muted_glyph != null) {\n            this.muted_glyph.set_visuals(source);\n        }\n        length = source.get_length();\n        if (length == null) {\n            length = 1;\n        }\n        this.all_indices = (function () {\n            results = [];\n            for (var j = 0; 0 <= length ? j < length : j > length; 0 <= length ? j++ : j--) {\n                results.push(j);\n            }\n            return results;\n        }).apply(this);\n        lod_factor = this.plot_model.plot.lod_factor;\n        this.decimated = [];\n        for (i = k = 0, ref = Math.floor(this.all_indices.length / lod_factor); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            this.decimated.push(this.all_indices[i * lod_factor]);\n        }\n        dt = Date.now() - t0;\n        logging_1.logger.debug(this.glyph.model.type + \" GlyphRenderer (\" + this.model.id + \"): set_data finished in \" + dt + \"ms\");\n        this.set_data_timestamp = Date.now();\n        if (request_render) {\n            return this.request_render();\n        }\n    };\n    GlyphRendererView.prototype.render = function () {\n        var ctx, dtmap, dtmask, dtrender, dtselect, dttot, glsupport, glyph, i, indices, inspected, j, k, len, len1, lod_threshold, nonselected, nonselection_glyph, selected, selected_mask, selection_glyph, t0, tmap, tmask, trender, tselect;\n        if (!this.model.visible) {\n            return;\n        }\n        t0 = Date.now();\n        glsupport = this.glyph.glglyph;\n        tmap = Date.now();\n        this.glyph.map_data();\n        dtmap = Date.now() - t0;\n        tmask = Date.now();\n        indices = this.glyph.mask_data(this.all_indices);\n        dtmask = Date.now() - tmask;\n        ctx = this.plot_view.canvas_view.ctx;\n        ctx.save();\n        selected = this.model.data_source.selected;\n        if (!selected || selected.length === 0) {\n            selected = [];\n        }\n        else {\n            if (selected['0d'].glyph) {\n                selected = indices;\n            }\n            else if (selected['1d'].indices.length > 0) {\n                selected = selected['1d'].indices;\n            }\n            else {\n                selected = [];\n            }\n        }\n        inspected = this.model.data_source.inspected;\n        if (!inspected || inspected.length === 0) {\n            inspected = [];\n        }\n        else {\n            if (inspected['0d'].glyph) {\n                inspected = indices;\n            }\n            else if (inspected['1d'].indices.length > 0) {\n                inspected = inspected['1d'].indices;\n            }\n            else {\n                inspected = [];\n            }\n        }\n        lod_threshold = this.plot_model.plot.lod_threshold;\n        if (this.plot_view.interactive && !glsupport && (lod_threshold != null) && this.all_indices.length > lod_threshold) {\n            indices = this.decimated;\n            glyph = this.decimated_glyph;\n            nonselection_glyph = this.decimated_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        else {\n            glyph = this.model.muted && (this.muted_glyph != null) ? this.muted_glyph : this.glyph;\n            nonselection_glyph = this.nonselection_glyph;\n            selection_glyph = this.selection_glyph;\n        }\n        if ((this.hover_glyph != null) && inspected.length) {\n            indices = array_1.difference(indices, inspected);\n        }\n        if (!(selected.length && this.have_selection_glyphs())) {\n            trender = Date.now();\n            glyph.render(ctx, indices, this.glyph);\n            if (this.hover_glyph && inspected.length) {\n                this.hover_glyph.render(ctx, inspected, this.glyph);\n            }\n            dtrender = Date.now() - trender;\n        }\n        else {\n            tselect = Date.now();\n            selected_mask = {};\n            for (j = 0, len = selected.length; j < len; j++) {\n                i = selected[j];\n                selected_mask[i] = true;\n            }\n            selected = new Array();\n            nonselected = new Array();\n            for (k = 0, len1 = indices.length; k < len1; k++) {\n                i = indices[k];\n                if (selected_mask[i] != null) {\n                    selected.push(i);\n                }\n                else {\n                    nonselected.push(i);\n                }\n            }\n            dtselect = Date.now() - tselect;\n            trender = Date.now();\n            nonselection_glyph.render(ctx, nonselected, this.glyph);\n            selection_glyph.render(ctx, selected, this.glyph);\n            if (this.hover_glyph != null) {\n                this.hover_glyph.render(ctx, inspected, this.glyph);\n            }\n            dtrender = Date.now() - trender;\n        }\n        this.last_dtrender = dtrender;\n        dttot = Date.now() - t0;\n        logging_1.logger.debug(this.glyph.model.type + \" GlyphRenderer (\" + this.model.id + \"): render finished in \" + dttot + \"ms\");\n        logging_1.logger.trace(\" - map_data finished in       : \" + dtmap + \"ms\");\n        if (dtmask != null) {\n            logging_1.logger.trace(\" - mask_data finished in      : \" + dtmask + \"ms\");\n        }\n        if (dtselect != null) {\n            logging_1.logger.trace(\" - selection mask finished in : \" + dtselect + \"ms\");\n        }\n        logging_1.logger.trace(\" - glyph renders finished in  : \" + dtrender + \"ms\");\n        return ctx.restore();\n    };\n    GlyphRendererView.prototype.map_to_screen = function (x, y) {\n        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    GlyphRendererView.prototype.draw_legend = function (ctx, x0, x1, y0, y1, field, label) {\n        var index;\n        index = this.model.get_reference_point(field, label);\n        return this.glyph.draw_legend_for_index(ctx, x0, x1, y0, y1, index);\n    };\n    GlyphRendererView.prototype.hit_test = function (geometry) {\n        return this.glyph.hit_test(geometry);\n    };\n    return GlyphRendererView;\n})(renderer_1.RendererView);\nexports.GlyphRenderer = (function (superClass) {\n    extend1(GlyphRenderer, superClass);\n    function GlyphRenderer() {\n        return GlyphRenderer.__super__.constructor.apply(this, arguments);\n    }\n    GlyphRenderer.prototype.default_view = exports.GlyphRendererView;\n    GlyphRenderer.prototype.type = 'GlyphRenderer';\n    GlyphRenderer.prototype.get_reference_point = function (field, value) {\n        var data, i, index;\n        index = 0;\n        if ((field != null) && (this.data_source.get_column != null)) {\n            data = this.data_source.get_column(field);\n            if (data) {\n                i = data.indexOf(value);\n                if (i > 0) {\n                    index = i;\n                }\n            }\n        }\n        return index;\n    };\n    GlyphRenderer.define({\n        x_range_name: [p.String, 'default'],\n        y_range_name: [p.String, 'default'],\n        data_source: [p.Instance],\n        glyph: [p.Instance],\n        hover_glyph: [p.Instance],\n        nonselection_glyph: [p.Any, 'auto'],\n        selection_glyph: [p.Any, 'auto'],\n        muted_glyph: [p.Instance],\n        muted: [p.Bool, false]\n    });\n    GlyphRenderer.override({\n        level: 'glyph'\n    });\n    GlyphRenderer.prototype.selection_defaults = {\n        fill: {},\n        line: {}\n    };\n    GlyphRenderer.prototype.decimated_defaults = {\n        fill: {\n            fill_alpha: 0.3,\n            fill_color: \"grey\"\n        },\n        line: {\n            line_alpha: 0.3,\n            line_color: \"grey\"\n        }\n    };\n    GlyphRenderer.prototype.nonselection_defaults = {\n        fill: {\n            fill_alpha: 0.2,\n            line_alpha: 0.2\n        },\n        line: {}\n    };\n    return GlyphRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar renderer_1 = require(\"./renderer\");\nvar p = require(\"core/properties\");\nexports.GuideRenderer = (function (superClass) {\n    extend(GuideRenderer, superClass);\n    function GuideRenderer() {\n        return GuideRenderer.__super__.constructor.apply(this, arguments);\n    }\n    GuideRenderer.prototype.type = 'GuideRenderer';\n    GuideRenderer.define({\n        plot: [p.Instance]\n    });\n    GuideRenderer.override({\n        level: 'overlay'\n    });\n    return GuideRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar glyph_renderer_1 = require(\"./glyph_renderer\");\nexports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;\nvar guide_renderer_1 = require(\"./guide_renderer\");\nexports.GuideRenderer = guide_renderer_1.GuideRenderer;\nvar renderer_1 = require(\"./renderer\");\nexports.Renderer = renderer_1.Renderer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend1 = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar visuals_1 = require(\"core/visuals\");\nvar p = require(\"core/properties\");\nvar proj = require(\"core/util/projections\");\nvar object_1 = require(\"core/util/object\");\nvar model_1 = require(\"../../model\");\nexports.RendererView = (function (superClass) {\n    extend1(RendererView, superClass);\n    function RendererView() {\n        return RendererView.__super__.constructor.apply(this, arguments);\n    }\n    RendererView.prototype.initialize = function (options) {\n        RendererView.__super__.initialize.call(this, options);\n        this.plot_view = options.plot_view;\n        return this.visuals = new visuals_1.Visuals(this.model);\n    };\n    RendererView.getters({\n        plot_model: function () {\n            return this.plot_view.model;\n        }\n    });\n    RendererView.prototype.request_render = function () {\n        return this.plot_view.request_render();\n    };\n    RendererView.prototype.set_data = function (source) {\n        var data, ref, ref1;\n        data = this.model.materialize_dataspecs(source);\n        object_1.extend(this, data);\n        if (this.plot_model.use_map) {\n            if (this._x != null) {\n                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];\n            }\n            if (this._xs != null) {\n                return ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1], ref1;\n            }\n        }\n    };\n    RendererView.prototype.map_to_screen = function (x, y) {\n        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n    };\n    return RendererView;\n})(bokeh_view_1.BokehView);\nexports.Renderer = (function (superClass) {\n    extend1(Renderer, superClass);\n    function Renderer() {\n        return Renderer.__super__.constructor.apply(this, arguments);\n    }\n    Renderer.prototype.type = \"Renderer\";\n    Renderer.define({\n        level: [p.RenderLevel, null],\n        visible: [p.Bool, true]\n    });\n    return Renderer;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar remote_data_source_1 = require(\"./remote_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.AjaxDataSource = (function (superClass) {\n    extend(AjaxDataSource, superClass);\n    function AjaxDataSource() {\n        this.get_data = bind(this.get_data, this);\n        this.setup = bind(this.setup, this);\n        this.destroy = bind(this.destroy, this);\n        return AjaxDataSource.__super__.constructor.apply(this, arguments);\n    }\n    AjaxDataSource.prototype.type = 'AjaxDataSource';\n    AjaxDataSource.define({\n        mode: [p.String, 'replace'],\n        content_type: [p.String, 'application/json'],\n        http_headers: [p.Any, {}],\n        max_size: [p.Number],\n        method: [p.String, 'POST'],\n        if_modified: [p.Bool, false]\n    });\n    AjaxDataSource.prototype.destroy = function () {\n        if (this.interval != null) {\n            return clearInterval(this.interval);\n        }\n    };\n    AjaxDataSource.prototype.setup = function (plot_view, glyph) {\n        this.pv = plot_view;\n        this.get_data(this.mode);\n        if (this.polling_interval) {\n            return this.interval = setInterval(this.get_data, this.polling_interval, this.mode, this.max_size, this.if_modified);\n        }\n    };\n    AjaxDataSource.prototype.get_data = function (mode, max_size, if_modified) {\n        var name, ref, value, xhr;\n        if (max_size == null) {\n            max_size = 0;\n        }\n        if (if_modified == null) {\n            if_modified = false;\n        }\n        xhr = new XMLHttpRequest();\n        xhr.open(this.method, this.data_url, true);\n        xhr.withCredentials = false;\n        xhr.setRequestHeader(\"Content-Type\", this.content_type);\n        ref = this.http_headers;\n        for (name in ref) {\n            value = ref[name];\n            xhr.setRequestHeader(name, value);\n        }\n        xhr.addEventListener(\"load\", (function (_this) {\n            return function () {\n                var column, data, i, len, original_data, ref1;\n                if (xhr.status === 200) {\n                    data = JSON.parse(xhr.responseText);\n                    switch (mode) {\n                        case 'replace':\n                            return _this.data = data;\n                        case 'append':\n                            original_data = _this.data;\n                            ref1 = _this.columns();\n                            for (i = 0, len = ref1.length; i < len; i++) {\n                                column = ref1[i];\n                                data[column] = original_data[column].concat(data[column]).slice(-max_size);\n                            }\n                            return _this.data = data;\n                    }\n                }\n            };\n        })(this));\n        xhr.addEventListener(\"error\", (function (_this) {\n            return function () {\n                return logging_1.logger.error(\"Failed to fetch JSON from \" + _this.data_url + \" with code \" + xhr.status);\n            };\n        })(this));\n        xhr.send();\n        return null;\n    };\n    return AjaxDataSource;\n})(remote_data_source_1.RemoteDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nvar has_props_1 = require(\"core/has_props\");\nvar p = require(\"core/properties\");\nvar serialization = require(\"core/util/serialization\");\nvar types_1 = require(\"core/util/types\");\nexports.concat_typed_arrays = function (a, b) {\n    var c;\n    c = new a.constructor(a.length + b.length);\n    c.set(a, 0);\n    c.set(b, a.length);\n    return c;\n};\nexports.stream_to_column = function (col, new_col, rollover) {\n    var end, i, j, l, ref, ref1, ref2, start, tmp, total_len;\n    if (col.concat != null) {\n        col = col.concat(new_col);\n        if (col.length > rollover) {\n            col = col.slice(-rollover);\n        }\n        return col;\n    }\n    total_len = col.length + new_col.length;\n    if ((rollover != null) && total_len > rollover) {\n        start = total_len - rollover;\n        end = col.length;\n        if (col.length < rollover) {\n            tmp = new col.constructor(rollover);\n            tmp.set(col, 0);\n            col = tmp;\n        }\n        for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n            col[i - start] = col[i];\n        }\n        for (i = l = 0, ref2 = new_col.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {\n            col[i + (end - start)] = new_col[i];\n        }\n        return col;\n    }\n    tmp = new col.constructor(new_col);\n    return exports.concat_typed_arrays(col, tmp);\n};\nexports.patch_to_column = function (col, patch) {\n    var i, ind, j, ref, ref1, results, value;\n    results = [];\n    for (i = j = 0, ref = patch.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        ref1 = patch[i], ind = ref1[0], value = ref1[1];\n        results.push(col[ind] = value);\n    }\n    return results;\n};\nexports.ColumnDataSource = (function (superClass) {\n    extend(ColumnDataSource, superClass);\n    function ColumnDataSource() {\n        return ColumnDataSource.__super__.constructor.apply(this, arguments);\n    }\n    ColumnDataSource.prototype.type = 'ColumnDataSource';\n    ColumnDataSource.prototype.initialize = function (options) {\n        var ref;\n        ColumnDataSource.__super__.initialize.call(this, options);\n        return ref = serialization.decode_column_data(this.data), this.data = ref[0], this._shapes = ref[1], ref;\n    };\n    ColumnDataSource.define({\n        data: [p.Any, {}]\n    });\n    ColumnDataSource.prototype.attributes_as_json = function (include_defaults, value_to_json) {\n        var attrs, key, ref, value;\n        if (include_defaults == null) {\n            include_defaults = true;\n        }\n        if (value_to_json == null) {\n            value_to_json = ColumnDataSource._value_to_json;\n        }\n        attrs = {};\n        ref = this.serializable_attributes();\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            value = ref[key];\n            if (key === 'data') {\n                value = serialization.encode_column_data(value, this._shapes);\n            }\n            if (include_defaults) {\n                attrs[key] = value;\n            }\n            else if (key in this._set_after_defaults) {\n                attrs[key] = value;\n            }\n        }\n        return value_to_json(\"attributes\", attrs, this);\n    };\n    ColumnDataSource._value_to_json = function (key, value, optional_parent_object) {\n        if (types_1.isObject(value) && key === 'data') {\n            return serialization.encode_column_data(value, optional_parent_object._shapes);\n        }\n        else {\n            return has_props_1.HasProps._value_to_json(key, value, optional_parent_object);\n        }\n    };\n    ColumnDataSource.prototype.stream = function (new_data, rollover) {\n        var data, k, v;\n        data = this.data;\n        for (k in new_data) {\n            v = new_data[k];\n            data[k] = exports.stream_to_column(data[k], new_data[k], rollover);\n        }\n        this.setv('data', data, {\n            silent: true\n        });\n        return this.trigger('stream');\n    };\n    ColumnDataSource.prototype.patch = function (patches) {\n        var data, k, patch;\n        data = this.data;\n        for (k in patches) {\n            patch = patches[k];\n            exports.patch_to_column(data[k], patch);\n        }\n        this.setv('data', data, {\n            silent: true\n        });\n        return this.trigger('patch');\n    };\n    return ColumnDataSource;\n})(columnar_data_source_1.ColumnarDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar data_source_1 = require(\"./data_source\");\nvar logging_1 = require(\"core/logging\");\nvar selection_manager_1 = require(\"core/selection_manager\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.ColumnarDataSource = (function (superClass) {\n    extend(ColumnarDataSource, superClass);\n    function ColumnarDataSource() {\n        return ColumnarDataSource.__super__.constructor.apply(this, arguments);\n    }\n    ColumnarDataSource.prototype.type = 'ColumnarDataSource';\n    ColumnarDataSource.define({\n        column_names: [p.Array, []]\n    });\n    ColumnarDataSource.internal({\n        selection_manager: [\n            p.Instance, function (self) {\n                return new selection_manager_1.SelectionManager({\n                    source: self\n                });\n            }\n        ],\n        inspected: [p.Any],\n        _shapes: [p.Any, {}]\n    });\n    ColumnarDataSource.prototype.get_column = function (colname) {\n        var ref;\n        return (ref = this.data[colname]) != null ? ref : null;\n    };\n    ColumnarDataSource.prototype.columns = function () {\n        return Object.keys(this.data);\n    };\n    ColumnarDataSource.prototype.get_length = function (soft) {\n        var _key, lengths, msg, val;\n        if (soft == null) {\n            soft = true;\n        }\n        lengths = array_1.uniq((function () {\n            var ref, results;\n            ref = this.data;\n            results = [];\n            for (_key in ref) {\n                val = ref[_key];\n                results.push(val.length);\n            }\n            return results;\n        }).call(this));\n        switch (lengths.length) {\n            case 0:\n                return null;\n            case 1:\n                return lengths[0];\n            default:\n                msg = \"data source has columns of inconsistent lengths\";\n                if (soft) {\n                    logging_1.logger.warn(msg);\n                    return lengths.sort()[0];\n                }\n                else {\n                    throw new Error(msg);\n                }\n        }\n    };\n    return ColumnarDataSource;\n})(data_source_1.DataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar hittest = require(\"core/hittest\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.DataSource = (function (superClass) {\n    extend(DataSource, superClass);\n    function DataSource() {\n        return DataSource.__super__.constructor.apply(this, arguments);\n    }\n    DataSource.prototype.type = 'DataSource';\n    DataSource.define({\n        selected: [p.Any, hittest.create_hit_test_result()],\n        callback: [p.Any]\n    });\n    DataSource.prototype.initialize = function (options) {\n        DataSource.__super__.initialize.call(this, options);\n        return this.listenTo(this, 'change:selected', (function (_this) {\n            return function () {\n                var callback;\n                callback = _this.callback;\n                if (callback != null) {\n                    if (types_1.isFunction(callback)) {\n                        return callback(_this);\n                    }\n                    else {\n                        return callback.execute(_this);\n                    }\n                }\n            };\n        })(this));\n    };\n    return DataSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.GeoJSONDataSource = (function (superClass) {\n    extend(GeoJSONDataSource, superClass);\n    function GeoJSONDataSource() {\n        return GeoJSONDataSource.__super__.constructor.apply(this, arguments);\n    }\n    GeoJSONDataSource.prototype.type = 'GeoJSONDataSource';\n    GeoJSONDataSource.define({\n        geojson: [p.Any]\n    });\n    GeoJSONDataSource.internal({\n        data: [p.Any, {}]\n    });\n    GeoJSONDataSource.prototype.initialize = function (options) {\n        GeoJSONDataSource.__super__.initialize.call(this, options);\n        this._update_data();\n        return this.listenTo(this, 'change:geojson', (function (_this) {\n            return function () {\n                return _this._update_data();\n            };\n        })(this));\n    };\n    GeoJSONDataSource.prototype._update_data = function () {\n        return this.data = this.geojson_to_column_data();\n    };\n    GeoJSONDataSource.prototype._get_new_list_array = function (length) {\n        var i, k, ref, results;\n        results = [];\n        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            results.push([]);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._get_new_nan_array = function (length) {\n        var i, k, ref, results;\n        results = [];\n        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            results.push(0 / 0);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._flatten_function = function (accumulator, currentItem) {\n        return accumulator.concat([[0 / 0, 0 / 0, 0 / 0]]).concat(currentItem);\n    };\n    GeoJSONDataSource.prototype._add_properties = function (item, data, i, item_count) {\n        var property, results;\n        results = [];\n        for (property in item.properties) {\n            if (!data.hasOwnProperty(property)) {\n                data[property] = this._get_new_nan_array(item_count);\n            }\n            results.push(data[property][i] = item.properties[property]);\n        }\n        return results;\n    };\n    GeoJSONDataSource.prototype._add_geometry = function (geometry, data, i) {\n        var coord_list, coords, exterior_ring, exterior_rings, flattened_coord_list, j, k, l, len, len1, len2, len3, len4, m, n, o, polygon, ref, ref1, ref2, ref3, ref4, ref5, results, results1, results2, results3;\n        switch (geometry.type) {\n            case \"Point\":\n                coords = geometry.coordinates;\n                data.x[i] = coords[0];\n                data.y[i] = coords[1];\n                return data.z[i] = (ref = coords[2]) != null ? ref : 0 / 0;\n            case \"LineString\":\n                coord_list = geometry.coordinates;\n                results = [];\n                for (j = k = 0, len = coord_list.length; k < len; j = ++k) {\n                    coords = coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results.push(data.zs[i][j] = (ref1 = coords[2]) != null ? ref1 : 0 / 0);\n                }\n                return results;\n                break;\n            case \"Polygon\":\n                if (geometry.coordinates.length > 1) {\n                    logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                }\n                exterior_ring = geometry.coordinates[0];\n                results1 = [];\n                for (j = l = 0, len1 = exterior_ring.length; l < len1; j = ++l) {\n                    coords = exterior_ring[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results1.push(data.zs[i][j] = (ref2 = coords[2]) != null ? ref2 : 0 / 0);\n                }\n                return results1;\n                break;\n            case \"MultiPoint\":\n                return logging_1.logger.warn('MultiPoint not supported in Bokeh');\n            case \"MultiLineString\":\n                flattened_coord_list = geometry.coordinates.reduce(this._flatten_function);\n                results2 = [];\n                for (j = m = 0, len2 = flattened_coord_list.length; m < len2; j = ++m) {\n                    coords = flattened_coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results2.push(data.zs[i][j] = (ref3 = coords[2]) != null ? ref3 : 0 / 0);\n                }\n                return results2;\n                break;\n            case \"MultiPolygon\":\n                exterior_rings = [];\n                ref4 = geometry.coordinates;\n                for (n = 0, len3 = ref4.length; n < len3; n++) {\n                    polygon = ref4[n];\n                    if (polygon.length > 1) {\n                        logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                    }\n                    exterior_rings.push(polygon[0]);\n                }\n                flattened_coord_list = exterior_rings.reduce(this._flatten_function);\n                results3 = [];\n                for (j = o = 0, len4 = flattened_coord_list.length; o < len4; j = ++o) {\n                    coords = flattened_coord_list[j];\n                    data.xs[i][j] = coords[0];\n                    data.ys[i][j] = coords[1];\n                    results3.push(data.zs[i][j] = (ref5 = coords[2]) != null ? ref5 : 0 / 0);\n                }\n                return results3;\n                break;\n            default:\n                throw new Error('Invalid type ' + geometry.type);\n        }\n    };\n    GeoJSONDataSource.prototype._get_items_length = function (items) {\n        var count, g, geometry, i, item, j, k, l, len, len1, ref;\n        count = 0;\n        for (i = k = 0, len = items.length; k < len; i = ++k) {\n            item = items[i];\n            geometry = item.type === 'Feature' ? item.geometry : item;\n            if (geometry.type === 'GeometryCollection') {\n                ref = geometry.geometries;\n                for (j = l = 0, len1 = ref.length; l < len1; j = ++l) {\n                    g = ref[j];\n                    count += 1;\n                }\n            }\n            else {\n                count += 1;\n            }\n        }\n        return count;\n    };\n    GeoJSONDataSource.prototype.geojson_to_column_data = function () {\n        var arr_index, data, g, geojson, geometry, i, item, item_count, items, j, k, l, len, len1, ref, ref1;\n        geojson = JSON.parse(this.geojson);\n        if ((ref = geojson.type) !== 'GeometryCollection' && ref !== 'FeatureCollection') {\n            throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\n        }\n        if (geojson.type === 'GeometryCollection') {\n            if (geojson.geometries == null) {\n                throw new Error('No geometries found in GeometryCollection');\n            }\n            if (geojson.geometries.length === 0) {\n                throw new Error('geojson.geometries must have one or more items');\n            }\n            items = geojson.geometries;\n        }\n        if (geojson.type === 'FeatureCollection') {\n            if (geojson.features == null) {\n                throw new Error('No features found in FeaturesCollection');\n            }\n            if (geojson.features.length === 0) {\n                throw new Error('geojson.features must have one or more items');\n            }\n            items = geojson.features;\n        }\n        item_count = this._get_items_length(items);\n        data = {\n            'x': this._get_new_nan_array(item_count),\n            'y': this._get_new_nan_array(item_count),\n            'z': this._get_new_nan_array(item_count),\n            'xs': this._get_new_list_array(item_count),\n            'ys': this._get_new_list_array(item_count),\n            'zs': this._get_new_list_array(item_count)\n        };\n        arr_index = 0;\n        for (i = k = 0, len = items.length; k < len; i = ++k) {\n            item = items[i];\n            geometry = item.type === 'Feature' ? item.geometry : item;\n            if (geometry.type === 'GeometryCollection') {\n                ref1 = geometry.geometries;\n                for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {\n                    g = ref1[j];\n                    this._add_geometry(g, data, arr_index);\n                    if (item.type === 'Feature') {\n                        this._add_properties(item, data, arr_index, item_count);\n                    }\n                    arr_index += 1;\n                }\n            }\n            else {\n                this._add_geometry(geometry, data, arr_index);\n                if (item.type === 'Feature') {\n                    this._add_properties(item, data, arr_index, item_count);\n                }\n                arr_index += 1;\n            }\n        }\n        return data;\n    };\n    return GeoJSONDataSource;\n})(columnar_data_source_1.ColumnarDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ajax_data_source_1 = require(\"./ajax_data_source\");\nexports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;\nvar column_data_source_1 = require(\"./column_data_source\");\nexports.ColumnDataSource = column_data_source_1.ColumnDataSource;\nvar columnar_data_source_1 = require(\"./columnar_data_source\");\nexports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;\nvar data_source_1 = require(\"./data_source\");\nexports.DataSource = data_source_1.DataSource;\nvar geojson_data_source_1 = require(\"./geojson_data_source\");\nexports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;\nvar remote_data_source_1 = require(\"./remote_data_source\");\nexports.RemoteDataSource = remote_data_source_1.RemoteDataSource;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar column_data_source_1 = require(\"./column_data_source\");\nvar p = require(\"core/properties\");\nexports.RemoteDataSource = (function (superClass) {\n    extend(RemoteDataSource, superClass);\n    function RemoteDataSource() {\n        return RemoteDataSource.__super__.constructor.apply(this, arguments);\n    }\n    RemoteDataSource.prototype.type = 'RemoteDataSource';\n    RemoteDataSource.define({\n        data_url: [p.String],\n        polling_interval: [p.Number]\n    });\n    return RemoteDataSource;\n})(column_data_source_1.ColumnDataSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar clamp, log, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nclamp = function (x, min_val, max_val) {\n    return Math.max(min_val, Math.min(max_val, x));\n};\nlog = function (x, base) {\n    if (base == null) {\n        base = Math.E;\n    }\n    return Math.log(x) / Math.log(base);\n};\nexports.AdaptiveTicker = (function (superClass) {\n    extend(AdaptiveTicker, superClass);\n    function AdaptiveTicker() {\n        return AdaptiveTicker.__super__.constructor.apply(this, arguments);\n    }\n    AdaptiveTicker.prototype.type = 'AdaptiveTicker';\n    AdaptiveTicker.define({\n        base: [p.Number, 10.0],\n        mantissas: [p.Array, [1, 2, 5]],\n        min_interval: [p.Number, 0.0],\n        max_interval: [p.Number]\n    });\n    AdaptiveTicker.prototype.initialize = function (attrs, options) {\n        var prefix_mantissa, suffix_mantissa;\n        AdaptiveTicker.__super__.initialize.call(this, attrs, options);\n        prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;\n        suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;\n        this.extended_mantissas = [prefix_mantissa].concat(slice.call(this.mantissas), [suffix_mantissa]);\n        return this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\n    };\n    AdaptiveTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {\n        var best_mantissa, candidate_mantissas, data_range, errors, ideal_interval, ideal_magnitude, ideal_mantissa, interval, interval_exponent;\n        data_range = data_high - data_low;\n        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n        interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\n        ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor;\n        ideal_mantissa = ideal_interval / ideal_magnitude;\n        candidate_mantissas = this.extended_mantissas;\n        errors = candidate_mantissas.map(function (mantissa) {\n            return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));\n        });\n        best_mantissa = candidate_mantissas[array_1.argmin(errors)];\n        interval = best_mantissa * ideal_magnitude;\n        return clamp(interval, this.get_min_interval(), this.get_max_interval());\n    };\n    return AdaptiveTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.BasicTicker = (function (superClass) {\n    extend(BasicTicker, superClass);\n    function BasicTicker() {\n        return BasicTicker.__super__.constructor.apply(this, arguments);\n    }\n    BasicTicker.prototype.type = 'BasicTicker';\n    return BasicTicker;\n})(adaptive_ticker_1.AdaptiveTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar ticker_1 = require(\"./ticker\");\nexports.CategoricalTicker = (function (superClass) {\n    extend(CategoricalTicker, superClass);\n    function CategoricalTicker() {\n        return CategoricalTicker.__super__.constructor.apply(this, arguments);\n    }\n    CategoricalTicker.prototype.type = 'CategoricalTicker';\n    CategoricalTicker.prototype.get_ticks = function (start, end, range, cross_loc, arg) {\n        var desired_n_ticks, factors, i, ii, j, majors, ref;\n        desired_n_ticks = arg.desired_n_ticks;\n        majors = [];\n        factors = range.factors;\n        for (i = j = 0, ref = factors.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            ii = i + range.offset;\n            if ((ii + 1) > start && (ii + 1) < end) {\n                majors.push(factors[i]);\n            }\n        }\n        return {\n            \"major\": majors,\n            \"minor\": []\n        };\n    };\n    return CategoricalTicker;\n})(ticker_1.Ticker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.CompositeTicker = (function (superClass) {\n    extend(CompositeTicker, superClass);\n    function CompositeTicker() {\n        return CompositeTicker.__super__.constructor.apply(this, arguments);\n    }\n    CompositeTicker.prototype.type = 'CompositeTicker';\n    CompositeTicker.define({\n        tickers: [p.Array, []]\n    });\n    CompositeTicker.getters({\n        min_intervals: function () {\n            var i, len, ref, results, ticker;\n            ref = this.tickers;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                ticker = ref[i];\n                results.push(ticker.get_min_interval());\n            }\n            return results;\n        },\n        max_intervals: function () {\n            var i, len, ref, results, ticker;\n            ref = this.tickers;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                ticker = ref[i];\n                results.push(ticker.get_max_interval());\n            }\n            return results;\n        },\n        min_interval: function () {\n            return this.min_intervals[0];\n        },\n        max_interval: function () {\n            return this.max_intervals[0];\n        }\n    });\n    CompositeTicker.prototype.get_best_ticker = function (data_low, data_high, desired_n_ticks) {\n        var best_index, best_ticker, best_ticker_ndx, data_range, errors, ideal_interval, intervals, ticker_ndxs;\n        data_range = data_high - data_low;\n        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n        ticker_ndxs = [array_1.sortedIndex(this.min_intervals, ideal_interval) - 1, array_1.sortedIndex(this.max_intervals, ideal_interval)];\n        intervals = [this.min_intervals[ticker_ndxs[0]], this.max_intervals[ticker_ndxs[1]]];\n        errors = intervals.map(function (interval) {\n            return Math.abs(desired_n_ticks - (data_range / interval));\n        });\n        best_index = array_1.argmin(errors);\n        if (best_index === 2e308) {\n            return this.tickers[0];\n        }\n        best_ticker_ndx = ticker_ndxs[best_index];\n        best_ticker = this.tickers[best_ticker_ndx];\n        return best_ticker;\n    };\n    CompositeTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {\n        var best_ticker;\n        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n        return best_ticker.get_interval(data_low, data_high, desired_n_ticks);\n    };\n    CompositeTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var best_ticker, ticks;\n        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n        ticks = best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);\n        return ticks;\n    };\n    return CompositeTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar ticker_1 = require(\"./ticker\");\nvar p = require(\"core/properties\");\nexports.ContinuousTicker = (function (superClass) {\n    extend(ContinuousTicker, superClass);\n    function ContinuousTicker() {\n        return ContinuousTicker.__super__.constructor.apply(this, arguments);\n    }\n    ContinuousTicker.prototype.type = 'ContinuousTicker';\n    ContinuousTicker.define({\n        num_minor_ticks: [p.Number, 5],\n        desired_num_ticks: [p.Number, 6]\n    });\n    ContinuousTicker.prototype.get_interval = void 0;\n    ContinuousTicker.prototype.get_min_interval = function () {\n        return this.min_interval;\n    };\n    ContinuousTicker.prototype.get_max_interval = function () {\n        var ref;\n        return (ref = this.max_interval) != null ? ref : 2e308;\n    };\n    ContinuousTicker.prototype.get_ideal_interval = function (data_low, data_high, desired_n_ticks) {\n        var data_range;\n        data_range = data_high - data_low;\n        return data_range / desired_n_ticks;\n    };\n    return ContinuousTicker;\n})(ticker_1.Ticker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_HOUR, ONE_MILLI, ONE_MINUTE, ONE_MONTH, ONE_SECOND, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nvar composite_ticker_1 = require(\"./composite_ticker\");\nvar days_ticker_1 = require(\"./days_ticker\");\nvar months_ticker_1 = require(\"./months_ticker\");\nvar years_ticker_1 = require(\"./years_ticker\");\nvar util = require(\"./util\");\nONE_MILLI = util.ONE_MILLI;\nONE_SECOND = util.ONE_SECOND;\nONE_MINUTE = util.ONE_MINUTE;\nONE_HOUR = util.ONE_HOUR;\nONE_MONTH = util.ONE_MONTH;\nexports.DatetimeTicker = (function (superClass) {\n    extend(DatetimeTicker, superClass);\n    function DatetimeTicker() {\n        return DatetimeTicker.__super__.constructor.apply(this, arguments);\n    }\n    DatetimeTicker.prototype.type = 'DatetimeTicker';\n    DatetimeTicker.override({\n        num_minor_ticks: 0,\n        tickers: function () {\n            return [\n                new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 5],\n                    base: 10,\n                    min_interval: 0,\n                    max_interval: 500 * ONE_MILLI,\n                    num_minor_ticks: 0\n                }), new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 5, 10, 15, 20, 30],\n                    base: 60,\n                    min_interval: ONE_SECOND,\n                    max_interval: 30 * ONE_MINUTE,\n                    num_minor_ticks: 0\n                }), new adaptive_ticker_1.AdaptiveTicker({\n                    mantissas: [1, 2, 4, 6, 8, 12],\n                    base: 24.0,\n                    min_interval: ONE_HOUR,\n                    max_interval: 12 * ONE_HOUR,\n                    num_minor_ticks: 0\n                }), new days_ticker_1.DaysTicker({\n                    days: array_1.range(1, 32)\n                }), new days_ticker_1.DaysTicker({\n                    days: array_1.range(1, 31, 3)\n                }), new days_ticker_1.DaysTicker({\n                    days: [1, 8, 15, 22]\n                }), new days_ticker_1.DaysTicker({\n                    days: [1, 15]\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 1)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 2)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 4)\n                }), new months_ticker_1.MonthsTicker({\n                    months: array_1.range(0, 12, 6)\n                }), new years_ticker_1.YearsTicker({})\n            ];\n        }\n    });\n    return DatetimeTicker;\n})(composite_ticker_1.CompositeTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_DAY, copy_date, date_range_by_month, last_month_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\ncopy_date = util.copy_date;\nlast_month_no_later_than = util.last_month_no_later_than;\nONE_DAY = util.ONE_DAY;\ndate_range_by_month = function (start_time, end_time) {\n    var date, dates, end_date, prev_end_date, start_date;\n    start_date = last_month_no_later_than(new Date(start_time));\n    end_date = last_month_no_later_than(new Date(end_time));\n    prev_end_date = copy_date(end_date);\n    end_date.setUTCMonth(end_date.getUTCMonth() + 1);\n    dates = [];\n    date = start_date;\n    while (true) {\n        dates.push(copy_date(date));\n        date.setUTCMonth(date.getUTCMonth() + 1);\n        if (date > end_date) {\n            break;\n        }\n    }\n    return dates;\n};\nexports.DaysTicker = (function (superClass) {\n    extend(DaysTicker, superClass);\n    function DaysTicker() {\n        return DaysTicker.__super__.constructor.apply(this, arguments);\n    }\n    DaysTicker.prototype.type = 'DaysTicker';\n    DaysTicker.define({\n        days: [p.Array, []]\n    });\n    DaysTicker.prototype.initialize = function (attrs, options) {\n        var days, interval;\n        attrs.num_minor_ticks = 0;\n        DaysTicker.__super__.initialize.call(this, attrs, options);\n        days = this.days;\n        interval = days.length > 1 ? (days[1] - days[0]) * ONE_DAY : 31 * ONE_DAY;\n        return this.interval = interval;\n    };\n    DaysTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, date, day_date, day_dates, days, days_of_month, interval, month_dates, ticks_in_range;\n        month_dates = date_range_by_month(data_low, data_high);\n        days = this.days;\n        days_of_month = (function (_this) {\n            return function (month_date, interval) {\n                var dates, day, day_date, future_date, i, len;\n                dates = [];\n                for (i = 0, len = days.length; i < len; i++) {\n                    day = days[i];\n                    day_date = copy_date(month_date);\n                    day_date.setUTCDate(day);\n                    future_date = new Date(day_date.getTime() + (interval / 2));\n                    if (future_date.getUTCMonth() === month_date.getUTCMonth()) {\n                        dates.push(day_date);\n                    }\n                }\n                return dates;\n            };\n        })(this);\n        interval = this.interval;\n        day_dates = array_1.concat((function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = month_dates.length; i < len; i++) {\n                date = month_dates[i];\n                results.push(days_of_month(date, interval));\n            }\n            return results;\n        })());\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = day_dates.length; i < len; i++) {\n                day_date = day_dates[i];\n                results.push(day_date.getTime());\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            \"major\": ticks_in_range,\n            \"minor\": []\n        };\n    };\n    return DaysTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nexports.FixedTicker = (function (superClass) {\n    extend(FixedTicker, superClass);\n    function FixedTicker() {\n        return FixedTicker.__super__.constructor.apply(this, arguments);\n    }\n    FixedTicker.prototype.type = 'FixedTicker';\n    FixedTicker.define({\n        ticks: [p.Array, []]\n    });\n    FixedTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        return {\n            major: this.ticks,\n            minor: []\n        };\n    };\n    return FixedTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nexports.BasicTicker = basic_ticker_1.BasicTicker;\nvar categorical_ticker_1 = require(\"./categorical_ticker\");\nexports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;\nvar composite_ticker_1 = require(\"./composite_ticker\");\nexports.CompositeTicker = composite_ticker_1.CompositeTicker;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nexports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;\nvar datetime_ticker_1 = require(\"./datetime_ticker\");\nexports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;\nvar days_ticker_1 = require(\"./days_ticker\");\nexports.DaysTicker = days_ticker_1.DaysTicker;\nvar fixed_ticker_1 = require(\"./fixed_ticker\");\nexports.FixedTicker = fixed_ticker_1.FixedTicker;\nvar log_ticker_1 = require(\"./log_ticker\");\nexports.LogTicker = log_ticker_1.LogTicker;\nvar mercator_ticker_1 = require(\"./mercator_ticker\");\nexports.MercatorTicker = mercator_ticker_1.MercatorTicker;\nvar months_ticker_1 = require(\"./months_ticker\");\nexports.MonthsTicker = months_ticker_1.MonthsTicker;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nexports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;\nvar ticker_1 = require(\"./ticker\");\nexports.Ticker = ticker_1.Ticker;\nvar years_ticker_1 = require(\"./years_ticker\");\nexports.YearsTicker = years_ticker_1.YearsTicker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nvar adaptive_ticker_1 = require(\"./adaptive_ticker\");\nexports.LogTicker = (function (superClass) {\n    extend(LogTicker, superClass);\n    function LogTicker() {\n        return LogTicker.__super__.constructor.apply(this, arguments);\n    }\n    LogTicker.prototype.type = 'LogTicker';\n    LogTicker.override({\n        mantissas: [1, 5]\n    });\n    LogTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var base, end_factor, endlog, factor, factors, i, interval, j, k, l, len, len1, len2, len3, len4, len5, log_high, log_interval, log_low, m, minor_interval, minor_offsets, minor_ticks, n, num_minor_ticks, o, start_factor, startlog, tick, ticks, x;\n        num_minor_ticks = this.num_minor_ticks;\n        minor_ticks = [];\n        base = this.base;\n        log_low = Math.log(data_low) / Math.log(base);\n        log_high = Math.log(data_high) / Math.log(base);\n        log_interval = log_high - log_low;\n        if (log_interval < 2) {\n            interval = this.get_interval(data_low, data_high, desired_n_ticks);\n            start_factor = Math.floor(data_low / interval);\n            end_factor = Math.ceil(data_high / interval);\n            if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor)) {\n                factors = [];\n            }\n            else {\n                factors = array_1.range(start_factor, end_factor + 1);\n            }\n            ticks = (function () {\n                var j, len, results;\n                results = [];\n                for (j = 0, len = factors.length; j < len; j++) {\n                    factor = factors[j];\n                    if (factor !== 0) {\n                        results.push(factor * interval);\n                    }\n                }\n                return results;\n            })();\n            if (num_minor_ticks > 1) {\n                minor_interval = interval / num_minor_ticks;\n                minor_offsets = (function () {\n                    var j, ref, results;\n                    results = [];\n                    for (i = j = 1, ref = num_minor_ticks; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n                        results.push(i * minor_interval);\n                    }\n                    return results;\n                })();\n                for (j = 0, len = minor_offsets.length; j < len; j++) {\n                    x = minor_offsets[j];\n                    minor_ticks.push(ticks[0] - x);\n                }\n                for (k = 0, len1 = ticks.length; k < len1; k++) {\n                    tick = ticks[k];\n                    for (l = 0, len2 = minor_offsets.length; l < len2; l++) {\n                        x = minor_offsets[l];\n                        minor_ticks.push(tick + x);\n                    }\n                }\n            }\n        }\n        else {\n            startlog = Math.ceil(log_low);\n            endlog = Math.floor(log_high);\n            interval = Math.ceil((endlog - startlog) / 9.0);\n            ticks = array_1.range(startlog, endlog, interval);\n            if ((endlog - startlog) % interval === 0) {\n                ticks = ticks.concat([endlog]);\n            }\n            ticks = ticks.map(function (i) {\n                return Math.pow(base, i);\n            });\n            if (num_minor_ticks > 1) {\n                minor_interval = Math.pow(base, interval) / num_minor_ticks;\n                minor_offsets = (function () {\n                    var m, ref, results;\n                    results = [];\n                    for (i = m = 1, ref = num_minor_ticks; 1 <= ref ? m <= ref : m >= ref; i = 1 <= ref ? ++m : --m) {\n                        results.push(i * minor_interval);\n                    }\n                    return results;\n                })();\n                for (m = 0, len3 = minor_offsets.length; m < len3; m++) {\n                    x = minor_offsets[m];\n                    minor_ticks.push(ticks[0] / x);\n                }\n                for (n = 0, len4 = ticks.length; n < len4; n++) {\n                    tick = ticks[n];\n                    for (o = 0, len5 = minor_offsets.length; o < len5; o++) {\n                        x = minor_offsets[o];\n                        minor_ticks.push(tick * x);\n                    }\n                }\n            }\n        }\n        return {\n            major: ticks,\n            minor: minor_ticks\n        };\n    };\n    return LogTicker;\n})(adaptive_ticker_1.AdaptiveTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nvar p = require(\"core/properties\");\nvar proj4_1 = require(\"core/util/proj4\");\nexports.MercatorTicker = (function (superClass) {\n    extend(MercatorTicker, superClass);\n    function MercatorTicker() {\n        return MercatorTicker.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTicker.prototype.type = 'MercatorTicker';\n    MercatorTicker.define({\n        dimension: [p.LatLon]\n    });\n    MercatorTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var _, i, j, k, l, lat, len, len1, len2, len3, lon, proj_cross_loc, proj_high, proj_low, proj_ticks, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tick, ticks;\n        if (this.dimension == null) {\n            throw new Error(\"MercatorTicker.dimension not configured\");\n        }\n        if (this.dimension === \"lon\") {\n            ref = proj4_1.proj4(proj4_1.mercator).inverse([data_low, cross_loc]), proj_low = ref[0], proj_cross_loc = ref[1];\n            ref1 = proj4_1.proj4(proj4_1.mercator).inverse([data_high, cross_loc]), proj_high = ref1[0], proj_cross_loc = ref1[1];\n        }\n        else {\n            ref2 = proj4_1.proj4(proj4_1.mercator).inverse([cross_loc, data_low]), proj_cross_loc = ref2[0], proj_low = ref2[1];\n            ref3 = proj4_1.proj4(proj4_1.mercator).inverse([cross_loc, data_high]), proj_cross_loc = ref3[0], proj_high = ref3[1];\n        }\n        proj_ticks = MercatorTicker.__super__.get_ticks_no_defaults.call(this, proj_low, proj_high, cross_loc, desired_n_ticks);\n        ticks = {\n            major: [],\n            minor: []\n        };\n        if (this.dimension === \"lon\") {\n            ref4 = proj_ticks.major;\n            for (i = 0, len = ref4.length; i < len; i++) {\n                tick = ref4[i];\n                ref5 = proj4_1.proj4(proj4_1.mercator).forward([tick, proj_cross_loc]), lon = ref5[0], _ = ref5[1];\n                ticks.major.push(lon);\n            }\n            ref6 = proj_ticks.minor;\n            for (j = 0, len1 = ref6.length; j < len1; j++) {\n                tick = ref6[j];\n                ref7 = proj4_1.proj4(proj4_1.mercator).forward([tick, proj_cross_loc]), lon = ref7[0], _ = ref7[1];\n                ticks.minor.push(lon);\n            }\n        }\n        else {\n            ref8 = proj_ticks.major;\n            for (k = 0, len2 = ref8.length; k < len2; k++) {\n                tick = ref8[k];\n                ref9 = proj4_1.proj4(proj4_1.mercator).forward([proj_cross_loc, tick]), _ = ref9[0], lat = ref9[1];\n                ticks.major.push(lat);\n            }\n            ref10 = proj_ticks.minor;\n            for (l = 0, len3 = ref10.length; l < len3; l++) {\n                tick = ref10[l];\n                ref11 = proj4_1.proj4(proj4_1.mercator).forward([proj_cross_loc, tick]), _ = ref11[0], lat = ref11[1];\n                ticks.minor.push(lat);\n            }\n        }\n        return ticks;\n    };\n    return MercatorTicker;\n})(basic_ticker_1.BasicTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_MONTH, copy_date, date_range_by_year, last_year_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\ncopy_date = util.copy_date;\nlast_year_no_later_than = util.last_year_no_later_than;\nONE_MONTH = util.ONE_MONTH;\ndate_range_by_year = function (start_time, end_time) {\n    var date, dates, end_date, start_date;\n    start_date = last_year_no_later_than(new Date(start_time));\n    end_date = last_year_no_later_than(new Date(end_time));\n    end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);\n    dates = [];\n    date = start_date;\n    while (true) {\n        dates.push(copy_date(date));\n        date.setUTCFullYear(date.getUTCFullYear() + 1);\n        if (date > end_date) {\n            break;\n        }\n    }\n    return dates;\n};\nexports.MonthsTicker = (function (superClass) {\n    extend(MonthsTicker, superClass);\n    function MonthsTicker() {\n        return MonthsTicker.__super__.constructor.apply(this, arguments);\n    }\n    MonthsTicker.prototype.type = 'MonthsTicker';\n    MonthsTicker.define({\n        months: [p.Array, []]\n    });\n    MonthsTicker.prototype.initialize = function (attrs, options) {\n        var interval, months;\n        MonthsTicker.__super__.initialize.call(this, attrs, options);\n        months = this.months;\n        interval = months.length > 1 ? (months[1] - months[0]) * ONE_MONTH : 12 * ONE_MONTH;\n        return this.interval = interval;\n    };\n    MonthsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, date, month_date, month_dates, months, months_of_year, ticks_in_range, year_dates;\n        year_dates = date_range_by_year(data_low, data_high);\n        months = this.months;\n        months_of_year = function (year_date) {\n            return months.map(function (month) {\n                var month_date;\n                month_date = copy_date(year_date);\n                month_date.setUTCMonth(month);\n                return month_date;\n            });\n        };\n        month_dates = array_1.concat((function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = year_dates.length; i < len; i++) {\n                date = year_dates[i];\n                results.push(months_of_year(date));\n            }\n            return results;\n        })());\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = month_dates.length; i < len; i++) {\n                month_date = month_dates[i];\n                results.push(month_date.getTime());\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            \"major\": ticks_in_range,\n            \"minor\": []\n        };\n    };\n    return MonthsTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar continuous_ticker_1 = require(\"./continuous_ticker\");\nvar p = require(\"core/properties\");\nexports.SingleIntervalTicker = (function (superClass) {\n    extend(SingleIntervalTicker, superClass);\n    function SingleIntervalTicker() {\n        return SingleIntervalTicker.__super__.constructor.apply(this, arguments);\n    }\n    SingleIntervalTicker.prototype.type = 'SingleIntervalTicker';\n    SingleIntervalTicker.define({\n        interval: [p.Number]\n    });\n    SingleIntervalTicker.getters({\n        min_interval: function () {\n            return this.interval;\n        },\n        max_interval: function () {\n            return this.interval;\n        }\n    });\n    SingleIntervalTicker.prototype.get_interval = function (data_low, data_high, n_desired_ticks) {\n        return this.interval;\n    };\n    return SingleIntervalTicker;\n})(continuous_ticker_1.ContinuousTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar array_1 = require(\"core/util/array\");\nvar types_1 = require(\"core/util/types\");\nexports.Ticker = (function (superClass) {\n    extend(Ticker, superClass);\n    function Ticker() {\n        return Ticker.__super__.constructor.apply(this, arguments);\n    }\n    Ticker.prototype.type = 'Ticker';\n    Ticker.prototype.get_ticks = function (data_low, data_high, range, cross_loc, arg) {\n        var desired_n_ticks;\n        desired_n_ticks = arg.desired_n_ticks;\n        return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\n    };\n    Ticker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var end_factor, factor, factors, i, interval, j, k, l, len, len1, len2, minor_interval, minor_offsets, minor_ticks, num_minor_ticks, start_factor, tick, ticks, x;\n        interval = this.get_interval(data_low, data_high, desired_n_ticks);\n        start_factor = Math.floor(data_low / interval);\n        end_factor = Math.ceil(data_high / interval);\n        if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor)) {\n            factors = [];\n        }\n        else {\n            factors = array_1.range(start_factor, end_factor + 1);\n        }\n        ticks = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = factors.length; j < len; j++) {\n                factor = factors[j];\n                results.push(factor * interval);\n            }\n            return results;\n        })();\n        num_minor_ticks = this.num_minor_ticks;\n        minor_ticks = [];\n        if (num_minor_ticks > 1) {\n            minor_interval = interval / num_minor_ticks;\n            minor_offsets = (function () {\n                var j, ref, results;\n                results = [];\n                for (i = j = 1, ref = num_minor_ticks; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n                    results.push(i * minor_interval);\n                }\n                return results;\n            })();\n            for (j = 0, len = minor_offsets.length; j < len; j++) {\n                x = minor_offsets[j];\n                minor_ticks.push(ticks[0] - x);\n            }\n            for (k = 0, len1 = ticks.length; k < len1; k++) {\n                tick = ticks[k];\n                for (l = 0, len2 = minor_offsets.length; l < len2; l++) {\n                    x = minor_offsets[l];\n                    minor_ticks.push(tick + x);\n                }\n            }\n        }\n        return {\n            \"major\": ticks,\n            \"minor\": minor_ticks\n        };\n    };\n    return Ticker;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ONE_MILLI = 1.0;\nexports.ONE_SECOND = 1000.0;\nexports.ONE_MINUTE = 60.0 * exports.ONE_SECOND;\nexports.ONE_HOUR = 60 * exports.ONE_MINUTE;\nexports.ONE_DAY = 24 * exports.ONE_HOUR;\nexports.ONE_MONTH = 30 * exports.ONE_DAY;\nexports.ONE_YEAR = 365 * exports.ONE_DAY;\nexports.copy_date = function (date) {\n    return new Date(date.getTime());\n};\nexports.last_month_no_later_than = function (date) {\n    date = exports.copy_date(date);\n    date.setUTCDate(1);\n    date.setUTCHours(0);\n    date.setUTCMinutes(0);\n    date.setUTCSeconds(0);\n    date.setUTCMilliseconds(0);\n    return date;\n};\nexports.last_year_no_later_than = function (date) {\n    date = exports.last_month_no_later_than(date);\n    date.setUTCMonth(0);\n    return date;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ONE_YEAR, last_year_no_later_than, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar basic_ticker_1 = require(\"./basic_ticker\");\nvar single_interval_ticker_1 = require(\"./single_interval_ticker\");\nvar util = require(\"./util\");\nlast_year_no_later_than = util.last_year_no_later_than;\nONE_YEAR = util.ONE_YEAR;\nexports.YearsTicker = (function (superClass) {\n    extend(YearsTicker, superClass);\n    function YearsTicker() {\n        return YearsTicker.__super__.constructor.apply(this, arguments);\n    }\n    YearsTicker.prototype.type = 'YearsTicker';\n    YearsTicker.prototype.initialize = function (attrs, options) {\n        YearsTicker.__super__.initialize.call(this, attrs, options);\n        this.interval = ONE_YEAR;\n        return this.basic_ticker = new basic_ticker_1.BasicTicker({\n            num_minor_ticks: 0\n        });\n    };\n    YearsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {\n        var all_ticks, end_year, start_year, ticks_in_range, year, years;\n        start_year = last_year_no_later_than(new Date(data_low)).getUTCFullYear();\n        end_year = last_year_no_later_than(new Date(data_high)).getUTCFullYear();\n        years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;\n        all_ticks = (function () {\n            var i, len, results;\n            results = [];\n            for (i = 0, len = years.length; i < len; i++) {\n                year = years[i];\n                results.push(Date.UTC(year, 0, 1));\n            }\n            return results;\n        })();\n        ticks_in_range = all_ticks.filter(function (tick) {\n            return (data_low <= tick && tick <= data_high);\n        });\n        return {\n            major: ticks_in_range,\n            minor: []\n        };\n    };\n    return YearsTicker;\n})(single_interval_ticker_1.SingleIntervalTicker);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nvar p = require(\"core/properties\");\nexports.BBoxTileSource = (function (superClass) {\n    extend(BBoxTileSource, superClass);\n    function BBoxTileSource() {\n        return BBoxTileSource.__super__.constructor.apply(this, arguments);\n    }\n    BBoxTileSource.prototype.type = 'BBoxTileSource';\n    BBoxTileSource.define({\n        use_latlon: [p.Bool, false]\n    });\n    BBoxTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, ref, ref1, xmax, xmin, ymax, ymin;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        if (this.use_latlon) {\n            ref = this.get_tile_geographic_bounds(x, y, z), xmin = ref[0], ymin = ref[1], xmax = ref[2], ymax = ref[3];\n        }\n        else {\n            ref1 = this.get_tile_meter_bounds(x, y, z), xmin = ref1[0], ymin = ref1[1], xmax = ref1[2], ymax = ref1[3];\n        }\n        return image_url.replace(\"{XMIN}\", xmin).replace(\"{YMIN}\", ymin).replace(\"{XMAX}\", xmax).replace(\"{YMAX}\", ymax);\n    };\n    return BBoxTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar renderer_1 = require(\"../renderers/renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nexports.DynamicImageView = (function (superClass) {\n    extend(DynamicImageView, superClass);\n    function DynamicImageView() {\n        this._on_image_error = bind(this._on_image_error, this);\n        this._on_image_load = bind(this._on_image_load, this);\n        return DynamicImageView.__super__.constructor.apply(this, arguments);\n    }\n    DynamicImageView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change', this.request_render);\n    };\n    DynamicImageView.prototype.get_extent = function () {\n        return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\n    };\n    DynamicImageView.prototype._set_data = function () {\n        this.map_plot = this.plot_view.model.plot;\n        this.map_canvas = this.plot_view.canvas_view.ctx;\n        this.map_frame = this.plot_view.frame;\n        this.x_range = this.map_plot.x_range;\n        this.x_mapper = this.map_frame.x_mappers['default'];\n        this.y_range = this.map_plot.y_range;\n        this.y_mapper = this.map_frame.y_mappers['default'];\n        this.lastImage = void 0;\n        return this.extent = this.get_extent();\n    };\n    DynamicImageView.prototype._map_data = function () {\n        return this.initial_extent = this.get_extent();\n    };\n    DynamicImageView.prototype._on_image_load = function (e) {\n        var image_data;\n        image_data = e.target.image_data;\n        image_data.img = e.target;\n        image_data.loaded = true;\n        this.lastImage = image_data;\n        if (this.get_extent().join(':') === image_data.cache_key) {\n            return this.request_render();\n        }\n    };\n    DynamicImageView.prototype._on_image_error = function (e) {\n        var image_data;\n        logging_1.logger.error('Error loading image: #{e.target.src}');\n        image_data = e.target.image_data;\n        return this.model.image_source.remove_image(image_data);\n    };\n    DynamicImageView.prototype._create_image = function (bounds) {\n        var image;\n        image = new Image();\n        image.onload = this._on_image_load;\n        image.onerror = this._on_image_error;\n        image.alt = '';\n        image.image_data = {\n            bounds: bounds,\n            loaded: false,\n            cache_key: bounds.join(':')\n        };\n        this.model.image_source.add_image(image.image_data);\n        image.src = this.model.image_source.get_image_url(bounds[0], bounds[1], bounds[2], bounds[3], Math.ceil(this.map_frame.height), Math.ceil(this.map_frame.width));\n        return image;\n    };\n    DynamicImageView.prototype.render = function (ctx, indices, args) {\n        var extent, image_obj;\n        if (this.map_initialized == null) {\n            this._set_data();\n            this._map_data();\n            this.map_initialized = true;\n        }\n        extent = this.get_extent();\n        if (this.render_timer) {\n            clearTimeout(this.render_timer);\n        }\n        image_obj = this.model.image_source.images[extent.join(':')];\n        if ((image_obj != null) && image_obj.loaded) {\n            this._draw_image(extent.join(':'));\n            return;\n        }\n        if (this.lastImage != null) {\n            this._draw_image(this.lastImage.cache_key);\n        }\n        if (image_obj == null) {\n            return this.render_timer = setTimeout(((function (_this) {\n                return function () {\n                    return _this._create_image(extent);\n                };\n            })(this)), 125);\n        }\n    };\n    DynamicImageView.prototype._draw_image = function (image_key) {\n        var image_obj, ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin;\n        image_obj = this.model.image_source.images[image_key];\n        if (image_obj != null) {\n            this.map_canvas.save();\n            this._set_rect();\n            this.map_canvas.globalAlpha = this.model.alpha;\n            ref = this.plot_view.frame.map_to_screen([image_obj.bounds[0]], [image_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];\n            ref1 = this.plot_view.frame.map_to_screen([image_obj.bounds[2]], [image_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];\n            sxmin = sxmin[0];\n            symin = symin[0];\n            sxmax = sxmax[0];\n            symax = symax[0];\n            sw = sxmax - sxmin;\n            sh = symax - symin;\n            sx = sxmin;\n            sy = symin;\n            this.map_canvas.drawImage(image_obj.img, sx, sy, sw, sh);\n            return this.map_canvas.restore();\n        }\n    };\n    DynamicImageView.prototype._set_rect = function () {\n        var h, l, outline_width, t, w;\n        outline_width = this.plot_model.plot.properties.outline_line_width.value();\n        l = this.plot_view.canvas.vx_to_sx(this.map_frame.left) + (outline_width / 2);\n        t = this.plot_view.canvas.vy_to_sy(this.map_frame.top) + (outline_width / 2);\n        w = this.map_frame.width - outline_width;\n        h = this.map_frame.height - outline_width;\n        this.map_canvas.rect(l, t, w, h);\n        return this.map_canvas.clip();\n    };\n    return DynamicImageView;\n})(renderer_1.RendererView);\nexports.DynamicImageRenderer = (function (superClass) {\n    extend(DynamicImageRenderer, superClass);\n    function DynamicImageRenderer() {\n        return DynamicImageRenderer.__super__.constructor.apply(this, arguments);\n    }\n    DynamicImageRenderer.prototype.default_view = exports.DynamicImageView;\n    DynamicImageRenderer.prototype.type = 'DynamicImageRenderer';\n    DynamicImageRenderer.define({\n        alpha: [p.Number, 1.0],\n        image_source: [p.Instance],\n        render_parents: [p.Bool, true]\n    });\n    DynamicImageRenderer.override({\n        level: 'underlay'\n    });\n    return DynamicImageRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImagePool = (function () {\n    function ImagePool() {\n        this.images = [];\n    }\n    ImagePool.prototype.pop = function () {\n        var img;\n        img = this.images.pop();\n        if (img != null) {\n            return img;\n        }\n        else {\n            return new Image();\n        }\n    };\n    ImagePool.prototype.push = function (img) {\n        if (this.images.length > 50) {\n            return;\n        }\n        if (img.constructor === Array) {\n            return Array.prototype.push.apply(this.images, img);\n        }\n        else {\n            return this.images.push(img);\n        }\n    };\n    return ImagePool;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.ImageSource = (function (superClass) {\n    extend(ImageSource, superClass);\n    ImageSource.prototype.type = 'ImageSource';\n    ImageSource.define({\n        url: [p.String, ''],\n        extra_url_vars: [p.Any, {}]\n    });\n    function ImageSource(options) {\n        if (options == null) {\n            options = {};\n        }\n        ImageSource.__super__.constructor.apply(this, arguments);\n        this.images = {};\n        this.normalize_case();\n    }\n    ImageSource.prototype.normalize_case = function () {\n        'Note: should probably be refactored into subclasses.';\n        var url;\n        url = this.url;\n        url = url.replace('{xmin}', '{XMIN}');\n        url = url.replace('{ymin}', '{YMIN}');\n        url = url.replace('{xmax}', '{XMAX}');\n        url = url.replace('{ymax}', '{YMAX}');\n        url = url.replace('{height}', '{HEIGHT}');\n        url = url.replace('{width}', '{WIDTH}');\n        return this.url = url;\n    };\n    ImageSource.prototype.string_lookup_replace = function (str, lookup) {\n        var key, result_str, value;\n        result_str = str;\n        for (key in lookup) {\n            value = lookup[key];\n            result_str = result_str.replace('{' + key + '}', value.toString());\n        }\n        return result_str;\n    };\n    ImageSource.prototype.add_image = function (image_obj) {\n        return this.images[image_obj.cache_key] = image_obj;\n    };\n    ImageSource.prototype.remove_image = function (image_obj) {\n        return delete this.images[image_obj.cache_key];\n    };\n    ImageSource.prototype.get_image_url = function (xmin, ymin, xmax, ymax, height, width) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{XMIN}\", xmin).replace(\"{YMIN}\", ymin).replace(\"{XMAX}\", xmax).replace(\"{YMAX}\", ymax).replace(\"{WIDTH}\", width).replace(\"{HEIGHT}\", height);\n    };\n    return ImageSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_tile_source_1 = require(\"./bbox_tile_source\");\nexports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;\nvar dynamic_image_renderer_1 = require(\"./dynamic_image_renderer\");\nexports.DynamicImageRenderer = dynamic_image_renderer_1.DynamicImageRenderer;\nvar image_source_1 = require(\"./image_source\");\nexports.ImageSource = image_source_1.ImageSource;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;\nvar quadkey_tile_source_1 = require(\"./quadkey_tile_source\");\nexports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;\nvar tile_renderer_1 = require(\"./tile_renderer\");\nexports.TileRenderer = tile_renderer_1.TileRenderer;\nvar tile_source_1 = require(\"./tile_source\");\nexports.TileSource = tile_source_1.TileSource;\nvar tms_tile_source_1 = require(\"./tms_tile_source\");\nexports.TMSTileSource = tms_tile_source_1.TMSTileSource;\nvar wmts_tile_source_1 = require(\"./wmts_tile_source\");\nexports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar tile_source_1 = require(\"./tile_source\");\nvar p = require(\"core/properties\");\nexports.MercatorTileSource = (function (superClass) {\n    extend(MercatorTileSource, superClass);\n    function MercatorTileSource() {\n        return MercatorTileSource.__super__.constructor.apply(this, arguments);\n    }\n    MercatorTileSource.prototype.type = 'MercatorTileSource';\n    MercatorTileSource.define({\n        wrap_around: [p.Bool, true]\n    });\n    MercatorTileSource.override({\n        x_origin_offset: 20037508.34,\n        y_origin_offset: 20037508.34,\n        initial_resolution: 156543.03392804097\n    });\n    MercatorTileSource.prototype.initialize = function (options) {\n        var z;\n        MercatorTileSource.__super__.initialize.call(this, options);\n        return this._resolutions = (function () {\n            var j, results;\n            results = [];\n            for (z = j = 0; j <= 30; z = ++j) {\n                results.push(this.get_resolution(z));\n            }\n            return results;\n        }).call(this);\n    };\n    MercatorTileSource.prototype._computed_initial_resolution = function () {\n        if (this.initial_resolution != null) {\n            return this.initial_resolution;\n        }\n        else {\n            return 2 * Math.PI * 6378137 / this.tile_size;\n        }\n    };\n    MercatorTileSource.prototype.is_valid_tile = function (x, y, z) {\n        if (!this.wrap_around) {\n            if (x < 0 || x >= Math.pow(2, z)) {\n                return false;\n            }\n        }\n        if (y < 0 || y >= Math.pow(2, z)) {\n            return false;\n        }\n        return true;\n    };\n    MercatorTileSource.prototype.retain_children = function (reference_tile) {\n        var key, max_zoom, min_zoom, quadkey, ref, results, tile;\n        quadkey = reference_tile.quadkey;\n        min_zoom = quadkey.length;\n        max_zoom = min_zoom + 3;\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            if (tile.quadkey.indexOf(quadkey) === 0 && tile.quadkey.length > min_zoom && tile.quadkey.length <= max_zoom) {\n                results.push(tile.retain = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.retain_neighbors = function (reference_tile) {\n        var key, neighbor_radius, neighbor_x, neighbor_y, ref, ref1, ref2, ref3, results, tile, tx, ty, tz, x, y;\n        neighbor_radius = 4;\n        ref = reference_tile.tile_coords, tx = ref[0], ty = ref[1], tz = ref[2];\n        neighbor_x = (function () {\n            var j, ref1, ref2, results;\n            results = [];\n            for (x = j = ref1 = tx - neighbor_radius, ref2 = tx + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; x = ref1 <= ref2 ? ++j : --j) {\n                results.push(x);\n            }\n            return results;\n        })();\n        neighbor_y = (function () {\n            var j, ref1, ref2, results;\n            results = [];\n            for (y = j = ref1 = ty - neighbor_radius, ref2 = ty + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; y = ref1 <= ref2 ? ++j : --j) {\n                results.push(y);\n            }\n            return results;\n        })();\n        ref1 = this.tiles;\n        results = [];\n        for (key in ref1) {\n            tile = ref1[key];\n            if (tile.tile_coords[2] === tz && (ref2 = tile.tile_coords[0], indexOf.call(neighbor_x, ref2) >= 0) && (ref3 = tile.tile_coords[1], indexOf.call(neighbor_y, ref3) >= 0)) {\n                results.push(tile.retain = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.retain_parents = function (reference_tile) {\n        var key, quadkey, ref, results, tile;\n        quadkey = reference_tile.quadkey;\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            results.push(tile.retain = quadkey.indexOf(tile.quadkey) === 0);\n        }\n        return results;\n    };\n    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {\n        var b, child_tile_xyz, i, j, quad_key, ref, ref1, ref2, world_x;\n        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n        if (world_x !== 0) {\n            ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        }\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        child_tile_xyz = [];\n        for (i = j = 0; j <= 3; i = j += 1) {\n            ref1 = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref1[0], y = ref1[1], z = ref1[2];\n            if (world_x !== 0) {\n                ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];\n            }\n            b = this.get_tile_meter_bounds(x, y, z);\n            if (b != null) {\n                child_tile_xyz.push([x, y, z, b]);\n            }\n        }\n        return child_tile_xyz;\n    };\n    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {\n        var parent_quad_key, quad_key;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        parent_quad_key = quad_key.substring(0, quad_key.length - 1);\n        return this.quadkey_to_tile_xyz(parent_quad_key);\n    };\n    MercatorTileSource.prototype.get_resolution = function (level) {\n        return this._computed_initial_resolution() / Math.pow(2, level);\n    };\n    MercatorTileSource.prototype.get_resolution_by_extent = function (extent, height, width) {\n        var x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        return [x_rs, y_rs];\n    };\n    MercatorTileSource.prototype.get_level_by_extent = function (extent, height, width) {\n        var i, j, len, r, ref, resolution, x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        resolution = Math.max(x_rs, y_rs);\n        i = 0;\n        ref = this._resolutions;\n        for (j = 0, len = ref.length; j < len; j++) {\n            r = ref[j];\n            if (resolution > r) {\n                if (i === 0) {\n                    return 0;\n                }\n                if (i > 0) {\n                    return i - 1;\n                }\n            }\n            i += 1;\n        }\n    };\n    MercatorTileSource.prototype.get_closest_level_by_extent = function (extent, height, width) {\n        var closest, resolution, ress, x_rs, y_rs;\n        x_rs = (extent[2] - extent[0]) / width;\n        y_rs = (extent[3] - extent[1]) / height;\n        resolution = Math.max(x_rs, y_rs);\n        ress = this._resolutions;\n        closest = this._resolutions.reduce(function (previous, current) {\n            if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {\n                return current;\n            }\n            return previous;\n        });\n        return this._resolutions.indexOf(closest);\n    };\n    MercatorTileSource.prototype.snap_to_zoom = function (extent, height, width, level) {\n        var desired_res, desired_x_delta, desired_y_delta, x_adjust, xmax, xmin, y_adjust, ymax, ymin;\n        desired_res = this._resolutions[level];\n        desired_x_delta = width * desired_res;\n        desired_y_delta = height * desired_res;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\n        y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\n        return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\n    };\n    MercatorTileSource.prototype.tms_to_wmts = function (x, y, z) {\n        'Note this works both ways';\n        return [x, Math.pow(2, z) - 1 - y, z];\n    };\n    MercatorTileSource.prototype.wmts_to_tms = function (x, y, z) {\n        'Note this works both ways';\n        return [x, Math.pow(2, z) - 1 - y, z];\n    };\n    MercatorTileSource.prototype.pixels_to_meters = function (px, py, level) {\n        var mx, my, res;\n        res = this.get_resolution(level);\n        mx = px * res - this.x_origin_offset;\n        my = py * res - this.y_origin_offset;\n        return [mx, my];\n    };\n    MercatorTileSource.prototype.meters_to_pixels = function (mx, my, level) {\n        var px, py, res;\n        res = this.get_resolution(level);\n        px = (mx + this.x_origin_offset) / res;\n        py = (my + this.y_origin_offset) / res;\n        return [px, py];\n    };\n    MercatorTileSource.prototype.pixels_to_tile = function (px, py) {\n        var tx, ty;\n        tx = Math.ceil(px / parseFloat(this.tile_size));\n        tx = tx === 0 ? tx : tx - 1;\n        ty = Math.max(Math.ceil(py / parseFloat(this.tile_size)) - 1, 0);\n        return [tx, ty];\n    };\n    MercatorTileSource.prototype.pixels_to_raster = function (px, py, level) {\n        var mapSize;\n        mapSize = this.tile_size << level;\n        return [px, mapSize - py];\n    };\n    MercatorTileSource.prototype.meters_to_tile = function (mx, my, level) {\n        var px, py, ref;\n        ref = this.meters_to_pixels(mx, my, level), px = ref[0], py = ref[1];\n        return this.pixels_to_tile(px, py);\n    };\n    MercatorTileSource.prototype.get_tile_meter_bounds = function (tx, ty, level) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        ref = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level), xmin = ref[0], ymin = ref[1];\n        ref1 = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level), xmax = ref1[0], ymax = ref1[1];\n        if ((xmin != null) && (ymin != null) && (xmax != null) && (ymax != null)) {\n            return [xmin, ymin, xmax, ymax];\n        }\n        else {\n            return void 0;\n        }\n    };\n    MercatorTileSource.prototype.get_tile_geographic_bounds = function (tx, ty, level) {\n        var bounds, maxLat, maxLon, minLat, minLon, ref;\n        bounds = this.get_tile_meter_bounds(tx, ty, level);\n        ref = this.utils.meters_extent_to_geographic(bounds), minLon = ref[0], minLat = ref[1], maxLon = ref[2], maxLat = ref[3];\n        return [minLon, minLat, maxLon, maxLat];\n    };\n    MercatorTileSource.prototype.get_tiles_by_extent = function (extent, level, tile_border) {\n        var j, k, ref, ref1, ref2, ref3, ref4, ref5, tiles, tx, txmax, txmin, ty, tymax, tymin, xmax, xmin, ymax, ymin;\n        if (tile_border == null) {\n            tile_border = 1;\n        }\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.meters_to_tile(xmin, ymin, level), txmin = ref[0], tymin = ref[1];\n        ref1 = this.meters_to_tile(xmax, ymax, level), txmax = ref1[0], tymax = ref1[1];\n        txmin -= tile_border;\n        tymin -= tile_border;\n        txmax += tile_border;\n        tymax += tile_border;\n        tiles = [];\n        for (ty = j = ref2 = tymax, ref3 = tymin; j >= ref3; ty = j += -1) {\n            for (tx = k = ref4 = txmin, ref5 = txmax; k <= ref5; tx = k += 1) {\n                if (this.is_valid_tile(tx, ty, level)) {\n                    tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\n                }\n            }\n        }\n        tiles = this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\n        return tiles;\n    };\n    MercatorTileSource.prototype.quadkey_to_tile_xyz = function (quadKey) {\n        'Computes tile x, y and z values based on quadKey.';\n        var i, j, mask, ref, tileX, tileY, tileZ, value;\n        tileX = 0;\n        tileY = 0;\n        tileZ = quadKey.length;\n        for (i = j = ref = tileZ; j > 0; i = j += -1) {\n            value = quadKey.charAt(tileZ - i);\n            mask = 1 << (i - 1);\n            switch (value) {\n                case '0':\n                    continue;\n                case '1':\n                    tileX |= mask;\n                    break;\n                case '2':\n                    tileY |= mask;\n                    break;\n                case '3':\n                    tileX |= mask;\n                    tileY |= mask;\n                    break;\n                default:\n                    throw new TypeError(\"Invalid Quadkey: \" + quadKey);\n            }\n        }\n        return [tileX, tileY, tileZ];\n    };\n    MercatorTileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {\n        'Computes quadkey value based on tile x, y and z values.';\n        var digit, i, j, mask, quadKey, ref;\n        quadKey = '';\n        for (i = j = ref = z; j > 0; i = j += -1) {\n            digit = 0;\n            mask = 1 << (i - 1);\n            if ((x & mask) !== 0) {\n                digit += 1;\n            }\n            if ((y & mask) !== 0) {\n                digit += 2;\n            }\n            quadKey += digit.toString();\n        }\n        return quadKey;\n    };\n    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {\n        var b, child_tile_xyz, i, j, quad_key, ref;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        child_tile_xyz = [];\n        for (i = j = 0; j <= 3; i = j += 1) {\n            ref = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref[0], y = ref[1], z = ref[2];\n            b = this.get_tile_meter_bounds(x, y, z);\n            if (b != null) {\n                child_tile_xyz.push([x, y, z, b]);\n            }\n        }\n        return child_tile_xyz;\n    };\n    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {\n        var parent_quad_key, quad_key;\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        parent_quad_key = quad_key.substring(0, quad_key.length - 1);\n        return this.quadkey_to_tile_xyz(parent_quad_key);\n    };\n    MercatorTileSource.prototype.get_closest_parent_by_tile_xyz = function (x, y, z) {\n        var quad_key, ref, ref1, ref2, world_x;\n        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n        ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        quad_key = this.tile_xyz_to_quadkey(x, y, z);\n        while (quad_key.length > 0) {\n            quad_key = quad_key.substring(0, quad_key.length - 1);\n            ref1 = this.quadkey_to_tile_xyz(quad_key), x = ref1[0], y = ref1[1], z = ref1[2];\n            ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];\n            if (this.tile_xyz_to_key(x, y, z) in this.tiles) {\n                return [x, y, z];\n            }\n        }\n        return [0, 0, 0];\n    };\n    MercatorTileSource.prototype.normalize_xyz = function (x, y, z) {\n        var tile_count;\n        if (this.wrap_around) {\n            tile_count = Math.pow(2, z);\n            return [((x % tile_count) + tile_count) % tile_count, y, z];\n        }\n        else {\n            return [x, y, z];\n        }\n    };\n    MercatorTileSource.prototype.denormalize_xyz = function (x, y, z, world_x) {\n        return [x + world_x * Math.pow(2, z), y, z];\n    };\n    MercatorTileSource.prototype.denormalize_meters = function (meters_x, meters_y, level, world_x) {\n        return [meters_x + world_x * 2 * Math.PI * 6378137, meters_y];\n    };\n    MercatorTileSource.prototype.calculate_world_x_by_tile_xyz = function (x, y, z) {\n        return Math.floor(x / Math.pow(2, z));\n    };\n    return MercatorTileSource;\n})(tile_source_1.TileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.QUADKEYTileSource = (function (superClass) {\n    extend(QUADKEYTileSource, superClass);\n    function QUADKEYTileSource() {\n        return QUADKEYTileSource.__super__.constructor.apply(this, arguments);\n    }\n    QUADKEYTileSource.prototype.type = 'QUADKEYTileSource';\n    QUADKEYTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, quadKey, ref;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        quadKey = this.tile_xyz_to_quadkey(x, y, z);\n        return image_url.replace(\"{Q}\", quadKey);\n    };\n    return QUADKEYTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar image_pool_1 = require(\"./image_pool\");\nvar wmts_tile_source_1 = require(\"./wmts_tile_source\");\nvar renderer_1 = require(\"../renderers/renderer\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.TileRendererView = (function (superClass) {\n    extend(TileRendererView, superClass);\n    function TileRendererView() {\n        this._update = bind(this._update, this);\n        this._prefetch_tiles = bind(this._prefetch_tiles, this);\n        this._on_tile_error = bind(this._on_tile_error, this);\n        this._on_tile_cache_load = bind(this._on_tile_cache_load, this);\n        this._on_tile_load = bind(this._on_tile_load, this);\n        this._add_attribution = bind(this._add_attribution, this);\n        return TileRendererView.__super__.constructor.apply(this, arguments);\n    }\n    TileRendererView.prototype.initialize = function (options) {\n        this.attributionEl = null;\n        return TileRendererView.__super__.initialize.apply(this, arguments);\n    };\n    TileRendererView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change', this.request_render);\n    };\n    TileRendererView.prototype.get_extent = function () {\n        return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\n    };\n    TileRendererView.prototype._set_data = function () {\n        this.pool = new image_pool_1.ImagePool();\n        this.map_plot = this.plot_model.plot;\n        this.map_canvas = this.plot_view.canvas_view.ctx;\n        this.map_frame = this.plot_model.frame;\n        this.x_range = this.map_plot.x_range;\n        this.x_mapper = this.map_frame.x_mappers['default'];\n        this.y_range = this.map_plot.y_range;\n        this.y_mapper = this.map_frame.y_mappers['default'];\n        this.extent = this.get_extent();\n        this._last_height = void 0;\n        return this._last_width = void 0;\n    };\n    TileRendererView.prototype._add_attribution = function () {\n        var attribution, border_width, bottom_offset, max_width, overlays, right_offset;\n        attribution = this.model.tile_source.attribution;\n        if (types_1.isString(attribution) && attribution.length > 0) {\n            if (this.attributionEl == null) {\n                border_width = this.map_plot.outline_line_width;\n                bottom_offset = this.map_plot.min_border_bottom + border_width;\n                right_offset = this.map_frame.right - this.map_frame.width;\n                max_width = this.map_frame.width - border_width;\n                this.attributionEl = dom_1.div({\n                    \"class\": 'bk-tile-attribution',\n                    style: {\n                        position: 'absolute',\n                        bottom: bottom_offset + \"px\",\n                        right: right_offset + \"px\",\n                        'max-width': max_width + \"px\",\n                        'background-color': 'rgba(255,255,255,0.8)',\n                        'font-size': '9pt',\n                        'font-family': 'sans-serif'\n                    }\n                });\n                overlays = this.plot_view.el.querySelector('div.bk-canvas-events');\n                overlays.appendChild(this.attributionEl);\n            }\n            return this.attributionEl.innerHTML = attribution;\n        }\n    };\n    TileRendererView.prototype._map_data = function () {\n        var new_extent, zoom_level;\n        this.initial_extent = this.get_extent();\n        zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame.height, this.map_frame.width);\n        new_extent = this.model.tile_source.snap_to_zoom(this.initial_extent, this.map_frame.height, this.map_frame.width, zoom_level);\n        this.x_range.start = new_extent[0];\n        this.y_range.start = new_extent[1];\n        this.x_range.end = new_extent[2];\n        this.y_range.end = new_extent[3];\n        return this._add_attribution();\n    };\n    TileRendererView.prototype._on_tile_load = function (e) {\n        var tile_data;\n        tile_data = e.target.tile_data;\n        tile_data.img = e.target;\n        tile_data.current = true;\n        tile_data.loaded = true;\n        return this.request_render();\n    };\n    TileRendererView.prototype._on_tile_cache_load = function (e) {\n        var tile_data;\n        tile_data = e.target.tile_data;\n        tile_data.img = e.target;\n        return tile_data.loaded = true;\n    };\n    TileRendererView.prototype._on_tile_error = function (e) {\n        return '';\n    };\n    TileRendererView.prototype._create_tile = function (x, y, z, bounds, cache_only) {\n        var normalized_coords, ref, tile;\n        if (cache_only == null) {\n            cache_only = false;\n        }\n        normalized_coords = this.model.tile_source.normalize_xyz(x, y, z);\n        tile = this.pool.pop();\n        if (cache_only) {\n            tile.onload = this._on_tile_cache_load;\n        }\n        else {\n            tile.onload = this._on_tile_load;\n        }\n        tile.onerror = this._on_tile_error;\n        tile.alt = '';\n        tile.tile_data = {\n            tile_coords: [x, y, z],\n            normalized_coords: normalized_coords,\n            quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),\n            cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),\n            bounds: bounds,\n            loaded: false,\n            x_coord: bounds[0],\n            y_coord: bounds[3]\n        };\n        this.model.tile_source.tiles[tile.tile_data.cache_key] = tile.tile_data;\n        tile.src = (ref = this.model.tile_source).get_image_url.apply(ref, normalized_coords);\n        return tile;\n    };\n    TileRendererView.prototype._enforce_aspect_ratio = function () {\n        var extent, new_extent, zoom_level;\n        if (this._last_height !== this.map_frame.height || this._last_width !== this.map_frame.width) {\n            extent = this.get_extent();\n            zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame.height, this.map_frame.width);\n            new_extent = this.model.tile_source.snap_to_zoom(extent, this.map_frame.height, this.map_frame.width, zoom_level);\n            this.x_range.setv({\n                start: new_extent[0],\n                end: new_extent[2]\n            });\n            this.y_range.setv({\n                start: new_extent[1],\n                end: new_extent[3]\n            });\n            this.extent = new_extent;\n            this._last_height = this.map_frame.height;\n            this._last_width = this.map_frame.width;\n            return true;\n        }\n        return false;\n    };\n    TileRendererView.prototype.render = function (ctx, indices, args) {\n        if (this.map_initialized == null) {\n            this._set_data();\n            this._map_data();\n            this.map_initialized = true;\n        }\n        if (this._enforce_aspect_ratio()) {\n            return;\n        }\n        this._update();\n        if (this.prefetch_timer != null) {\n            clearTimeout(this.prefetch_timer);\n        }\n        return this.prefetch_timer = setTimeout(this._prefetch_tiles, 500);\n    };\n    TileRendererView.prototype._draw_tile = function (tile_key) {\n        var ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin, tile_obj;\n        tile_obj = this.model.tile_source.tiles[tile_key];\n        if (tile_obj != null) {\n            ref = this.plot_view.frame.map_to_screen([tile_obj.bounds[0]], [tile_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];\n            ref1 = this.plot_view.frame.map_to_screen([tile_obj.bounds[2]], [tile_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];\n            sxmin = sxmin[0];\n            symin = symin[0];\n            sxmax = sxmax[0];\n            symax = symax[0];\n            sw = sxmax - sxmin;\n            sh = symax - symin;\n            sx = sxmin;\n            sy = symin;\n            return this.map_canvas.drawImage(tile_obj.img, sx, sy, sw, sh);\n        }\n    };\n    TileRendererView.prototype._set_rect = function () {\n        var h, l, outline_width, t, w;\n        outline_width = this.plot_model.plot.properties.outline_line_width.value();\n        l = this.plot_view.canvas.vx_to_sx(this.map_frame.left) + (outline_width / 2);\n        t = this.plot_view.canvas.vy_to_sy(this.map_frame.top) + (outline_width / 2);\n        w = this.map_frame.width - outline_width;\n        h = this.map_frame.height - outline_width;\n        this.map_canvas.rect(l, t, w, h);\n        return this.map_canvas.clip();\n    };\n    TileRendererView.prototype._render_tiles = function (tile_keys) {\n        var i, len, tile_key;\n        this.map_canvas.save();\n        this._set_rect();\n        this.map_canvas.globalAlpha = this.model.alpha;\n        for (i = 0, len = tile_keys.length; i < len; i++) {\n            tile_key = tile_keys[i];\n            this._draw_tile(tile_key);\n        }\n        return this.map_canvas.restore();\n    };\n    TileRendererView.prototype._prefetch_tiles = function () {\n        var bounds, c, cbounds, children, cx, cy, cz, extent, h, i, ref, results, t, tile_source, tiles, w, x, y, z, zoom_level;\n        tile_source = this.model.tile_source;\n        extent = this.get_extent();\n        h = this.map_frame.height;\n        w = this.map_frame.width;\n        zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);\n        tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);\n        results = [];\n        for (t = i = 0, ref = Math.min(10, tiles.length); i <= ref; t = i += 1) {\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            children = this.model.tile_source.children_by_tile_xyz(x, y, z);\n            results.push((function () {\n                var j, len, results1;\n                results1 = [];\n                for (j = 0, len = children.length; j < len; j++) {\n                    c = children[j];\n                    cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];\n                    if (tile_source.tile_xyz_to_key(cx, cy, cz) in tile_source.tiles) {\n                        continue;\n                    }\n                    else {\n                        results1.push(this._create_tile(cx, cy, cz, cbounds, true));\n                    }\n                }\n                return results1;\n            }).call(this));\n        }\n        return results;\n    };\n    TileRendererView.prototype._fetch_tiles = function (tiles) {\n        var bounds, i, len, results, t, x, y, z;\n        results = [];\n        for (i = 0, len = tiles.length; i < len; i++) {\n            t = tiles[i];\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            results.push(this._create_tile(x, y, z, bounds));\n        }\n        return results;\n    };\n    TileRendererView.prototype._update = function () {\n        var bounds, c, cached, cbounds, child_key, children, cx, cy, cz, extent, h, i, j, k, key, len, len1, len2, max_zoom, min_zoom, need_load, parent_key, parent_tile, parents, px, py, pz, ref, snap_back, t, tile, tile_source, tiles, w, x, y, z, zoom_level, zooming_out;\n        tile_source = this.model.tile_source;\n        min_zoom = tile_source.min_zoom;\n        max_zoom = tile_source.max_zoom;\n        tile_source.update();\n        extent = this.get_extent();\n        zooming_out = this.extent[2] - this.extent[0] < extent[2] - extent[0];\n        h = this.map_frame.height;\n        w = this.map_frame.width;\n        zoom_level = tile_source.get_level_by_extent(extent, h, w);\n        snap_back = false;\n        if (zoom_level < min_zoom) {\n            extent = this.extent;\n            zoom_level = min_zoom;\n            snap_back = true;\n        }\n        else if (zoom_level > max_zoom) {\n            extent = this.extent;\n            zoom_level = max_zoom;\n            snap_back = true;\n        }\n        if (snap_back) {\n            this.x_range.setv({\n                x_range: {\n                    start: extent[0],\n                    end: extent[2]\n                }\n            });\n            this.y_range.setv({\n                start: extent[1],\n                end: extent[3]\n            });\n            this.extent = extent;\n        }\n        this.extent = extent;\n        tiles = tile_source.get_tiles_by_extent(extent, zoom_level);\n        parents = [];\n        need_load = [];\n        cached = [];\n        children = [];\n        for (i = 0, len = tiles.length; i < len; i++) {\n            t = tiles[i];\n            x = t[0], y = t[1], z = t[2], bounds = t[3];\n            key = tile_source.tile_xyz_to_key(x, y, z);\n            tile = tile_source.tiles[key];\n            if ((tile != null) && tile.loaded === true) {\n                cached.push(key);\n            }\n            else {\n                if (this.model.render_parents) {\n                    ref = tile_source.get_closest_parent_by_tile_xyz(x, y, z), px = ref[0], py = ref[1], pz = ref[2];\n                    parent_key = tile_source.tile_xyz_to_key(px, py, pz);\n                    parent_tile = tile_source.tiles[parent_key];\n                    if ((parent_tile != null) && parent_tile.loaded && indexOf.call(parents, parent_key) < 0) {\n                        parents.push(parent_key);\n                    }\n                    if (zooming_out) {\n                        children = tile_source.children_by_tile_xyz(x, y, z);\n                        for (j = 0, len1 = children.length; j < len1; j++) {\n                            c = children[j];\n                            cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];\n                            child_key = tile_source.tile_xyz_to_key(cx, cy, cz);\n                            if (child_key in tile_source.tiles) {\n                                children.push(child_key);\n                            }\n                        }\n                    }\n                }\n            }\n            if (tile == null) {\n                need_load.push(t);\n            }\n        }\n        this._render_tiles(parents);\n        this._render_tiles(children);\n        this._render_tiles(cached);\n        for (k = 0, len2 = cached.length; k < len2; k++) {\n            t = cached[k];\n            tile_source.tiles[t].current = true;\n        }\n        if (this.render_timer != null) {\n            clearTimeout(this.render_timer);\n        }\n        return this.render_timer = setTimeout(((function (_this) {\n            return function () {\n                return _this._fetch_tiles(need_load);\n            };\n        })(this)), 65);\n    };\n    return TileRendererView;\n})(renderer_1.RendererView);\nexports.TileRenderer = (function (superClass) {\n    extend(TileRenderer, superClass);\n    function TileRenderer() {\n        return TileRenderer.__super__.constructor.apply(this, arguments);\n    }\n    TileRenderer.prototype.default_view = exports.TileRendererView;\n    TileRenderer.prototype.type = 'TileRenderer';\n    TileRenderer.define({\n        alpha: [p.Number, 1.0],\n        x_range_name: [p.String, \"default\"],\n        y_range_name: [p.String, \"default\"],\n        tile_source: [\n            p.Instance, function () {\n                return new wmts_tile_source_1.WMTSTileSource();\n            }\n        ],\n        render_parents: [p.Bool, true]\n    });\n    TileRenderer.override({\n        level: 'underlay'\n    });\n    return TileRenderer;\n})(renderer_1.Renderer);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar image_pool_1 = require(\"./image_pool\");\nvar tile_utils_1 = require(\"./tile_utils\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.TileSource = (function (superClass) {\n    extend(TileSource, superClass);\n    TileSource.prototype.type = 'TileSource';\n    TileSource.define({\n        url: [p.String, ''],\n        tile_size: [p.Number, 256],\n        max_zoom: [p.Number, 30],\n        min_zoom: [p.Number, 0],\n        extra_url_vars: [p.Any, {}],\n        attribution: [p.String, ''],\n        x_origin_offset: [p.Number],\n        y_origin_offset: [p.Number],\n        initial_resolution: [p.Number]\n    });\n    TileSource.prototype.initialize = function (options) {\n        TileSource.__super__.initialize.call(this, options);\n        return this.normalize_case();\n    };\n    function TileSource(options) {\n        if (options == null) {\n            options = {};\n        }\n        TileSource.__super__.constructor.apply(this, arguments);\n        this.utils = new tile_utils_1.ProjectionUtils();\n        this.pool = new image_pool_1.ImagePool();\n        this.tiles = {};\n        this.normalize_case();\n    }\n    TileSource.prototype.string_lookup_replace = function (str, lookup) {\n        var key, result_str, value;\n        result_str = str;\n        for (key in lookup) {\n            value = lookup[key];\n            result_str = result_str.replace('{' + key + '}', value.toString());\n        }\n        return result_str;\n    };\n    TileSource.prototype.normalize_case = function () {\n        'Note: should probably be refactored into subclasses.';\n        var url;\n        url = this.url;\n        url = url.replace('{x}', '{X}');\n        url = url.replace('{y}', '{Y}');\n        url = url.replace('{z}', '{Z}');\n        url = url.replace('{q}', '{Q}');\n        url = url.replace('{xmin}', '{XMIN}');\n        url = url.replace('{ymin}', '{YMIN}');\n        url = url.replace('{xmax}', '{XMAX}');\n        url = url.replace('{ymax}', '{YMAX}');\n        return this.url = url;\n    };\n    TileSource.prototype.update = function () {\n        var key, ref, results, tile;\n        logging_1.logger.debug(\"TileSource: tile cache count: \" + (Object.keys(this.tiles).length));\n        ref = this.tiles;\n        results = [];\n        for (key in ref) {\n            tile = ref[key];\n            tile.current = false;\n            results.push(tile.retain = false);\n        }\n        return results;\n    };\n    TileSource.prototype.tile_xyz_to_key = function (x, y, z) {\n        var key;\n        key = x + \":\" + y + \":\" + z;\n        return key;\n    };\n    TileSource.prototype.key_to_tile_xyz = function (key) {\n        var c;\n        return (function () {\n            var i, len, ref, results;\n            ref = key.split(':');\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                c = ref[i];\n                results.push(parseInt(c));\n            }\n            return results;\n        })();\n    };\n    TileSource.prototype.sort_tiles_from_center = function (tiles, tile_extent) {\n        var center_x, center_y, txmax, txmin, tymax, tymin;\n        txmin = tile_extent[0], tymin = tile_extent[1], txmax = tile_extent[2], tymax = tile_extent[3];\n        center_x = (txmax - txmin) / 2 + txmin;\n        center_y = (tymax - tymin) / 2 + tymin;\n        tiles.sort(function (a, b) {\n            var a_distance, b_distance;\n            a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));\n            b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));\n            return a_distance - b_distance;\n        });\n        return tiles;\n    };\n    TileSource.prototype.prune_tiles = function () {\n        var key, ref, ref1, results, tile;\n        ref = this.tiles;\n        for (key in ref) {\n            tile = ref[key];\n            tile.retain = tile.current || tile.tile_coords[2] < 3;\n            if (tile.current) {\n                this.retain_neighbors(tile);\n                this.retain_children(tile);\n                this.retain_parents(tile);\n            }\n        }\n        ref1 = this.tiles;\n        results = [];\n        for (key in ref1) {\n            tile = ref1[key];\n            if (!tile.retain) {\n                results.push(this.remove_tile(key));\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    TileSource.prototype.remove_tile = function (key) {\n        var tile;\n        tile = this.tiles[key];\n        if (tile != null) {\n            this.pool.push(tile.img);\n            return delete this.tiles[key];\n        }\n    };\n    TileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    TileSource.prototype.retain_neighbors = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.retain_parents = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.retain_children = function (reference_tile) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {\n        throw new Error(\"Not Implemented\");\n    };\n    TileSource.prototype.quadkey_to_tile_xyz = function (quadkey) {\n        throw new Error(\"Not Implemented\");\n    };\n    return TileSource;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar proj4_1 = require(\"core/util/proj4\");\nexports.ProjectionUtils = (function () {\n    function ProjectionUtils() {\n        this.origin_shift = 2 * Math.PI * 6378137 / 2.0;\n    }\n    ProjectionUtils.prototype.geographic_to_meters = function (xLon, yLat) {\n        return proj4_1.proj4(proj4_1.wgs84, proj4_1.mercator, [xLon, yLat]);\n    };\n    ProjectionUtils.prototype.meters_to_geographic = function (mx, my) {\n        return proj4_1.proj4(proj4_1.mercator, proj4_1.wgs84, [mx, my]);\n    };\n    ProjectionUtils.prototype.geographic_extent_to_meters = function (extent) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.geographic_to_meters(xmin, ymin), xmin = ref[0], ymin = ref[1];\n        ref1 = this.geographic_to_meters(xmax, ymax), xmax = ref1[0], ymax = ref1[1];\n        return [xmin, ymin, xmax, ymax];\n    };\n    ProjectionUtils.prototype.meters_extent_to_geographic = function (extent) {\n        var ref, ref1, xmax, xmin, ymax, ymin;\n        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];\n        ref = this.meters_to_geographic(xmin, ymin), xmin = ref[0], ymin = ref[1];\n        ref1 = this.meters_to_geographic(xmax, ymax), xmax = ref1[0], ymax = ref1[1];\n        return [xmin, ymin, xmax, ymax];\n    };\n    return ProjectionUtils;\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.TMSTileSource = (function (superClass) {\n    extend(TMSTileSource, superClass);\n    function TMSTileSource() {\n        return TMSTileSource.__super__.constructor.apply(this, arguments);\n    }\n    TMSTileSource.prototype.type = 'TMSTileSource';\n    TMSTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    return TMSTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar mercator_tile_source_1 = require(\"./mercator_tile_source\");\nexports.WMTSTileSource = (function (superClass) {\n    extend(WMTSTileSource, superClass);\n    function WMTSTileSource() {\n        return WMTSTileSource.__super__.constructor.apply(this, arguments);\n    }\n    WMTSTileSource.prototype.type = 'WMTSTileSource';\n    WMTSTileSource.prototype.get_image_url = function (x, y, z) {\n        var image_url, ref;\n        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];\n        return image_url.replace(\"{X}\", x).replace('{Y}', y).replace(\"{Z}\", z);\n    };\n    return WMTSTileSource;\n})(mercator_tile_source_1.MercatorTileSource);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"../button_tool\");\nexports.ActionToolButtonView = (function (superClass) {\n    extend(ActionToolButtonView, superClass);\n    function ActionToolButtonView() {\n        return ActionToolButtonView.__super__.constructor.apply(this, arguments);\n    }\n    ActionToolButtonView.prototype._clicked = function () {\n        return this.model.trigger('do');\n    };\n    return ActionToolButtonView;\n})(button_tool_1.ButtonToolButtonView);\nexports.ActionToolView = (function (superClass) {\n    extend(ActionToolView, superClass);\n    function ActionToolView() {\n        return ActionToolView.__super__.constructor.apply(this, arguments);\n    }\n    ActionToolView.prototype.initialize = function (options) {\n        ActionToolView.__super__.initialize.call(this, options);\n        return this.listenTo(this.model, 'do', this[\"do\"]);\n    };\n    return ActionToolView;\n})(button_tool_1.ButtonToolView);\nexports.ActionTool = (function (superClass) {\n    extend(ActionTool, superClass);\n    function ActionTool() {\n        return ActionTool.__super__.constructor.apply(this, arguments);\n    }\n    return ActionTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar p = require(\"core/properties\");\nexports.HelpToolView = (function (superClass) {\n    extend(HelpToolView, superClass);\n    function HelpToolView() {\n        return HelpToolView.__super__.constructor.apply(this, arguments);\n    }\n    HelpToolView.prototype[\"do\"] = function () {\n        return window.open(this.model.redirect);\n    };\n    return HelpToolView;\n})(action_tool_1.ActionToolView);\nexports.HelpTool = (function (superClass) {\n    extend(HelpTool, superClass);\n    function HelpTool() {\n        return HelpTool.__super__.constructor.apply(this, arguments);\n    }\n    HelpTool.prototype.default_view = exports.HelpToolView;\n    HelpTool.prototype.type = \"HelpTool\";\n    HelpTool.prototype.tool_name = \"Help\";\n    HelpTool.prototype.icon = \"bk-tool-icon-help\";\n    HelpTool.define({\n        help_tooltip: [p.String, 'Click the question mark to learn more about Bokeh plot tools.'],\n        redirect: [p.String, 'http://bokeh.pydata.org/en/latest/docs/user_guide/tools.html']\n    });\n    HelpTool.getters({\n        tooltip: function () {\n            return this.help_tooltip;\n        }\n    });\n    return HelpTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.RedoToolView = (function (superClass) {\n    extend(RedoToolView, superClass);\n    function RedoToolView() {\n        return RedoToolView.__super__.constructor.apply(this, arguments);\n    }\n    RedoToolView.prototype.initialize = function (options) {\n        RedoToolView.__super__.initialize.call(this, options);\n        return this.listenTo(this.plot_view, \"state_changed\", (function (_this) {\n            return function () {\n                return _this.model.disabled = !_this.plot_view.can_redo();\n            };\n        })(this));\n    };\n    RedoToolView.prototype[\"do\"] = function () {\n        return this.plot_view.redo();\n    };\n    return RedoToolView;\n})(action_tool_1.ActionToolView);\nexports.RedoTool = (function (superClass) {\n    extend(RedoTool, superClass);\n    function RedoTool() {\n        return RedoTool.__super__.constructor.apply(this, arguments);\n    }\n    RedoTool.prototype.default_view = exports.RedoToolView;\n    RedoTool.prototype.type = \"RedoTool\";\n    RedoTool.prototype.tool_name = \"Redo\";\n    RedoTool.prototype.icon = \"bk-tool-icon-redo\";\n    RedoTool.override({\n        disabled: true\n    });\n    return RedoTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar p = require(\"core/properties\");\nexports.ResetToolView = (function (superClass) {\n    extend(ResetToolView, superClass);\n    function ResetToolView() {\n        return ResetToolView.__super__.constructor.apply(this, arguments);\n    }\n    ResetToolView.prototype[\"do\"] = function () {\n        this.plot_view.clear_state();\n        this.plot_view.reset_range();\n        this.plot_view.reset_selection();\n        if (this.model.reset_size) {\n            return this.plot_view.reset_dimensions();\n        }\n    };\n    return ResetToolView;\n})(action_tool_1.ActionToolView);\nexports.ResetTool = (function (superClass) {\n    extend(ResetTool, superClass);\n    function ResetTool() {\n        return ResetTool.__super__.constructor.apply(this, arguments);\n    }\n    ResetTool.prototype.default_view = exports.ResetToolView;\n    ResetTool.prototype.type = \"ResetTool\";\n    ResetTool.prototype.tool_name = \"Reset\";\n    ResetTool.prototype.icon = \"bk-tool-icon-reset\";\n    ResetTool.define({\n        reset_size: [p.Bool, true]\n    });\n    return ResetTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.SaveToolView = (function (superClass) {\n    extend(SaveToolView, superClass);\n    function SaveToolView() {\n        return SaveToolView.__super__.constructor.apply(this, arguments);\n    }\n    SaveToolView.prototype[\"do\"] = function () {\n        return this.plot_view.save(\"bokeh_plot.png\");\n    };\n    return SaveToolView;\n})(action_tool_1.ActionToolView);\nexports.SaveTool = (function (superClass) {\n    extend(SaveTool, superClass);\n    function SaveTool() {\n        return SaveTool.__super__.constructor.apply(this, arguments);\n    }\n    SaveTool.prototype.default_view = exports.SaveToolView;\n    SaveTool.prototype.type = \"SaveTool\";\n    SaveTool.prototype.tool_name = \"Save\";\n    SaveTool.prototype.icon = \"bk-tool-icon-save\";\n    return SaveTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nexports.UndoToolView = (function (superClass) {\n    extend(UndoToolView, superClass);\n    function UndoToolView() {\n        return UndoToolView.__super__.constructor.apply(this, arguments);\n    }\n    UndoToolView.prototype.initialize = function (options) {\n        UndoToolView.__super__.initialize.call(this, options);\n        return this.listenTo(this.plot_view, \"state_changed\", (function (_this) {\n            return function () {\n                return _this.model.disabled = !_this.plot_view.can_undo();\n            };\n        })(this));\n    };\n    UndoToolView.prototype[\"do\"] = function () {\n        return this.plot_view.undo();\n    };\n    return UndoToolView;\n})(action_tool_1.ActionToolView);\nexports.UndoTool = (function (superClass) {\n    extend(UndoTool, superClass);\n    function UndoTool() {\n        return UndoTool.__super__.constructor.apply(this, arguments);\n    }\n    UndoTool.prototype.default_view = exports.UndoToolView;\n    UndoTool.prototype.type = \"UndoTool\";\n    UndoTool.prototype.tool_name = \"Undo\";\n    UndoTool.prototype.icon = \"bk-tool-icon-undo\";\n    UndoTool.override({\n        disabled: true\n    });\n    return UndoTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nexports.ZoomInToolView = (function (superClass) {\n    extend(ZoomInToolView, superClass);\n    function ZoomInToolView() {\n        return ZoomInToolView.__super__.constructor.apply(this, arguments);\n    }\n    ZoomInToolView.prototype[\"do\"] = function () {\n        var dims, frame, h_axis, v_axis, zoom_info;\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        h_axis = dims === 'width' || dims === 'both';\n        v_axis = dims === 'height' || dims === 'both';\n        zoom_info = zoom_1.scale_range(frame, this.model.factor, h_axis, v_axis);\n        this.plot_view.push_state('zoom_out', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return ZoomInToolView;\n})(action_tool_1.ActionToolView);\nexports.ZoomInTool = (function (superClass) {\n    extend(ZoomInTool, superClass);\n    function ZoomInTool() {\n        return ZoomInTool.__super__.constructor.apply(this, arguments);\n    }\n    ZoomInTool.prototype.default_view = exports.ZoomInToolView;\n    ZoomInTool.prototype.type = \"ZoomInTool\";\n    ZoomInTool.prototype.tool_name = \"Zoom In\";\n    ZoomInTool.prototype.icon = \"bk-tool-icon-zoom-in\";\n    ZoomInTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    ZoomInTool.define({\n        factor: [p.Percent, 0.1],\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    return ZoomInTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar action_tool_1 = require(\"./action_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nexports.ZoomOutToolView = (function (superClass) {\n    extend(ZoomOutToolView, superClass);\n    function ZoomOutToolView() {\n        return ZoomOutToolView.__super__.constructor.apply(this, arguments);\n    }\n    ZoomOutToolView.prototype[\"do\"] = function () {\n        var dims, frame, h_axis, v_axis, zoom_info;\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        h_axis = dims === 'width' || dims === 'both';\n        v_axis = dims === 'height' || dims === 'both';\n        zoom_info = zoom_1.scale_range(frame, -this.model.factor, h_axis, v_axis);\n        this.plot_view.push_state('zoom_out', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return ZoomOutToolView;\n})(action_tool_1.ActionToolView);\nexports.ZoomOutTool = (function (superClass) {\n    extend(ZoomOutTool, superClass);\n    function ZoomOutTool() {\n        return ZoomOutTool.__super__.constructor.apply(this, arguments);\n    }\n    ZoomOutTool.prototype.default_view = exports.ZoomOutToolView;\n    ZoomOutTool.prototype.type = \"ZoomOutTool\";\n    ZoomOutTool.prototype.tool_name = \"Zoom Out\";\n    ZoomOutTool.prototype.icon = \"bk-tool-icon-zoom-out\";\n    ZoomOutTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    ZoomOutTool.define({\n        factor: [p.Percent, 0.1],\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    return ZoomOutTool;\n})(action_tool_1.ActionTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar tool_1 = require(\"./tool\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nexports.ButtonToolButtonView = (function (superClass) {\n    extend(ButtonToolButtonView, superClass);\n    function ButtonToolButtonView() {\n        return ButtonToolButtonView.__super__.constructor.apply(this, arguments);\n    }\n    ButtonToolButtonView.prototype.className = \"bk-toolbar-button\";\n    ButtonToolButtonView.prototype.initialize = function (options) {\n        ButtonToolButtonView.__super__.initialize.call(this, options);\n        this.listenTo(this.model, 'change', (function (_this) {\n            return function () {\n                return _this.render();\n            };\n        })(this));\n        this.el.addEventListener(\"click\", (function (_this) {\n            return function (e) {\n                return _this._clicked(e);\n            };\n        })(this));\n        return this.render();\n    };\n    ButtonToolButtonView.prototype.render = function () {\n        var icon, tip;\n        dom_1.empty(this.el);\n        this.el.disabled = this.model.disabled;\n        icon = dom_1.div({\n            \"class\": ['bk-btn-icon', this.model.icon]\n        });\n        tip = dom_1.span({\n            \"class\": 'bk-tip'\n        }, this.model.tooltip);\n        this.el.appendChild(icon);\n        return this.el.appendChild(tip);\n    };\n    ButtonToolButtonView.prototype._clicked = function (e) { };\n    return ButtonToolButtonView;\n})(bokeh_view_1.BokehView);\nexports.ButtonToolView = (function (superClass) {\n    extend(ButtonToolView, superClass);\n    function ButtonToolView() {\n        return ButtonToolView.__super__.constructor.apply(this, arguments);\n    }\n    return ButtonToolView;\n})(tool_1.ToolView);\nexports.ButtonTool = (function (superClass) {\n    extend(ButtonTool, superClass);\n    function ButtonTool() {\n        return ButtonTool.__super__.constructor.apply(this, arguments);\n    }\n    ButtonTool.prototype.icon = null;\n    ButtonTool.getters({\n        tooltip: function () {\n            return this.tool_name;\n        }\n    });\n    ButtonTool.internal({\n        disabled: [p.Boolean, false]\n    });\n    return ButtonTool;\n})(tool_1.Tool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_BOX_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar box_annotation_1 = require(\"../../annotations/box_annotation\");\nvar p = require(\"core/properties\");\nexports.BoxSelectToolView = (function (superClass) {\n    extend(BoxSelectToolView, superClass);\n    function BoxSelectToolView() {\n        return BoxSelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    BoxSelectToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        return null;\n    };\n    BoxSelectToolView.prototype._pan = function (e) {\n        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];\n        this.model.overlay.update({\n            left: vxlim[0],\n            right: vxlim[1],\n            top: vylim[1],\n            bottom: vylim[0]\n        });\n        if (this.model.select_every_mousemove) {\n            append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;\n            this._select(vxlim, vylim, false, append);\n        }\n        return null;\n    };\n    BoxSelectToolView.prototype._pan_end = function (e) {\n        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];\n        append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;\n        this._select(vxlim, vylim, true, append);\n        this.model.overlay.update({\n            left: null,\n            right: null,\n            top: null,\n            bottom: null\n        });\n        this._baseboint = null;\n        this.plot_view.push_state('box_select', {\n            selection: this.plot_view.get_selection()\n        });\n        return null;\n    };\n    BoxSelectToolView.prototype._select = function (arg, arg1, final, append) {\n        var ds, geometry, i, len, r, ref, sm, vx0, vx1, vy0, vy1;\n        vx0 = arg[0], vx1 = arg[1];\n        vy0 = arg1[0], vy1 = arg1[1];\n        if (append == null) {\n            append = false;\n        }\n        geometry = {\n            type: 'rect',\n            vx0: vx0,\n            vx1: vx1,\n            vy0: vy0,\n            vy1: vy1\n        };\n        ref = this.model.computed_renderers;\n        for (i = 0, len = ref.length; i < len; i++) {\n            r = ref[i];\n            ds = r.data_source;\n            sm = ds.selection_manager;\n            sm.select(this, this.plot_view.renderer_views[r.id], geometry, final, append);\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n        this._save_geometry(geometry, final, append);\n        return null;\n    };\n    BoxSelectToolView.prototype._emit_callback = function (geometry) {\n        var canvas, frame, r, xmapper, ymapper;\n        r = this.model.computed_renderers[0];\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx0'] = canvas.vx_to_sx(geometry.vx0);\n        geometry['sx1'] = canvas.vx_to_sx(geometry.vx1);\n        geometry['sy0'] = canvas.vy_to_sy(geometry.vy0);\n        geometry['sy1'] = canvas.vy_to_sy(geometry.vy1);\n        xmapper = frame.x_mappers[r.x_range_name];\n        ymapper = frame.y_mappers[r.y_range_name];\n        geometry['x0'] = xmapper.map_from_target(geometry.vx0);\n        geometry['x1'] = xmapper.map_from_target(geometry.vx1);\n        geometry['y0'] = ymapper.map_from_target(geometry.vy0);\n        geometry['y1'] = ymapper.map_from_target(geometry.vy1);\n        this.model.callback.execute(this.model, {\n            geometry: geometry\n        });\n    };\n    return BoxSelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_BOX_OVERLAY = function () {\n    return new box_annotation_1.BoxAnnotation({\n        level: \"overlay\",\n        render_mode: \"css\",\n        top_units: \"screen\",\n        left_units: \"screen\",\n        bottom_units: \"screen\",\n        right_units: \"screen\",\n        fill_color: \"lightgrey\",\n        fill_alpha: 0.5,\n        line_color: \"black\",\n        line_alpha: 1.0,\n        line_width: 2,\n        line_dash: [4, 4]\n    });\n};\nexports.BoxSelectTool = (function (superClass) {\n    extend(BoxSelectTool, superClass);\n    function BoxSelectTool() {\n        return BoxSelectTool.__super__.constructor.apply(this, arguments);\n    }\n    BoxSelectTool.prototype.default_view = exports.BoxSelectToolView;\n    BoxSelectTool.prototype.type = \"BoxSelectTool\";\n    BoxSelectTool.prototype.tool_name = \"Box Select\";\n    BoxSelectTool.prototype.icon = \"bk-tool-icon-box-select\";\n    BoxSelectTool.prototype.event_type = \"pan\";\n    BoxSelectTool.prototype.default_order = 30;\n    BoxSelectTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        select_every_mousemove: [p.Bool, false],\n        callback: [p.Instance],\n        overlay: [p.Instance, DEFAULT_BOX_OVERLAY]\n    });\n    BoxSelectTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    return BoxSelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_BOX_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar box_annotation_1 = require(\"../../annotations/box_annotation\");\nvar p = require(\"core/properties\");\nexports.BoxZoomToolView = (function (superClass) {\n    extend(BoxZoomToolView, superClass);\n    function BoxZoomToolView() {\n        return BoxZoomToolView.__super__.constructor.apply(this, arguments);\n    }\n    BoxZoomToolView.prototype._match_aspect = function (basepoint, curpoint, frame) {\n        var a, bottom, h, hend, hstart, left, ref, ref1, right, top, va, vend, vh, vstart, vw, w, xmod, ymod;\n        hend = frame.h_range.end;\n        hstart = frame.h_range.start;\n        vend = frame.v_range.end;\n        vstart = frame.v_range.start;\n        w = hend - hstart;\n        h = vend - vstart;\n        a = w / h;\n        vw = Math.abs(basepoint[0] - curpoint[0]);\n        vh = Math.abs(basepoint[1] - curpoint[1]);\n        if (vh === 0) {\n            va = 0;\n        }\n        else {\n            va = vw / vh;\n        }\n        if (va >= a) {\n            ref = [1, va / a], xmod = ref[0], ymod = ref[1];\n        }\n        else {\n            ref1 = [a / va, 1], xmod = ref1[0], ymod = ref1[1];\n        }\n        if (basepoint[0] <= curpoint[0]) {\n            left = basepoint[0];\n            right = basepoint[0] + vw * xmod;\n            if (right > hend) {\n                right = hend;\n            }\n        }\n        else {\n            right = basepoint[0];\n            left = basepoint[0] - vw * xmod;\n            if (left < hstart) {\n                left = hstart;\n            }\n        }\n        vw = Math.abs(right - left);\n        if (basepoint[1] <= curpoint[1]) {\n            bottom = basepoint[1];\n            top = basepoint[1] + vw / a;\n            if (top > vend) {\n                top = vend;\n            }\n        }\n        else {\n            top = basepoint[1];\n            bottom = basepoint[1] - vw / a;\n            if (bottom < vstart) {\n                bottom = vstart;\n            }\n        }\n        vh = Math.abs(top - bottom);\n        if (basepoint[0] <= curpoint[0]) {\n            right = basepoint[0] + a * vh;\n        }\n        else {\n            left = basepoint[0] - a * vh;\n        }\n        return [[left, right], [bottom, top]];\n    };\n    BoxZoomToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        return null;\n    };\n    BoxZoomToolView.prototype._pan = function (e) {\n        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        if (this.model.match_aspect && dims === 'both') {\n            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];\n        }\n        else {\n            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];\n        }\n        this.model.overlay.update({\n            left: vx[0],\n            right: vx[1],\n            top: vy[1],\n            bottom: vy[0]\n        });\n        return null;\n    };\n    BoxZoomToolView.prototype._pan_end = function (e) {\n        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;\n        canvas = this.plot_view.canvas;\n        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];\n        frame = this.plot_model.frame;\n        dims = this.model.dimensions;\n        if (this.model.match_aspect && dims === 'both') {\n            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];\n        }\n        else {\n            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];\n        }\n        this._update(vx, vy);\n        this.model.overlay.update({\n            left: null,\n            right: null,\n            top: null,\n            bottom: null\n        });\n        this._baseboint = null;\n        return null;\n    };\n    BoxZoomToolView.prototype._update = function (vx, vy) {\n        var end, mapper, name, ref, ref1, ref2, ref3, start, xrs, yrs, zoom_info;\n        if (Math.abs(vx[1] - vx[0]) <= 5 || Math.abs(vy[1] - vy[0]) <= 5) {\n            return;\n        }\n        xrs = {};\n        ref = this.plot_view.frame.x_mappers;\n        for (name in ref) {\n            mapper = ref[name];\n            ref1 = mapper.v_map_from_target(vx, true), start = ref1[0], end = ref1[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref2 = this.plot_view.frame.y_mappers;\n        for (name in ref2) {\n            mapper = ref2[name];\n            ref3 = mapper.v_map_from_target(vy, true), start = ref3[0], end = ref3[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        zoom_info = {\n            xrs: xrs,\n            yrs: yrs\n        };\n        this.plot_view.push_state('box_zoom', {\n            range: zoom_info\n        });\n        return this.plot_view.update_range(zoom_info);\n    };\n    return BoxZoomToolView;\n})(gesture_tool_1.GestureToolView);\nDEFAULT_BOX_OVERLAY = function () {\n    return new box_annotation_1.BoxAnnotation({\n        level: \"overlay\",\n        render_mode: \"css\",\n        top_units: \"screen\",\n        left_units: \"screen\",\n        bottom_units: \"screen\",\n        right_units: \"screen\",\n        fill_color: \"lightgrey\",\n        fill_alpha: 0.5,\n        line_color: \"black\",\n        line_alpha: 1.0,\n        line_width: 2,\n        line_dash: [4, 4]\n    });\n};\nexports.BoxZoomTool = (function (superClass) {\n    extend(BoxZoomTool, superClass);\n    function BoxZoomTool() {\n        return BoxZoomTool.__super__.constructor.apply(this, arguments);\n    }\n    BoxZoomTool.prototype.default_view = exports.BoxZoomToolView;\n    BoxZoomTool.prototype.type = \"BoxZoomTool\";\n    BoxZoomTool.prototype.tool_name = \"Box Zoom\";\n    BoxZoomTool.prototype.icon = \"bk-tool-icon-box-zoom\";\n    BoxZoomTool.prototype.event_type = \"pan\";\n    BoxZoomTool.prototype.default_order = 20;\n    BoxZoomTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    BoxZoomTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\n        match_aspect: [p.Bool, false]\n    });\n    return BoxZoomTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"../button_tool\");\nexports.GestureToolView = (function (superClass) {\n    extend(GestureToolView, superClass);\n    function GestureToolView() {\n        return GestureToolView.__super__.constructor.apply(this, arguments);\n    }\n    return GestureToolView;\n})(button_tool_1.ButtonToolView);\nexports.GestureTool = (function (superClass) {\n    extend(GestureTool, superClass);\n    function GestureTool() {\n        return GestureTool.__super__.constructor.apply(this, arguments);\n    }\n    GestureTool.prototype.event_type = null;\n    GestureTool.prototype.default_order = null;\n    return GestureTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_POLY_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar poly_annotation_1 = require(\"../../annotations/poly_annotation\");\nvar p = require(\"core/properties\");\nexports.LassoSelectToolView = (function (superClass) {\n    extend(LassoSelectToolView, superClass);\n    function LassoSelectToolView() {\n        return LassoSelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    LassoSelectToolView.prototype.initialize = function (options) {\n        LassoSelectToolView.__super__.initialize.call(this, options);\n        this.listenTo(this.model, 'change:active', this._active_change);\n        return this.data = null;\n    };\n    LassoSelectToolView.prototype._active_change = function () {\n        if (!this.model.active) {\n            return this._clear_overlay();\n        }\n    };\n    LassoSelectToolView.prototype._keyup = function (e) {\n        if (e.keyCode === 13) {\n            return this._clear_overlay();\n        }\n    };\n    LassoSelectToolView.prototype._pan_start = function (e) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        this.data = {\n            vx: [vx],\n            vy: [vy]\n        };\n        return null;\n    };\n    LassoSelectToolView.prototype._pan = function (e) {\n        var append, canvas, h_range, overlay, ref, v_range, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        h_range = this.plot_model.frame.h_range;\n        v_range = this.plot_model.frame.v_range;\n        if (vx > h_range.end) {\n            vx = h_range.end;\n        }\n        if (vx < h_range.start) {\n            vx = h_range.start;\n        }\n        if (vy > v_range.end) {\n            vy = v_range.end;\n        }\n        if (vy < v_range.start) {\n            vy = v_range.start;\n        }\n        this.data.vx.push(vx);\n        this.data.vy.push(vy);\n        overlay = this.model.overlay;\n        overlay.update({\n            xs: this.data.vx,\n            ys: this.data.vy\n        });\n        if (this.model.select_every_mousemove) {\n            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n            return this._select(this.data.vx, this.data.vy, false, append);\n        }\n    };\n    LassoSelectToolView.prototype._pan_end = function (e) {\n        var append, ref;\n        this._clear_overlay();\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        this._select(this.data.vx, this.data.vy, true, append);\n        return this.plot_view.push_state('lasso_select', {\n            selection: this.plot_view.get_selection()\n        });\n    };\n    LassoSelectToolView.prototype._clear_overlay = function () {\n        return this.model.overlay.update({\n            xs: [],\n            ys: []\n        });\n    };\n    LassoSelectToolView.prototype._select = function (vx, vy, final, append) {\n        var ds, geometry, i, len, r, ref, sm;\n        geometry = {\n            type: 'poly',\n            vx: vx,\n            vy: vy\n        };\n        ref = this.model.computed_renderers;\n        for (i = 0, len = ref.length; i < len; i++) {\n            r = ref[i];\n            ds = r.data_source;\n            sm = ds.selection_manager;\n            sm.select(this, this.plot_view.renderer_views[r.id], geometry, final, append);\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n        this._save_geometry(geometry, final, append);\n        return null;\n    };\n    LassoSelectToolView.prototype._emit_callback = function (geometry) {\n        var canvas, frame, r, xmapper, ymapper;\n        r = this.model.computed_renderers[0];\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx'] = canvas.v_vx_to_sx(geometry.vx);\n        geometry['sy'] = canvas.v_vy_to_sy(geometry.vy);\n        xmapper = frame.x_mappers[r.x_range_name];\n        ymapper = frame.y_mappers[r.y_range_name];\n        geometry['x'] = xmapper.v_map_from_target(geometry.vx);\n        geometry['y'] = ymapper.v_map_from_target(geometry.vy);\n        this.model.callback.execute(this.model, {\n            geometry: geometry\n        });\n    };\n    return LassoSelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_POLY_OVERLAY = function () {\n    return new poly_annotation_1.PolyAnnotation({\n        level: \"overlay\",\n        xs_units: \"screen\",\n        ys_units: \"screen\",\n        fill_color: \"lightgrey\",\n        fill_alpha: 0.5,\n        line_color: \"black\",\n        line_alpha: 1.0,\n        line_width: 2,\n        line_dash: [4, 4]\n    });\n};\nexports.LassoSelectTool = (function (superClass) {\n    extend(LassoSelectTool, superClass);\n    function LassoSelectTool() {\n        return LassoSelectTool.__super__.constructor.apply(this, arguments);\n    }\n    LassoSelectTool.prototype.default_view = exports.LassoSelectToolView;\n    LassoSelectTool.prototype.type = \"LassoSelectTool\";\n    LassoSelectTool.prototype.tool_name = \"Lasso Select\";\n    LassoSelectTool.prototype.icon = \"bk-tool-icon-lasso-select\";\n    LassoSelectTool.prototype.event_type = \"pan\";\n    LassoSelectTool.prototype.default_order = 12;\n    LassoSelectTool.define({\n        select_every_mousemove: [p.Bool, true],\n        callback: [p.Instance],\n        overlay: [p.Instance, DEFAULT_POLY_OVERLAY]\n    });\n    return LassoSelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar p = require(\"core/properties\");\nexports.PanToolView = (function (superClass) {\n    extend(PanToolView, superClass);\n    function PanToolView() {\n        return PanToolView.__super__.constructor.apply(this, arguments);\n    }\n    PanToolView.prototype._pan_start = function (e) {\n        var canvas, frame, hr, vr, vx, vy;\n        this.last_dx = 0;\n        this.last_dy = 0;\n        canvas = this.plot_view.canvas;\n        frame = this.plot_view.frame;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!frame.contains(vx, vy)) {\n            hr = frame.h_range;\n            vr = frame.v_range;\n            if (vx < hr.start || vx > hr.end) {\n                this.v_axis_only = true;\n            }\n            if (vy < vr.start || vy > vr.end) {\n                this.h_axis_only = true;\n            }\n        }\n        return this.plot_view.interactive_timestamp = Date.now();\n    };\n    PanToolView.prototype._pan = function (e) {\n        this._update(e.deltaX, -e.deltaY);\n        return this.plot_view.interactive_timestamp = Date.now();\n    };\n    PanToolView.prototype._pan_end = function (e) {\n        this.h_axis_only = false;\n        this.v_axis_only = false;\n        if (this.pan_info != null) {\n            return this.plot_view.push_state('pan', {\n                range: this.pan_info\n            });\n        }\n    };\n    PanToolView.prototype._update = function (dx, dy) {\n        var dims, end, frame, hr, is_panning, mapper, name, new_dx, new_dy, ref, ref1, ref2, ref3, sdx, sdy, start, sx0, sx1, sx_high, sx_low, sy0, sy1, sy_high, sy_low, vr, xrs, yrs;\n        frame = this.plot_view.frame;\n        new_dx = dx - this.last_dx;\n        new_dy = dy - this.last_dy;\n        hr = frame.h_range;\n        sx_low = hr.start - new_dx;\n        sx_high = hr.end - new_dx;\n        vr = frame.v_range;\n        sy_low = vr.start - new_dy;\n        sy_high = vr.end - new_dy;\n        dims = this.model.dimensions;\n        if ((dims === 'width' || dims === 'both') && !this.v_axis_only) {\n            sx0 = sx_low;\n            sx1 = sx_high;\n            sdx = -new_dx;\n        }\n        else {\n            sx0 = hr.start;\n            sx1 = hr.end;\n            sdx = 0;\n        }\n        if ((dims === 'height' || dims === 'both') && !this.h_axis_only) {\n            sy0 = sy_low;\n            sy1 = sy_high;\n            sdy = new_dy;\n        }\n        else {\n            sy0 = vr.start;\n            sy1 = vr.end;\n            sdy = 0;\n        }\n        this.last_dx = dx;\n        this.last_dy = dy;\n        xrs = {};\n        ref = frame.x_mappers;\n        for (name in ref) {\n            mapper = ref[name];\n            ref1 = mapper.v_map_from_target([sx0, sx1], true), start = ref1[0], end = ref1[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref2 = frame.y_mappers;\n        for (name in ref2) {\n            mapper = ref2[name];\n            ref3 = mapper.v_map_from_target([sy0, sy1], true), start = ref3[0], end = ref3[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        this.pan_info = {\n            xrs: xrs,\n            yrs: yrs,\n            sdx: sdx,\n            sdy: sdy\n        };\n        this.plot_view.update_range(this.pan_info, is_panning = true);\n        return null;\n    };\n    return PanToolView;\n})(gesture_tool_1.GestureToolView);\nexports.PanTool = (function (superClass) {\n    extend(PanTool, superClass);\n    function PanTool() {\n        return PanTool.__super__.constructor.apply(this, arguments);\n    }\n    PanTool.prototype.default_view = exports.PanToolView;\n    PanTool.prototype.type = \"PanTool\";\n    PanTool.prototype.tool_name = \"Pan\";\n    PanTool.prototype.event_type = \"pan\";\n    PanTool.prototype.default_order = 10;\n    PanTool.define({\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    PanTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(\"Pan\", this.dimensions);\n        },\n        icon: function () {\n            var suffix;\n            suffix = (function () {\n                switch (this.dimensions) {\n                    case \"both\":\n                        return \"pan\";\n                    case \"width\":\n                        return \"xpan\";\n                    case \"height\":\n                        return \"ypan\";\n                }\n            }).call(this);\n            return \"bk-tool-icon-\" + suffix;\n        }\n    });\n    return PanTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_POLY_OVERLAY, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar poly_annotation_1 = require(\"../../annotations/poly_annotation\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.PolySelectToolView = (function (superClass) {\n    extend(PolySelectToolView, superClass);\n    function PolySelectToolView() {\n        return PolySelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    PolySelectToolView.prototype.initialize = function (options) {\n        PolySelectToolView.__super__.initialize.call(this, options);\n        this.listenTo(this.model, 'change:active', this._active_change);\n        return this.data = {\n            vx: [],\n            vy: []\n        };\n    };\n    PolySelectToolView.prototype._active_change = function () {\n        if (!this.model.active) {\n            return this._clear_data();\n        }\n    };\n    PolySelectToolView.prototype._keyup = function (e) {\n        if (e.keyCode === 13) {\n            return this._clear_data();\n        }\n    };\n    PolySelectToolView.prototype._doubletap = function (e) {\n        var append, ref;\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        this._select(this.data.vx, this.data.vy, true, append);\n        return this._clear_data();\n    };\n    PolySelectToolView.prototype._clear_data = function () {\n        this.data = {\n            vx: [],\n            vy: []\n        };\n        return this.model.overlay.update({\n            xs: [],\n            ys: []\n        });\n    };\n    PolySelectToolView.prototype._tap = function (e) {\n        var canvas, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        this.data.vx.push(vx);\n        this.data.vy.push(vy);\n        return this.model.overlay.update({\n            xs: array_1.copy(this.data.vx),\n            ys: array_1.copy(this.data.vy)\n        });\n    };\n    PolySelectToolView.prototype._select = function (vx, vy, final, append) {\n        var ds, geometry, i, len, r, ref, sm;\n        geometry = {\n            type: 'poly',\n            vx: vx,\n            vy: vy\n        };\n        ref = this.model.computed_renderers;\n        for (i = 0, len = ref.length; i < len; i++) {\n            r = ref[i];\n            ds = r.data_source;\n            sm = ds.selection_manager;\n            sm.select(this, this.plot_view.renderer_views[r.id], geometry, final, append);\n        }\n        this._save_geometry(geometry, final, append);\n        this.plot_view.push_state('poly_select', {\n            selection: this.plot_view.get_selection()\n        });\n        return null;\n    };\n    return PolySelectToolView;\n})(select_tool_1.SelectToolView);\nDEFAULT_POLY_OVERLAY = function () {\n    return new poly_annotation_1.PolyAnnotation({\n        level: \"overlay\",\n        xs_units: \"screen\",\n        ys_units: \"screen\",\n        fill_color: \"lightgrey\",\n        fill_alpha: 0.5,\n        line_color: \"black\",\n        line_alpha: 1.0,\n        line_width: 2,\n        line_dash: [4, 4]\n    });\n};\nexports.PolySelectTool = (function (superClass) {\n    extend(PolySelectTool, superClass);\n    function PolySelectTool() {\n        return PolySelectTool.__super__.constructor.apply(this, arguments);\n    }\n    PolySelectTool.prototype.default_view = exports.PolySelectToolView;\n    PolySelectTool.prototype.type = \"PolySelectTool\";\n    PolySelectTool.prototype.tool_name = \"Poly Select\";\n    PolySelectTool.prototype.icon = \"bk-tool-icon-polygon-select\";\n    PolySelectTool.prototype.event_type = \"tap\";\n    PolySelectTool.prototype.default_order = 11;\n    PolySelectTool.define({\n        overlay: [p.Instance, DEFAULT_POLY_OVERLAY]\n    });\n    return PolySelectTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar dom_1 = require(\"core/dom\");\nexports.ResizeToolView = (function (superClass) {\n    extend(ResizeToolView, superClass);\n    function ResizeToolView() {\n        return ResizeToolView.__super__.constructor.apply(this, arguments);\n    }\n    ResizeToolView.prototype.className = \"bk-resize-popup\";\n    ResizeToolView.prototype.initialize = function (options) {\n        var wrapper;\n        ResizeToolView.__super__.initialize.call(this, options);\n        wrapper = this.plot_view.el.querySelector('div.bk-canvas-wrapper');\n        wrapper.appendChild(this.el);\n        dom_1.hide(this.el);\n        this.active = false;\n        return null;\n    };\n    ResizeToolView.prototype.activate = function () {\n        this.active = true;\n        this.render();\n        return null;\n    };\n    ResizeToolView.prototype.deactivate = function () {\n        this.active = false;\n        this.render();\n        return null;\n    };\n    ResizeToolView.prototype.render = function (ctx) {\n        var canvas, frame, left, top;\n        if (this.active) {\n            canvas = this.plot_view.canvas;\n            frame = this.plot_view.frame;\n            left = canvas.vx_to_sx(frame.h_range.end - 40);\n            top = canvas.vy_to_sy(frame.v_range.start + 40);\n            this.el.style.position = \"absolute\";\n            this.el.style.top = top + \"px\";\n            this.el.style.left = left + \"px\";\n            dom_1.show(this.el);\n        }\n        else {\n            dom_1.hide(this.el);\n        }\n        return this;\n    };\n    ResizeToolView.prototype._pan_start = function (e) {\n        var canvas;\n        canvas = this.plot_view.canvas;\n        this.ch = canvas.height;\n        this.cw = canvas.width;\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    ResizeToolView.prototype._pan = function (e) {\n        this._update(e.deltaX, e.deltaY);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    ResizeToolView.prototype._pan_end = function (e) {\n        return this.plot_view.push_state(\"resize\", {\n            dimensions: {\n                width: this.plot_view.canvas.width,\n                height: this.plot_view.canvas.height\n            }\n        });\n    };\n    ResizeToolView.prototype._update = function (dx, dy) {\n        var new_height, new_width;\n        new_width = this.cw + dx;\n        new_height = this.ch + dy;\n        if (new_width < 100 || new_height < 100) {\n            return;\n        }\n        this.plot_view.update_dimensions(new_width, new_height);\n    };\n    return ResizeToolView;\n})(gesture_tool_1.GestureToolView);\nexports.ResizeTool = (function (superClass) {\n    extend(ResizeTool, superClass);\n    function ResizeTool() {\n        return ResizeTool.__super__.constructor.apply(this, arguments);\n    }\n    ResizeTool.prototype.default_view = exports.ResizeToolView;\n    ResizeTool.prototype.type = \"ResizeTool\";\n    ResizeTool.prototype.tool_name = \"Resize\";\n    ResizeTool.prototype.icon = \"bk-tool-icon-resize\";\n    ResizeTool.prototype.event_type = \"pan\";\n    ResizeTool.prototype.default_order = 40;\n    return ResizeTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar glyph_renderer_1 = require(\"../../renderers/glyph_renderer\");\nvar logging_1 = require(\"core/logging\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.SelectToolView = (function (superClass) {\n    extend(SelectToolView, superClass);\n    function SelectToolView() {\n        return SelectToolView.__super__.constructor.apply(this, arguments);\n    }\n    SelectToolView.prototype._keyup = function (e) {\n        var ds, j, len, r, ref, results, sm;\n        if (e.keyCode === 27) {\n            ref = this.model.computed_renderers;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n                r = ref[j];\n                ds = r.data_source;\n                sm = ds.selection_manager;\n                results.push(sm.clear());\n            }\n            return results;\n        }\n    };\n    SelectToolView.prototype._save_geometry = function (geometry, final, append) {\n        var g, geoms, i, j, ref, tool_events, xm, ym;\n        g = object_1.clone(geometry);\n        xm = this.plot_view.frame.x_mappers['default'];\n        ym = this.plot_view.frame.y_mappers['default'];\n        switch (g.type) {\n            case 'point':\n                g.x = xm.map_from_target(g.vx);\n                g.y = ym.map_from_target(g.vy);\n                break;\n            case 'rect':\n                g.x0 = xm.map_from_target(g.vx0);\n                g.y0 = ym.map_from_target(g.vy0);\n                g.x1 = xm.map_from_target(g.vx1);\n                g.y1 = ym.map_from_target(g.vy1);\n                break;\n            case 'poly':\n                g.x = new Array(g.vx.length);\n                g.y = new Array(g.vy.length);\n                for (i = j = 0, ref = g.vx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    g.x[i] = xm.map_from_target(g.vx[i]);\n                    g.y[i] = ym.map_from_target(g.vy[i]);\n                }\n                break;\n            default:\n                logging_1.logger.debug(\"Unrecognized selection geometry type: '\" + g.type + \"'\");\n        }\n        if (final) {\n            tool_events = this.plot_model.plot.tool_events;\n            if (append) {\n                geoms = tool_events.geometries;\n                geoms.push(g);\n            }\n            else {\n                geoms = [g];\n            }\n            tool_events.geometries = geoms;\n        }\n        return null;\n    };\n    return SelectToolView;\n})(gesture_tool_1.GestureToolView);\nexports.SelectTool = (function (superClass) {\n    extend(SelectTool, superClass);\n    function SelectTool() {\n        return SelectTool.__super__.constructor.apply(this, arguments);\n    }\n    SelectTool.define({\n        renderers: [p.Array, []],\n        names: [p.Array, []]\n    });\n    SelectTool.internal({\n        multi_select_modifier: [p.String, \"shift\"]\n    });\n    SelectTool.prototype.initialize = function (attrs, options) {\n        SelectTool.__super__.initialize.call(this, attrs, options);\n        this.define_computed_property('computed_renderers', function () {\n            var all_renderers, names, r, renderers;\n            renderers = this.renderers;\n            names = this.names;\n            if (renderers.length === 0) {\n                all_renderers = this.plot.renderers;\n                renderers = (function () {\n                    var j, len, results;\n                    results = [];\n                    for (j = 0, len = all_renderers.length; j < len; j++) {\n                        r = all_renderers[j];\n                        if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n            }\n            if (names.length > 0) {\n                renderers = (function () {\n                    var j, len, results;\n                    results = [];\n                    for (j = 0, len = renderers.length; j < len; j++) {\n                        r = renderers[j];\n                        if (names.indexOf(r.name) >= 0) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n            }\n            return renderers;\n        }, true);\n        this.add_dependencies('computed_renderers', this, ['renderers', 'names', 'plot']);\n        return this.add_dependencies('computed_renderers', this.plot, ['renderers']);\n    };\n    SelectTool.getters({\n        computed_renderers: function () {\n            return this._get_computed('computed_renderers');\n        }\n    });\n    return SelectTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar select_tool_1 = require(\"./select_tool\");\nvar p = require(\"core/properties\");\nvar types_1 = require(\"core/util/types\");\nexports.TapToolView = (function (superClass) {\n    extend(TapToolView, superClass);\n    function TapToolView() {\n        return TapToolView.__super__.constructor.apply(this, arguments);\n    }\n    TapToolView.prototype._tap = function (e) {\n        var append, canvas, ref, vx, vy;\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;\n        return this._select(vx, vy, true, append);\n    };\n    TapToolView.prototype._select = function (vx, vy, final, append) {\n        var callback, cb_data, did_hit, ds, geometry, i, len, r, ref, sm, view;\n        geometry = {\n            type: 'point',\n            vx: vx,\n            vy: vy\n        };\n        callback = this.model.callback;\n        this._save_geometry(geometry, final, append);\n        cb_data = {\n            geometries: this.plot_model.plot.tool_events.geometries\n        };\n        ref = this.model.computed_renderers;\n        for (i = 0, len = ref.length; i < len; i++) {\n            r = ref[i];\n            ds = r.data_source;\n            sm = ds.selection_manager;\n            view = this.plot_view.renderer_views[r.id];\n            if (this.model.behavior === \"select\") {\n                did_hit = sm.select(this, view, geometry, final, append);\n            }\n            else {\n                did_hit = sm.inspect(this, view, geometry, {\n                    geometry: geometry\n                });\n            }\n            if (did_hit && (callback != null)) {\n                if (types_1.isFunction(callback)) {\n                    callback(ds, cb_data);\n                }\n                else {\n                    callback.execute(ds, cb_data);\n                }\n            }\n        }\n        if (this.model.behavior === \"select\") {\n            this.plot_view.push_state('tap', {\n                selection: this.plot_view.get_selection()\n            });\n        }\n        return null;\n    };\n    return TapToolView;\n})(select_tool_1.SelectToolView);\nexports.TapTool = (function (superClass) {\n    extend(TapTool, superClass);\n    function TapTool() {\n        return TapTool.__super__.constructor.apply(this, arguments);\n    }\n    TapTool.prototype.default_view = exports.TapToolView;\n    TapTool.prototype.type = \"TapTool\";\n    TapTool.prototype.tool_name = \"Tap\";\n    TapTool.prototype.icon = \"bk-tool-icon-tap-select\";\n    TapTool.prototype.event_type = \"tap\";\n    TapTool.prototype.default_order = 10;\n    TapTool.define({\n        behavior: [p.String, \"select\"],\n        callback: [p.Any]\n    });\n    return TapTool;\n})(select_tool_1.SelectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar p = require(\"core/properties\");\nexports.WheelPanToolView = (function (superClass) {\n    extend(WheelPanToolView, superClass);\n    function WheelPanToolView() {\n        return WheelPanToolView.__super__.constructor.apply(this, arguments);\n    }\n    WheelPanToolView.prototype._scroll = function (e) {\n        var factor;\n        factor = this.model.speed * e.bokeh.delta;\n        if (factor > 0.9) {\n            factor = 0.9;\n        }\n        else if (factor < -0.9) {\n            factor = -0.9;\n        }\n        return this._update_ranges(factor);\n    };\n    WheelPanToolView.prototype._update_ranges = function (factor) {\n        var end, frame, hr, mapper, name, pan_info, ref, ref1, ref2, ref3, ref4, ref5, start, sx0, sx1, sy0, sy1, vr, vx_high, vx_low, vx_range, vy_high, vy_low, vy_range, xrs, yrs;\n        frame = this.plot_model.frame;\n        hr = frame.h_range;\n        vr = frame.v_range;\n        ref = [hr.start, hr.end], vx_low = ref[0], vx_high = ref[1];\n        ref1 = [vr.start, vr.end], vy_low = ref1[0], vy_high = ref1[1];\n        switch (this.model.dimension) {\n            case \"height\":\n                vy_range = Math.abs(vy_high - vy_low);\n                sx0 = vx_low;\n                sx1 = vx_high;\n                sy0 = vy_low + vy_range * factor;\n                sy1 = vy_high + vy_range * factor;\n                break;\n            case \"width\":\n                vx_range = Math.abs(vx_high - vx_low);\n                sx0 = vx_low - vx_range * factor;\n                sx1 = vx_high - vx_range * factor;\n                sy0 = vy_low;\n                sy1 = vy_high;\n        }\n        xrs = {};\n        ref2 = frame.x_mappers;\n        for (name in ref2) {\n            mapper = ref2[name];\n            ref3 = mapper.v_map_from_target([sx0, sx1], true), start = ref3[0], end = ref3[1];\n            xrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        yrs = {};\n        ref4 = frame.y_mappers;\n        for (name in ref4) {\n            mapper = ref4[name];\n            ref5 = mapper.v_map_from_target([sy0, sy1], true), start = ref5[0], end = ref5[1];\n            yrs[name] = {\n                start: start,\n                end: end\n            };\n        }\n        pan_info = {\n            xrs: xrs,\n            yrs: yrs,\n            factor: factor\n        };\n        this.plot_view.push_state('wheel_pan', {\n            range: pan_info\n        });\n        this.plot_view.update_range(pan_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return WheelPanToolView;\n})(gesture_tool_1.GestureToolView);\nexports.WheelPanTool = (function (superClass) {\n    extend(WheelPanTool, superClass);\n    function WheelPanTool() {\n        return WheelPanTool.__super__.constructor.apply(this, arguments);\n    }\n    WheelPanTool.prototype.type = 'WheelPanTool';\n    WheelPanTool.prototype.default_view = exports.WheelPanToolView;\n    WheelPanTool.prototype.tool_name = \"Wheel Pan\";\n    WheelPanTool.prototype.icon = \"bk-tool-icon-wheel-pan\";\n    WheelPanTool.prototype.event_type = 'scroll';\n    WheelPanTool.prototype.default_order = 12;\n    WheelPanTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimension);\n        }\n    });\n    WheelPanTool.define({\n        dimension: [p.Dimension, \"width\"]\n    });\n    WheelPanTool.internal({\n        speed: [p.Number, 1 / 1000]\n    });\n    return WheelPanTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar document, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gesture_tool_1 = require(\"./gesture_tool\");\nvar zoom_1 = require(\"core/util/zoom\");\nvar p = require(\"core/properties\");\nif (typeof document === \"undefined\" || document === null) {\n    document = {};\n}\nexports.WheelZoomToolView = (function (superClass) {\n    extend(WheelZoomToolView, superClass);\n    function WheelZoomToolView() {\n        return WheelZoomToolView.__super__.constructor.apply(this, arguments);\n    }\n    WheelZoomToolView.prototype._pinch = function (e) {\n        var delta;\n        if (e.scale >= 1) {\n            delta = (e.scale - 1) * 20.0;\n        }\n        else {\n            delta = -20.0 / e.scale;\n        }\n        e.bokeh.delta = delta;\n        return this._scroll(e);\n    };\n    WheelZoomToolView.prototype._scroll = function (e) {\n        var dims, factor, frame, h_axis, hr, v_axis, vr, vx, vy, zoom_info;\n        frame = this.plot_model.frame;\n        hr = frame.h_range;\n        vr = frame.v_range;\n        vx = this.plot_view.canvas.sx_to_vx(e.bokeh.sx);\n        vy = this.plot_view.canvas.sy_to_vy(e.bokeh.sy);\n        dims = this.model.dimensions;\n        h_axis = (dims === 'width' || dims === 'both') && (hr.min < vx && vx < hr.max);\n        v_axis = (dims === 'height' || dims === 'both') && (vr.min < vy && vy < vr.max);\n        factor = this.model.speed * e.bokeh.delta;\n        zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, {\n            x: vx,\n            y: vy\n        });\n        this.plot_view.push_state('wheel_zoom', {\n            range: zoom_info\n        });\n        this.plot_view.update_range(zoom_info, false, true);\n        this.plot_view.interactive_timestamp = Date.now();\n        return null;\n    };\n    return WheelZoomToolView;\n})(gesture_tool_1.GestureToolView);\nexports.WheelZoomTool = (function (superClass) {\n    extend(WheelZoomTool, superClass);\n    function WheelZoomTool() {\n        return WheelZoomTool.__super__.constructor.apply(this, arguments);\n    }\n    WheelZoomTool.prototype.default_view = exports.WheelZoomToolView;\n    WheelZoomTool.prototype.type = \"WheelZoomTool\";\n    WheelZoomTool.prototype.tool_name = \"Wheel Zoom\";\n    WheelZoomTool.prototype.icon = \"bk-tool-icon-wheel-zoom\";\n    WheelZoomTool.prototype.event_type = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'pinch' : 'scroll';\n    WheelZoomTool.prototype.default_order = 10;\n    WheelZoomTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    });\n    WheelZoomTool.define({\n        dimensions: [p.Dimensions, \"both\"]\n    });\n    WheelZoomTool.internal({\n        speed: [p.Number, 1 / 600]\n    });\n    return WheelZoomTool;\n})(gesture_tool_1.GestureTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar action_tool_1 = require(\"./actions/action_tool\");\nexports.ActionTool = action_tool_1.ActionTool;\nvar help_tool_1 = require(\"./actions/help_tool\");\nexports.HelpTool = help_tool_1.HelpTool;\nvar redo_tool_1 = require(\"./actions/redo_tool\");\nexports.RedoTool = redo_tool_1.RedoTool;\nvar reset_tool_1 = require(\"./actions/reset_tool\");\nexports.ResetTool = reset_tool_1.ResetTool;\nvar save_tool_1 = require(\"./actions/save_tool\");\nexports.SaveTool = save_tool_1.SaveTool;\nvar undo_tool_1 = require(\"./actions/undo_tool\");\nexports.UndoTool = undo_tool_1.UndoTool;\nvar zoom_in_tool_1 = require(\"./actions/zoom_in_tool\");\nexports.ZoomInTool = zoom_in_tool_1.ZoomInTool;\nvar zoom_out_tool_1 = require(\"./actions/zoom_out_tool\");\nexports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;\nvar button_tool_1 = require(\"./button_tool\");\nexports.ButtonTool = button_tool_1.ButtonTool;\nvar box_select_tool_1 = require(\"./gestures/box_select_tool\");\nexports.BoxSelectTool = box_select_tool_1.BoxSelectTool;\nvar box_zoom_tool_1 = require(\"./gestures/box_zoom_tool\");\nexports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nexports.GestureTool = gesture_tool_1.GestureTool;\nvar lasso_select_tool_1 = require(\"./gestures/lasso_select_tool\");\nexports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;\nvar pan_tool_1 = require(\"./gestures/pan_tool\");\nexports.PanTool = pan_tool_1.PanTool;\nvar poly_select_tool_1 = require(\"./gestures/poly_select_tool\");\nexports.PolySelectTool = poly_select_tool_1.PolySelectTool;\nvar resize_tool_1 = require(\"./gestures/resize_tool\");\nexports.ResizeTool = resize_tool_1.ResizeTool;\nvar select_tool_1 = require(\"./gestures/select_tool\");\nexports.SelectTool = select_tool_1.SelectTool;\nvar tap_tool_1 = require(\"./gestures/tap_tool\");\nexports.TapTool = tap_tool_1.TapTool;\nvar wheel_pan_tool_1 = require(\"./gestures/wheel_pan_tool\");\nexports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;\nvar wheel_zoom_tool_1 = require(\"./gestures/wheel_zoom_tool\");\nexports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;\nvar crosshair_tool_1 = require(\"./inspectors/crosshair_tool\");\nexports.CrosshairTool = crosshair_tool_1.CrosshairTool;\nvar hover_tool_1 = require(\"./inspectors/hover_tool\");\nexports.HoverTool = hover_tool_1.HoverTool;\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nexports.InspectTool = inspect_tool_1.InspectTool;\nvar tool_1 = require(\"./tool\");\nexports.Tool = tool_1.Tool;\nvar tool_events_1 = require(\"./tool_events\");\nexports.ToolEvents = tool_events_1.ToolEvents;\nvar tool_proxy_1 = require(\"./tool_proxy\");\nexports.ToolProxy = tool_proxy_1.ToolProxy;\nvar toolbar_1 = require(\"./toolbar\");\nexports.Toolbar = toolbar_1.Toolbar;\nvar toolbar_base_1 = require(\"./toolbar_base\");\nexports.ToolbarBase = toolbar_base_1.ToolbarBase;\nvar toolbar_box_1 = require(\"./toolbar_box\");\nexports.ToolbarBoxToolbar = toolbar_box_1.ToolbarBoxToolbar;\nvar toolbar_box_2 = require(\"./toolbar_box\");\nexports.ToolbarBox = toolbar_box_2.ToolbarBox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar inspect_tool_1 = require(\"./inspect_tool\");\nvar span_1 = require(\"../../annotations/span\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.CrosshairToolView = (function (superClass) {\n    extend(CrosshairToolView, superClass);\n    function CrosshairToolView() {\n        return CrosshairToolView.__super__.constructor.apply(this, arguments);\n    }\n    CrosshairToolView.prototype._move = function (e) {\n        var canvas, frame, vx, vy;\n        if (!this.model.active) {\n            return;\n        }\n        frame = this.plot_model.frame;\n        canvas = this.plot_model.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!frame.contains(vx, vy)) {\n            vx = vy = null;\n        }\n        return this._update_spans(vx, vy);\n    };\n    CrosshairToolView.prototype._move_exit = function (e) {\n        return this._update_spans(null, null);\n    };\n    CrosshairToolView.prototype._update_spans = function (x, y) {\n        var dims;\n        dims = this.model.dimensions;\n        if (dims === 'width' || dims === 'both') {\n            this.model.spans.width.computed_location = y;\n        }\n        if (dims === 'height' || dims === 'both') {\n            return this.model.spans.height.computed_location = x;\n        }\n    };\n    return CrosshairToolView;\n})(inspect_tool_1.InspectToolView);\nexports.CrosshairTool = (function (superClass) {\n    extend(CrosshairTool, superClass);\n    function CrosshairTool() {\n        return CrosshairTool.__super__.constructor.apply(this, arguments);\n    }\n    CrosshairTool.prototype.default_view = exports.CrosshairToolView;\n    CrosshairTool.prototype.type = \"CrosshairTool\";\n    CrosshairTool.prototype.tool_name = \"Crosshair\";\n    CrosshairTool.prototype.icon = \"bk-tool-icon-crosshair\";\n    CrosshairTool.define({\n        dimensions: [p.Dimensions, \"both\"],\n        line_color: [p.Color, 'black'],\n        line_width: [p.Number, 1],\n        line_alpha: [p.Number, 1.0]\n    });\n    CrosshairTool.internal({\n        location_units: [p.SpatialUnits, \"screen\"],\n        render_mode: [p.RenderMode, \"css\"],\n        spans: [p.Any]\n    });\n    CrosshairTool.getters({\n        tooltip: function () {\n            return this._get_dim_tooltip(\"Crosshair\", this.dimensions);\n        },\n        synthetic_renderers: function () {\n            return object_1.values(this.spans);\n        }\n    });\n    CrosshairTool.prototype.initialize = function (attrs, options) {\n        CrosshairTool.__super__.initialize.call(this, attrs, options);\n        return this.spans = {\n            width: new span_1.Span({\n                for_hover: true,\n                dimension: \"width\",\n                render_mode: this.render_mode,\n                location_units: this.location_units,\n                line_color: this.line_color,\n                line_width: this.line_width,\n                line_alpha: this.line_alpha\n            }),\n            height: new span_1.Span({\n                for_hover: true,\n                dimension: \"height\",\n                render_mode: this.render_mode,\n                location_units: this.location_units,\n                line_color: this.line_color,\n                line_width: this.line_width,\n                line_alpha: this.line_alpha\n            })\n        };\n    };\n    return CrosshairTool;\n})(inspect_tool_1.InspectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _color_to_hex, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar inspect_tool_1 = require(\"./inspect_tool\");\nvar tooltip_1 = require(\"../../annotations/tooltip\");\nvar glyph_renderer_1 = require(\"../../renderers/glyph_renderer\");\nvar hittest = require(\"core/hittest\");\nvar templating_1 = require(\"core/util/templating\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nvar types_1 = require(\"core/util/types\");\n_color_to_hex = function (color) {\n    var blue, digits, green, red, rgb;\n    if (color.substr(0, 1) === '#') {\n        return color;\n    }\n    digits = /(.*?)rgb\\((\\d+), (\\d+), (\\d+)\\)/.exec(color);\n    red = parseInt(digits[2]);\n    green = parseInt(digits[3]);\n    blue = parseInt(digits[4]);\n    rgb = blue | (green << 8) | (red << 16);\n    return digits[1] + '#' + rgb.toString(16);\n};\nexports.HoverToolView = (function (superClass) {\n    extend(HoverToolView, superClass);\n    function HoverToolView() {\n        return HoverToolView.__super__.constructor.apply(this, arguments);\n    }\n    HoverToolView.prototype.bind_bokeh_events = function () {\n        var k, len, r, ref;\n        ref = this.model.computed_renderers;\n        for (k = 0, len = ref.length; k < len; k++) {\n            r = ref[k];\n            this.listenTo(r.data_source, 'inspect', this._update);\n        }\n        return this.plot_view.canvas_view.el.style.cursor = \"crosshair\";\n    };\n    HoverToolView.prototype._clear = function () {\n        var ref, results, rid, tt;\n        this._inspect(2e308, 2e308);\n        ref = this.model.ttmodels;\n        results = [];\n        for (rid in ref) {\n            tt = ref[rid];\n            results.push(tt.clear());\n        }\n        return results;\n    };\n    HoverToolView.prototype._move = function (e) {\n        var canvas, vx, vy;\n        if (!this.model.active) {\n            return;\n        }\n        canvas = this.plot_view.canvas;\n        vx = canvas.sx_to_vx(e.bokeh.sx);\n        vy = canvas.sy_to_vy(e.bokeh.sy);\n        if (!this.plot_view.frame.contains(vx, vy)) {\n            return this._clear();\n        }\n        else {\n            return this._inspect(vx, vy);\n        }\n    };\n    HoverToolView.prototype._move_exit = function () {\n        return this._clear();\n    };\n    HoverToolView.prototype._inspect = function (vx, vy, e) {\n        var geometry, hovered_indexes, hovered_renderers, k, len, r, ref, sm;\n        geometry = {\n            type: 'point',\n            vx: vx,\n            vy: vy\n        };\n        if (this.model.mode === 'mouse') {\n            geometry['type'] = 'point';\n        }\n        else {\n            geometry['type'] = 'span';\n            if (this.model.mode === 'vline') {\n                geometry.direction = 'h';\n            }\n            else {\n                geometry.direction = 'v';\n            }\n        }\n        hovered_indexes = [];\n        hovered_renderers = [];\n        ref = this.model.computed_renderers;\n        for (k = 0, len = ref.length; k < len; k++) {\n            r = ref[k];\n            sm = r.data_source.selection_manager;\n            sm.inspect(this, this.plot_view.renderer_views[r.id], geometry, {\n                \"geometry\": geometry\n            });\n        }\n        if (this.model.callback != null) {\n            this._emit_callback(geometry);\n        }\n    };\n    HoverToolView.prototype._update = function (indices, tool, renderer, ds, arg) {\n        var canvas, d1x, d1y, d2x, d2y, data_x, data_y, dist1, dist2, frame, geometry, i, j, k, l, len, len1, pt, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rx, ry, sdatax, sdatay, sx, sy, tooltip, vars, vx, vy, x, xmapper, y, ymapper;\n        geometry = arg.geometry;\n        tooltip = (ref = this.model.ttmodels[renderer.model.id]) != null ? ref : null;\n        if (tooltip == null) {\n            return;\n        }\n        tooltip.clear();\n        if (indices['0d'].glyph === null && indices['1d'].indices.length === 0) {\n            return;\n        }\n        vx = geometry.vx;\n        vy = geometry.vy;\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        sx = canvas.vx_to_sx(vx);\n        sy = canvas.vy_to_sy(vy);\n        xmapper = frame.x_mappers[renderer.model.x_range_name];\n        ymapper = frame.y_mappers[renderer.model.y_range_name];\n        x = xmapper.map_from_target(vx);\n        y = ymapper.map_from_target(vy);\n        ref1 = indices['0d'].indices;\n        for (k = 0, len = ref1.length; k < len; k++) {\n            i = ref1[k];\n            data_x = renderer.glyph._x[i + 1];\n            data_y = renderer.glyph._y[i + 1];\n            switch (this.model.line_policy) {\n                case \"interp\":\n                    ref2 = renderer.glyph.get_interpolation_hit(i, geometry), data_x = ref2[0], data_y = ref2[1];\n                    rx = xmapper.map_to_target(data_x);\n                    ry = ymapper.map_to_target(data_y);\n                    break;\n                case \"prev\":\n                    rx = canvas.sx_to_vx(renderer.glyph.sx[i]);\n                    ry = canvas.sy_to_vy(renderer.glyph.sy[i]);\n                    break;\n                case \"next\":\n                    rx = canvas.sx_to_vx(renderer.glyph.sx[i + 1]);\n                    ry = canvas.sy_to_vy(renderer.glyph.sy[i + 1]);\n                    break;\n                case \"nearest\":\n                    d1x = renderer.glyph.sx[i];\n                    d1y = renderer.glyph.sy[i];\n                    dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);\n                    d2x = renderer.glyph.sx[i + 1];\n                    d2y = renderer.glyph.sy[i + 1];\n                    dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);\n                    if (dist1 < dist2) {\n                        ref3 = [d1x, d1y], sdatax = ref3[0], sdatay = ref3[1];\n                    }\n                    else {\n                        ref4 = [d2x, d2y], sdatax = ref4[0], sdatay = ref4[1];\n                        i = i + 1;\n                    }\n                    data_x = renderer.glyph._x[i];\n                    data_y = renderer.glyph._y[i];\n                    rx = canvas.sx_to_vx(sdatax);\n                    ry = canvas.sy_to_vy(sdatay);\n                    break;\n                default:\n                    ref5 = [vx, vy], rx = ref5[0], ry = ref5[1];\n            }\n            vars = {\n                index: i,\n                x: x,\n                y: y,\n                vx: vx,\n                vy: vy,\n                sx: sx,\n                sy: sy,\n                data_x: data_x,\n                data_y: data_y,\n                rx: rx,\n                ry: ry\n            };\n            tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));\n        }\n        ref6 = indices['1d'].indices;\n        for (l = 0, len1 = ref6.length; l < len1; l++) {\n            i = ref6[l];\n            if (!object_1.isEmpty(indices['2d'].indices)) {\n                ref7 = indices['2d'].indices;\n                for (i in ref7) {\n                    j = ref7[i][0];\n                    data_x = renderer.glyph._xs[i][j];\n                    data_y = renderer.glyph._ys[i][j];\n                    switch (this.model.line_policy) {\n                        case \"interp\":\n                            ref8 = renderer.glyph.get_interpolation_hit(i, j, geometry), data_x = ref8[0], data_y = ref8[1];\n                            rx = xmapper.map_to_target(data_x);\n                            ry = ymapper.map_to_target(data_y);\n                            break;\n                        case \"prev\":\n                            rx = canvas.sx_to_vx(renderer.glyph.sxs[i][j]);\n                            ry = canvas.sy_to_vy(renderer.glyph.sys[i][j]);\n                            break;\n                        case \"next\":\n                            rx = canvas.sx_to_vx(renderer.glyph.sxs[i][j + 1]);\n                            ry = canvas.sy_to_vy(renderer.glyph.sys[i][j + 1]);\n                            break;\n                        case \"nearest\":\n                            d1x = renderer.glyph.sx[i][j];\n                            d1y = renderer.glyph.sy[i][j];\n                            dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);\n                            d2x = renderer.glyph.sx[i][j + 1];\n                            d2y = renderer.glyph.sy[i][j + 1];\n                            dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);\n                            if (dist1 < dist2) {\n                                ref9 = [d1x, d1y], sdatax = ref9[0], sdatay = ref9[1];\n                            }\n                            else {\n                                ref10 = [d2x, d2y], sdatax = ref10[0], sdatay = ref10[1];\n                                j = j + 1;\n                            }\n                            data_x = renderer.glyph._x[i][j];\n                            data_y = renderer.glyph._y[i][j];\n                            rx = canvas.sx_to_vx(sdatax);\n                            ry = canvas.sy_to_vy(sdatay);\n                    }\n                    vars = {\n                        index: i,\n                        segment_index: j,\n                        x: x,\n                        y: y,\n                        vx: vx,\n                        vy: vy,\n                        sx: sx,\n                        sy: sy,\n                        data_x: data_x,\n                        data_y: data_y\n                    };\n                    tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));\n                }\n            }\n            else {\n                data_x = (ref11 = renderer.glyph._x) != null ? ref11[i] : void 0;\n                data_y = (ref12 = renderer.glyph._y) != null ? ref12[i] : void 0;\n                if (this.model.point_policy === 'snap_to_data') {\n                    pt = renderer.glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\n                    if (pt == null) {\n                        pt = renderer.glyph.get_anchor_point(\"center\", i, [sx, sy]);\n                    }\n                    rx = canvas.sx_to_vx(pt.x);\n                    ry = canvas.sy_to_vy(pt.y);\n                }\n                else {\n                    ref13 = [vx, vy], rx = ref13[0], ry = ref13[1];\n                }\n                vars = {\n                    index: i,\n                    x: x,\n                    y: y,\n                    vx: vx,\n                    vy: vy,\n                    sx: sx,\n                    sy: sy,\n                    data_x: data_x,\n                    data_y: data_y\n                };\n                tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));\n            }\n        }\n        return null;\n    };\n    HoverToolView.prototype._emit_callback = function (geometry) {\n        var callback, canvas, data, frame, indices, obj, r, ref, xmapper, ymapper;\n        r = this.model.computed_renderers[0];\n        indices = this.plot_view.renderer_views[r.id].hit_test(geometry);\n        canvas = this.plot_model.canvas;\n        frame = this.plot_model.frame;\n        geometry['sx'] = canvas.vx_to_sx(geometry.vx);\n        geometry['sy'] = canvas.vy_to_sy(geometry.vy);\n        xmapper = frame.x_mappers[r.x_range_name];\n        ymapper = frame.y_mappers[r.y_range_name];\n        geometry['x'] = xmapper.map_from_target(geometry.vx);\n        geometry['y'] = ymapper.map_from_target(geometry.vy);\n        callback = this.model.callback;\n        ref = [\n            callback, {\n                index: indices,\n                geometry: geometry\n            }\n        ], obj = ref[0], data = ref[1];\n        if (types_1.isFunction(callback)) {\n            callback(obj, data);\n        }\n        else {\n            callback.execute(obj, data);\n        }\n    };\n    HoverToolView.prototype._render_tooltips = function (ds, i, vars) {\n        var cell, colname, color, column, el, hex, k, label, len, match, opts, ref, ref1, row, rows, swatch, tooltips, value;\n        tooltips = this.model.tooltips;\n        if (types_1.isString(tooltips)) {\n            el = dom_1.div();\n            el.innerHTML = templating_1.replace_placeholders(tooltips, ds, i, vars);\n            return el;\n        }\n        else if (types_1.isFunction(tooltips)) {\n            return tooltips(ds, vars);\n        }\n        else {\n            rows = dom_1.div({\n                style: {\n                    display: \"table\",\n                    borderSpacing: \"2px\"\n                }\n            });\n            for (k = 0, len = tooltips.length; k < len; k++) {\n                ref = tooltips[k], label = ref[0], value = ref[1];\n                row = dom_1.div({\n                    style: {\n                        display: \"table-row\"\n                    }\n                });\n                rows.appendChild(row);\n                cell = dom_1.div({\n                    style: {\n                        display: \"table-cell\"\n                    },\n                    \"class\": 'bk-tooltip-row-label'\n                }, label + \": \");\n                row.appendChild(cell);\n                cell = dom_1.div({\n                    style: {\n                        display: \"table-cell\"\n                    },\n                    \"class\": 'bk-tooltip-row-value'\n                });\n                row.appendChild(cell);\n                if (value.indexOf(\"$color\") >= 0) {\n                    ref1 = value.match(/\\$color(\\[.*\\])?:(\\w*)/), match = ref1[0], opts = ref1[1], colname = ref1[2];\n                    column = ds.get_column(colname);\n                    if (column == null) {\n                        el = dom_1.span({}, colname + \" unknown\");\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    hex = (opts != null ? opts.indexOf(\"hex\") : void 0) >= 0;\n                    swatch = (opts != null ? opts.indexOf(\"swatch\") : void 0) >= 0;\n                    color = column[i];\n                    if (color == null) {\n                        el = dom_1.span({}, \"(null)\");\n                        cell.appendChild(el);\n                        continue;\n                    }\n                    if (hex) {\n                        color = _color_to_hex(color);\n                    }\n                    el = dom_1.span({}, color);\n                    cell.appendChild(el);\n                    if (swatch) {\n                        el = dom_1.span({\n                            \"class\": 'bk-tooltip-color-block',\n                            style: {\n                                backgroundColor: color\n                            }\n                        }, \" \");\n                        cell.appendChild(el);\n                    }\n                }\n                else {\n                    value = value.replace(\"$~\", \"$data_\");\n                    el = dom_1.span();\n                    el.innerHTML = templating_1.replace_placeholders(value, ds, i, vars);\n                    cell.appendChild(el);\n                }\n            }\n            return rows;\n        }\n    };\n    return HoverToolView;\n})(inspect_tool_1.InspectToolView);\nexports.HoverTool = (function (superClass) {\n    extend(HoverTool, superClass);\n    function HoverTool() {\n        return HoverTool.__super__.constructor.apply(this, arguments);\n    }\n    HoverTool.prototype.default_view = exports.HoverToolView;\n    HoverTool.prototype.type = \"HoverTool\";\n    HoverTool.prototype.tool_name = \"Hover\";\n    HoverTool.prototype.icon = \"bk-tool-icon-hover\";\n    HoverTool.define({\n        tooltips: [p.Any, [[\"index\", \"$index\"], [\"data (x, y)\", \"($x, $y)\"], [\"canvas (x, y)\", \"($sx, $sy)\"]]],\n        renderers: [p.Array, []],\n        names: [p.Array, []],\n        mode: [p.String, 'mouse'],\n        point_policy: [p.String, 'snap_to_data'],\n        line_policy: [p.String, 'nearest'],\n        show_arrow: [p.Boolean, true],\n        anchor: [p.String, 'center'],\n        attachment: [p.String, 'horizontal'],\n        callback: [p.Any]\n    });\n    HoverTool.prototype.initialize = function (attrs, options) {\n        HoverTool.__super__.initialize.call(this, attrs, options);\n        this.define_computed_property('computed_renderers', function () {\n            var all_renderers, names, r, renderers;\n            renderers = this.renderers;\n            names = this.names;\n            if (renderers.length === 0) {\n                all_renderers = this.plot.renderers;\n                renderers = (function () {\n                    var k, len, results;\n                    results = [];\n                    for (k = 0, len = all_renderers.length; k < len; k++) {\n                        r = all_renderers[k];\n                        if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n            }\n            if (names.length > 0) {\n                renderers = (function () {\n                    var k, len, results;\n                    results = [];\n                    for (k = 0, len = renderers.length; k < len; k++) {\n                        r = renderers[k];\n                        if (names.indexOf(r.name) >= 0) {\n                            results.push(r);\n                        }\n                    }\n                    return results;\n                })();\n            }\n            return renderers;\n        }, true);\n        this.add_dependencies('computed_renderers', this, ['renderers', 'names', 'plot']);\n        this.add_dependencies('computed_renderers', this.plot, ['renderers']);\n        this.define_computed_property('ttmodels', function () {\n            var k, len, r, ref, tooltip, tooltips, ttmodels;\n            ttmodels = {};\n            tooltips = this.tooltips;\n            if (tooltips != null) {\n                ref = this.computed_renderers;\n                for (k = 0, len = ref.length; k < len; k++) {\n                    r = ref[k];\n                    tooltip = new tooltip_1.Tooltip({\n                        custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),\n                        attachment: this.attachment,\n                        show_arrow: this.show_arrow\n                    });\n                    ttmodels[r.id] = tooltip;\n                }\n            }\n            return ttmodels;\n        });\n        return this.add_dependencies('ttmodels', this, ['computed_renderers', 'tooltips']);\n    };\n    HoverTool.getters({\n        computed_renderers: function () {\n            return this._get_computed('computed_renderers');\n        },\n        ttmodels: function () {\n            return this._get_computed('ttmodels');\n        },\n        synthetic_renderers: function () {\n            return object_1.values(this.ttmodels);\n        }\n    });\n    return HoverTool;\n})(inspect_tool_1.InspectTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"../button_tool\");\nexports.InspectToolView = (function (superClass) {\n    extend(InspectToolView, superClass);\n    function InspectToolView() {\n        return InspectToolView.__super__.constructor.apply(this, arguments);\n    }\n    return InspectToolView;\n})(button_tool_1.ButtonToolView);\nexports.InspectTool = (function (superClass) {\n    extend(InspectTool, superClass);\n    function InspectTool() {\n        return InspectTool.__super__.constructor.apply(this, arguments);\n    }\n    InspectTool.prototype.event_type = \"move\";\n    InspectTool.override({\n        active: true\n    });\n    return InspectTool;\n})(button_tool_1.ButtonTool);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar button_tool_1 = require(\"./button_tool\");\nexports.OnOffButtonView = (function (superClass) {\n    extend(OnOffButtonView, superClass);\n    function OnOffButtonView() {\n        return OnOffButtonView.__super__.constructor.apply(this, arguments);\n    }\n    OnOffButtonView.prototype.render = function () {\n        OnOffButtonView.__super__.render.call(this);\n        if (this.model.active) {\n            return this.el.classList.add('bk-active');\n        }\n        else {\n            return this.el.classList.remove('bk-active');\n        }\n    };\n    OnOffButtonView.prototype._clicked = function () {\n        var active;\n        active = this.model.active;\n        return this.model.active = !active;\n    };\n    return OnOffButtonView;\n})(button_tool_1.ButtonToolButtonView);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar bokeh_view_1 = require(\"core/bokeh_view\");\nvar array_1 = require(\"core/util/array\");\nvar model_1 = require(\"../../model\");\nexports.ToolView = (function (superClass) {\n    extend(ToolView, superClass);\n    function ToolView() {\n        return ToolView.__super__.constructor.apply(this, arguments);\n    }\n    ToolView.prototype.initialize = function (options) {\n        ToolView.__super__.initialize.call(this, options);\n        return this.plot_view = options.plot_view;\n    };\n    ToolView.getters({\n        plot_model: function () {\n            return this.plot_view.model;\n        }\n    });\n    ToolView.prototype.bind_bokeh_events = function () {\n        return this.listenTo(this.model, 'change:active', (function (_this) {\n            return function () {\n                if (_this.model.active) {\n                    return _this.activate();\n                }\n                else {\n                    return _this.deactivate();\n                }\n            };\n        })(this));\n    };\n    ToolView.prototype.activate = function () { };\n    ToolView.prototype.deactivate = function () { };\n    return ToolView;\n})(bokeh_view_1.BokehView);\nexports.Tool = (function (superClass) {\n    extend(Tool, superClass);\n    function Tool() {\n        return Tool.__super__.constructor.apply(this, arguments);\n    }\n    Tool.getters({\n        synthetic_renderers: function () {\n            return [];\n        }\n    });\n    Tool.define({\n        plot: [p.Instance]\n    });\n    Tool.internal({\n        active: [p.Boolean, false]\n    });\n    Tool.prototype._get_dim_tooltip = function (name, dims) {\n        switch (dims) {\n            case 'width':\n                return name + \" (x-axis)\";\n            case 'height':\n                return name + \" (y-axis)\";\n            case 'both':\n                return name;\n        }\n    };\n    Tool.prototype._get_dim_limits = function (arg, arg1, frame, dims) {\n        var hr, vr, vx0, vx1, vxlim, vy0, vy1, vylim;\n        vx0 = arg[0], vy0 = arg[1];\n        vx1 = arg1[0], vy1 = arg1[1];\n        hr = frame.h_range;\n        if (dims === 'width' || dims === 'both') {\n            vxlim = [array_1.min([vx0, vx1]), array_1.max([vx0, vx1])];\n            vxlim = [array_1.max([vxlim[0], hr.min]), array_1.min([vxlim[1], hr.max])];\n        }\n        else {\n            vxlim = [hr.min, hr.max];\n        }\n        vr = frame.v_range;\n        if (dims === 'height' || dims === 'both') {\n            vylim = [array_1.min([vy0, vy1]), array_1.max([vy0, vy1])];\n            vylim = [array_1.max([vylim[0], vr.min]), array_1.min([vylim[1], vr.max])];\n        }\n        else {\n            vylim = [vr.min, vr.max];\n        }\n        return [vxlim, vylim];\n    };\n    return Tool;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nvar p = require(\"core/properties\");\nexports.ToolEvents = (function (superClass) {\n    extend(ToolEvents, superClass);\n    function ToolEvents() {\n        return ToolEvents.__super__.constructor.apply(this, arguments);\n    }\n    ToolEvents.prototype.type = 'ToolEvents';\n    ToolEvents.define({\n        geometries: [p.Array, []]\n    });\n    return ToolEvents;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar model_1 = require(\"../../model\");\nexports.ToolProxy = (function (superClass) {\n    extend(ToolProxy, superClass);\n    function ToolProxy() {\n        return ToolProxy.__super__.constructor.apply(this, arguments);\n    }\n    ToolProxy.prototype.initialize = function (options) {\n        ToolProxy.__super__.initialize.call(this, options);\n        this.listenTo(this, 'do', this[\"do\"]);\n        return this.listenTo(this, 'change:active', this.set_active);\n    };\n    ToolProxy.prototype[\"do\"] = function () {\n        var i, len, ref, tool;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            tool.trigger('do');\n        }\n        return null;\n    };\n    ToolProxy.prototype.set_active = function () {\n        var i, len, ref, tool;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            tool.active = this.active;\n        }\n        return null;\n    };\n    ToolProxy.define({\n        tools: [p.Array, []],\n        active: [p.Bool, false],\n        tooltip: [p.String],\n        tool_name: [p.String],\n        disabled: [p.Bool, false],\n        event_type: [p.String],\n        icon: [p.String]\n    });\n    ToolProxy.prototype._clicked = function () {\n        var active;\n        active = this.model.active;\n        return this.model.active = !active;\n    };\n    return ToolProxy;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar help_tool_1 = require(\"./actions/help_tool\");\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nvar toolbar_base_1 = require(\"./toolbar_base\");\nexports.Toolbar = (function (superClass) {\n    extend(Toolbar, superClass);\n    function Toolbar() {\n        return Toolbar.__super__.constructor.apply(this, arguments);\n    }\n    Toolbar.prototype.type = 'Toolbar';\n    Toolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;\n    Toolbar.prototype.initialize = function (attrs, options) {\n        Toolbar.__super__.initialize.call(this, attrs, options);\n        this.listenTo(this, 'change:tools', this._init_tools);\n        return this._init_tools();\n    };\n    Toolbar.prototype._init_tools = function () {\n        var et, i, len, ref, results, tool, tools;\n        ref = this.tools;\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            if (tool instanceof inspect_tool_1.InspectTool) {\n                if (!array_1.any(this.inspectors, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.inspectors = this.inspectors.concat([tool]);\n                }\n            }\n            else if (tool instanceof help_tool_1.HelpTool) {\n                if (!array_1.any(this.help, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.help = this.help.concat([tool]);\n                }\n            }\n            else if (tool instanceof action_tool_1.ActionTool) {\n                if (!array_1.any(this.actions, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.actions = this.actions.concat([tool]);\n                }\n            }\n            else if (tool instanceof gesture_tool_1.GestureTool) {\n                et = tool.event_type;\n                if (!(et in this.gestures)) {\n                    logger.warn(\"Toolbar: unknown event type '\" + et + \"' for tool: \" + tool.type + \" (\" + tool.id + \")\");\n                    continue;\n                }\n                if (!array_1.any(this.gestures[et].tools, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    this.gestures[et].tools = this.gestures[et].tools.concat([tool]);\n                }\n                this.listenTo(tool, 'change:active', this._active_change.bind(tool));\n            }\n        }\n        results = [];\n        for (et in this.gestures) {\n            tools = this.gestures[et].tools;\n            if (tools.length === 0) {\n                continue;\n            }\n            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {\n                return tool.default_order;\n            });\n            if (et === 'tap') {\n                if (this.active_tap === null) {\n                    continue;\n                }\n                if (this.active_tap === 'auto') {\n                    this.gestures[et].tools[0].active = true;\n                }\n                else {\n                    this.active_tap.active = true;\n                }\n            }\n            if (et === 'pan') {\n                if (this.active_drag === null) {\n                    continue;\n                }\n                if (this.active_drag === 'auto') {\n                    this.gestures[et].tools[0].active = true;\n                }\n                else {\n                    this.active_drag.active = true;\n                }\n            }\n            if (et === 'pinch' || et === 'scroll') {\n                if (this.active_scroll === null || this.active_scroll === 'auto') {\n                    continue;\n                }\n                results.push(this.active_scroll.active = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    Toolbar.define({\n        active_drag: [p.Any, 'auto'],\n        active_scroll: [p.Any, 'auto'],\n        active_tap: [p.Any, 'auto']\n    });\n    return Toolbar;\n})(toolbar_base_1.ToolbarBase);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; };\nvar logging_1 = require(\"core/logging\");\nvar solver_1 = require(\"core/layout/solver\");\nvar dom_1 = require(\"core/dom\");\nvar p = require(\"core/properties\");\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar on_off_button_1 = require(\"./on_off_button\");\nvar toolbar_template_1 = require(\"./toolbar_template\");\nexports.ToolbarBaseView = (function (superClass) {\n    extend(ToolbarBaseView, superClass);\n    function ToolbarBaseView() {\n        return ToolbarBaseView.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBaseView.prototype.className = \"bk-toolbar-wrapper\";\n    ToolbarBaseView.prototype.template = toolbar_template_1.default;\n    ToolbarBaseView.prototype.render = function () {\n        var buttons, et, gestures, i, j, k, l, len, len1, len2, len3, obj, ref, ref1, ref2, ref3;\n        dom_1.empty(this.el);\n        if (this.model.sizing_mode !== 'fixed') {\n            this.el.style.left = this.model._dom_left._value + \"px\";\n            this.el.style.top = this.model._dom_top._value + \"px\";\n            this.el.style.width = this.model._width._value + \"px\";\n            this.el.style.height = this.model._height._value + \"px\";\n        }\n        this.el.appendChild(this.template({\n            logo: this.model.logo,\n            location: this.model.toolbar_location,\n            sticky: this.model.toolbar_sticky ? 'sticky' : 'not-sticky'\n        }));\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='inspectors']\");\n        ref = this.model.inspectors;\n        for (i = 0, len = ref.length; i < len; i++) {\n            obj = ref[i];\n            buttons.appendChild(new on_off_button_1.OnOffButtonView({\n                model: obj\n            }).el);\n        }\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='help']\");\n        ref1 = this.model.help;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n            obj = ref1[j];\n            buttons.appendChild(new action_tool_1.ActionToolButtonView({\n                model: obj\n            }).el);\n        }\n        buttons = this.el.querySelector(\".bk-button-bar-list[type='actions']\");\n        ref2 = this.model.actions;\n        for (k = 0, len2 = ref2.length; k < len2; k++) {\n            obj = ref2[k];\n            buttons.appendChild(new action_tool_1.ActionToolButtonView({\n                model: obj\n            }).el);\n        }\n        gestures = this.model.gestures;\n        for (et in gestures) {\n            buttons = this.el.querySelector(\".bk-button-bar-list[type='\" + et + \"']\");\n            ref3 = gestures[et].tools;\n            for (l = 0, len3 = ref3.length; l < len3; l++) {\n                obj = ref3[l];\n                buttons.appendChild(new on_off_button_1.OnOffButtonView({\n                    model: obj\n                }).el);\n            }\n        }\n        return this;\n    };\n    return ToolbarBaseView;\n})(layout_dom_1.LayoutDOMView);\nexports.ToolbarBase = (function (superClass) {\n    extend(ToolbarBase, superClass);\n    function ToolbarBase() {\n        this._active_change = bind(this._active_change, this);\n        return ToolbarBase.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBase.prototype.type = 'ToolbarBase';\n    ToolbarBase.prototype.default_view = exports.ToolbarBaseView;\n    ToolbarBase.prototype._active_change = function (tool) {\n        var currently_active_tool, event_type, gestures;\n        event_type = tool.event_type;\n        gestures = this.gestures;\n        currently_active_tool = gestures[event_type].active;\n        if ((currently_active_tool != null) && currently_active_tool !== tool) {\n            logging_1.logger.debug(\"Toolbar: deactivating tool: \" + currently_active_tool.type + \" (\" + currently_active_tool.id + \") for event type '\" + event_type + \"'\");\n            currently_active_tool.active = false;\n        }\n        gestures[event_type].active = tool;\n        this.gestures = gestures;\n        logging_1.logger.debug(\"Toolbar: activating tool: \" + tool.type + \" (\" + tool.id + \") for event type '\" + event_type + \"'\");\n        return null;\n    };\n    ToolbarBase.prototype.get_constraints = function () {\n        var constraints;\n        constraints = ToolbarBase.__super__.get_constraints.call(this);\n        constraints.push(solver_1.EQ(this._sizeable, -30));\n        return constraints;\n    };\n    ToolbarBase.define({\n        tools: [p.Array, []],\n        logo: [p.String, 'normal']\n    });\n    ToolbarBase.internal({\n        gestures: [\n            p.Any, function () {\n                return {\n                    pan: {\n                        tools: [],\n                        active: null\n                    },\n                    tap: {\n                        tools: [],\n                        active: null\n                    },\n                    doubletap: {\n                        tools: [],\n                        active: null\n                    },\n                    scroll: {\n                        tools: [],\n                        active: null\n                    },\n                    pinch: {\n                        tools: [],\n                        active: null\n                    },\n                    press: {\n                        tools: [],\n                        active: null\n                    },\n                    rotate: {\n                        tools: [],\n                        active: null\n                    }\n                };\n            }\n        ],\n        actions: [p.Array, []],\n        inspectors: [p.Array, []],\n        help: [p.Array, []],\n        toolbar_location: [p.Location, 'right'],\n        toolbar_sticky: [p.Bool]\n    });\n    ToolbarBase.override({\n        sizing_mode: null\n    });\n    return ToolbarBase;\n})(layout_dom_1.LayoutDOM);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nvar action_tool_1 = require(\"./actions/action_tool\");\nvar help_tool_1 = require(\"./actions/help_tool\");\nvar gesture_tool_1 = require(\"./gestures/gesture_tool\");\nvar inspect_tool_1 = require(\"./inspectors/inspect_tool\");\nvar toolbar_base_1 = require(\"./toolbar_base\");\nvar tool_proxy_1 = require(\"./tool_proxy\");\nvar box_1 = require(\"../layouts/box\");\nexports.ToolbarBoxToolbar = (function (superClass) {\n    extend(ToolbarBoxToolbar, superClass);\n    function ToolbarBoxToolbar() {\n        return ToolbarBoxToolbar.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBoxToolbar.prototype.type = 'ToolbarBoxToolbar';\n    ToolbarBoxToolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;\n    ToolbarBoxToolbar.prototype.initialize = function (options) {\n        ToolbarBoxToolbar.__super__.initialize.call(this, options);\n        this._init_tools();\n        if (this.merge_tools === true) {\n            return this._merge_tools();\n        }\n    };\n    ToolbarBoxToolbar.define({\n        merge_tools: [p.Bool, true]\n    });\n    ToolbarBoxToolbar.prototype._init_tools = function () {\n        var et, i, len, ref, results, tool;\n        ref = this.tools;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n            tool = ref[i];\n            if (tool instanceof inspect_tool_1.InspectTool) {\n                if (!array_1.any(this.inspectors, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.inspectors = this.inspectors.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof help_tool_1.HelpTool) {\n                if (!array_1.any(this.help, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.help = this.help.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof action_tool_1.ActionTool) {\n                if (!array_1.any(this.actions, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.actions = this.actions.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else if (tool instanceof gesture_tool_1.GestureTool) {\n                et = tool.event_type;\n                if (!array_1.any(this.gestures[et].tools, (function (_this) {\n                    return function (t) {\n                        return t.id === tool.id;\n                    };\n                })(this))) {\n                    results.push(this.gestures[et].tools = this.gestures[et].tools.concat([tool]));\n                }\n                else {\n                    results.push(void 0);\n                }\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    ToolbarBoxToolbar.prototype._merge_tools = function () {\n        var actions, active, et, event_type, gestures, helptool, i, info, inspectors, j, k, l, len, len1, len2, len3, make_proxy, new_help_tools, new_help_urls, proxy, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, tool, tool_type, tools;\n        inspectors = {};\n        actions = {};\n        gestures = {};\n        new_help_tools = [];\n        new_help_urls = [];\n        ref = this.help;\n        for (i = 0, len = ref.length; i < len; i++) {\n            helptool = ref[i];\n            if (ref1 = helptool.redirect, indexOf.call(new_help_urls, ref1) < 0) {\n                new_help_tools.push(helptool);\n                new_help_urls.push(helptool.redirect);\n            }\n        }\n        this.help = new_help_tools;\n        ref2 = this.gestures;\n        for (event_type in ref2) {\n            info = ref2[event_type];\n            if (!(event_type in gestures)) {\n                gestures[event_type] = {};\n            }\n            ref3 = info.tools;\n            for (j = 0, len1 = ref3.length; j < len1; j++) {\n                tool = ref3[j];\n                if (!(tool.type in gestures[event_type])) {\n                    gestures[event_type][tool.type] = [];\n                }\n                gestures[event_type][tool.type].push(tool);\n            }\n        }\n        ref4 = this.inspectors;\n        for (k = 0, len2 = ref4.length; k < len2; k++) {\n            tool = ref4[k];\n            if (!(tool.type in inspectors)) {\n                inspectors[tool.type] = [];\n            }\n            inspectors[tool.type].push(tool);\n        }\n        ref5 = this.actions;\n        for (l = 0, len3 = ref5.length; l < len3; l++) {\n            tool = ref5[l];\n            if (!(tool.type in actions)) {\n                actions[tool.type] = [];\n            }\n            actions[tool.type].push(tool);\n        }\n        make_proxy = function (tools, active) {\n            if (active == null) {\n                active = false;\n            }\n            return new tool_proxy_1.ToolProxy({\n                tools: tools,\n                event_type: tools[0].event_type,\n                tooltip: tools[0].tool_name,\n                tool_name: tools[0].tool_name,\n                icon: tools[0].icon,\n                active: active\n            });\n        };\n        for (event_type in gestures) {\n            this.gestures[event_type].tools = [];\n            ref6 = gestures[event_type];\n            for (tool_type in ref6) {\n                tools = ref6[tool_type];\n                if (tools.length > 0) {\n                    proxy = make_proxy(tools);\n                    this.gestures[event_type].tools.push(proxy);\n                    this.listenTo(proxy, 'change:active', this._active_change.bind(proxy));\n                }\n            }\n        }\n        this.actions = [];\n        for (tool_type in actions) {\n            tools = actions[tool_type];\n            if (tools.length > 0) {\n                this.actions.push(make_proxy(tools));\n            }\n        }\n        this.inspectors = [];\n        for (tool_type in inspectors) {\n            tools = inspectors[tool_type];\n            if (tools.length > 0) {\n                this.inspectors.push(make_proxy(tools, active = true));\n            }\n        }\n        results = [];\n        for (et in this.gestures) {\n            tools = this.gestures[et].tools;\n            if (tools.length === 0) {\n                continue;\n            }\n            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {\n                return tool.default_order;\n            });\n            if (et !== 'pinch' && et !== 'scroll') {\n                results.push(this.gestures[et].tools[0].active = true);\n            }\n            else {\n                results.push(void 0);\n            }\n        }\n        return results;\n    };\n    return ToolbarBoxToolbar;\n})(toolbar_base_1.ToolbarBase);\nexports.ToolbarBoxView = (function (superClass) {\n    extend(ToolbarBoxView, superClass);\n    function ToolbarBoxView() {\n        return ToolbarBoxView.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBoxView.prototype.className = 'bk-toolbar-box';\n    ToolbarBoxView.prototype.get_width = function () {\n        if (this.model._horizontal === true) {\n            return 30;\n        }\n        else {\n            return null;\n        }\n    };\n    ToolbarBoxView.prototype.get_height = function () {\n        return 30;\n    };\n    return ToolbarBoxView;\n})(box_1.BoxView);\nexports.ToolbarBox = (function (superClass) {\n    extend(ToolbarBox, superClass);\n    function ToolbarBox() {\n        return ToolbarBox.__super__.constructor.apply(this, arguments);\n    }\n    ToolbarBox.prototype.type = 'ToolbarBox';\n    ToolbarBox.prototype.default_view = exports.ToolbarBoxView;\n    ToolbarBox.prototype.initialize = function (options) {\n        var ref;\n        ToolbarBox.__super__.initialize.call(this, options);\n        this._toolbar = new exports.ToolbarBoxToolbar(options);\n        if ((ref = this.toolbar_location) === 'left' || ref === 'right') {\n            this._horizontal = true;\n            return this._toolbar._sizeable = this._toolbar._width;\n        }\n        else {\n            this._horizontal = false;\n            return this._toolbar._sizeable = this._toolbar._height;\n        }\n    };\n    ToolbarBox.prototype._doc_attached = function () {\n        return this._toolbar.attach_document(this.document);\n    };\n    ToolbarBox.prototype.get_layoutable_children = function () {\n        return [this._toolbar];\n    };\n    ToolbarBox.define({\n        toolbar_location: [p.Location, \"right\"],\n        merge_tools: [p.Bool, true],\n        tools: [p.Any, []],\n        logo: [p.String, \"normal\"]\n    });\n    return ToolbarBox;\n})(box_1.Box);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DOM = require(\"core/dom\");\nexports.default = function (props) {\n    var logo;\n    if (props.logo != null) {\n        var cls = props.logo === \"grey\" ? \"bk-grey\" : null;\n        logo = DOM.createElement(\"a\", { href: \"http://bokeh.pydata.org/\", target: \"_blank\", class: [\"bk-logo\", \"bk-logo-small\", cls] });\n    }\n    return (DOM.createElement(\"div\", { class: [\"bk-toolbar-\" + props.location, \"bk-toolbar-\" + props.sticky] },\n        logo,\n        DOM.createElement(\"div\", { class: 'bk-button-bar' },\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"pan\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"scroll\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"pinch\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"tap\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"press\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"rotate\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"actions\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"inspectors\" }),\n            DOM.createElement(\"div\", { class: 'bk-button-bar-list', type: \"help\" }))));\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, slice = [].slice;\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nvar object_1 = require(\"core/util/object\");\nexports.CustomJSTransform = (function (superClass) {\n    extend(CustomJSTransform, superClass);\n    function CustomJSTransform() {\n        return CustomJSTransform.__super__.constructor.apply(this, arguments);\n    }\n    CustomJSTransform.prototype.type = 'CustomJSTransform';\n    CustomJSTransform.define({\n        args: [p.Any, {}],\n        func: [p.String, \"\"],\n        v_func: [p.String, \"\"]\n    });\n    CustomJSTransform.getters({\n        values: function () {\n            return this._make_values();\n        },\n        scalar_transform: function () {\n            return this._make_transform(\"x\", this.func);\n        },\n        vector_transform: function () {\n            return this._make_transform(\"xs\", this.v_func);\n        }\n    });\n    CustomJSTransform.prototype.compute = function (x) {\n        return this.scalar_transform.apply(this, slice.call(this.values).concat([x], [require], [exports]));\n    };\n    CustomJSTransform.prototype.v_compute = function (xs) {\n        return this.vector_transform.apply(this, slice.call(this.values).concat([xs], [require], [exports]));\n    };\n    CustomJSTransform.prototype._make_transform = function (val, fn) {\n        return (function (func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n        })(Function, slice.call(Object.keys(this.args)).concat([val], [\"require\"], [\"exports\"], [fn]), function () { });\n    };\n    CustomJSTransform.prototype._make_values = function () {\n        return object_1.values(this.args);\n    };\n    return CustomJSTransform;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar customjs_transform_1 = require(\"./customjs_transform\");\nexports.CustomJSTransform = customjs_transform_1.CustomJSTransform;\nvar interpolator_1 = require(\"./interpolator\");\nexports.Interpolator = interpolator_1.Interpolator;\nvar jitter_1 = require(\"./jitter\");\nexports.Jitter = jitter_1.Jitter;\nvar linear_interpolator_1 = require(\"./linear_interpolator\");\nexports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;\nvar step_interpolator_1 = require(\"./step_interpolator\");\nexports.StepInterpolator = step_interpolator_1.StepInterpolator;\nvar transform_1 = require(\"./transform\");\nexports.Transform = transform_1.Transform;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nexports.Interpolator = (function (superClass) {\n    extend(Interpolator, superClass);\n    function Interpolator() {\n        return Interpolator.__super__.constructor.apply(this, arguments);\n    }\n    Interpolator.prototype.initialize = function (attrs, options) {\n        Interpolator.__super__.initialize.call(this, attrs, options);\n        this._x_sorted = [];\n        this._y_sorted = [];\n        this._sorted_dirty = true;\n        return this.on('change', function () {\n            return this._sorted_dirty = true;\n        });\n    };\n    Interpolator.define({\n        x: [p.Any],\n        y: [p.Any],\n        data: [p.Any],\n        clip: [p.Bool, true]\n    });\n    Interpolator.prototype.sort = function (descending) {\n        var column_names, data, i, j, k, list, ref, ref1, ref2, tsx, tsy;\n        if (descending == null) {\n            descending = false;\n        }\n        if (typeof this.x !== typeof this.y) {\n            throw new Error('The parameters for x and y must be of the same type, either both strings which define a column in the data source or both arrays of the same length');\n            return;\n        }\n        else {\n            if (typeof this.x === 'string' && this.data === null) {\n                throw new Error('If the x and y parameters are not specified as an array, the data parameter is reqired.');\n                return;\n            }\n        }\n        if (this._sorted_dirty === false) {\n            return;\n        }\n        tsx = [];\n        tsy = [];\n        if (typeof this.x === 'string') {\n            data = this.data;\n            column_names = data.columns();\n            if (ref = this.x, indexOf.call(column_names, ref) < 0) {\n                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');\n            }\n            if (ref1 = this.y, indexOf.call(column_names, ref1) < 0) {\n                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');\n            }\n            tsx = data.get_column(this.x);\n            tsy = data.get_column(this.y);\n        }\n        else {\n            tsx = this.x;\n            tsy = this.y;\n        }\n        if (tsx.length !== tsy.length) {\n            throw new Error('The length for x and y do not match');\n        }\n        if (tsx.length < 2) {\n            throw new Error('x and y must have at least two elements to support interpolation');\n        }\n        list = [];\n        for (j in tsx) {\n            list.push({\n                'x': tsx[j],\n                'y': tsy[j]\n            });\n        }\n        if (descending === true) {\n            list.sort(function (a, b) {\n                var ref2, ref3;\n                return (ref2 = a.x < b.x) != null ? ref2 : -{\n                    1: (ref3 = a.x === b.x) != null ? ref3 : {\n                        0: 1\n                    }\n                };\n            });\n        }\n        else {\n            list.sort(function (a, b) {\n                var ref2, ref3;\n                return (ref2 = a.x > b.x) != null ? ref2 : -{\n                    1: (ref3 = a.x === b.x) != null ? ref3 : {\n                        0: 1\n                    }\n                };\n            });\n        }\n        for (k = i = 0, ref2 = list.length; 0 <= ref2 ? i < ref2 : i > ref2; k = 0 <= ref2 ? ++i : --i) {\n            this._x_sorted[k] = list[k].x;\n            this._y_sorted[k] = list[k].y;\n        }\n        return this._sorted_dirty = false;\n    };\n    return Interpolator;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar transform_1 = require(\"./transform\");\nvar p = require(\"core/properties\");\nvar bokeh_math = require(\"core/util/math\");\nexports.Jitter = (function (superClass) {\n    extend(Jitter, superClass);\n    function Jitter() {\n        return Jitter.__super__.constructor.apply(this, arguments);\n    }\n    Jitter.define({\n        mean: [p.Number, 0],\n        width: [p.Number, 1],\n        distribution: [p.Distribution, 'uniform']\n    });\n    Jitter.prototype.compute = function (x) {\n        if (this.distribution === 'uniform') {\n            return x + this.mean + ((bokeh_math.random() - 0.5) * this.width);\n        }\n        if (this.distribution === 'normal') {\n            return x + bokeh_math.rnorm(this.mean, this.width);\n        }\n    };\n    Jitter.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return Jitter;\n})(transform_1.Transform);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar array_1 = require(\"core/util/array\");\nvar interpolator_1 = require(\"./interpolator\");\nexports.LinearInterpolator = (function (superClass) {\n    extend(LinearInterpolator, superClass);\n    function LinearInterpolator() {\n        return LinearInterpolator.__super__.constructor.apply(this, arguments);\n    }\n    LinearInterpolator.prototype.compute = function (x) {\n        var descending, ind, ret, x1, x2, y1, y2;\n        this.sort(descending = false);\n        if (this.clip === true) {\n            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {\n                return null;\n            }\n        }\n        else {\n            if (x < this._x_sorted[0]) {\n                return this._y_sorted[0];\n            }\n            if (x > this._x_sorted[this._x_sorted.length - 1]) {\n                return this._y_sorted[this._y_sorted.length - 1];\n            }\n        }\n        if (x === this._x_sorted[0]) {\n            return this._y_sorted[0];\n        }\n        ind = array_1.findLastIndex(this._x_sorted, function (num) {\n            return num < x;\n        });\n        x1 = this._x_sorted[ind];\n        x2 = this._x_sorted[ind + 1];\n        y1 = this._y_sorted[ind];\n        y2 = this._y_sorted[ind + 1];\n        ret = y1 + (((x - x1) / (x2 - x1)) * (y2 - y1));\n        return ret;\n    };\n    LinearInterpolator.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return LinearInterpolator;\n})(interpolator_1.Interpolator);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar interpolator_1 = require(\"./interpolator\");\nvar p = require(\"core/properties\");\nvar array_1 = require(\"core/util/array\");\nexports.StepInterpolator = (function (superClass) {\n    extend(StepInterpolator, superClass);\n    function StepInterpolator() {\n        return StepInterpolator.__super__.constructor.apply(this, arguments);\n    }\n    StepInterpolator.define({\n        mode: [p.TransformStepMode, \"after\"]\n    });\n    StepInterpolator.prototype.compute = function (x) {\n        var descending, diffs, ind, mdiff, ret, tx;\n        this.sort(descending = false);\n        if (this.clip === true) {\n            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {\n                return null;\n            }\n        }\n        else {\n            if (x < this._x_sorted[0]) {\n                return this._y_sorted[0];\n            }\n            if (x > this._x_sorted[this._x_sorted.length - 1]) {\n                return this._y_sorted[this._y_sorted.length - 1];\n            }\n        }\n        ind = -1;\n        if (this.mode === \"after\") {\n            ind = array_1.findLastIndex(this._x_sorted, function (num) {\n                return x >= num;\n            });\n        }\n        if (this.mode === \"before\") {\n            ind = array_1.findIndex(this._x_sorted, function (num) {\n                return x <= num;\n            });\n        }\n        if (this.mode === \"center\") {\n            diffs = (function () {\n                var i, len, ref, results;\n                ref = this._x_sorted;\n                results = [];\n                for (i = 0, len = ref.length; i < len; i++) {\n                    tx = ref[i];\n                    results.push(Math.abs(tx - x));\n                }\n                return results;\n            }).call(this);\n            mdiff = array_1.min(diffs);\n            ind = array_1.findIndex(diffs, function (num) {\n                return mdiff === num;\n            });\n        }\n        if (ind !== -1) {\n            ret = this._y_sorted[ind];\n        }\n        else {\n            ret = null;\n        }\n        return ret;\n    };\n    StepInterpolator.prototype.v_compute = function (xs) {\n        var i, idx, len, result, x;\n        result = new Float64Array(xs.length);\n        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {\n            x = xs[idx];\n            result[idx] = this.compute(x);\n        }\n        return result;\n    };\n    return StepInterpolator;\n})(interpolator_1.Interpolator);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar model_1 = require(\"../../model\");\nexports.Transform = (function (superClass) {\n    extend(Transform, superClass);\n    function Transform() {\n        return Transform.__super__.constructor.apply(this, arguments);\n    }\n    return Transform;\n})(model_1.Model);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _burst_into_flames;\n_burst_into_flames = function (error) {\n    var body, box, button, message, ref, title;\n    box = document.createElement(\"div\");\n    box.style[\"background-color\"] = \"#f2dede\";\n    box.style[\"border\"] = \"1px solid #a94442\";\n    box.style[\"border-radius\"] = \"4px\";\n    box.style[\"display\"] = \"inline-block\";\n    box.style[\"font-family\"] = \"sans-serif\";\n    box.style[\"margin-top\"] = \"5px\";\n    box.style[\"min-width\"] = \"200px\";\n    box.style[\"padding\"] = \"5px 5px 5px 10px\";\n    button = document.createElement(\"span\");\n    button.style[\"background-color\"] = \"#a94442\";\n    button.style[\"border-radius\"] = \"0px 4px 0px 0px\";\n    button.style[\"color\"] = \"white\";\n    button.style[\"cursor\"] = \"pointer\";\n    button.style[\"float\"] = \"right\";\n    button.style[\"font-size\"] = \"0.8em\";\n    button.style[\"margin\"] = \"-6px -6px 0px 0px\";\n    button.style[\"padding\"] = \"2px 5px 4px 5px\";\n    button.title = \"close\";\n    button.setAttribute(\"aria-label\", \"close\");\n    button.appendChild(document.createTextNode(\"x\"));\n    button.addEventListener(\"click\", function () {\n        return body.removeChild(box);\n    });\n    title = document.createElement(\"h3\");\n    title.style[\"color\"] = \"#a94442\";\n    title.style[\"margin\"] = \"8px 0px 0px 0px\";\n    title.style[\"padding\"] = \"0px\";\n    title.appendChild(document.createTextNode(\"Bokeh Error\"));\n    message = document.createElement(\"pre\");\n    message.style[\"white-space\"] = \"unset\";\n    message.style[\"overflow-x\"] = \"auto\";\n    message.appendChild(document.createTextNode((ref = error.message) != null ? ref : error));\n    box.appendChild(button);\n    box.appendChild(title);\n    box.appendChild(message);\n    body = document.getElementsByTagName(\"body\")[0];\n    return body.insertBefore(box, body.firstChild);\n};\nexports.safely = function (fn, silent) {\n    var error;\n    if (silent == null) {\n        silent = false;\n    }\n    try {\n        return fn();\n    }\n    catch (error1) {\n        error = error1;\n        _burst_into_flames(error);\n        if (!silent) {\n            throw error;\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = '0.12.5';\n","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    /**\n     * An enum defining the linear constraint operators.\n     */\n    var Operator;\n    (function (Operator) {\n        Operator[Operator[\"Le\"] = 0] = \"Le\";\n        Operator[Operator[\"Ge\"] = 1] = \"Ge\";\n        Operator[Operator[\"Eq\"] = 2] = \"Eq\"; // ==\n    })(Operator = kiwi.Operator || (kiwi.Operator = {}));\n    /**\n     * A linear constraint equation.\n     *\n     * A constraint equation is composed of an expression, an operator,\n     * and a strength. The RHS of the equation is implicitly zero.\n     *\n     * @class\n     */\n    var Constraint = (function () {\n        /**\n         * Construct a new Constraint.\n         *\n         * @param expression The constraint expression.\n         * @param operator The equation operator.\n         * @param strength The strength of the constraint.\n         */\n        function Constraint(expression, operator, strength) {\n            if (strength === void 0) { strength = kiwi.Strength.required; }\n            this._id = CnId++;\n            this._operator = operator;\n            this._expression = expression;\n            this._strength = kiwi.Strength.clip(strength);\n        }\n        /**\n         * A static constraint comparison function.\n         */\n        Constraint.Compare = function (a, b) {\n            return a.id() - b.id();\n        };\n        /**\n         * Returns the unique id number of the constraint.\n         */\n        Constraint.prototype.id = function () {\n            return this._id;\n        };\n        /**\n         * Returns the expression of the constraint.\n         */\n        Constraint.prototype.expression = function () {\n            return this._expression;\n        };\n        /**\n         * Returns the relational operator of the constraint.\n         */\n        Constraint.prototype.op = function () {\n            return this._operator;\n        };\n        /**\n         * Returns the strength of the constraint.\n         */\n        Constraint.prototype.strength = function () {\n            return this._strength;\n        };\n        return Constraint;\n    }());\n    kiwi.Constraint = Constraint;\n    /**\n     * The internal constraint id counter.\n     */\n    var CnId = 0;\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    /**\n     * An expression of variable terms and a constant.\n     *\n     * @class\n     */\n    var Expression = (function () {\n        function Expression() {\n            var parsed = parseArgs(arguments);\n            this._terms = parsed.terms;\n            this._constant = parsed.constant;\n        }\n        /**\n         * Returns the mapping of terms in the expression.\n         *\n         * This *must* be treated as const.\n         */\n        Expression.prototype.terms = function () {\n            return this._terms;\n        };\n        /**\n         * Returns the constant of the expression.\n         */\n        Expression.prototype.constant = function () {\n            return this._constant;\n        };\n        /**\n         * Returns the computed value of the expression.\n         */\n        Expression.prototype.value = function () {\n            var result = this._constant;\n            tsu.forEach(this._terms, function (pair) {\n                result += pair.first.value() * pair.second;\n            });\n            return result;\n        };\n        return Expression;\n    }());\n    kiwi.Expression = Expression;\n    /**\n     * An internal argument parsing function.\n     */\n    function parseArgs(args) {\n        var constant = 0.0;\n        var factory = function () { return 0.0; };\n        var terms = kiwi.createMap(kiwi.Variable.Compare);\n        for (var i = 0, n = args.length; i < n; ++i) {\n            var item = args[i];\n            if (typeof item === \"number\") {\n                constant += item;\n            }\n            else if (item instanceof kiwi.Variable) {\n                terms.setDefault(item, factory).second += 1.0;\n            }\n            else if (item instanceof Array) {\n                if (item.length !== 2) {\n                    throw new Error(\"array must have length 2\");\n                }\n                var value = item[0];\n                var variable = item[1];\n                if (typeof value !== \"number\") {\n                    throw new Error(\"array item 0 must be a number\");\n                }\n                if (!(variable instanceof kiwi.Variable)) {\n                    throw new Error(\"array item 1 must be a variable\");\n                }\n                terms.setDefault(variable, factory).second += value;\n            }\n            else {\n                throw new Error(\"invalid Expression argument: \" + item);\n            }\n        }\n        return { terms: terms, constant: constant };\n    }\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    function createMap(compare) {\n        return new tsu.AssociativeArray(compare);\n    }\n    kiwi.createMap = createMap;\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    /**\n     * The constraint solver class.\n     *\n     * @class\n     */\n    var Solver = (function () {\n        /**\n         * Construct a new Solver.\n         */\n        function Solver() {\n            this._cnMap = createCnMap();\n            this._rowMap = createRowMap();\n            this._varMap = createVarMap();\n            this._editMap = createEditMap();\n            this._infeasibleRows = [];\n            this._objective = new Row();\n            this._artificial = null;\n            this._idTick = 0;\n        }\n        /**\n         * Add a constraint to the solver.\n         */\n        Solver.prototype.addConstraint = function (constraint) {\n            var cnPair = this._cnMap.find(constraint);\n            if (cnPair !== undefined) {\n                throw new Error(\"duplicate constraint\");\n            }\n            // Creating a row causes symbols to be reserved for the variables\n            // in the constraint. If this method exits with an exception,\n            // then its possible those variables will linger in the var map.\n            // Since its likely that those variables will be used in other\n            // constraints and since exceptional conditions are uncommon,\n            // i'm not too worried about aggressive cleanup of the var map.\n            var data = this._createRow(constraint);\n            var row = data.row;\n            var tag = data.tag;\n            var subject = this._chooseSubject(row, tag);\n            // If chooseSubject couldnt find a valid entering symbol, one\n            // last option is available if the entire row is composed of\n            // dummy variables. If the constant of the row is zero, then\n            // this represents redundant constraints and the new dummy\n            // marker can enter the basis. If the constant is non-zero,\n            // then it represents an unsatisfiable constraint.\n            if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n                if (!nearZero(row.constant())) {\n                    var names = [];\n                    for (var _i = 0, _a = constraint.expression().terms()._array; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        names.push(item.first.name());\n                    }\n                    var op = ['LE', 'GE', 'EQ'][constraint.op()];\n                    throw new Error(\"unsatisfiable constraint [\" + names.join(\",\") + \"] operator: \" + op);\n                }\n                else {\n                    subject = tag.marker;\n                }\n            }\n            // If an entering symbol still isn't found, then the row must\n            // be added using an artificial variable. If that fails, then\n            // the row represents an unsatisfiable constraint.\n            if (subject.type() === SymbolType.Invalid) {\n                if (!this._addWithArtificialVariable(row)) {\n                    throw new Error(\"unsatisfiable constraint\");\n                }\n            }\n            else {\n                row.solveFor(subject);\n                this._substitute(subject, row);\n                this._rowMap.insert(subject, row);\n            }\n            this._cnMap.insert(constraint, tag);\n            // Optimizing after each constraint is added performs less\n            // aggregate work due to a smaller average system size. It\n            // also ensures the solver remains in a consistent state.\n            this._optimize(this._objective);\n        };\n        /**\n         * Remove a constraint from the solver.\n         */\n        Solver.prototype.removeConstraint = function (constraint, silent) {\n            if (silent === void 0) { silent = false; }\n            var cnPair = this._cnMap.erase(constraint);\n            if (cnPair === undefined) {\n                if (silent)\n                    return;\n                else\n                    throw new Error(\"unknown constraint\");\n            }\n            // Remove the error effects from the objective function\n            // *before* pivoting, or substitutions into the objective\n            // will lead to incorrect solver results.\n            this._removeConstraintEffects(constraint, cnPair.second);\n            // If the marker is basic, simply drop the row. Otherwise,\n            // pivot the marker into the basis and then drop the row.\n            var marker = cnPair.second.marker;\n            var rowPair = this._rowMap.erase(marker);\n            if (rowPair === undefined) {\n                var leaving = this._getMarkerLeavingSymbol(marker);\n                if (leaving.type() === SymbolType.Invalid) {\n                    throw new Error(\"failed to find leaving row\");\n                }\n                rowPair = this._rowMap.erase(leaving);\n                rowPair.second.solveForEx(leaving, marker);\n                this._substitute(marker, rowPair.second);\n            }\n            // Optimizing after each constraint is removed ensures that the\n            // solver remains consistent. It makes the solver api easier to\n            // use at a small tradeoff for speed.\n            this._optimize(this._objective);\n        };\n        /**\n         * Test whether the solver contains the constraint.\n         */\n        Solver.prototype.hasConstraint = function (constraint) {\n            return this._cnMap.contains(constraint);\n        };\n        /**\n         * Add an edit variable to the solver.\n         */\n        Solver.prototype.addEditVariable = function (variable, strength) {\n            var editPair = this._editMap.find(variable);\n            if (editPair !== undefined) {\n                throw new Error(\"duplicate edit variable: \" + variable.name());\n            }\n            strength = kiwi.Strength.clip(strength);\n            if (strength === kiwi.Strength.required) {\n                throw new Error(\"bad required strength\");\n            }\n            var expr = new kiwi.Expression(variable);\n            var cn = new kiwi.Constraint(expr, kiwi.Operator.Eq, strength);\n            this.addConstraint(cn);\n            var tag = this._cnMap.find(cn).second;\n            var info = { tag: tag, constraint: cn, constant: 0.0 };\n            this._editMap.insert(variable, info);\n        };\n        /**\n         * Remove an edit variable from the solver.\n         */\n        Solver.prototype.removeEditVariable = function (variable, silent) {\n            if (silent === void 0) { silent = false; }\n            var editPair = this._editMap.erase(variable);\n            if (editPair === undefined) {\n                if (silent)\n                    return;\n                else\n                    throw new Error(\"unknown edit variable: \" + variable.name());\n            }\n            this.removeConstraint(editPair.second.constraint, silent);\n        };\n        /**\n         * Test whether the solver contains the edit variable.\n         */\n        Solver.prototype.hasEditVariable = function (variable) {\n            return this._editMap.contains(variable);\n        };\n        /**\n         * Suggest the value of an edit variable.\n         */\n        Solver.prototype.suggestValue = function (variable, value) {\n            var editPair = this._editMap.find(variable);\n            if (editPair === undefined) {\n                throw new Error(\"unknown edit variable: \" + variable.name());\n            }\n            var rows = this._rowMap;\n            var info = editPair.second;\n            var delta = value - info.constant;\n            info.constant = value;\n            // Check first if the positive error variable is basic.\n            var marker = info.tag.marker;\n            var rowPair = rows.find(marker);\n            if (rowPair !== undefined) {\n                if (rowPair.second.add(-delta) < 0.0) {\n                    this._infeasibleRows.push(marker);\n                }\n                this._dualOptimize();\n                return;\n            }\n            // Check next if the negative error variable is basic.\n            var other = info.tag.other;\n            var rowPair = rows.find(other);\n            if (rowPair !== undefined) {\n                if (rowPair.second.add(delta) < 0.0) {\n                    this._infeasibleRows.push(other);\n                }\n                this._dualOptimize();\n                return;\n            }\n            // Otherwise update each row where the error variables exist.\n            for (var i = 0, n = rows.size(); i < n; ++i) {\n                var rowPair = rows.itemAt(i);\n                var row = rowPair.second;\n                var coeff = row.coefficientFor(marker);\n                if (coeff !== 0.0 && row.add(delta * coeff) < 0.0 &&\n                    rowPair.first.type() !== SymbolType.External) {\n                    this._infeasibleRows.push(rowPair.first);\n                }\n            }\n            this._dualOptimize();\n        };\n        /**\n         * Update the values of the variables.\n         */\n        Solver.prototype.updateVariables = function () {\n            var vars = this._varMap;\n            var rows = this._rowMap;\n            for (var i = 0, n = vars.size(); i < n; ++i) {\n                var pair = vars.itemAt(i);\n                var rowPair = rows.find(pair.second);\n                if (rowPair !== undefined) {\n                    pair.first.setValue(rowPair.second.constant());\n                }\n                else {\n                    pair.first.setValue(0.0);\n                }\n            }\n        };\n        /**\n         * Get the symbol for the given variable.\n         *\n         * If a symbol does not exist for the variable, one will be created.\n         */\n        Solver.prototype._getVarSymbol = function (variable) {\n            var _this = this;\n            var factory = function () { return _this._makeSymbol(SymbolType.External); };\n            return this._varMap.setDefault(variable, factory).second;\n        };\n        /**\n         * Create a new Row object for the given constraint.\n         *\n         * The terms in the constraint will be converted to cells in the row.\n         * Any term in the constraint with a coefficient of zero is ignored.\n         * This method uses the `_getVarSymbol` method to get the symbol for\n         * the variables added to the row. If the symbol for a given cell\n         * variable is basic, the cell variable will be substituted with the\n         * basic row.\n         *\n         * The necessary slack and error variables will be added to the row.\n         * If the constant for the row is negative, the sign for the row\n         * will be inverted so the constant becomes positive.\n         *\n         * Returns the created Row and the tag for tracking the constraint.\n         */\n        Solver.prototype._createRow = function (constraint) {\n            var expr = constraint.expression();\n            var row = new Row(expr.constant());\n            // Substitute the current basic variables into the row.\n            var terms = expr.terms();\n            for (var i = 0, n = terms.size(); i < n; ++i) {\n                var termPair = terms.itemAt(i);\n                if (!nearZero(termPair.second)) {\n                    var symbol = this._getVarSymbol(termPair.first);\n                    var basicPair = this._rowMap.find(symbol);\n                    if (basicPair !== undefined) {\n                        row.insertRow(basicPair.second, termPair.second);\n                    }\n                    else {\n                        row.insertSymbol(symbol, termPair.second);\n                    }\n                }\n            }\n            // Add the necessary slack, error, and dummy variables.\n            var objective = this._objective;\n            var strength = constraint.strength();\n            var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n            switch (constraint.op()) {\n                case kiwi.Operator.Le:\n                case kiwi.Operator.Ge:\n                    {\n                        var coeff = constraint.op() === kiwi.Operator.Le ? 1.0 : -1.0;\n                        var slack = this._makeSymbol(SymbolType.Slack);\n                        tag.marker = slack;\n                        row.insertSymbol(slack, coeff);\n                        if (strength < kiwi.Strength.required) {\n                            var error = this._makeSymbol(SymbolType.Error);\n                            tag.other = error;\n                            row.insertSymbol(error, -coeff);\n                            objective.insertSymbol(error, strength);\n                        }\n                        break;\n                    }\n                case kiwi.Operator.Eq:\n                    {\n                        if (strength < kiwi.Strength.required) {\n                            var errplus = this._makeSymbol(SymbolType.Error);\n                            var errminus = this._makeSymbol(SymbolType.Error);\n                            tag.marker = errplus;\n                            tag.other = errminus;\n                            row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n                            row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n                            objective.insertSymbol(errplus, strength);\n                            objective.insertSymbol(errminus, strength);\n                        }\n                        else {\n                            var dummy = this._makeSymbol(SymbolType.Dummy);\n                            tag.marker = dummy;\n                            row.insertSymbol(dummy);\n                        }\n                        break;\n                    }\n            }\n            // Ensure the row has a positive constant.\n            if (row.constant() < 0.0) {\n                row.reverseSign();\n            }\n            return { row: row, tag: tag };\n        };\n        /**\n         * Choose the subject for solving for the row.\n         *\n         * This method will choose the best subject for using as the solve\n         * target for the row. An invalid symbol will be returned if there\n         * is no valid target.\n         *\n         * The symbols are chosen according to the following precedence:\n         *\n         * 1) The first symbol representing an external variable.\n         * 2) A negative slack or error tag variable.\n         *\n         * If a subject cannot be found, an invalid symbol will be returned.\n         */\n        Solver.prototype._chooseSubject = function (row, tag) {\n            var cells = row.cells();\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                if (pair.first.type() === SymbolType.External) {\n                    return pair.first;\n                }\n            }\n            var type = tag.marker.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                if (row.coefficientFor(tag.marker) < 0.0) {\n                    return tag.marker;\n                }\n            }\n            type = tag.other.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                if (row.coefficientFor(tag.other) < 0.0) {\n                    return tag.other;\n                }\n            }\n            return INVALID_SYMBOL;\n        };\n        /**\n         * Add the row to the tableau using an artificial variable.\n         *\n         * This will return false if the constraint cannot be satisfied.\n         */\n        Solver.prototype._addWithArtificialVariable = function (row) {\n            // Create and add the artificial variable to the tableau.\n            var art = this._makeSymbol(SymbolType.Slack);\n            this._rowMap.insert(art, row.copy());\n            this._artificial = row.copy();\n            // Optimize the artificial objective. This is successful\n            // only if the artificial objective is optimized to zero.\n            this._optimize(this._artificial);\n            var success = nearZero(this._artificial.constant());\n            this._artificial = null;\n            // If the artificial variable is basic, pivot the row so that\n            // it becomes non-basic. If the row is constant, exit early.\n            var pair = this._rowMap.erase(art);\n            if (pair !== undefined) {\n                var basicRow = pair.second;\n                if (basicRow.isConstant()) {\n                    return success;\n                }\n                var entering = this._anyPivotableSymbol(basicRow);\n                if (entering.type() === SymbolType.Invalid) {\n                    return false; // unsatisfiable (will this ever happen?)\n                }\n                basicRow.solveForEx(art, entering);\n                this._substitute(entering, basicRow);\n                this._rowMap.insert(entering, basicRow);\n            }\n            // Remove the artificial variable from the tableau.\n            var rows = this._rowMap;\n            for (var i = 0, n = rows.size(); i < n; ++i) {\n                rows.itemAt(i).second.removeSymbol(art);\n            }\n            this._objective.removeSymbol(art);\n            return success;\n        };\n        /**\n         * Substitute the parametric symbol with the given row.\n         *\n         * This method will substitute all instances of the parametric symbol\n         * in the tableau and the objective function with the given row.\n         */\n        Solver.prototype._substitute = function (symbol, row) {\n            var rows = this._rowMap;\n            for (var i = 0, n = rows.size(); i < n; ++i) {\n                var pair = rows.itemAt(i);\n                pair.second.substitute(symbol, row);\n                if (pair.second.constant() < 0.0 &&\n                    pair.first.type() !== SymbolType.External) {\n                    this._infeasibleRows.push(pair.first);\n                }\n            }\n            this._objective.substitute(symbol, row);\n            if (this._artificial) {\n                this._artificial.substitute(symbol, row);\n            }\n        };\n        /**\n         * Optimize the system for the given objective function.\n         *\n         * This method performs iterations of Phase 2 of the simplex method\n         * until the objective function reaches a minimum.\n         */\n        Solver.prototype._optimize = function (objective) {\n            while (true) {\n                var entering = this._getEnteringSymbol(objective);\n                if (entering.type() === SymbolType.Invalid) {\n                    return;\n                }\n                var leaving = this._getLeavingSymbol(entering);\n                if (leaving.type() === SymbolType.Invalid) {\n                    throw new Error(\"the objective is unbounded\");\n                }\n                // pivot the entering symbol into the basis\n                var row = this._rowMap.erase(leaving).second;\n                row.solveForEx(leaving, entering);\n                this._substitute(entering, row);\n                this._rowMap.insert(entering, row);\n            }\n        };\n        /**\n         * Optimize the system using the dual of the simplex method.\n         *\n         * The current state of the system should be such that the objective\n         * function is optimal, but not feasible. This method will perform\n         * an iteration of the dual simplex method to make the solution both\n         * optimal and feasible.\n         */\n        Solver.prototype._dualOptimize = function () {\n            var rows = this._rowMap;\n            var infeasible = this._infeasibleRows;\n            while (infeasible.length !== 0) {\n                var leaving = infeasible.pop();\n                var pair = rows.find(leaving);\n                if (pair !== undefined && pair.second.constant() < 0.0) {\n                    var entering = this._getDualEnteringSymbol(pair.second);\n                    if (entering.type() === SymbolType.Invalid) {\n                        throw new Error(\"dual optimize failed\");\n                    }\n                    // pivot the entering symbol into the basis\n                    var row = pair.second;\n                    rows.erase(leaving);\n                    row.solveForEx(leaving, entering);\n                    this._substitute(entering, row);\n                    rows.insert(entering, row);\n                }\n            }\n        };\n        /**\n         * Compute the entering variable for a pivot operation.\n         *\n         * This method will return first symbol in the objective function which\n         * is non-dummy and has a coefficient less than zero. If no symbol meets\n         * the criteria, it means the objective function is at a minimum, and an\n         * invalid symbol is returned.\n         */\n        Solver.prototype._getEnteringSymbol = function (objective) {\n            var cells = objective.cells();\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                var symbol = pair.first;\n                if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n                    return symbol;\n                }\n            }\n            return INVALID_SYMBOL;\n        };\n        /**\n         * Compute the entering symbol for the dual optimize operation.\n         *\n         * This method will return the symbol in the row which has a positive\n         * coefficient and yields the minimum ratio for its respective symbol\n         * in the objective function. The provided row *must* be infeasible.\n         * If no symbol is found which meats the criteria, an invalid symbol\n         * is returned.\n         */\n        Solver.prototype._getDualEnteringSymbol = function (row) {\n            var ratio = Number.MAX_VALUE;\n            var entering = INVALID_SYMBOL;\n            var cells = row.cells();\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                var symbol = pair.first;\n                var c = pair.second;\n                if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n                    var coeff = this._objective.coefficientFor(symbol);\n                    var r = coeff / c;\n                    if (r < ratio) {\n                        ratio = r;\n                        entering = symbol;\n                    }\n                }\n            }\n            return entering;\n        };\n        /**\n         * Compute the symbol for pivot exit row.\n         *\n         * This method will return the symbol for the exit row in the row\n         * map. If no appropriate exit symbol is found, an invalid symbol\n         * will be returned. This indicates that the objective function is\n         * unbounded.\n         */\n        Solver.prototype._getLeavingSymbol = function (entering) {\n            var ratio = Number.MAX_VALUE;\n            var found = INVALID_SYMBOL;\n            var rows = this._rowMap;\n            for (var i = 0, n = rows.size(); i < n; ++i) {\n                var pair = rows.itemAt(i);\n                var symbol = pair.first;\n                if (symbol.type() !== SymbolType.External) {\n                    var row = pair.second;\n                    var temp = row.coefficientFor(entering);\n                    if (temp < 0.0) {\n                        var temp_ratio = -row.constant() / temp;\n                        if (temp_ratio < ratio) {\n                            ratio = temp_ratio;\n                            found = symbol;\n                        }\n                    }\n                }\n            }\n            return found;\n        };\n        /**\n         * Compute the leaving symbol for a marker variable.\n         *\n         * This method will return a symbol corresponding to a basic row\n         * which holds the given marker variable. The row will be chosen\n         * according to the following precedence:\n         *\n         * 1) The row with a restricted basic varible and a negative coefficient\n         *    for the marker with the smallest ratio of -constant / coefficient.\n         *\n         * 2) The row with a restricted basic variable and the smallest ratio\n         *    of constant / coefficient.\n         *\n         * 3) The last unrestricted row which contains the marker.\n         *\n         * If the marker does not exist in any row, an invalid symbol will be\n         * returned. This indicates an internal solver error since the marker\n         * *should* exist somewhere in the tableau.\n         */\n        Solver.prototype._getMarkerLeavingSymbol = function (marker) {\n            var dmax = Number.MAX_VALUE;\n            var r1 = dmax;\n            var r2 = dmax;\n            var invalid = INVALID_SYMBOL;\n            var first = invalid;\n            var second = invalid;\n            var third = invalid;\n            var rows = this._rowMap;\n            for (var i = 0, n = rows.size(); i < n; ++i) {\n                var pair = rows.itemAt(i);\n                var row = pair.second;\n                var c = row.coefficientFor(marker);\n                if (c === 0.0) {\n                    continue;\n                }\n                var symbol = pair.first;\n                if (symbol.type() === SymbolType.External) {\n                    third = symbol;\n                }\n                else if (c < 0.0) {\n                    var r = -row.constant() / c;\n                    if (r < r1) {\n                        r1 = r;\n                        first = symbol;\n                    }\n                }\n                else {\n                    var r = row.constant() / c;\n                    if (r < r2) {\n                        r2 = r;\n                        second = symbol;\n                    }\n                }\n            }\n            if (first !== invalid) {\n                return first;\n            }\n            if (second !== invalid) {\n                return second;\n            }\n            return third;\n        };\n        /**\n         * Remove the effects of a constraint on the objective function.\n         */\n        Solver.prototype._removeConstraintEffects = function (cn, tag) {\n            if (tag.marker.type() === SymbolType.Error) {\n                this._removeMarkerEffects(tag.marker, cn.strength());\n            }\n            if (tag.other.type() === SymbolType.Error) {\n                this._removeMarkerEffects(tag.other, cn.strength());\n            }\n        };\n        /**\n         * Remove the effects of an error marker on the objective function.\n         */\n        Solver.prototype._removeMarkerEffects = function (marker, strength) {\n            var pair = this._rowMap.find(marker);\n            if (pair !== undefined) {\n                this._objective.insertRow(pair.second, -strength);\n            }\n            else {\n                this._objective.insertSymbol(marker, -strength);\n            }\n        };\n        /**\n         * Get the first Slack or Error symbol in the row.\n         *\n         * If no such symbol is present, an invalid symbol will be returned.\n         */\n        Solver.prototype._anyPivotableSymbol = function (row) {\n            var cells = row.cells();\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                var type = pair.first.type();\n                if (type === SymbolType.Slack || type === SymbolType.Error) {\n                    return pair.first;\n                }\n            }\n            return INVALID_SYMBOL;\n        };\n        /**\n         * Returns a new Symbol of the given type.\n         */\n        Solver.prototype._makeSymbol = function (type) {\n            return new Symbol(type, this._idTick++);\n        };\n        return Solver;\n    }());\n    kiwi.Solver = Solver;\n    /**\n     * Test whether a value is approximately zero.\n     */\n    function nearZero(value) {\n        var eps = 1.0e-8;\n        return value < 0.0 ? -value < eps : value < eps;\n    }\n    /**\n     * An internal function for creating a constraint map.\n     */\n    function createCnMap() {\n        return kiwi.createMap(kiwi.Constraint.Compare);\n    }\n    /**\n     * An internal function for creating a row map.\n     */\n    function createRowMap() {\n        return kiwi.createMap(Symbol.Compare);\n    }\n    /**\n     * An internal function for creating a variable map.\n     */\n    function createVarMap() {\n        return kiwi.createMap(kiwi.Variable.Compare);\n    }\n    /**\n     * An internal function for creating an edit map.\n     */\n    function createEditMap() {\n        return kiwi.createMap(kiwi.Variable.Compare);\n    }\n    /**\n     * An enum defining the available symbol types.\n     */\n    var SymbolType;\n    (function (SymbolType) {\n        SymbolType[SymbolType[\"Invalid\"] = 0] = \"Invalid\";\n        SymbolType[SymbolType[\"External\"] = 1] = \"External\";\n        SymbolType[SymbolType[\"Slack\"] = 2] = \"Slack\";\n        SymbolType[SymbolType[\"Error\"] = 3] = \"Error\";\n        SymbolType[SymbolType[\"Dummy\"] = 4] = \"Dummy\";\n    })(SymbolType || (SymbolType = {}));\n    /**\n     * An internal class representing a symbol in the solver.\n     */\n    var Symbol = (function () {\n        /**\n         * Construct a new Symbol\n         *\n         * @param [type] The type of the symbol.\n         * @param [id] The unique id number of the symbol.\n         */\n        function Symbol(type, id) {\n            this._id = id;\n            this._type = type;\n        }\n        /**\n         * The static Symbol comparison function.\n         */\n        Symbol.Compare = function (a, b) {\n            return a.id() - b.id();\n        };\n        /**\n         * Returns the unique id number of the symbol.\n         */\n        Symbol.prototype.id = function () {\n            return this._id;\n        };\n        /**\n         * Returns the type of the symbol.\n         */\n        Symbol.prototype.type = function () {\n            return this._type;\n        };\n        return Symbol;\n    }());\n    /**\n     * A static invalid symbol\n     */\n    var INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n    /**\n     * An internal row class used by the solver.\n     */\n    var Row = (function () {\n        /**\n         * Construct a new Row.\n         */\n        function Row(constant) {\n            if (constant === void 0) { constant = 0.0; }\n            this._cellMap = kiwi.createMap(Symbol.Compare);\n            this._constant = constant;\n        }\n        /**\n         * Returns the mapping of symbols to coefficients.\n         */\n        Row.prototype.cells = function () {\n            return this._cellMap;\n        };\n        /**\n         * Returns the constant for the row.\n         */\n        Row.prototype.constant = function () {\n            return this._constant;\n        };\n        /**\n         * Returns true if the row is a constant value.\n         */\n        Row.prototype.isConstant = function () {\n            return this._cellMap.empty();\n        };\n        /**\n         * Returns true if the Row has all dummy symbols.\n         */\n        Row.prototype.allDummies = function () {\n            var cells = this._cellMap;\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                if (pair.first.type() !== SymbolType.Dummy) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        /**\n         * Create a copy of the row.\n         */\n        Row.prototype.copy = function () {\n            var theCopy = new Row(this._constant);\n            theCopy._cellMap = this._cellMap.copy();\n            return theCopy;\n        };\n        /**\n         * Add a constant value to the row constant.\n         *\n         * Returns the new value of the constant.\n         */\n        Row.prototype.add = function (value) {\n            return this._constant += value;\n        };\n        /**\n         * Insert the symbol into the row with the given coefficient.\n         *\n         * If the symbol already exists in the row, the coefficient\n         * will be added to the existing coefficient. If the resulting\n         * coefficient is zero, the symbol will be removed from the row.\n         */\n        Row.prototype.insertSymbol = function (symbol, coefficient) {\n            if (coefficient === void 0) { coefficient = 1.0; }\n            var pair = this._cellMap.setDefault(symbol, function () { return 0.0; });\n            if (nearZero(pair.second += coefficient)) {\n                this._cellMap.erase(symbol);\n            }\n        };\n        /**\n         * Insert a row into this row with a given coefficient.\n         *\n         * The constant and the cells of the other row will be\n         * multiplied by the coefficient and added to this row. Any\n         * cell with a resulting coefficient of zero will be removed\n         * from the row.\n         */\n        Row.prototype.insertRow = function (other, coefficient) {\n            if (coefficient === void 0) { coefficient = 1.0; }\n            this._constant += other._constant * coefficient;\n            var cells = other._cellMap;\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                this.insertSymbol(pair.first, pair.second * coefficient);\n            }\n        };\n        /**\n         * Remove a symbol from the row.\n         */\n        Row.prototype.removeSymbol = function (symbol) {\n            this._cellMap.erase(symbol);\n        };\n        /**\n         * Reverse the sign of the constant and cells in the row.\n         */\n        Row.prototype.reverseSign = function () {\n            this._constant = -this._constant;\n            var cells = this._cellMap;\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                var pair = cells.itemAt(i);\n                pair.second = -pair.second;\n            }\n        };\n        /**\n         * Solve the row for the given symbol.\n         *\n         * This method assumes the row is of the form\n         * a * x + b * y + c = 0 and (assuming solve for x) will modify\n         * the row to represent the right hand side of\n         * x = -b/a * y - c / a. The target symbol will be removed from\n         * the row, and the constant and other cells will be multiplied\n         * by the negative inverse of the target coefficient.\n         *\n         * The given symbol *must* exist in the row.\n         */\n        Row.prototype.solveFor = function (symbol) {\n            var cells = this._cellMap;\n            var pair = cells.erase(symbol);\n            var coeff = -1.0 / pair.second;\n            this._constant *= coeff;\n            for (var i = 0, n = cells.size(); i < n; ++i) {\n                cells.itemAt(i).second *= coeff;\n            }\n        };\n        /**\n         * Solve the row for the given symbols.\n         *\n         * This method assumes the row is of the form\n         * x = b * y + c and will solve the row such that\n         * y = x / b - c / b. The rhs symbol will be removed from the\n         * row, the lhs added, and the result divided by the negative\n         * inverse of the rhs coefficient.\n         *\n         * The lhs symbol *must not* exist in the row, and the rhs\n         * symbol must* exist in the row.\n         */\n        Row.prototype.solveForEx = function (lhs, rhs) {\n            this.insertSymbol(lhs, -1.0);\n            this.solveFor(rhs);\n        };\n        /**\n         * Returns the coefficient for the given symbol.\n         */\n        Row.prototype.coefficientFor = function (symbol) {\n            var pair = this._cellMap.find(symbol);\n            return pair !== undefined ? pair.second : 0.0;\n        };\n        /**\n         * Substitute a symbol with the data from another row.\n         *\n         * Given a row of the form a * x + b and a substitution of the\n         * form x = 3 * y + c the row will be updated to reflect the\n         * expression 3 * a * y + a * c + b.\n         *\n         * If the symbol does not exist in the row, this is a no-op.\n         */\n        Row.prototype.substitute = function (symbol, row) {\n            var pair = this._cellMap.erase(symbol);\n            if (pair !== undefined) {\n                this.insertRow(row, pair.second);\n            }\n        };\n        return Row;\n    }());\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    var Strength;\n    (function (Strength) {\n        /**\n         * Create a new symbolic strength.\n         */\n        function create(a, b, c, w) {\n            if (w === void 0) { w = 1.0; }\n            var result = 0.0;\n            result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n            result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n            result += Math.max(0.0, Math.min(1000.0, c * w));\n            return result;\n        }\n        Strength.create = create;\n        /**\n         * The 'required' symbolic strength.\n         */\n        Strength.required = create(1000.0, 1000.0, 1000.0);\n        /**\n         * The 'strong' symbolic strength.\n         */\n        Strength.strong = create(1.0, 0.0, 0.0);\n        /**\n         * The 'medium' symbolic strength.\n         */\n        Strength.medium = create(0.0, 1.0, 0.0);\n        /**\n         * The 'weak' symbolic strength.\n         */\n        Strength.weak = create(0.0, 0.0, 1.0);\n        /**\n         * Clip a symbolic strength to the allowed min and max.\n         */\n        function clip(value) {\n            return Math.max(0.0, Math.min(Strength.required, value));\n        }\n        Strength.clip = clip;\n    })(Strength = kiwi.Strength || (kiwi.Strength = {}));\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar kiwi;\n(function (kiwi) {\n    /**\n     * The primary user constraint variable.\n     *\n     * @class\n     */\n    var Variable = (function () {\n        /**\n         * Construct a new Variable\n         *\n         * @param [name] The name to associated with the variable.\n         */\n        function Variable(name) {\n            if (name === void 0) { name = \"\"; }\n            this._value = 0.0;\n            this._context = null;\n            this._id = VarId++;\n            this._name = name;\n        }\n        /**\n         * A static variable comparison function.\n         */\n        Variable.Compare = function (a, b) {\n            return a.id() - b.id();\n        };\n        /**\n         * Returns the unique id number of the variable.\n         */\n        Variable.prototype.id = function () {\n            return this._id;\n        };\n        /**\n         * Returns the name of the variable.\n         */\n        Variable.prototype.name = function () {\n            return this._name;\n        };\n        /**\n         * Set the name of the variable.\n         */\n        Variable.prototype.setName = function (name) {\n            this._name = name;\n        };\n        /**\n         * Returns the user context object of the variable.\n         */\n        Variable.prototype.context = function () {\n            return this._context;\n        };\n        /**\n         * Set the user context object of the variable.\n         */\n        Variable.prototype.setContext = function (context) {\n            this._context = context;\n        };\n        /**\n         * Returns the value of the variable.\n         */\n        Variable.prototype.value = function () {\n            return this._value;\n        };\n        /**\n         * Set the value of the variable.\n         */\n        Variable.prototype.setValue = function (value) {\n            this._value = value;\n        };\n        return Variable;\n    }());\n    kiwi.Variable = Variable;\n    /**\n     * The internal variable id counter.\n     */\n    var VarId = 0;\n})(kiwi || (kiwi = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar tsu;\n(function (tsu) {\n    /**\n    * Perform a lower bound search on a sorted array.\n    *\n    * @param array The array of sorted items to search.\n    * @param value The value to located in the array.\n    * @param compare The value comparison function.\n    * @returns The index of the first element in the array which\n    *          compares greater than or equal to the given value.\n    */\n    function lowerBound(array, value, compare) {\n        var begin = 0;\n        var n = array.length;\n        var half;\n        var middle;\n        while (n > 0) {\n            half = n >> 1;\n            middle = begin + half;\n            if (compare(array[middle], value) < 0) {\n                begin = middle + 1;\n                n -= half + 1;\n            }\n            else {\n                n = half;\n            }\n        }\n        return begin;\n    }\n    tsu.lowerBound = lowerBound;\n    /**\n    * Perform a binary search on a sorted array.\n    *\n    * @param array The array of sorted items to search.\n    * @param value The value to located in the array.\n    * @param compare The value comparison function.\n    * @returns The index of the found item, or -1.\n    */\n    function binarySearch(array, value, compare) {\n        var index = lowerBound(array, value, compare);\n        if (index === array.length) {\n            return -1;\n        }\n        var item = array[index];\n        if (compare(item, value) !== 0) {\n            return -1;\n        }\n        return index;\n    }\n    tsu.binarySearch = binarySearch;\n    /**\n    * Perform a binary find on a sorted array.\n    *\n    * @param array The array of sorted items to search.\n    * @param value The value to located in the array.\n    * @param compare The value comparison function.\n    * @returns The found item in the array, or undefined.\n    */\n    function binaryFind(array, value, compare) {\n        var index = lowerBound(array, value, compare);\n        if (index === array.length) {\n            return undefined;\n        }\n        var item = array[index];\n        if (compare(item, value) !== 0) {\n            return undefined;\n        }\n        return item;\n    }\n    tsu.binaryFind = binaryFind;\n    function asSet(items, compare) {\n        var array = tsu.asArray(items);\n        var n = array.length;\n        if (n <= 1) {\n            return array;\n        }\n        array.sort(compare);\n        var result = [array[0]];\n        for (var i = 1, j = 0; i < n; ++i) {\n            var item = array[i];\n            if (compare(result[j], item) !== 0) {\n                result.push(item);\n                ++j;\n            }\n        }\n        return result;\n    }\n    tsu.asSet = asSet;\n    /**\n    * Test whether a two sorted arrays sets are disjoint.\n    *\n    * @param first The first sorted array set.\n    * @param second The second sorted array set.\n    * @param compare The value comparison function.\n    * @returns true if the sets are disjoint, false otherwise.\n    */\n    function setIsDisjoint(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        while (i < len1 && j < len2) {\n            var v = compare(first[i], second[j]);\n            if (v < 0) {\n                ++i;\n            }\n            else if (v > 0) {\n                ++j;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    tsu.setIsDisjoint = setIsDisjoint;\n    /**\n    * Test whether one sorted array set is the subset of another.\n    *\n    * @param first The potential subset.\n    * @param second The potential superset.\n    * @param compare The value comparison function.\n    * @returns true if the first set is a subset of the second.\n    */\n    function setIsSubset(first, second, compare) {\n        var len1 = first.length;\n        var len2 = second.length;\n        if (len1 > len2) {\n            return false;\n        }\n        var i = 0, j = 0;\n        while (i < len1 && j < len2) {\n            var v = compare(first[i], second[j]);\n            if (v < 0) {\n                return false;\n            }\n            else if (v > 0) {\n                ++j;\n            }\n            else {\n                ++i;\n                ++j;\n            }\n        }\n        if (i < len1) {\n            return false;\n        }\n        return true;\n    }\n    tsu.setIsSubset = setIsSubset;\n    /**\n    * Create the set union of two sorted set arrays.\n    var j = 0;\n    *\n    * @param first The first sorted array set.\n    * @param second The second sorted array set.\n    * @param compare The value comparison function.\n    * @returns The set union of the two arrays.\n    */\n    function setUnion(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        var merged = [];\n        while (i < len1 && j < len2) {\n            var a = first[i];\n            var b = second[j];\n            var v = compare(a, b);\n            if (v < 0) {\n                merged.push(a);\n                ++i;\n            }\n            else if (v > 0) {\n                merged.push(b);\n                ++j;\n            }\n            else {\n                merged.push(a);\n                ++i;\n                ++j;\n            }\n        }\n        while (i < len1) {\n            merged.push(first[i]);\n            ++i;\n        }\n        while (j < len2) {\n            merged.push(second[j]);\n            ++j;\n        }\n        return merged;\n    }\n    tsu.setUnion = setUnion;\n    /**\n    * Create a set intersection of two sorted set arrays.\n    *\n    * @param first The first sorted array set.\n    * @param second The second sorted array set.\n    * @param compare The value comparison function.\n    * @returns The set intersection of the two arrays.\n    */\n    function setIntersection(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        var merged = [];\n        while (i < len1 && j < len2) {\n            var a = first[i];\n            var b = second[j];\n            var v = compare(a, b);\n            if (v < 0) {\n                ++i;\n            }\n            else if (v > 0) {\n                ++j;\n            }\n            else {\n                merged.push(a);\n                ++i;\n                ++j;\n            }\n        }\n        return merged;\n    }\n    tsu.setIntersection = setIntersection;\n    /**\n    * Create a set difference of two sorted set arrays.\n    *\n    * @param first The first sorted array set.\n    * @param second The second sorted array set.\n    * @param compare The value comparison function.\n    * @returns The set difference of the two arrays.\n    */\n    function setDifference(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        var merged = [];\n        while (i < len1 && j < len2) {\n            var a = first[i];\n            var b = second[j];\n            var v = compare(a, b);\n            if (v < 0) {\n                merged.push(a);\n                ++i;\n            }\n            else if (v > 0) {\n                ++j;\n            }\n            else {\n                ++i;\n                ++j;\n            }\n        }\n        while (i < len1) {\n            merged.push(first[i]);\n            ++i;\n        }\n        return merged;\n    }\n    tsu.setDifference = setDifference;\n    /**\n    * Create a set symmetric difference of two sorted set arrays.\n    *\n    * @param first The first sorted array set.\n    * @param second The second sorted array set.\n    * @param compare The value comparison function.\n    * @returns The set symmetric difference of the two arrays.\n    */\n    function setSymmetricDifference(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        var merged = [];\n        while (i < len1 && j < len2) {\n            var a = first[i];\n            var b = second[j];\n            var v = compare(a, b);\n            if (v < 0) {\n                merged.push(a);\n                ++i;\n            }\n            else if (v > 0) {\n                merged.push(b);\n                ++j;\n            }\n            else {\n                ++i;\n                ++j;\n            }\n        }\n        while (i < len1) {\n            merged.push(first[i]);\n            ++i;\n        }\n        while (j < len2) {\n            merged.push(second[j]);\n            ++j;\n        }\n        return merged;\n    }\n    tsu.setSymmetricDifference = setSymmetricDifference;\n})(tsu || (tsu = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar tsu;\n(function (tsu) {\n    /**\n    * A base class for implementing array-based data structures.\n    *\n    * @class\n    */\n    var ArrayBase = (function () {\n        function ArrayBase() {\n            /*\n            * The internal data array.\n            *\n            * @protected\n            */\n            this._array = [];\n        }\n        /**\n        * Returns the number of items in the array.\n        */\n        ArrayBase.prototype.size = function () {\n            return this._array.length;\n        };\n        /**\n        * Returns true if the array is empty.\n        */\n        ArrayBase.prototype.empty = function () {\n            return this._array.length === 0;\n        };\n        /**\n        * Returns the item at the given array index.\n        *\n        * @param index The integer index of the desired item.\n        */\n        ArrayBase.prototype.itemAt = function (index) {\n            return this._array[index];\n        };\n        /**\n        * Removes and returns the item at the given index.\n        *\n        * @param index The integer index of the desired item.\n        */\n        ArrayBase.prototype.takeAt = function (index) {\n            return this._array.splice(index, 1)[0];\n        };\n        /**\n        * Clear the internal contents of array.\n        */\n        ArrayBase.prototype.clear = function () {\n            this._array = [];\n        };\n        /**\n        * Swap this array's contents with another array.\n        *\n        * @param other The array base to use for the swap.\n        */\n        ArrayBase.prototype.swap = function (other) {\n            var array = this._array;\n            this._array = other._array;\n            other._array = array;\n        };\n        /**\n        * Returns an iterator over the array of items.\n        */\n        ArrayBase.prototype.__iter__ = function () {\n            return tsu.iter(this._array);\n        };\n        /**\n        * Returns a reverse iterator over the array of items.\n        */\n        ArrayBase.prototype.__reversed__ = function () {\n            return tsu.reversed(this._array);\n        };\n        return ArrayBase;\n    }());\n    tsu.ArrayBase = ArrayBase;\n})(tsu || (tsu = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar tsu;\n(function (tsu) {\n    /**\n    * A mapping container build on a sorted array.\n    *\n    * @class\n    */\n    var AssociativeArray = (function (_super) {\n        __extends(AssociativeArray, _super);\n        /**\n        * Construct a new AssociativeArray.\n        *\n        * @param compare The key comparison function.\n        */\n        function AssociativeArray(compare) {\n            var _this = _super.call(this) || this;\n            _this._compare = compare;\n            _this._wrapped = wrapCompare(compare);\n            return _this;\n        }\n        /**\n        * Returns the key comparison function used by this array.\n        */\n        AssociativeArray.prototype.comparitor = function () {\n            return this._compare;\n        };\n        /**\n        * Return the array index of the given key, or -1.\n        *\n        * @param key The key to locate in the array.\n        */\n        AssociativeArray.prototype.indexOf = function (key) {\n            return tsu.binarySearch(this._array, key, this._wrapped);\n        };\n        /**\n        * Returns true if the key is in the array, false otherwise.\n        *\n        * @param key The key to locate in the array.\n        */\n        AssociativeArray.prototype.contains = function (key) {\n            return tsu.binarySearch(this._array, key, this._wrapped) >= 0;\n        };\n        /**\n        * Returns the pair associated with the given key, or undefined.\n        *\n        * @param key The key to locate in the array.\n        */\n        AssociativeArray.prototype.find = function (key) {\n            return tsu.binaryFind(this._array, key, this._wrapped);\n        };\n        /**\n        * Returns the pair associated with the key if it exists.\n        *\n        * If the key does not exist, a new pair will be created and\n        * inserted using the value created by the given factory.\n        *\n        * @param key The key to locate in the array.\n        * @param factory The function which creates the default value.\n        */\n        AssociativeArray.prototype.setDefault = function (key, factory) {\n            var array = this._array;\n            var index = tsu.lowerBound(array, key, this._wrapped);\n            if (index === array.length) {\n                var pair = new tsu.Pair(key, factory());\n                array.push(pair);\n                return pair;\n            }\n            var currPair = array[index];\n            if (this._compare(currPair.first, key) !== 0) {\n                var pair = new tsu.Pair(key, factory());\n                array.splice(index, 0, pair);\n                return pair;\n            }\n            return currPair;\n        };\n        /**\n        * Insert the pair into the array and return the pair.\n        *\n        * This will overwrite any existing entry in the array.\n        *\n        * @param key The key portion of the pair.\n        * @param value The value portion of the pair.\n        */\n        AssociativeArray.prototype.insert = function (key, value) {\n            var array = this._array;\n            var index = tsu.lowerBound(array, key, this._wrapped);\n            if (index === array.length) {\n                var pair = new tsu.Pair(key, value);\n                array.push(pair);\n                return pair;\n            }\n            var currPair = array[index];\n            if (this._compare(currPair.first, key) !== 0) {\n                var pair = new tsu.Pair(key, value);\n                array.splice(index, 0, pair);\n                return pair;\n            }\n            currPair.second = value;\n            return currPair;\n        };\n        AssociativeArray.prototype.update = function (object) {\n            var _this = this;\n            if (object instanceof AssociativeArray) {\n                this._array = merge(this._array, object._array, this._compare);\n            }\n            else {\n                tsu.forEach(object, function (pair) {\n                    _this.insert(pair.first, pair.second);\n                });\n            }\n        };\n        /**\n        * Removes and returns the pair for the given key, or undefined.\n        *\n        * @param key The key to remove from the map.\n        */\n        AssociativeArray.prototype.erase = function (key) {\n            var array = this._array;\n            var index = tsu.binarySearch(array, key, this._wrapped);\n            if (index < 0) {\n                return undefined;\n            }\n            return array.splice(index, 1)[0];\n        };\n        /**\n        * Create a copy of this associative array.\n        */\n        AssociativeArray.prototype.copy = function () {\n            var theCopy = new AssociativeArray(this._compare);\n            var copyArray = theCopy._array;\n            var thisArray = this._array;\n            for (var i = 0, n = thisArray.length; i < n; ++i) {\n                copyArray.push(thisArray[i].copy());\n            }\n            return theCopy;\n        };\n        return AssociativeArray;\n    }(tsu.ArrayBase));\n    tsu.AssociativeArray = AssociativeArray;\n    /**\n    * An internal which wraps a comparison key function.\n    */\n    function wrapCompare(cmp) {\n        return function (pair, value) {\n            return cmp(pair.first, value);\n        };\n    }\n    /**\n    * An internal function which merges two ordered pair arrays.\n    */\n    function merge(first, second, compare) {\n        var i = 0, j = 0;\n        var len1 = first.length;\n        var len2 = second.length;\n        var merged = [];\n        while (i < len1 && j < len2) {\n            var a = first[i];\n            var b = second[j];\n            var v = compare(a.first, b.first);\n            if (v < 0) {\n                merged.push(a.copy());\n                ++i;\n            }\n            else if (v > 0) {\n                merged.push(b.copy());\n                ++j;\n            }\n            else {\n                merged.push(b.copy());\n                ++i;\n                ++j;\n            }\n        }\n        while (i < len1) {\n            merged.push(first[i].copy());\n            ++i;\n        }\n        while (j < len2) {\n            merged.push(second[j].copy());\n            ++j;\n        }\n        return merged;\n    }\n})(tsu || (tsu = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar tsu;\n(function (tsu) {\n    /**\n    * An iterator for an array of items.\n    */\n    var ArrayIterator = (function () {\n        /*\n        * Construct a new ArrayIterator.\n        *\n        * @param array The array of items to iterate.\n        * @param [index] The index at which to start iteration.\n        */\n        function ArrayIterator(array, index) {\n            if (typeof index === \"undefined\") {\n                index = 0;\n            }\n            this._array = array;\n            this._index = Math.max(0, Math.min(index, array.length));\n        }\n        /**\n        * Returns the next item from the iterator or undefined.\n        */\n        ArrayIterator.prototype.__next__ = function () {\n            return this._array[this._index++];\n        };\n        /**\n        * Returns this same iterator.\n        */\n        ArrayIterator.prototype.__iter__ = function () {\n            return this;\n        };\n        return ArrayIterator;\n    }());\n    tsu.ArrayIterator = ArrayIterator;\n    /**\n    * A reverse iterator for an array of items.\n    */\n    var ReverseArrayIterator = (function () {\n        /**\n        * Construct a new ReverseArrayIterator.\n        *\n        * @param array The array of items to iterate.\n        * @param [index] The index at which to start iteration.\n        */\n        function ReverseArrayIterator(array, index) {\n            if (typeof index === \"undefined\") {\n                index = array.length;\n            }\n            this._array = array;\n            this._index = Math.max(0, Math.min(index, array.length));\n        }\n        /**\n        * Returns the next item from the iterator or undefined.\n        */\n        ReverseArrayIterator.prototype.__next__ = function () {\n            return this._array[--this._index];\n        };\n        /**\n        * Returns this same iterator.\n        */\n        ReverseArrayIterator.prototype.__iter__ = function () {\n            return this;\n        };\n        return ReverseArrayIterator;\n    }());\n    tsu.ReverseArrayIterator = ReverseArrayIterator;\n    function iter(object) {\n        if (object instanceof Array) {\n            return new ArrayIterator(object);\n        }\n        return object.__iter__();\n    }\n    tsu.iter = iter;\n    function reversed(object) {\n        if (object instanceof Array) {\n            return new ReverseArrayIterator(object);\n        }\n        return object.__reversed__();\n    }\n    tsu.reversed = reversed;\n    /**\n    * Returns the next value from an iterator, or undefined.\n    */\n    function next(iterator) {\n        return iterator.__next__();\n    }\n    tsu.next = next;\n    function asArray(object) {\n        if (object instanceof Array) {\n            return object.slice();\n        }\n        var value;\n        var array = [];\n        var it = object.__iter__();\n        while ((value = it.__next__()) !== undefined) {\n            array.push(value);\n        }\n        return array;\n    }\n    tsu.asArray = asArray;\n    function forEach(object, callback) {\n        if (object instanceof Array) {\n            for (var i = 0, n = object.length; i < n; ++i) {\n                if (callback(object[i]) === false) {\n                    return;\n                }\n            }\n        }\n        else {\n            var value;\n            var it = object.__iter__();\n            while ((value = it.__next__()) !== undefined) {\n                if (callback(value) === false) {\n                    return;\n                }\n            }\n        }\n    }\n    tsu.forEach = forEach;\n    function map(object, callback) {\n        var result = [];\n        if (object instanceof Array) {\n            for (var i = 0, n = object.length; i < n; ++i) {\n                result.push(callback(object[i]));\n            }\n        }\n        else {\n            var value;\n            var it = object.__iter__();\n            while ((value = it.__next__()) !== undefined) {\n                result.push(callback(value));\n            }\n        }\n        return result;\n    }\n    tsu.map = map;\n    function filter(object, callback) {\n        var value;\n        var result = [];\n        if (object instanceof Array) {\n            for (var i = 0, n = object.length; i < n; ++i) {\n                value = object[i];\n                if (callback(value)) {\n                    result.push(value);\n                }\n            }\n        }\n        else {\n            var it = object.__iter__();\n            while ((value = it.__next__()) !== undefined) {\n                if (callback(value)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    }\n    tsu.filter = filter;\n})(tsu || (tsu = {}));\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nvar tsu;\n(function (tsu) {\n    /**\n    * A class which defines a generic pair object.\n    */\n    var Pair = (function () {\n        /**\n        * Construct a new Pair object.\n        *\n        * @param first The first item of the pair.\n        * @param second The second item of the pair.\n        */\n        function Pair(first, second) {\n            this.first = first;\n            this.second = second;\n        }\n        /**\n        * Create a copy of the pair.\n        */\n        Pair.prototype.copy = function () {\n            return new Pair(this.first, this.second);\n        };\n        return Pair;\n    }());\n    tsu.Pair = Pair;\n})(tsu || (tsu = {}));\nmodule.exports = kiwi;\n","/*!\n * numbro.js\n * version : 1.6.2\n * author : Företagsplatsen AB\n * license : MIT\n * http://www.foretagsplatsen.se\n */\n\n    /************************************\n        Constants\n    ************************************/\n\n    var numbro,\n        VERSION = '1.6.2',\n    // internal storage for culture config files\n        cultures = {},\n    // Todo: Remove in 2.0.0\n        languages = cultures,\n        currentCulture = 'en-US',\n        zeroFormat = null,\n        defaultFormat = '0,0',\n        defaultCurrencyFormat = '0$',\n        // check for nodeJS\n        hasModule = (typeof module !== 'undefined' && module.exports),\n    // default culture\n        enUS = {\n            delimiters: {\n                thousands: ',',\n                decimal: '.'\n            },\n            abbreviations: {\n                thousand: 'k',\n                million: 'm',\n                billion: 'b',\n                trillion: 't'\n            },\n            ordinal: function(number) {\n                var b = number % 10;\n                return (~~(number % 100 / 10) === 1) ? 'th' :\n                    (b === 1) ? 'st' :\n                        (b === 2) ? 'nd' :\n                            (b === 3) ? 'rd' : 'th';\n            },\n            currency: {\n                symbol: '$',\n                position: 'prefix'\n            },\n            defaults: {\n                currencyFormat: ',0000 a'\n            },\n            formats: {\n                fourDigits: '0000 a',\n                fullWithTwoDecimals: '$ ,0.00',\n                fullWithTwoDecimalsNoCurrency: ',0.00'\n            }\n        };\n\n    /************************************\n        Constructors\n    ************************************/\n\n\n    // Numbro prototype object\n    function Numbro(number) {\n        this._value = number;\n    }\n\n    function zeroes(count) {\n        var i, ret = '';\n\n        for (i = 0; i < count; i++) {\n            ret += '0';\n        }\n\n        return ret;\n    }\n    /**\n     * Implementation of toFixed() for numbers with exponent > 21\n     *\n     *\n     */\n    function toFixedLarge(value, precision) {\n        var mantissa,\n            beforeDec,\n            afterDec,\n            exponent,\n            str;\n\n        str = value.toString();\n\n        mantissa = str.split('e')[0];\n        exponent  = str.split('e')[1];\n\n        beforeDec = mantissa.split('.')[0];\n        afterDec = mantissa.split('.')[1] || '';\n\n        str = beforeDec + afterDec + zeroes(exponent - afterDec.length);\n        if (precision > 0) {\n            str += '.' + zeroes(precision);\n        }\n\n        return str;\n    }\n\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed(value, precision, roundingFunction, optionals) {\n        var power = Math.pow(10, precision),\n            optionalsRegExp,\n            output;\n\n        if (value.toFixed(0).search('e') > -1) {\n            // Above 1e21, toFixed returns scientific notation, which\n            // is useless and unexpected\n            output = toFixedLarge(value, precision);\n        }\n        else {\n            //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value * power) / power).toFixed(precision);\n        }\n\n        if (optionals) {\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n\n        return output;\n    }\n\n    /************************************\n        Formatting\n    ************************************/\n\n    // determine what type of formatting we need to do\n    function formatNumbro(value, format, roundingFunction) {\n        var output;\n        // TODO: do something with `language`\n\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(value, format, roundingFunction);\n        } else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(value, format, roundingFunction);\n        } else if (format.indexOf(':') > -1) { // time\n            output = formatTime(value);\n        } else { // plain ol' numbers or bytes\n            output = formatNumber(value, format, roundingFunction);\n        }\n\n        // return string\n        return output;\n    }\n\n    function formatCurrency(value, originalFormat, roundingFunction) {\n        var format = originalFormat,\n            symbolIndex = format.indexOf('$'),\n            openParenIndex = format.indexOf('('),\n            plusSignIndex = format.indexOf('+'),\n            minusSignIndex = format.indexOf('-'),\n            space = '',\n            decimalSeparator = '',\n            spliceIndex,\n            output;\n\n        if(format.indexOf('$') === -1){\n            // Use defaults instead of the format provided\n            if (cultures[currentCulture].currency.position === 'infix') {\n                decimalSeparator = cultures[currentCulture].currency.symbol;\n                if (cultures[currentCulture].currency.spaceSeparated) {\n                    decimalSeparator = ' ' + decimalSeparator + ' ';\n                }\n            } else if (cultures[currentCulture].currency.spaceSeparated) {\n                space = ' ';\n            }\n        } else {\n            // check for space before or after currency\n            if (format.indexOf(' $') > -1) {\n                space = ' ';\n                format = format.replace(' $', '');\n            } else if (format.indexOf('$ ') > -1) {\n                space = ' ';\n                format = format.replace('$ ', '');\n            } else {\n                format = format.replace('$', '');\n            }\n        }\n\n        // Format The Number\n        output = formatNumber(value, format, roundingFunction, decimalSeparator);\n\n        if (originalFormat.indexOf('$') === -1) {\n            // Use defaults instead of the format provided\n            switch (cultures[currentCulture].currency.position) {\n                case 'postfix':\n                    if (output.indexOf(')') > -1) {\n                        output = output.split('');\n                        output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                        output = output.join('');\n                    } else {\n                        output = output + space + cultures[currentCulture].currency.symbol;\n                    }\n                    break;\n                case 'infix':\n                    break;\n                case 'prefix':\n                    if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                        output = output.split('');\n                        spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;\n\n                        output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                        output = output.join('');\n                    } else {\n                        output = cultures[currentCulture].currency.symbol + space + output;\n                    }\n                    break;\n                default:\n                    throw Error('Currency position should be among [\"prefix\", \"infix\", \"postfix\"]');\n            }\n        } else {\n            // position the symbol\n            if (symbolIndex <= 1) {\n                if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {\n                    output = output.split('');\n                    spliceIndex = 1;\n                    if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {\n                        // the symbol appears before the \"(\", \"+\" or \"-\"\n                        spliceIndex = 0;\n                    }\n                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                    output = output.join('');\n                } else {\n                    output = cultures[currentCulture].currency.symbol + space + output;\n                }\n            } else {\n                if (output.indexOf(')') > -1) {\n                    output = output.split('');\n                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                    output = output.join('');\n                } else {\n                    output = output + space + cultures[currentCulture].currency.symbol;\n                }\n            }\n        }\n\n        return output;\n    }\n\n    function formatPercentage(value, format, roundingFunction) {\n        var space = '',\n            output;\n        value = value * 100;\n\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        } else {\n            format = format.replace('%', '');\n        }\n\n        output = formatNumber(value, format, roundingFunction);\n\n        if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        } else {\n            output = output + space + '%';\n        }\n\n        return output;\n    }\n\n    function formatTime(value) {\n        var hours = Math.floor(value / 60 / 60),\n            minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n            seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' +\n            ((minutes < 10) ? '0' + minutes : minutes) + ':' +\n            ((seconds < 10) ? '0' + seconds : seconds);\n    }\n\n    function formatNumber (value, format, roundingFunction, sep) {\n        var negP = false,\n            signed = false,\n            optDec = false,\n            abbr = '',\n            i,\n            abbrK = false, // force abbreviation to thousands\n            abbrM = false, // force abbreviation to millions\n            abbrB = false, // force abbreviation to billions\n            abbrT = false, // force abbreviation to trillions\n            abbrForce = false, // force abbreviation\n            bytes = '',\n            ord = '',\n            abs = Math.abs(value),\n            binarySuffixes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],\n            decimalSuffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n            min,\n            max,\n            power,\n            totalLength,\n            length,\n            minimumPrecision,\n            pow,\n            w,\n            intPrecision,\n            precision,\n            prefix,\n            postfix,\n            thousands,\n            d = '',\n            forcedNeg = false,\n            neg = false,\n            indexOpenP,\n            size,\n            indexMinus,\n            paren = '',\n            minlen;\n\n        // check if number is zero and a custom zero format has been set\n        if (value === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        }\n\n        if (!isFinite(value)) {\n            return '' + value;\n        }\n\n        if (format.indexOf('{') === 0) {\n            var end = format.indexOf('}');\n            if (end === -1) {\n                throw Error('Format should also contain a \"}\"');\n            }\n            prefix = format.slice(1, end);\n            format = format.slice(end + 1);\n        } else {\n            prefix = '';\n        }\n\n        if (format.indexOf('}') === format.length - 1) {\n            var start = format.indexOf('{');\n            if (start === -1) {\n                throw Error('Format should also contain a \"{\"');\n            }\n            postfix = format.slice(start + 1, -1);\n            format = format.slice(0, start + 1);\n        } else {\n            postfix = '';\n        }\n\n        // check for min length\n        var info;\n        if (format.indexOf('.') === -1) {\n            info = format.match(/([0-9]+).*/);\n        } else {\n            info = format.match(/([0-9]+)\\..*/);\n        }\n        minlen = info === null ? -1 : info[1].length;\n\n        // see if we should use parentheses for negative number or if we should prefix with a sign\n        // if both are present we default to parentheses\n        if (format.indexOf('-') !== -1) {\n            forcedNeg = true;\n        }\n        if (format.indexOf('(') > -1) {\n            negP = true;\n            format = format.slice(1, -1);\n        } else if (format.indexOf('+') > -1) {\n            signed = true;\n            format = format.replace(/\\+/g, '');\n        }\n\n        // see if abbreviation is wanted\n        if (format.indexOf('a') > -1) {\n            intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];\n            intPrecision = parseInt(intPrecision[0], 10);\n\n            // check if abbreviation is specified\n            abbrK = format.indexOf('aK') >= 0;\n            abbrM = format.indexOf('aM') >= 0;\n            abbrB = format.indexOf('aB') >= 0;\n            abbrT = format.indexOf('aT') >= 0;\n            abbrForce = abbrK || abbrM || abbrB || abbrT;\n\n            // check for space before abbreviation\n            if (format.indexOf(' a') > -1) {\n                abbr = ' ';\n                format = format.replace(' a', '');\n            } else {\n                format = format.replace('a', '');\n            }\n\n            totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;\n\n            minimumPrecision = totalLength % 3;\n            minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;\n\n            if (intPrecision && abs !== 0) {\n\n                length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;\n\n                pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);\n\n                abs = abs / Math.pow(10, pow);\n\n                if (format.indexOf('.') === -1 && intPrecision > 3) {\n                    format += '[.]';\n\n                    size = length === 0 ? 0 : 3 * ~~(length / 3) - length;\n                    size = size < 0 ? size + 3 : size;\n\n                    for (i = 0; i < size; i++) {\n                        format += '0';\n                    }\n                }\n            }\n\n            if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n                    // trillion\n                    abbr = abbr + cultures[currentCulture].abbreviations.trillion;\n                    value = value / Math.pow(10, 12);\n                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n                    // billion\n                    abbr = abbr + cultures[currentCulture].abbreviations.billion;\n                    value = value / Math.pow(10, 9);\n                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n                    // million\n                    abbr = abbr + cultures[currentCulture].abbreviations.million;\n                    value = value / Math.pow(10, 6);\n                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n                    // thousand\n                    abbr = abbr + cultures[currentCulture].abbreviations.thousand;\n                    value = value / Math.pow(10, 3);\n                }\n            }\n        }\n\n        // see if we are formatting binary bytes\n        if (format.indexOf('b') > -1) {\n            // check for space before\n            if (format.indexOf(' b') > -1) {\n                bytes = ' ';\n                format = format.replace(' b', '');\n            } else {\n                format = format.replace('b', '');\n            }\n\n            for (power = 0; power <= binarySuffixes.length; power++) {\n                min = Math.pow(1024, power);\n                max = Math.pow(1024, power + 1);\n\n                if (value >= min && value < max) {\n                    bytes = bytes + binarySuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n\n        // see if we are formatting decimal bytes\n        if (format.indexOf('d') > -1) {\n            // check for space before\n            if (format.indexOf(' d') > -1) {\n                bytes = ' ';\n                format = format.replace(' d', '');\n            } else {\n                format = format.replace('d', '');\n            }\n\n            for (power = 0; power <= decimalSuffixes.length; power++) {\n                min = Math.pow(1000, power);\n                max = Math.pow(1000, power + 1);\n\n                if (value >= min && value < max) {\n                    bytes = bytes + decimalSuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n\n        // see if ordinal is wanted\n        if (format.indexOf('o') > -1) {\n            // check for space before\n            if (format.indexOf(' o') > -1) {\n                ord = ' ';\n                format = format.replace(' o', '');\n            } else {\n                format = format.replace('o', '');\n            }\n\n            if (cultures[currentCulture].ordinal) {\n                ord = ord + cultures[currentCulture].ordinal(value);\n            }\n        }\n\n        if (format.indexOf('[.]') > -1) {\n            optDec = true;\n            format = format.replace('[.]', '.');\n        }\n\n        w = value.toString().split('.')[0];\n        precision = format.split('.')[1];\n        thousands = format.indexOf(',');\n\n        if (precision) {\n            if (precision.indexOf('*') !== -1) {\n                d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);\n            } else {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction,\n                        precision[1].length);\n                } else {\n                    d = toFixed(value, precision.length, roundingFunction);\n                }\n            }\n\n            w = d.split('.')[0];\n\n            if (d.split('.')[1].length) {\n                var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;\n                d = p + d.split('.')[1];\n            } else {\n                d = '';\n            }\n\n            if (optDec && Number(d.slice(1)) === 0) {\n                d = '';\n            }\n        } else {\n            w = toFixed(value, null, roundingFunction);\n        }\n\n        // format number\n        if (w.indexOf('-') > -1) {\n            w = w.slice(1);\n            neg = true;\n        }\n\n        if (w.length < minlen) {\n            w = new Array(minlen - w.length + 1).join('0') + w;\n        }\n\n        if (thousands > -1) {\n            w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' +\n                cultures[currentCulture].delimiters.thousands);\n        }\n\n        if (format.indexOf('.') === 0) {\n            w = '';\n        }\n\n        indexOpenP = format.indexOf('(');\n        indexMinus = format.indexOf('-');\n\n        if (indexOpenP < indexMinus) {\n            paren = ((negP && neg) ? '(' : '') + (((forcedNeg && neg) || (!negP && neg)) ? '-' : '');\n        } else {\n            paren = (((forcedNeg && neg) || (!negP && neg)) ? '-' : '') + ((negP && neg) ? '(' : '');\n        }\n\n        return prefix +\n            paren + ((!neg && signed && value !== 0) ? '+' : '') +\n            w + d +\n            ((ord) ? ord : '') +\n            ((abbr && !sep) ? abbr : '') +\n            ((bytes) ? bytes : '') +\n            ((negP && neg) ? ')' : '') +\n            postfix;\n    }\n\n    /************************************\n        Top Level Functions\n    ************************************/\n\n    numbro = function(input) {\n        if (numbro.isNumbro(input)) {\n            input = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            input = 0;\n        } else if (!Number(input)) {\n            input = numbro.fn.unformat(input);\n        }\n\n        return new Numbro(Number(input));\n    };\n\n    // version number\n    numbro.version = VERSION;\n\n    // compare numbro object\n    numbro.isNumbro = function(obj) {\n        return obj instanceof Numbro;\n    };\n\n    /**\n     * This function allow the user to set a new language with a fallback if\n     * the language does not exist. If no fallback language is provided,\n     * it fallbacks to english.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `setCulture` should be used instead.\n     */\n    numbro.setLanguage = function(newLanguage, fallbackLanguage) {\n        console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');\n        var key = newLanguage,\n            prefix = newLanguage.split('-')[0],\n            matchingLanguage = null;\n        if (!languages[key]) {\n            Object.keys(languages).forEach(function(language) {\n                if (!matchingLanguage && language.split('-')[0] === prefix) {\n                    matchingLanguage = language;\n                }\n            });\n            key = matchingLanguage || fallbackLanguage || 'en-US';\n        }\n        chooseCulture(key);\n    };\n\n    /**\n     * This function allow the user to set a new culture with a fallback if\n     * the culture does not exist. If no fallback culture is provided,\n     * it fallbacks to \"en-US\".\n     */\n    numbro.setCulture = function(newCulture, fallbackCulture) {\n        var key = newCulture,\n            suffix = newCulture.split('-')[1],\n            matchingCulture = null;\n        if (!cultures[key]) {\n            if (suffix) {\n                Object.keys(cultures).forEach(function(language) {\n                    if (!matchingCulture && language.split('-')[1] === suffix) {\n                        matchingCulture = language;\n                    }\n                });\n            }\n\n            key = matchingCulture || fallbackCulture || 'en-US';\n        }\n        chooseCulture(key);\n    };\n\n    /**\n     * This function will load languages and then set the global language.  If\n     * no arguments are passed in, it will simply return the current global\n     * language key.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.language = function(key, values) {\n        console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');\n\n        if (!key) {\n            return currentCulture;\n        }\n\n        if (key && !values) {\n            if (!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            chooseCulture(key);\n        }\n\n        if (values || !languages[key]) {\n            setCulture(key, values);\n        }\n\n        return numbro;\n    };\n\n    /**\n     * This function will load cultures and then set the global culture.  If\n     * no arguments are passed in, it will simply return the current global\n     * culture code.\n     */\n    numbro.culture = function(code, values) {\n        if (!code) {\n            return currentCulture;\n        }\n\n        if (code && !values) {\n            if (!cultures[code]) {\n                throw new Error('Unknown culture : ' + code);\n            }\n            chooseCulture(code);\n        }\n\n        if (values || !cultures[code]) {\n            setCulture(code, values);\n        }\n\n        return numbro;\n    };\n\n    /**\n     * This function provides access to the loaded language data.  If\n     * no arguments are passed in, it will simply return the current\n     * global language object.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.languageData = function(key) {\n        console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');\n\n        if (!key) {\n            return languages[currentCulture];\n        }\n\n        if (!languages[key]) {\n            throw new Error('Unknown language : ' + key);\n        }\n\n        return languages[key];\n    };\n\n    /**\n     * This function provides access to the loaded culture data.  If\n     * no arguments are passed in, it will simply return the current\n     * global culture object.\n     */\n    numbro.cultureData = function(code) {\n        if (!code) {\n            return cultures[currentCulture];\n        }\n\n        if (!cultures[code]) {\n            throw new Error('Unknown culture : ' + code);\n        }\n\n        return cultures[code];\n    };\n\n    numbro.culture('en-US', enUS);\n\n    /**\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `cultures` should be used instead.\n     */\n    numbro.languages = function() {\n        console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');\n\n        return languages;\n    };\n\n    numbro.cultures = function() {\n        return cultures;\n    };\n\n    numbro.zeroFormat = function(format) {\n        zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numbro.defaultFormat = function(format) {\n        defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numbro.defaultCurrencyFormat = function (format) {\n        defaultCurrencyFormat = typeof(format) === 'string' ? format : '0$';\n    };\n\n    numbro.validate = function(val, culture) {\n\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            cultureData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n            if (console.warn) {\n                console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if ( !! val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numbro.cultureData\n        try {\n            //check if the culture is understood by numbro. if not, default it to current culture\n            cultureData = numbro.cultureData(culture);\n        } catch (e) {\n            cultureData = numbro.cultureData(numbro.culture());\n        }\n\n        //setup the delimiters and currency symbol based on culture\n        _currSymbol = cultureData.currency.symbol;\n        _abbrObj = cultureData.abbreviations;\n        _decimalSep = cultureData.delimiters.decimal;\n        if (cultureData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = cultureData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million &&\n                    temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /************************************\n        Helpers\n    ************************************/\n\n    function setCulture(code, values) {\n        cultures[code] = values;\n    }\n\n    function chooseCulture(code) {\n        currentCulture = code;\n        var defaults = cultures[code].defaults;\n        if (defaults && defaults.format) {\n            numbro.defaultFormat(defaults.format);\n        }\n        if (defaults && defaults.currencyFormat) {\n            numbro.defaultCurrencyFormat(defaults.currencyFormat);\n        }\n    }\n\n    function format(input, formatString, language, roundingFunction) {\n        if (language != null && language !== numbro.culture()) {\n            numbro.setCulture(language);\n        }\n        return formatNumbro(\n            Number(input),\n            formatString != null     ? formatString : defaultFormat,\n            roundingFunction == null ? Math.round   : roundingFunction);\n    }\n\n    module.exports = {\"format\": format};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var parseCode = require('./parseCode');\nvar extend = require('./extend');\nvar projections = require('./projections');\nvar deriveConstants = require('./deriveConstants');\nvar Datum = require('./constants/Datum');\nvar datum = require('./datum');\n\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = Datum[json.datumCode];\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n\n  var sphere = deriveConstants.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = deriveConstants.eccentricity(sphere.a, sphere.b, sphere.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere.a, sphere.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere.a;\n  this.b = sphere.b;\n  this.rf = sphere.rf;\n  this.sphere = sphere.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nmodule.exports = Projection;\n","module.exports = function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n};\n","var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nvar SPI = 3.14159265359;\nvar sign = require('./sign');\n\nmodule.exports = function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n};","module.exports = function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n};","var HALF_PI = Math.PI/2;\nmodule.exports = function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n};","module.exports = function(x) {\n  return x<0 ? -1 : 1;\n};","module.exports = function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n};","var HALF_PI = Math.PI/2;\n\nmodule.exports = function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n};","exports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};","exports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\nexports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};","exports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"","exports.ft = {to_meter: 0.3048};\nexports['us-ft'] = {to_meter: 1200 / 3937};\n","var proj = require('./Proj');\nvar transform = require('./transform');\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords);\n    if (coords.length === 3) {\n      return [transformedArray.x, transformedArray.y, transformedArray.z];\n    }\n    else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  }\n  else {\n    return transform(from, to, coords);\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  }\n  else {\n    obj = {\n      forward: function(coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function(coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nmodule.exports = proj4;","var PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_WGS84 = 4; // WGS84 or equivalent\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n  out.datum_type = PJD_WGS84; //default setting\n  if (datumCode && datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nmodule.exports = datum;\n","'use strict';\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar HALF_PI = Math.PI/2;\n\nexports.compareDatums = function(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {\n    // the tolerence for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (this.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n}; // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexports.geodeticToGeocentric = function(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return null;\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n}; // cs_geodetic_to_geocentric()\n\n\nexports.geocentricToGeodetic = function(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n}; // cs_geocentric_to_geodetic()\n\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexports.geocentricToWgs84 = function(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n}; // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexports.geocentricFromWgs84 = function(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n};\n","var PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar datum = require('./datumUtils');\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\nmodule.exports = function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (datum.compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = datum.geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = datum.geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = datum.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return datum.geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n};\n","var globals = require('./global');\nvar parseProj = require('./projString');\nvar wkt = require('./wkt');\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nmodule.exports = defs;\n","// ellipoid pj_set_ell.c\nvar SIXTH = 0.1666666666666666667;\n/* 1/6 */\nvar RA4 = 0.04722222222222222222;\n/* 17/360 */\nvar RA6 = 0.02215608465608465608;\nvar EPSLN = 1.0e-10;\nvar Ellipsoid = require('./constants/Ellipsoid');\n\nexports.eccentricity = function(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n};\nexports.sphere = function (a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = Ellipsoid[ellps];\n    if (!ellipse) {\n      ellipse = Ellipsoid.WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n};\n","module.exports = function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n};\n","module.exports = function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n};\n","var defs = require('./defs');\nvar wkt = require('./wkt');\nvar projStr = require('./projString');\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\nvar codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];\n\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      return wkt(code);\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nmodule.exports = parse;\n","var D2R = 0.01745329251994329577;\nvar PrimeMeridian = require('./constants/PrimeMeridian');\nvar units = require('./constants/units');\n\nmodule.exports = function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      if (units[v]) {\n        self.to_meter = units[v].to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n};\n","var projs = [\n  require('./projections/merc'),\n  require('./projections/longlat')\n];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexports.add = add;\n\nexports.get = function(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n};\nexports.start = function() {\n  projs.forEach(add);\n};\n","exports.init = function() {\n  //no-op for longlat\n};\n\nfunction identity(pt) {\n  return pt;\n}\nexports.forward = identity;\nexports.inverse = identity;\nexports.names = [\"longlat\", \"identity\"];\n","var msfnz = require('../common/msfnz');\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar R2D = 57.29577951308232088;\nvar adjust_lon = require('../common/adjust_lon');\nvar FORTPI = Math.PI/4;\nvar tsfnz = require('../common/tsfnz');\nvar phi2z = require('../common/phi2z');\nexports.init = function() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n};\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n};\n\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexports.inverse = function(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\n\nexports.names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n","var D2R = 0.01745329251994329577;\nvar R2D = 57.29577951308232088;\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar datum_transform = require('./datum_transform');\nvar adjust_axis = require('./adjust_axis');\nvar proj = require('./Proj');\nvar toPoint = require('./common/toPoint');\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\nmodule.exports = function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R\n    };\n  }\n  else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.grom_greenwich,\n      y: point.y\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n};\n","var D2R = 0.01745329251994329577;\nvar extend = require('./extend');\n\nfunction mapit(obj, key, v) {\n  obj[key] = v.map(function(aa) {\n    var o = {};\n    sExpr(aa, o);\n    return o;\n  }).reduce(function(a, b) {\n    return extend(a, b);\n  }, {});\n}\n\nfunction sExpr(v, obj) {\n  var key;\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  else {\n    key = v.shift();\n    if (key === 'PARAMETER') {\n      key = v.shift();\n    }\n    if (v.length === 1) {\n      if (Array.isArray(v[0])) {\n        obj[key] = {};\n        sExpr(v[0], obj[key]);\n      }\n      else {\n        obj[key] = v[0];\n      }\n    }\n    else if (!v.length) {\n      obj[key] = true;\n    }\n    else if (key === 'TOWGS84') {\n      obj[key] = v;\n    }\n    else {\n      obj[key] = {};\n      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {\n        obj[key] = {\n          name: v[0].toLowerCase(),\n          convert: v[1]\n        };\n        if (v.length === 3) {\n          obj[key].auth = v[2];\n        }\n      }\n      else if (key === 'SPHEROID') {\n        obj[key] = {\n          name: v[0],\n          a: v[1],\n          rf: v[2]\n        };\n        if (v.length === 4) {\n          obj[key].auth = v[3];\n        }\n      }\n      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {\n        v[0] = ['name', v[0]];\n        mapit(obj, key, v);\n      }\n      else if (v.every(function(aa) {\n        return Array.isArray(aa);\n      })) {\n        mapit(obj, key, v);\n      }\n      else {\n        sExpr(v, obj[key]);\n      }\n    }\n  }\n}\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  }\n  else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  }\n  else {\n    if (typeof wkt.PROJECTION === \"object\") {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    }\n    else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);\n      }\n    }\n  }\n\n  if (wkt.GEOGCS) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (wkt.GEOGCS.DATUM) {\n      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();\n    }\n    else {\n      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === \"wgs_1984\") {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = \"rnb72\";\n    }\n    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {\n      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === \"international\") {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = \"osgb36\";\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return parseFloat(input, 10) * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nmodule.exports = function(wkt, self) {\n  var lisp = JSON.parse((\",\" + wkt).replace(/\\s*\\,\\s*([A-Z_0-9]+?)(\\[)/g, ',[\"$1\",').slice(1).replace(/\\s*\\,\\s*([A-Z_0-9]+?)\\]/g, ',\"$1\"]').replace(/,\\[\"VERTCS\".+/,''));\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  lisp.unshift('output');\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj.output);\n  return extend(self, obj.output);\n};\n","'use strict';\n\nmodule.exports = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","'use strict';\n\nmodule.exports = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","/**\nsprintf() for JavaScript 0.7-beta1\nhttp://www.diveintojavascript.com/projects/javascript-sprintf\n\nCopyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of sprintf() for JavaScript nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nChangelog:\n2010.11.07 - 0.7-beta1-node\n  - converted it to a node.js compatible module\n\n2010.09.06 - 0.7-beta1\n  - features: vsprintf, support for named placeholders\n  - enhancements: format cache, reduced global namespace pollution\n\n2010.05.22 - 0.6:\n - reverted to 0.4 and fixed the bug regarding the sign of the number 0\n Note:\n Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)\n who warned me about a bug in 0.5, I discovered that the last update was\n a regress. I appologize for that.\n\n2010.05.09 - 0.5:\n - bug fix: 0 is now preceeded with a + sign\n - bug fix: the sign was not at the right position on padded results (Kamal Abdali)\n - switched from GPL to BSD license\n\n2007.10.21 - 0.4:\n - unit test and patch (David Baird)\n\n2007.09.17 - 0.3:\n - bug fix: no longer throws exception on empty paramenters (Hans Pufal)\n\n2007.09.11 - 0.2:\n - feature: added argument swapping\n\n2007.04.03 - 0.1:\n - initial release\n**/\n\nvar sprintf = (function() {\n\tfunction get_type(variable) {\n\t\treturn Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n\t}\n\tfunction str_repeat(input, multiplier) {\n\t\tfor (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}\n\t\treturn output.join('');\n\t}\n\n\tvar str_format = function() {\n\t\tif (!str_format.cache.hasOwnProperty(arguments[0])) {\n\t\t\tstr_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n\t\t}\n\t\treturn str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n\t};\n\n\t// convert object to simple one line string without indentation or\n\t// newlines. Note that this implementation does not print array\n\t// values to their actual place for sparse arrays. \n\t//\n\t// For example sparse array like this\n\t//    l = []\n\t//    l[4] = 1\n\t// Would be printed as \"[1]\" instead of \"[, , , , 1]\"\n\t// \n\t// If argument 'seen' is not null and array the function will check for \n\t// circular object references from argument.\n\tstr_format.object_stringify = function(obj, depth, maxdepth, seen) {\n\t\tvar str = '';\n\t\tif (obj != null) {\n\t\t\tswitch( typeof(obj) ) {\n\t\t\tcase 'function': \n\t\t\t\treturn '[Function' + (obj.name ? ': '+obj.name : '') + ']';\n\t\t\t    break;\n\t\t\tcase 'object':\n\t\t\t\tif ( obj instanceof Error) { return '[' + obj.toString() + ']' };\n\t\t\t\tif (depth >= maxdepth) return '[Object]'\n\t\t\t\tif (seen) {\n\t\t\t\t\t// add object to seen list\n\t\t\t\t\tseen = seen.slice(0)\n\t\t\t\t\tseen.push(obj);\n\t\t\t\t}\n\t\t\t\tif (obj.length != null) { //array\n\t\t\t\t\tstr += '[';\n\t\t\t\t\tvar arr = []\n\t\t\t\t\tfor (var i in obj) {\n\t\t\t\t\t\tif (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');\n\t\t\t\t\t\telse arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));\n\t\t\t\t\t}\n\t\t\t\t\tstr += arr.join(', ') + ']';\n\t\t\t\t} else if ('getMonth' in obj) { // date\n\t\t\t\t\treturn 'Date(' + obj + ')';\n\t\t\t\t} else { // object\n\t\t\t\t\tstr += '{';\n\t\t\t\t\tvar arr = []\n\t\t\t\t\tfor (var k in obj) { \n\t\t\t\t\t\tif(obj.hasOwnProperty(k)) {\n\t\t\t\t\t\t\tif (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');\n\t\t\t\t\t\t\telse arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr += arr.join(', ') + '}';\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\t\t\t\t\n\t\t\t\treturn '\"' + obj + '\"';\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn '' + obj;\n\t}\n\n\tstr_format.format = function(parse_tree, argv) {\n\t\tvar cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n\t\tfor (i = 0; i < tree_length; i++) {\n\t\t\tnode_type = get_type(parse_tree[i]);\n\t\t\tif (node_type === 'string') {\n\t\t\t\toutput.push(parse_tree[i]);\n\t\t\t}\n\t\t\telse if (node_type === 'array') {\n\t\t\t\tmatch = parse_tree[i]; // convenience purposes only\n\t\t\t\tif (match[2]) { // keyword argument\n\t\t\t\t\targ = argv[cursor];\n\t\t\t\t\tfor (k = 0; k < match[2].length; k++) {\n\t\t\t\t\t\tif (!arg.hasOwnProperty(match[2][k])) {\n\t\t\t\t\t\t\tthrow new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg[match[2][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (match[1]) { // positional argument (explicit)\n\t\t\t\t\targ = argv[match[1]];\n\t\t\t\t}\n\t\t\t\telse { // positional argument (implicit)\n\t\t\t\t\targ = argv[cursor++];\n\t\t\t\t}\n\n\t\t\t\tif (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {\n\t\t\t\t\tthrow new Error(sprintf('[sprintf] expecting number but found %s \"' + arg + '\"', get_type(arg)));\n\t\t\t\t}\n\t\t\t\tswitch (match[8]) {\n\t\t\t\t\tcase 'b': arg = arg.toString(2); break;\n\t\t\t\t\tcase 'c': arg = String.fromCharCode(arg); break;\n\t\t\t\t\tcase 'd': arg = parseInt(arg, 10); break;\n\t\t\t\t\tcase 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n\t\t\t\t\tcase 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n\t\t\t\t    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;\n\t\t\t\t\tcase 'o': arg = arg.toString(8); break;\n\t\t\t\t\tcase 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n\t\t\t\t\tcase 'u': arg = Math.abs(arg); break;\n\t\t\t\t\tcase 'x': arg = arg.toString(16); break;\n\t\t\t\t\tcase 'X': arg = arg.toString(16).toUpperCase(); break;\n\t\t\t\t}\n\t\t\t\targ = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n\t\t\t\tpad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n\t\t\t\tpad_length = match[6] - String(arg).length;\n\t\t\t\tpad = match[6] ? str_repeat(pad_character, pad_length) : '';\n\t\t\t\toutput.push(match[5] ? arg + pad : pad + arg);\n\t\t\t}\n\t\t}\n\t\treturn output.join('');\n\t};\n\n\tstr_format.cache = {};\n\n\tstr_format.parse = function(fmt) {\n\t\tvar _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n\t\twhile (_fmt) {\n\t\t\tif ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push(match[0]);\n\t\t\t}\n\t\t\telse if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push('%');\n\t\t\t}\n\t\t\telse if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {\n\t\t\t\tif (match[2]) {\n\t\t\t\t\targ_names |= 1;\n\t\t\t\t\tvar field_list = [], replacement_field = match[2], field_match = [];\n\t\t\t\t\tif ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\twhile ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n\t\t\t\t\t\t\tif ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new Error('[sprintf] ' + replacement_field);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n                        throw new Error('[sprintf] ' + replacement_field);\n\t\t\t\t\t}\n\t\t\t\t\tmatch[2] = field_list;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targ_names |= 2;\n\t\t\t\t}\n\t\t\t\tif (arg_names === 3) {\n\t\t\t\t\tthrow new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');\n\t\t\t\t}\n\t\t\t\tparse_tree.push(match);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('[sprintf] ' + _fmt);\n\t\t\t}\n\t\t\t_fmt = _fmt.substring(match[0].length);\n\t\t}\n\t\treturn parse_tree;\n\t};\n\n\treturn str_format;\n})();\n\nvar vsprintf = function(fmt, argv) {\n\tvar argvClone = argv.slice();\n\targvClone.unshift(fmt);\n\treturn sprintf.apply(null, argvClone);\n};\n\nmodule.exports = sprintf;\nsprintf.sprintf = sprintf;\nsprintf.vsprintf = vsprintf;\n","!function (definition) {\n  if (typeof module == \"object\" && module.exports) module.exports = definition();\n  else if (typeof define == \"function\") define(definition);\n  else this.tz = definition();\n} (function () {\n/*\n  function die () {\n    console.log.apply(console, __slice.call(arguments, 0));\n    return process.exit(1);\n  }\n\n  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }\n*/\n  function actualize (entry, rule, year) {\n    var actualized, date = rule.day[1];\n\n    do {\n      actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));\n    } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0])\n\n    actualized = {\n      clock: rule.clock,\n      sort: actualized.getTime(),\n      rule: rule,\n      save: rule.save * 6e4,\n      offset: entry.offset\n    };\n\n    actualized[actualized.clock] = actualized.sort + rule.time * 6e4;\n\n    if (actualized.posix) {\n      actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);\n    } else {\n      actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);\n    }\n\n    return actualized;\n  }\n\n  function find (request, clock, time) {\n    var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules\n      , j, year = new Date(time).getUTCFullYear(), off = 1;\n    for (i = 1, I = zone.length; i < I; i++) if (zone[i][clock] <= time) break;\n    entry = zone[i];\n    if (entry.rules) {\n      rules = request[entry.rules];\n      for (j = year + 1; j >= year - off; --j)\n        for (i = 0, I = rules.length; i < I; i++)\n          if (rules[i].from <= j && j <= rules[i].to) actualized.push(actualize(entry, rules[i], j));\n          else if (rules[i].to < j && off == 1) off = j - rules[i].to;\n      actualized.sort(function (a, b) { return a.sort - b.sort });\n      for (i = 0, I = actualized.length; i < I; i++) {\n        if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock]) found = actualized[i];\n      }\n    }\n    if (found) {\n      if (abbrev = /^(.*)\\/(.*)$/.exec(entry.format)) {\n        found.abbrev = abbrev[found.save ? 2 : 1];\n      } else {\n        found.abbrev = entry.format.replace(/%s/, found.rule.letter);\n      }\n    }\n    return found || entry;\n  }\n\n  function convertToWallclock (request, posix) {\n    if (request.zone == \"UTC\") return posix;\n    request.entry = find(request, \"posix\", posix);\n    return posix + request.entry.offset + request.entry.save;\n  }\n\n  function convertToPOSIX (request, wallclock) {\n    if (request.zone == \"UTC\") return wallclock;\n\n    var entry, diff;\n    request.entry = entry = find(request, \"wallclock\", wallclock);\n    diff = wallclock - entry.wallclock;\n\n    return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;\n  }\n\n  function adjust (request, posix, match) {\n    var increment = +(match[1] + 1) // conversion necessary for week day addition\n      , offset = match[2] * increment\n      , index = UNITS.indexOf(match[3].toLowerCase())\n      , date\n      ;\n    if (index > 9) {\n      posix += offset * TIME[index - 10];\n    } else {\n      date = new Date(convertToWallclock(request, posix));\n      if (index < 7) {\n        while (offset) {\n          date.setUTCDate(date.getUTCDate() + increment);\n          if (date.getUTCDay() == index) offset -= increment;\n        }\n      } else if (index == 7) {\n        date.setUTCFullYear(date.getUTCFullYear() + offset);\n      } else if (index == 8) {\n        date.setUTCMonth(date.getUTCMonth() + offset);\n      } else {\n        date.setUTCDate(date.getUTCDate() + offset);\n      }\n      if ((posix = convertToPOSIX(request, date.getTime())) == null) {\n        posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;\n      }\n    }\n    return posix;\n  }\n\n  function convert (vargs) {\n    if (!vargs.length) return \"1.0.6\";\n\n    var request = Object.create(this)\n      , adjustments = []\n      , i, I, $, argument, date\n      ;\n\n    for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.\n      argument = vargs[i];\n      // https://twitter.com/bigeasy/status/215112186572439552\n      if (Array.isArray(argument)) {\n        if (!i && !isNaN(argument[1])) {\n          date = argument;\n        } else {\n          argument.splice.apply(vargs, [ i--, 1 ].concat(argument));\n        }\n      } else if (isNaN(argument)) {\n        $ = typeof argument;\n        if ($ == \"string\") {\n          if (~argument.indexOf(\"%\")) {\n            request.format = argument;\n          } else if (!i && argument == \"*\") {\n            date = argument;\n          } else if (!i && ($ = /^(\\d{4})-(\\d{2})-(\\d{2})(?:[T\\s](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d+))?)?(Z|(([+-])(\\d{2}(:\\d{2}){0,2})))?)?$/.exec(argument))) {\n            date = [];\n            date.push.apply(date, $.slice(1, 8));\n            if ($[9]) {\n              date.push($[10] + 1);\n              date.push.apply(date, $[11].split(/:/));\n            } else if ($[8]) {\n              date.push(1);\n            }\n          } else if (/^\\w{2,3}_\\w{2}$/.test(argument)) {\n            request.locale = argument;\n          } else if ($ = UNIT_RE.exec(argument)) {\n            adjustments.push($);\n          } else {\n            request.zone = argument;\n          }\n        } else if ($ == \"function\") {\n          if ($ = argument.call(request)) return $;\n        } else if (/^\\w{2,3}_\\w{2}$/.test(argument.name)) {\n          request[argument.name] = argument;\n        } else if (argument.zones) {\n          for ($ in argument.zones) request[$] = argument.zones[$];\n          for ($ in argument.rules) request[$] = argument.rules[$];\n        }\n      } else if (!i) {\n        date = argument;\n      }\n    }\n\n    if (!request[request.locale]) delete request.locale;\n    if (!request[request.zone]) delete request.zone;\n\n    if (date != null) {\n      if (date == \"*\") {\n        date = request.clock();\n      } else if (Array.isArray(date)) {\n        I = !date[7];\n        for (i = 0; i < 11; i++) date[i] = +(date[i] || 0); // conversion necessary for decrement\n        --date[1]; // Grr..\n        date = Date.UTC.apply(Date.UTC, date.slice(0, 8)) +\n          -date[7] * (date[8] * 36e5 + date[9] * 6e4 + date[10] * 1e3);\n      } else {\n        date = Math.floor(date);\n      }\n      if (!isNaN(date)) {\n        if (I) date = convertToPOSIX(request, date);\n\n        if (date == null) return date;\n\n        for (i = 0, I = adjustments.length; i < I; i++) {\n          date = adjust(request, date, adjustments[i]);\n        }\n\n        if (!request.format) return date;\n\n        $ = new Date(convertToWallclock(request, date));\n        return request.format.replace(/%([-0_^]?)(:{0,3})(\\d*)(.)/g,\n        function (value, flag, colons, padding, specifier) {\n          var f, fill = \"0\", pad;\n          if (f = request[specifier]) {\n            value = String(f.call(request, $, date, flag, colons.length));\n            if ((flag || f.style) == \"_\") fill = \" \";\n            pad = flag == \"-\" ? 0 : f.pad || 0;\n            while (value.length < pad) value = fill + value;\n            pad = flag == \"-\" ? 0 : padding || f.pad;\n            while (value.length < pad) value = fill + value;\n            if (specifier == \"N\" && pad < value.length) value = value.slice(0, pad);\n            if (flag == \"^\") value = value.toUpperCase();\n          }\n          return value;\n        });\n      }\n    }\n\n    return function () { return request.convert(arguments) };\n  }\n\n  var context =\n    { clock: function () { return +(new Date()) }\n    , zone: \"UTC\"\n    , entry: { abbrev: \"UTC\", offset: 0, save: 0 }\n    , UTC: 1\n    , z: function(date, posix, flag, delimiters) {\n        var offset = this.entry.offset + this.entry.save\n          , seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;\n        for (i = 0; i < 3; i++) {\n          parts.push((\"0\" + Math.floor(seconds / part)).slice(-2));\n          seconds %= part;\n          part /= 60;\n        }\n        if (flag == \"^\" && !offset) return \"Z\";\n        if (flag == \"^\") delimiters = 3;\n        if (delimiters == 3) {\n          z = parts.join(\":\");\n          z = z.replace(/:00$/, \"\");\n          if (flag != \"^\") z = z.replace(/:00$/, \"\");\n        } else if (delimiters) {\n          z = parts.slice(0, delimiters + 1).join(\":\");\n          if (flag == \"^\") z = z.replace(/:00$/, \"\");\n        } else {\n          z = parts.slice(0, 2).join(\"\");\n        }\n        z = (offset < 0 ? \"-\" : \"+\") + z;\n        z = z.replace(/([-+])(0)/, { \"_\": \" $1\", \"-\": \"$1\" }[flag] || \"$1$2\");\n        return z;\n      }\n    , \"%\": function(date) { return \"%\" }\n    , n: function (date) { return \"\\n\" }\n    , t: function (date) { return \"\\t\" }\n    , U: function (date) { return weekOfYear(date, 0) }\n    , W: function (date) { return weekOfYear(date, 1) }\n    , V: function (date) { return isoWeek(date)[0] }\n    , G: function (date) { return isoWeek(date)[1] }\n    , g: function (date) { return isoWeek(date)[1] % 100 }\n    , j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1 }\n    , s: function (date) { return Math.floor(date.getTime() / 1000) }\n    , C: function (date) { return Math.floor(date.getUTCFullYear() / 100) }\n    , N: function (date) { return date.getTime() % 1000 * 1000000 }\n    , m: function (date) { return date.getUTCMonth() + 1 }\n    , Y: function (date) { return date.getUTCFullYear() }\n    , y: function (date) { return date.getUTCFullYear() % 100 }\n    , H: function (date) { return date.getUTCHours() }\n    , M: function (date) { return date.getUTCMinutes() }\n    , S: function (date) { return date.getUTCSeconds() }\n    , e: function (date) { return date.getUTCDate() }\n    , d: function (date) { return date.getUTCDate() }\n    , u: function (date) { return date.getUTCDay() || 7 }\n    , w: function (date) { return date.getUTCDay() }\n    , l: function (date) { return date.getUTCHours() % 12 || 12 }\n    , I: function (date) { return date.getUTCHours() % 12 || 12 }\n    , k: function (date) { return date.getUTCHours() }\n    , Z: function (date) { return this.entry.abbrev }\n    , a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()] }\n    , A: function (date) { return this[this.locale].day.full[date.getUTCDay()] }\n    , h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }\n    , b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }\n    , B: function (date) { return this[this.locale].month.full[date.getUTCMonth()] }\n    , P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase() }\n    , p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)] }\n    , R: function (date, posix) { return this.convert([ posix, \"%H:%M\" ]) }\n    , T: function (date, posix) { return this.convert([ posix, \"%H:%M:%S\" ]) }\n    , D: function (date, posix) { return this.convert([ posix, \"%m/%d/%y\" ]) }\n    , F: function (date, posix) { return this.convert([ posix, \"%Y-%m-%d\" ]) }\n    , x: function (date, posix) { return this.convert([ posix, this[this.locale].date ]) }\n    , r: function (date, posix) { return this.convert([ posix, this[this.locale].time12 || '%I:%M:%S' ]) }\n    , X: function (date, posix) { return this.convert([ posix, this[this.locale].time24 ]) }\n    , c: function (date, posix) { return this.convert([ posix, this[this.locale].dateTime ]) }\n    , convert: convert\n    , locale: \"en_US\"\n    , en_US: {\n        date: \"%m/%d/%Y\",\n        time24: \"%I:%M:%S %p\",\n        time12: \"%I:%M:%S %p\",\n        dateTime: \"%a %d %b %Y %I:%M:%S %p %Z\",\n        meridiem: [ \"AM\", \"PM\" ],\n        month: {\n          abbrev: \"Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec\".split(\"|\"),\n          full: \"January|February|March|April|May|June|July|August|September|October|November|December\".split(\"|\")\n        },\n        day: {\n          abbrev: \"Sun|Mon|Tue|Wed|Thu|Fri|Sat\".split(\"|\"),\n          full: \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday\".split(\"|\")\n        }\n      }\n    };\n  var UNITS = \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond\"\n    , UNIT_RE = new RegExp(\"^\\\\s*([+-])(\\\\d+)\\\\s+(\" + UNITS + \")s?\\\\s*$\", \"i\")\n    , TIME = [ 36e5, 6e4, 1e3, 1 ]\n    ;\n  UNITS = UNITS.toLowerCase().split(\"|\");\n\n  \"delmHMSUWVgCIky\".replace(/./g, function (e) { context[e].pad = 2 });\n\n  context.N.pad = 9;\n  context.j.pad = 3;\n\n  context.k.style = \"_\";\n  context.l.style = \"_\";\n  context.e.style = \"_\";\n\n  function weekOfYear (date, startOfWeek) {\n    var diff, nyd, weekStart;\n    nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));\n    diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);\n    if (nyd.getUTCDay() == startOfWeek) {\n      weekStart = 0;\n    } else {\n      weekStart = 7 - nyd.getUTCDay() + startOfWeek;\n      if (weekStart == 8) {\n        weekStart = 1;\n      }\n    }\n    return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;\n  }\n\n  function isoWeek (date) {\n    var nyd, nyy, week;\n    nyy = date.getUTCFullYear();\n    nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n    week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);\n    if (!week) {\n      nyy = date.getUTCFullYear() - 1;\n      nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n      week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;\n      return [week, date.getUTCFullYear() - 1];\n    } else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {\n      return [1, date.getUTCFullYear() + 1];\n    } else {\n      return [week, date.getUTCFullYear()];\n    }\n  }\n\n  return function () { return context.convert(arguments) };\n});\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi93b3JrL2Jva2VoL2Jva2VoanMvc3JjL2pzL3ByZWx1ZGUuanMiLCJidWlsZC9qcy90cmVlL2Jhc2UuanMiLCJidWlsZC9qcy90cmVlL2NsaWVudC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9iYWNrYm9uZS5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9ib2tlaF9ldmVudHMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvYm9rZWhfdmlldy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9idWlsZF92aWV3cy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9kb20uanMiLCJidWlsZC9qcy90cmVlL2NvcmUvZW51bXMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvZXZlbnRzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2hhc19wcm9wcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9oaXR0ZXN0LmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2xheW91dC9sYXlvdXRfY2FudmFzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2xheW91dC9zaWRlX3BhbmVsLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL2xheW91dC9zb2x2ZXIuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvbG9nZ2luZy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9wcm9wZXJ0aWVzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3Byb3BlcnR5X21peGlucy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9zZWxlY3Rpb25fbWFuYWdlci5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS9zZWxlY3Rvci5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91aV9ldmVudHMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9hcnJheS5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL2Jib3guanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9jYWxsYmFjay5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL2NhbnZhcy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL2NvbG9yLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvZGF0YV9zdHJ1Y3R1cmVzLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvZXEuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9tYXRoLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvb2JqZWN0LmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvcHJvajQuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9wcm9qZWN0aW9ucy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3JlZnMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9zZWxlY3Rpb24uanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC9zZXJpYWxpemF0aW9uLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvc3BhdGlhbC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3N0cmluZy5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3N2Z19jb2xvcnMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC90ZW1wbGF0aW5nLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvdGV4dC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3Rocm90dGxlLmpzIiwiYnVpbGQvanMvdHJlZS9jb3JlL3V0aWwvdHlwZXMuanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdXRpbC93aGVlbC5qcyIsImJ1aWxkL2pzL3RyZWUvY29yZS91dGlsL3pvb20uanMiLCJidWlsZC9qcy90cmVlL2NvcmUvdmlzdWFscy5qcyIsImJ1aWxkL2pzL3RyZWUvZG9jdW1lbnQuanMiLCJidWlsZC9qcy90cmVlL2VtYmVkLmpzIiwiYnVpbGQvanMvdHJlZS9tYWluLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2Fubm90YXRpb24uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9hcnJvdy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2Fycm93X2hlYWQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9ib3hfYW5ub3RhdGlvbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2NvbG9yX2Jhci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYW5ub3RhdGlvbnMvbGFiZWwuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9sYWJlbF9zZXQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9sZWdlbmQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy9sZWdlbmRfaXRlbS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3BvbHlfYW5ub3RhdGlvbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3NwYW4uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy90ZXh0X2Fubm90YXRpb24uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9hbm5vdGF0aW9ucy90aXRsZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Fubm90YXRpb25zL3Rvb2x0aXAuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2F4aXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2NhdGVnb3JpY2FsX2F4aXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2NvbnRpbnVvdXNfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2F4ZXMvZGF0ZXRpbWVfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2F4ZXMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9heGVzL2xpbmVhcl9heGlzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvYXhlcy9sb2dfYXhpcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9jdXN0b21qcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbGxiYWNrcy9vcGVuX3VybC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbnZhcy9jYW52YXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9jYW52YXMvY2FudmFzX3RlbXBsYXRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvY2FudmFzL2NhcnRlc2lhbl9mcmFtZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2NhbnZhcy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvYmFzaWNfdGlja19mb3JtYXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9mb3JtYXR0ZXJzL2NhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZm9ybWF0dGVycy9kYXRldGltZV90aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvZnVuY190aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9mb3JtYXR0ZXJzL2xvZ190aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvbWVyY2F0b3JfdGlja19mb3JtYXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9mb3JtYXR0ZXJzL251bWVyYWxfdGlja19mb3JtYXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9mb3JtYXR0ZXJzL3ByaW50Zl90aWNrX2Zvcm1hdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2Zvcm1hdHRlcnMvdGlja19mb3JtYXR0ZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvYW5udWxhcl93ZWRnZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9hbm51bHVzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2FyYy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9iZXppZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvY2lyY2xlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2VsbGlwc2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvZ2x5cGguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvaGJhci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9pbWFnZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9pbWFnZV9yZ2JhLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL2ltYWdlX3VybC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9saW5lLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL211bHRpX2xpbmUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvb3ZhbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9wYXRjaC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9wYXRjaGVzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3F1YWQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvcXVhZHJhdGljLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3JheS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy9yZWN0LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3NlZ21lbnQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvdGV4dC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy92YmFyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3dlZGdlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3h5X2dseXBoLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ3JpZHMvZ3JpZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dyaWRzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9sYXlvdXRzL2JveC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2xheW91dHMvY29sdW1uLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbGF5b3V0cy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2xheW91dHMvbGF5b3V0X2RvbS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2xheW91dHMvcm93LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbGF5b3V0cy9zcGFjZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9sYXlvdXRzL3dpZGdldF9ib3guanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9tYXBwZXJzL2NhdGVnb3JpY2FsX2NvbG9yX21hcHBlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvY2F0ZWdvcmljYWxfbWFwcGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFwcGVycy9jb2xvcl9tYXBwZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9tYXBwZXJzL2dyaWRfbWFwcGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvbWFwcGVycy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvbGluZWFyX2NvbG9yX21hcHBlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvbGluZWFyX21hcHBlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvbG9nX2NvbG9yX21hcHBlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcHBlcnMvbG9nX21hcHBlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL21hcmtlcnMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9tYXJrZXJzL21hcmtlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Bsb3RzL2dtYXBfcGxvdC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Bsb3RzL2dtYXBfcGxvdF9jYW52YXMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9wbG90cy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Bsb3RzL3Bsb3QuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9wbG90cy9wbG90X2NhbnZhcy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Jhbmdlcy9kYXRhX3JhbmdlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvcmFuZ2VzL2RhdGFfcmFuZ2UxZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Jhbmdlcy9mYWN0b3JfcmFuZ2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9yYW5nZXMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9yYW5nZXMvcmFuZ2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9yYW5nZXMvcmFuZ2UxZC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3JlbmRlcmVycy9nbHlwaF9yZW5kZXJlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3JlbmRlcmVycy9ndWlkZV9yZW5kZXJlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3JlbmRlcmVycy9pbmRleC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3JlbmRlcmVycy9yZW5kZXJlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NvdXJjZXMvYWpheF9kYXRhX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NvdXJjZXMvY29sdW1uX2RhdGFfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc291cmNlcy9jb2x1bW5hcl9kYXRhX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3NvdXJjZXMvZGF0YV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zb3VyY2VzL2dlb2pzb25fZGF0YV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9zb3VyY2VzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvc291cmNlcy9yZW1vdGVfZGF0YV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2FkYXB0aXZlX3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvYmFzaWNfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9jYXRlZ29yaWNhbF90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2NvbXBvc2l0ZV90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2NvbnRpbnVvdXNfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9kYXRldGltZV90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2RheXNfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9maXhlZF90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9sb2dfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlja2Vycy9tZXJjYXRvcl90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL21vbnRoc190aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL3NpbmdsZV9pbnRlcnZhbF90aWNrZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWNrZXJzL3RpY2tlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMvdXRpbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpY2tlcnMveWVhcnNfdGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvYmJveF90aWxlX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL2R5bmFtaWNfaW1hZ2VfcmVuZGVyZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy9pbWFnZV9wb29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvaW1hZ2Vfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvaW5kZXguanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy9tZXJjYXRvcl90aWxlX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RpbGVzL3F1YWRrZXlfdGlsZV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy90aWxlX3JlbmRlcmVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvdGlsZV9zb3VyY2UuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90aWxlcy90aWxlX3V0aWxzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvdG1zX3RpbGVfc291cmNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdGlsZXMvd210c190aWxlX3NvdXJjZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvYWN0aW9uX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9hY3Rpb25zL2hlbHBfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvcmVkb190b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYWN0aW9ucy9yZXNldF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYWN0aW9ucy9zYXZlX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9hY3Rpb25zL3VuZG9fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2FjdGlvbnMvem9vbV9pbl90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYWN0aW9ucy96b29tX291dF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvYnV0dG9uX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9ib3hfc2VsZWN0X3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9ib3hfem9vbV90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvZ2VzdHVyZV90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvbGFzc29fc2VsZWN0X3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9wYW5fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL3BvbHlfc2VsZWN0X3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy9yZXNpemVfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL3NlbGVjdF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvZ2VzdHVyZXMvdGFwX3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy9nZXN0dXJlcy93aGVlbF9wYW5fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2dlc3R1cmVzL3doZWVsX3pvb21fdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvaW5zcGVjdG9ycy9jcm9zc2hhaXJfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2luc3BlY3RvcnMvaG92ZXJfdG9vbC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL2luc3BlY3RvcnMvaW5zcGVjdF90b29sLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvb25fb2ZmX2J1dHRvbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL3Rvb2wuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy90b29sX2V2ZW50cy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3Rvb2xzL3Rvb2xfcHJveHkuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy90b29sYmFyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvdG9vbGJhcl9iYXNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdG9vbHMvdG9vbGJhcl9ib3guanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90b29scy90b29sYmFyX3RlbXBsYXRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdHJhbnNmb3Jtcy9jdXN0b21qc190cmFuc2Zvcm0uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90cmFuc2Zvcm1zL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvdHJhbnNmb3Jtcy9pbnRlcnBvbGF0b3IuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90cmFuc2Zvcm1zL2ppdHRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RyYW5zZm9ybXMvbGluZWFyX2ludGVycG9sYXRvci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3RyYW5zZm9ybXMvc3RlcF9pbnRlcnBvbGF0b3IuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy90cmFuc2Zvcm1zL3RyYW5zZm9ybS5qcyIsImJ1aWxkL2pzL3RyZWUvc2FmZWx5LmpzIiwiYnVpbGQvanMvdHJlZS92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwibm9kZV9tb2R1bGVzL2tpd2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbnVtYnJvL251bWJyby5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL1Byb2ouanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2FkanVzdF9heGlzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xvbi5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL21zZm56LmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGhpMnouanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9zaWduLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdG9Qb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3RzZm56LmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvRGF0dW0uanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9FbGxpcHNvaWQuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvdW5pdHMuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2RhdHVtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2RlZnMuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL2Rlcml2ZUNvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvZXh0ZW5kLmpzIiwibm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3BhcnNlQ29kZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvalN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2xvbmdsYXQuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL21lcmMuanMiLCJub2RlX21vZHVsZXMvcHJvajQvbGliL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9qNC9saWIvd2t0LmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwcmludGYvbGliL3NwcmludGYuanMiLCJub2RlX21vZHVsZXMvdGltZXpvbmUvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMytCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25sRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBvdXRlcihtb2R1bGVzLCBjYWNoZSwgZW50cnkpIHtcbiAgICBmdW5jdGlvbiBuZXdSZXF1aXJlKG5hbWUpIHtcbiAgICAgICAgaWYgKCFjYWNoZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbW9kdWxlIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSBjYWNoZVtuYW1lXSA9IHtleHBvcnRzOiB7fX07XG5cbiAgICAgICAgICAgIHZhciBtb2R1bGVSZXF1aXJlID0gZnVuY3Rpb24gZm9vKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBtb2R1bGVzW25hbWVdWzFdW3hdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdSZXF1aXJlKGlkID8gaWQgOiB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZVJlcXVpcmUubW9kdWxlcyA9IG5ld1JlcXVpcmUubW9kdWxlcztcblxuICAgICAgICAgICAgbW9kdWxlc1tuYW1lXVswXS5jYWxsKG0uZXhwb3J0cywgbW9kdWxlUmVxdWlyZSwgbSwgbS5leHBvcnRzLCBvdXRlciwgbW9kdWxlcywgY2FjaGUsIGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZVtuYW1lXS5leHBvcnRzO1xuICAgIH1cblxuICAgIG5ld1JlcXVpcmUubW9kdWxlcyA9IG1vZHVsZXM7XG5cbiAgICB2YXIgbWFpbiA9IG5ld1JlcXVpcmUoZW50cnlbMF0pO1xuICAgIG1haW4ucmVxdWlyZSA9IG5ld1JlcXVpcmU7XG4gICAgcmV0dXJuIG1haW47XG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2FsbF9tb2RlbHMsIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbHMgPSByZXF1aXJlKFwiLi9tb2RlbHMvaW5kZXhcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5vdmVycmlkZXMgPSB7fTtcbl9hbGxfbW9kZWxzID0gb2JqZWN0XzEuY2xvbmUobW9kZWxzKTtcbmV4cG9ydHMuTW9kZWxzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbW9kZWwsIHJlZjtcbiAgICBtb2RlbCA9IChyZWYgPSBleHBvcnRzLm92ZXJyaWRlc1tuYW1lXSkgIT0gbnVsbCA/IHJlZiA6IF9hbGxfbW9kZWxzW25hbWVdO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGBcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3QuIFRoaXMgY291bGQgYmUgZHVlIHRvIGEgd2lkZ2V0IG9yIGEgY3VzdG9tIG1vZGVsIG5vdCBiZWluZyByZWdpc3RlcmVkIGJlZm9yZSBmaXJzdCB1c2FnZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn07XG5leHBvcnRzLk1vZGVscy5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCBtb2RlbCkge1xuICAgIHJldHVybiBleHBvcnRzLm92ZXJyaWRlc1tuYW1lXSA9IG1vZGVsO1xufTtcbmV4cG9ydHMuTW9kZWxzLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBkZWxldGUgZXhwb3J0cy5vdmVycmlkZXNbbmFtZV07XG59O1xuZXhwb3J0cy5Nb2RlbHMucmVnaXN0ZXJfbW9kZWxzID0gZnVuY3Rpb24gKG1vZGVscywgZm9yY2UsIGVycm9yRm4pIHtcbiAgICB2YXIgbW9kZWwsIG5hbWUsIHJlc3VsdHM7XG4gICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVycm9yRm4gPT0gbnVsbCkge1xuICAgICAgICBlcnJvckZuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vZGVscyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobmFtZSBpbiBtb2RlbHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobW9kZWxzLCBuYW1lKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFfYWxsX21vZGVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF9hbGxfbW9kZWxzW25hbWVdID0gbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHR5cGVvZiBlcnJvckZuID09PSBcImZ1bmN0aW9uXCIgPyBlcnJvckZuKG5hbWUpIDogdm9pZCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5leHBvcnRzLk1vZGVscy5yZWdpc3RlcmVkX25hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhfYWxsX21vZGVscyk7XG59O1xuZXhwb3J0cy5pbmRleCA9IHt9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xpZW50Q29ubmVjdGlvbiwgQ2xpZW50U2Vzc2lvbiwgTWVzc2FnZSwgbWVzc2FnZV9oYW5kbGVycztcbnZhciBlczZfcHJvbWlzZV8xID0gcmVxdWlyZShcImVzNi1wcm9taXNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nZ2luZ1wiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9zdHJpbmdcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIGRvY3VtZW50XzEgPSByZXF1aXJlKFwiLi9kb2N1bWVudFwiKTtcbmV4cG9ydHMuREVGQVVMVF9TRVJWRVJfV0VCU09DS0VUX1VSTCA9IFwid3M6Ly9sb2NhbGhvc3Q6NTAwNi93c1wiO1xuZXhwb3J0cy5ERUZBVUxUX1NFU1NJT05fSUQgPSBcImRlZmF1bHRcIjtcbk1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2UoaGVhZGVyMSwgbWV0YWRhdGExLCBjb250ZW50MSkge1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjE7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTE7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQxO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG4gICAgTWVzc2FnZS5hc3NlbWJsZSA9IGZ1bmN0aW9uIChoZWFkZXJfanNvbiwgbWV0YWRhdGFfanNvbiwgY29udGVudF9qc29uKSB7XG4gICAgICAgIHZhciBjb250ZW50LCBlLCBoZWFkZXIsIG1ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGVhZGVyID0gSlNPTi5wYXJzZShoZWFkZXJfanNvbik7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGFfanNvbik7XG4gICAgICAgICAgICBjb250ZW50ID0gSlNPTi5wYXJzZShjb250ZW50X2pzb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGhlYWRlciwgbWV0YWRhdGEsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgIGUgPSBlcnJvcjE7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiRmFpbHVyZSBwYXJzaW5nIGpzb24gXCIgKyBlICsgXCIgXCIgKyBoZWFkZXJfanNvbiArIFwiIFwiICsgbWV0YWRhdGFfanNvbiArIFwiIFwiICsgY29udGVudF9qc29uLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2UuY3JlYXRlX2hlYWRlciA9IGZ1bmN0aW9uIChtc2d0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICAgICdtc2dpZCc6IHN0cmluZ18xLnVuaXF1ZUlkKCksXG4gICAgICAgICAgICAnbXNndHlwZSc6IG1zZ3R5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLmV4dGVuZChoZWFkZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgTWVzc2FnZS5jcmVhdGUgPSBmdW5jdGlvbiAobXNndHlwZSwgaGVhZGVyX29wdGlvbnMsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGVudCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlciA9IE1lc3NhZ2UuY3JlYXRlX2hlYWRlcihtc2d0eXBlLCBoZWFkZXJfb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShoZWFkZXIsIHt9LCBjb250ZW50KTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciBjb250ZW50X2pzb24sIGUsIGhlYWRlcl9qc29uLCBtZXRhZGF0YV9qc29uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGVhZGVyX2pzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcik7XG4gICAgICAgICAgICBtZXRhZGF0YV9qc29uID0gSlNPTi5zdHJpbmdpZnkodGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICBjb250ZW50X2pzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoaGVhZGVyX2pzb24pO1xuICAgICAgICAgICAgc29ja2V0LnNlbmQobWV0YWRhdGFfanNvbik7XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0LnNlbmQoY29udGVudF9qc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICBlID0gZXJyb3IxO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkVycm9yIHNlbmRpbmcgXCIsIHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgodGhpcy5oZWFkZXIgIT0gbnVsbCkgJiYgKHRoaXMubWV0YWRhdGEgIT0gbnVsbCkgJiYgKHRoaXMuY29udGVudCAhPSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKCdudW1fYnVmZmVycycgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5oZWFkZXJbJ251bV9idWZmZXJzJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUuYWRkX2J1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5faGVhZGVyX2ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5tc2dpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcl9maWVsZCgnbXNnaWQnKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLm1zZ3R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJfZmllbGQoJ21zZ3R5cGUnKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnNlc3NpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcl9maWVsZCgnc2Vzc2lkJyk7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5yZXFpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcl9maWVsZCgncmVxaWQnKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnByb2JsZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKCdtc2dpZCcgaW4gdGhpcy5oZWFkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJObyBtc2dpZCBpbiBoZWFkZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKCdtc2d0eXBlJyBpbiB0aGlzLmhlYWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIG1zZ3R5cGUgaW4gaGVhZGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KSgpO1xubWVzc2FnZV9oYW5kbGVycyA9IHtcbiAgICAnUEFUQ0gtRE9DJzogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX2Zvcl9zZXNzaW9uKGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5faGFuZGxlX3BhdGNoKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgICdPSyc6IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiVW5oYW5kbGVkIE9LIHJlcGx5IHRvIFwiICsgKG1lc3NhZ2UucmVxaWQoKSkpO1xuICAgIH0sXG4gICAgJ0VSUk9SJzogZnVuY3Rpb24gKGNvbm5lY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJVbmhhbmRsZWQgRVJST1IgcmVwbHkgdG8gXCIgKyAobWVzc2FnZS5yZXFpZCgpKSArIFwiOiBcIiArIG1lc3NhZ2UuY29udGVudFsndGV4dCddKTtcbiAgICB9XG59O1xuQ2xpZW50Q29ubmVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5fY29ubmVjdGlvbl9jb3VudCA9IDA7XG4gICAgZnVuY3Rpb24gQ2xpZW50Q29ubmVjdGlvbih1cmwxLCBpZCwgYXJnc19zdHJpbmcxLCBfb25faGF2ZV9zZXNzaW9uX2hvb2ssIF9vbl9jbG9zZWRfcGVybWFuZW50bHlfaG9vaykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5hcmdzX3N0cmluZyA9IGFyZ3Nfc3RyaW5nMTtcbiAgICAgICAgdGhpcy5fb25faGF2ZV9zZXNzaW9uX2hvb2sgPSBfb25faGF2ZV9zZXNzaW9uX2hvb2s7XG4gICAgICAgIHRoaXMuX29uX2Nsb3NlZF9wZXJtYW5lbnRseV9ob29rID0gX29uX2Nsb3NlZF9wZXJtYW5lbnRseV9ob29rO1xuICAgICAgICB0aGlzLl9udW1iZXIgPSBDbGllbnRDb25uZWN0aW9uLl9jb25uZWN0aW9uX2NvdW50O1xuICAgICAgICBDbGllbnRDb25uZWN0aW9uLl9jb25uZWN0aW9uX2NvdW50ID0gdGhpcy5fbnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMudXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gZXhwb3J0cy5ERUZBVUxUX1NFUlZFUl9XRUJTT0NLRVRfVVJMO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBleHBvcnRzLkRFRkFVTFRfU0VTU0lPTl9JRDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgd2Vic29ja2V0IFwiICsgdGhpcy5fbnVtYmVyICsgXCIgdG8gJ1wiICsgdGhpcy51cmwgKyBcIicgc2Vzc2lvbiAnXCIgKyB0aGlzLmlkICsgXCInXCIpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xvc2VkX3Blcm1hbmVudGx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudF9oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ19hY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9wZW5kaW5nX3JlcGxpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICB9XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX2Zvcl9zZXNzaW9uID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGYodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycm9yLCByZWYsIHZlcnNpb25lZF91cmw7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZF9wZXJtYW5lbnRseSkge1xuICAgICAgICAgICAgcmV0dXJuIGVzNl9wcm9taXNlXzEuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQ2Fubm90IGNvbm5lY3QoKSBhIGNsb3NlZCBDbGllbnRDb25uZWN0aW9uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVzNl9wcm9taXNlXzEuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQWxyZWFkeSBjb25uZWN0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ19yZXBsaWVzID0ge307XG4gICAgICAgIHRoaXMuX2N1cnJlbnRfaGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2ZXJzaW9uZWRfdXJsID0gdGhpcy51cmwgKyBcIj9ib2tlaC1wcm90b2NvbC12ZXJzaW9uPTEuMCZib2tlaC1zZXNzaW9uLWlkPVwiICsgdGhpcy5pZDtcbiAgICAgICAgICAgIGlmICgoKHJlZiA9IHRoaXMuYXJnc19zdHJpbmcpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSA+IDApIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRfdXJsICs9IFwiJlwiICsgdGhpcy5hcmdzX3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aW5kb3cuTW96V2ViU29ja2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBNb3pXZWJTb2NrZXQodmVyc2lvbmVkX3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodmVyc2lvbmVkX3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGVzNl9wcm9taXNlXzEuUHJvbWlzZSgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0LmJpbmFyeXR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX29uX29wZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vbl9tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb25fY2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX29uX2Vycm9yKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yMTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJ3ZWJzb2NrZXQgY3JlYXRpb24gZmFpbGVkIHRvIHVybDogXCIgKyB0aGlzLnVybCk7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiIC0gXCIgKyBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZXM2X3Byb21pc2VfMS5Qcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkX3Blcm1hbmVudGx5KSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGVybWFuZW50bHkgY2xvc2luZyB3ZWJzb2NrZXQgY29ubmVjdGlvbiBcIiArIHRoaXMuX251bWJlcik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZF9wZXJtYW5lbnRseSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKDEwMDAsIFwiY2xvc2UgbWV0aG9kIGNhbGxlZCBvbiBDbGllbnRDb25uZWN0aW9uIFwiICsgdGhpcy5fbnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Zvcl9zZXNzaW9uKGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uX2Nvbm5lY3Rpb25fY2xvc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbl9jbG9zZWRfcGVybWFuZW50bHlfaG9vayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25fY2xvc2VkX3Blcm1hbmVudGx5X2hvb2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25fY2xvc2VkX3Blcm1hbmVudGx5X2hvb2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fc2NoZWR1bGVfcmVjb25uZWN0ID0gZnVuY3Rpb24gKG1pbGxpc2Vjb25kcykge1xuICAgICAgICB2YXIgcmV0cnk7XG4gICAgICAgIHJldHJ5ID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSB8fCBfdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuaW5mbyhcIldlYnNvY2tldCBjb25uZWN0aW9uIFwiICsgX3RoaXMuX251bWJlciArIFwiIGRpc2Nvbm5lY3RlZCwgd2lsbCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJBdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB3ZWJzb2NrZXQgXCIgKyBfdGhpcy5fbnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmV0cnksIG1pbGxpc2Vjb25kcyk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29ubmVjdGVkIHNvIGNhbm5vdCBzZW5kIFwiICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5zZW5kKHRoaXMuc29ja2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICBlID0gZXJyb3IxO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJFcnJvciBzZW5kaW5nIG1lc3NhZ2UgXCIsIGUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBtZXNzYWdlID0gTWVzc2FnZS5jcmVhdGUoJ0VWRU5UJywge30sIEpTT04uc3RyaW5naWZ5KGV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQobWVzc2FnZSk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kX3dpdGhfcmVwbHkgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBlczZfcHJvbWlzZV8xLlByb21pc2UoKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGVuZGluZ19yZXBsaWVzW21lc3NhZ2UubXNnaWQoKV0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubXNndHlwZSgpID09PSAnRVJST1InKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmVwbHkgXCIgKyBtZXNzYWdlLmNvbnRlbnRbJ3RleHQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fcHVsbF9kb2NfanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UsIHByb21pc2U7XG4gICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlLmNyZWF0ZSgnUFVMTC1ET0MtUkVRJywge30pO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5zZW5kX3dpdGhfcmVwbHkobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcGx5KSB7XG4gICAgICAgICAgICBpZiAoISgnZG9jJyBpbiByZXBseS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vICdkb2MnIGZpZWxkIGluIFBVTEwtRE9DLVJFUExZXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGx5LmNvbnRlbnRbJ2RvYyddO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9yZXB1bGxfc2Vzc2lvbl9kb2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJQdWxsaW5nIHNlc3Npb24gZm9yIGZpcnN0IHRpbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUmVwdWxsaW5nIHNlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1bGxfZG9jX2pzb24oKS50aGVuKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZG9jX2pzb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnQsIHBhdGNoLCBwYXRjaF9tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiR290IG5ldyBkb2N1bWVudCBhZnRlciBjb25uZWN0aW9uIHdhcyBhbHJlYWR5IGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gZG9jdW1lbnRfMS5Eb2N1bWVudC5mcm9tX2pzb24oZG9jX2pzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBkb2N1bWVudF8xLkRvY3VtZW50Ll9jb21wdXRlX3BhdGNoX3NpbmNlX2pzb24oZG9jX2pzb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaC5ldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJTZW5kaW5nIFwiICsgcGF0Y2guZXZlbnRzLmxlbmd0aCArIFwiIGNoYW5nZXMgZnJvbSBtb2RlbCBjb25zdHJ1Y3Rpb24gYmFjayB0byBzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hfbWVzc2FnZSA9IE1lc3NhZ2UuY3JlYXRlKCdQQVRDSC1ET0MnLCB7fSwgcGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmQocGF0Y2hfbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXNzaW9uID0gbmV3IENsaWVudFNlc3Npb24oX3RoaXMsIGRvY3VtZW50LCBfdGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiQ3JlYXRlZCBhIG5ldyBzZXNzaW9uIGZyb20gbmV3IHB1bGxlZCBkb2NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29uX2hhdmVfc2Vzc2lvbl9ob29rICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25faGF2ZV9zZXNzaW9uX2hvb2soX3RoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vbl9oYXZlX3Nlc3Npb25faG9vayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb24uZG9jdW1lbnQucmVwbGFjZV93aXRoX2pzb24oZG9jX2pzb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0ZWQgZXhpc3Rpbmcgc2Vzc2lvbiB3aXRoIG5ldyBwdWxsZWQgZG9jXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcmVwdWxsIHNlc3Npb24gXCIgKyBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX29uX29wZW4gPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuaW5mbyhcIldlYnNvY2tldCBjb25uZWN0aW9uIFwiICsgdGhpcy5fbnVtYmVyICsgXCIgaXMgbm93IG9wZW5cIik7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdfYWNrID0gW3Jlc29sdmUsIHJlamVjdF07XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50X2hhbmRsZXIgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F3YWl0aW5nX2Fja19oYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fb25fbWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbl9tZXNzYWdlX3VuY2hlY2tlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgZSA9IGVycm9yMTtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgbWVzc2FnZTogXCIgKyBlICsgXCIsIFwiICsgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0aW9uLnByb3RvdHlwZS5fb25fbWVzc2FnZV91bmNoZWNrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG1zZywgcHJvYmxlbTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRfaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiZ290IGEgbWVzc2FnZSBidXQgaGF2ZW4ndCBzZXQgX2N1cnJlbnRfaGFuZGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3BhcnRpYWwgIT0gbnVsbCkgJiYgIXRoaXMuX3BhcnRpYWwuY29tcGxldGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpYWwuYWRkX2J1ZmZlcihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlX2JhZF9wcm90b2NvbChcIkdvdCBiaW5hcnkgZnJvbSB3ZWJzb2NrZXQgYnV0IHdlIHdlcmUgZXhwZWN0aW5nIHRleHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGFydGlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZV9iYWRfcHJvdG9jb2woXCJHb3QgdGV4dCBmcm9tIHdlYnNvY2tldCBidXQgd2Ugd2VyZSBleHBlY3RpbmcgYmluYXJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnJhZ21lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpYWwgPSBNZXNzYWdlLmFzc2VtYmxlKHRoaXMuX2ZyYWdtZW50c1swXSwgdGhpcy5fZnJhZ21lbnRzWzFdLCB0aGlzLl9mcmFnbWVudHNbMl0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHByb2JsZW0gPSB0aGlzLl9wYXJ0aWFsLnByb2JsZW0oKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvYmxlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZV9iYWRfcHJvdG9jb2wocHJvYmxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fcGFydGlhbCAhPSBudWxsKSAmJiB0aGlzLl9wYXJ0aWFsLmNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIG1zZyA9IHRoaXMuX3BhcnRpYWw7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50X2hhbmRsZXIobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX29uX2Nsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb3BfcGVuZGluZywgcHJvbWlzZV9mdW5jcztcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiTG9zdCB3ZWJzb2NrZXQgXCIgKyB0aGlzLl9udW1iZXIgKyBcIiBjb25uZWN0aW9uLCBcIiArIGV2ZW50LmNvZGUgKyBcIiAoXCIgKyBldmVudC5yZWFzb24gKyBcIilcIik7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdfYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdfYWNrWzFdKG5ldyBFcnJvcihcIkxvc3Qgd2Vic29ja2V0IGNvbm5lY3Rpb24sIFwiICsgZXZlbnQuY29kZSArIFwiIChcIiArIGV2ZW50LnJlYXNvbiArIFwiKVwiKSk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nX2FjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcG9wX3BlbmRpbmcgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlX2Z1bmNzLCByZWYsIHJlcWlkO1xuICAgICAgICAgICAgICAgIHJlZiA9IF90aGlzLl9wZW5kaW5nX3JlcGxpZXM7XG4gICAgICAgICAgICAgICAgZm9yIChyZXFpZCBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV9mdW5jcyA9IHJlZltyZXFpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fcGVuZGluZ19yZXBsaWVzW3JlcWlkXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfZnVuY3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIHByb21pc2VfZnVuY3MgPSBwb3BfcGVuZGluZygpO1xuICAgICAgICB3aGlsZSAocHJvbWlzZV9mdW5jcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZV9mdW5jc1sxXShcIkRpc2Nvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIHByb21pc2VfZnVuY3MgPSBwb3BfcGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWRfcGVybWFuZW50bHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZV9yZWNvbm5lY3QoMjAwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbl9lcnJvciA9IGZ1bmN0aW9uIChyZWplY3QpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIldlYnNvY2tldCBlcnJvciBvbiBzb2NrZXQgIFwiICsgdGhpcy5fbnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJDb3VsZCBub3Qgb3BlbiB3ZWJzb2NrZXRcIikpO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlX2JhZF9wcm90b2NvbCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkNsb3NpbmcgY29ubmVjdGlvbjogXCIgKyBkZXRhaWwpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmNsb3NlKDEwMDIsIGRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9hd2FpdGluZ19hY2tfaGFuZGxlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1zZ3R5cGUoKSA9PT0gXCJBQ0tcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudF9oYW5kbGVyID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3N0ZWFkeV9zdGF0ZV9oYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcHVsbF9zZXNzaW9uX2RvYygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdfYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nX2Fja1swXSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ19hY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlX2JhZF9wcm90b2NvbChcIkZpcnN0IG1lc3NhZ2Ugd2FzIG5vdCBhbiBBQ0tcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rpb24ucHJvdG90eXBlLl9zdGVhZHlfc3RhdGVfaGFuZGxlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBwcm9taXNlX2Z1bmNzO1xuICAgICAgICBpZiAobWVzc2FnZS5yZXFpZCgpIGluIHRoaXMuX3BlbmRpbmdfcmVwbGllcykge1xuICAgICAgICAgICAgcHJvbWlzZV9mdW5jcyA9IHRoaXMuX3BlbmRpbmdfcmVwbGllc1ttZXNzYWdlLnJlcWlkKCldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdfcmVwbGllc1ttZXNzYWdlLnJlcWlkKCldO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfZnVuY3NbMF0obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5tc2d0eXBlKCkgaW4gbWVzc2FnZV9oYW5kbGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VfaGFuZGxlcnNbbWVzc2FnZS5tc2d0eXBlKCldKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJEb2luZyBub3RoaW5nIHdpdGggbWVzc2FnZSBcIiArIChtZXNzYWdlLm1zZ3R5cGUoKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50Q29ubmVjdGlvbjtcbn0pKCk7XG5DbGllbnRTZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnRTZXNzaW9uKF9jb25uZWN0aW9uLCBkb2N1bWVudDEsIGlkKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBfY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50MTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvY3VtZW50X2xpc3RlbmVyID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG9jdW1lbnRfY2hhbmdlZChldmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbl9jaGFuZ2UodGhpcy5kb2N1bWVudF9saXN0ZW5lcik7XG4gICAgICAgIHRoaXMuZXZlbnRfbWFuYWdlciA9IHRoaXMuZG9jdW1lbnQuZXZlbnRfbWFuYWdlcjtcbiAgICAgICAgdGhpcy5ldmVudF9tYW5hZ2VyLnNlc3Npb24gPSB0aGlzO1xuICAgIH1cbiAgICBDbGllbnRTZXNzaW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLnNlbmRfZXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5zZW5kX2V2ZW50KHR5cGUpO1xuICAgIH07XG4gICAgQ2xpZW50U2Vzc2lvbi5wcm90b3R5cGUuX2Nvbm5lY3Rpb25fY2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5yZW1vdmVfb25fY2hhbmdlKHRoaXMuZG9jdW1lbnRfbGlzdGVuZXIpO1xuICAgIH07XG4gICAgQ2xpZW50U2Vzc2lvbi5wcm90b3R5cGUucmVxdWVzdF9zZXJ2ZXJfaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UsIHByb21pc2U7XG4gICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlLmNyZWF0ZSgnU0VSVkVSLUlORk8tUkVRJywge30pO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fY29ubmVjdGlvbi5zZW5kX3dpdGhfcmVwbHkobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbHkuY29udGVudDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRTZXNzaW9uLnByb3RvdHlwZS5mb3JjZV9yb3VuZHRyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Rfc2VydmVyX2luZm8oKS50aGVuKGZ1bmN0aW9uIChpZ25vcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLl9kb2N1bWVudF9jaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwYXRjaDtcbiAgICAgICAgaWYgKGV2ZW50LnNldHRlcl9pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIGRvY3VtZW50XzEuTW9kZWxDaGFuZ2VkRXZlbnQgJiYgIShldmVudC5hdHRyIGluIGV2ZW50Lm1vZGVsLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2ggPSBNZXNzYWdlLmNyZWF0ZSgnUEFUQ0gtRE9DJywge30sIHRoaXMuZG9jdW1lbnQuY3JlYXRlX2pzb25fcGF0Y2goW2V2ZW50XSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbi5zZW5kKHBhdGNoKTtcbiAgICB9O1xuICAgIENsaWVudFNlc3Npb24ucHJvdG90eXBlLl9oYW5kbGVfcGF0Y2ggPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5hcHBseV9qc29uX3BhdGNoKG1lc3NhZ2UuY29udGVudCwgdGhpcy5pZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50U2Vzc2lvbjtcbn0pKCk7XG5leHBvcnRzLnB1bGxfc2Vzc2lvbiA9IGZ1bmN0aW9uICh1cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24sIHByb21pc2UsIHJlamVjdGVyO1xuICAgIHJlamVjdGVyID0gbnVsbDtcbiAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBwcm9taXNlID0gbmV3IGVzNl9wcm9taXNlXzEuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ2xpZW50Q29ubmVjdGlvbih1cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nLCBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgICAgIGUgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIlByb21pc2UgaGFuZGxlciB0aHJldyBhbiBlcnJvciwgY2xvc2luZyBzZXNzaW9uIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgd2Ugc3VjY2Vzc2Z1bGx5IHB1bGxlZCBhIHNlc3Npb25cIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29ubmVjdCgpLnRoZW4oZnVuY3Rpb24gKHdoYXRldmVyKSB7IH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIEJva2VoIHNlcnZlciBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm9taXNlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMy4zXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vICAgICAoYykgMjAxMC0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xudmFyIGVxXzEgPSByZXF1aXJlKFwiLi91dGlsL2VxXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vdXRpbC9vYmplY3RcIik7XG4vLyBCYWNrYm9uZS5Nb2RlbFxuLy8gLS0tLS0tLS0tLS0tLS1cbi8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4vLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4vLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4vLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cbi8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy5cbmV4cG9ydHMuTW9kZWwgPSBmdW5jdGlvbiAoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLnNldHYoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxub2JqZWN0XzEuZXh0ZW5kKGV4cG9ydHMuTW9kZWwucHJvdG90eXBlLCBldmVudHNfMS5FdmVudHMsIHtcbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0djogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0djogZnVuY3Rpb24gKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgICB2YXIgYXR0cnM7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgICB2YXIgc2lsZW50ID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gW107XG4gICAgICAgIHZhciBjaGFuZ2luZyA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgICB0aGlzLl9jaGFuZ2luZyA9IHRydWU7XG4gICAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IG9iamVjdF8xLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuICAgICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKCFlcV8xLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goYXR0cik7XG4gICAgICAgICAgICBpZiAoIWVxXzEuaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VkW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cbiAgICAgICAgaWYgKGNoYW5naW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB9LFxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH1cbn0pO1xuLy8gQmFja2JvbmUuVmlld1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4vLyBpcyBzaW1wbHkgYSBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBsb2dpY2FsIGNodW5rIG9mIFVJIGluIHRoZVxuLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4vLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuLy8gVUkgYXMgYSAqKlZpZXcqKiBhbGxvd3MgeW91IHRvIGRlZmluZSB5b3VyIERPTSBldmVudHMgZGVjbGFyYXRpdmVseSwgd2l0aG91dFxuLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4vLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cbi8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbmV4cG9ydHMuVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgdGhpcy5lbCA9IG9wdGlvbnMuZWw7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG4vLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG5vYmplY3RfMS5leHRlbmQoZXhwb3J0cy5WaWV3LnByb3RvdHlwZSwgZXZlbnRzXzEuRXZlbnRzLCB7XG4gICAgLy8gVGhlIGRlZmF1bHQgYHRhZ05hbWVgIG9mIGEgVmlldydzIGVsZW1lbnQgaXMgYFwiZGl2XCJgLlxuICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7IH0sXG4gICAgLy8gKipyZW5kZXIqKiBpcyB0aGUgY29yZSBmdW5jdGlvbiB0aGF0IHlvdXIgdmlldyBzaG91bGQgb3ZlcnJpZGUsIGluIG9yZGVyXG4gICAgLy8gdG8gcG9wdWxhdGUgaXRzIGVsZW1lbnQgKGB0aGlzLmVsYCksIHdpdGggdGhlIGFwcHJvcHJpYXRlIEhUTUwuIFRoZVxuICAgIC8vIGNvbnZlbnRpb24gaXMgZm9yICoqcmVuZGVyKiogdG8gYWx3YXlzIHJldHVybiBgdGhpc2AuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldydzIGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQgYW5kIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAvLyBhdHRhY2hlZCB0byBpdC4gRXhwb3NlZCBmb3Igc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET01cbiAgICAvLyBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9yZW1vdmVFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYC5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9LFxuICAgIC8vIFByb2R1Y2VzIGEgRE9NIGVsZW1lbnQgdG8gYmUgYXNzaWduZWQgdG8geW91ciB2aWV3LiBFeHBvc2VkIGZvclxuICAgIC8vIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH0sXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5leHBvcnRzLk1vZGVsLmdldHRlciA9IGV4cG9ydHMuVmlldy5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSwgZ2V0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCB7IGdldDogZ2V0IH0pO1xufTtcbmV4cG9ydHMuTW9kZWwuZ2V0dGVycyA9IGV4cG9ydHMuVmlldy5nZXR0ZXJzID0gZnVuY3Rpb24gKHNwZWNzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzcGVjcykge1xuICAgICAgICB0aGlzLmdldHRlcihuYW1lLCBzcGVjc1tuYW1lXSk7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvb2JqZWN0XCIpO1xudmFyIGV2ZW50X2NsYXNzZXMgPSB7fTtcbmZ1bmN0aW9uIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKGV2ZW50X25hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50X2Nscykge1xuICAgICAgICBldmVudF9jbHMucHJvdG90eXBlLmV2ZW50X25hbWUgPSBldmVudF9uYW1lO1xuICAgICAgICBldmVudF9jbGFzc2VzW2V2ZW50X25hbWVdID0gZXZlbnRfY2xzO1xuICAgIH07XG59XG5leHBvcnRzLnJlZ2lzdGVyX2V2ZW50X2NsYXNzID0gcmVnaXN0ZXJfZXZlbnRfY2xhc3M7XG5mdW5jdGlvbiByZWdpc3Rlcl93aXRoX2V2ZW50KGV2ZW50X2Nscykge1xuICAgIHZhciBtb2RlbHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBtb2RlbHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBhcHBsaWNhYmxlX21vZGVscyA9IGV2ZW50X2Nscy5wcm90b3R5cGUuYXBwbGljYWJsZV9tb2RlbHMuY29uY2F0KG1vZGVscyk7XG4gICAgZXZlbnRfY2xzLnByb3RvdHlwZS5hcHBsaWNhYmxlX21vZGVscyA9IGFwcGxpY2FibGVfbW9kZWxzO1xufVxuZXhwb3J0cy5yZWdpc3Rlcl93aXRoX2V2ZW50ID0gcmVnaXN0ZXJfd2l0aF9ldmVudDtcbnZhciBCb2tlaEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb2tlaEV2ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGVsX2lkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsX2lkID0gb3B0aW9ucy5tb2RlbF9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCb2tlaEV2ZW50LnByb3RvdHlwZS5zZXRfbW9kZWxfaWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5tb2RlbF9pZCA9IGlkO1xuICAgICAgICB0aGlzLm1vZGVsX2lkID0gaWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQm9rZWhFdmVudC5wcm90b3R5cGUuaXNfYXBwbGljYWJsZV90byA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYWJsZV9tb2RlbHMuc29tZShmdW5jdGlvbiAobW9kZWwpIHsgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIG1vZGVsOyB9KTtcbiAgICB9O1xuICAgIEJva2VoRXZlbnQuZXZlbnRfY2xhc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBHaXZlbiBhbiBldmVudCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIGV2ZW50X25hbWUsXG4gICAgICAgIC8vIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgQm9rZWhFdmVudCBjbGFzc1xuICAgICAgICBpZiAoZS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRfY2xhc3Nlc1tlLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdCb2tlaEV2ZW50LmV2ZW50X2NsYXNzIHJlcXVpcmVkIGV2ZW50cyB3aXRoIGEgc3RyaW5nIHR5cGUgYXR0cmlidXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJva2VoRXZlbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2ZW50X25hbWU6IHRoaXMuZXZlbnRfbmFtZSxcbiAgICAgICAgICAgIGV2ZW50X3ZhbHVlczogb2JqZWN0XzEuY2xvbmUodGhpcy5fb3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCb2tlaEV2ZW50LnByb3RvdHlwZS5fY3VzdG9taXplX2V2ZW50ID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEJva2VoRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5Cb2tlaEV2ZW50ID0gQm9rZWhFdmVudDtcbkJva2VoRXZlbnQucHJvdG90eXBlLmFwcGxpY2FibGVfbW9kZWxzID0gW107XG52YXIgQnV0dG9uQ2xpY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25DbGljaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25DbGljaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uQ2xpY2s7XG59KEJva2VoRXZlbnQpKTtcbkJ1dHRvbkNsaWNrID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJidXR0b25fY2xpY2tcIilcbl0sIEJ1dHRvbkNsaWNrKTtcbmV4cG9ydHMuQnV0dG9uQ2xpY2sgPSBCdXR0b25DbGljaztcbi8vIEEgVUlFdmVudCBpcyBhbiBldmVudCBvcmlnaW5hdGluZyBvbiBhIFBsb3RDYW52YXMgdGhpcyBpbmNsdWRlc1xuLy8gRE9NIGV2ZW50cyBzdWNoIGFzIGtleXN0cm9rZXMgYXMgd2VsbCBhcyBoYW1tZXIgZXZlbnRzIGFuZCBMT0QgZXZlbnRzLlxudmFyIFVJRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVSUV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVJRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVJRXZlbnQ7XG59KEJva2VoRXZlbnQpKTtcbmV4cG9ydHMuVUlFdmVudCA9IFVJRXZlbnQ7XG52YXIgTE9EU3RhcnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMT0RTdGFydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMT0RTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTE9EU3RhcnQ7XG59KFVJRXZlbnQpKTtcbkxPRFN0YXJ0ID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJsb2RzdGFydFwiKVxuXSwgTE9EU3RhcnQpO1xuZXhwb3J0cy5MT0RTdGFydCA9IExPRFN0YXJ0O1xudmFyIExPREVuZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExPREVuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMT0RFbmQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExPREVuZDtcbn0oVUlFdmVudCkpO1xuTE9ERW5kID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJsb2RlbmRcIilcbl0sIExPREVuZCk7XG5leHBvcnRzLkxPREVuZCA9IExPREVuZDtcbnZhciBQb2ludEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9pbnRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb2ludEV2ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ggPSBvcHRpb25zLnN4O1xuICAgICAgICBfdGhpcy5zeSA9IG9wdGlvbnMuc3k7XG4gICAgICAgIF90aGlzLnggPSBudWxsO1xuICAgICAgICBfdGhpcy55ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb2ludEV2ZW50LmZyb21fZXZlbnQgPSBmdW5jdGlvbiAoZSwgbW9kZWxfaWQpIHtcbiAgICAgICAgaWYgKG1vZGVsX2lkID09PSB2b2lkIDApIHsgbW9kZWxfaWQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7IHN4OiBlLmJva2VoWydzeCddLCBzeTogZS5ib2tlaFsnc3knXSwgbW9kZWxfaWQ6IG1vZGVsX2lkIH0pO1xuICAgIH07XG4gICAgUG9pbnRFdmVudC5wcm90b3R5cGUuX2N1c3RvbWl6ZV9ldmVudCA9IGZ1bmN0aW9uIChwbG90KSB7XG4gICAgICAgIHZhciB4bWFwcGVyID0gcGxvdC5wbG90X2NhbnZhcy5mcmFtZS54X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdmFyIHltYXBwZXIgPSBwbG90LnBsb3RfY2FudmFzLmZyYW1lLnlfbWFwcGVyc1snZGVmYXVsdCddO1xuICAgICAgICB0aGlzLnggPSB4bWFwcGVyLm1hcF9mcm9tX3RhcmdldChwbG90LnBsb3RfY2FudmFzLmNhbnZhcy5zeF90b192eCh0aGlzLnN4KSk7XG4gICAgICAgIHRoaXMueSA9IHltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHBsb3QucGxvdF9jYW52YXMuY2FudmFzLnN5X3RvX3Z5KHRoaXMuc3kpKTtcbiAgICAgICAgdGhpcy5fb3B0aW9uc1sneCddID0gdGhpcy54O1xuICAgICAgICB0aGlzLl9vcHRpb25zWyd5J10gPSB0aGlzLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50RXZlbnQ7XG59KFVJRXZlbnQpKTtcbmV4cG9ydHMuUG9pbnRFdmVudCA9IFBvaW50RXZlbnQ7XG52YXIgUGFuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhbihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlbHRhX3ggPSBvcHRpb25zLmRlbHRhX3g7XG4gICAgICAgIF90aGlzLmRlbHRhX3kgPSBvcHRpb25zLmRlbHRhX3k7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGFuLmZyb21fZXZlbnQgPSBmdW5jdGlvbiAoZSwgbW9kZWxfaWQpIHtcbiAgICAgICAgaWYgKG1vZGVsX2lkID09PSB2b2lkIDApIHsgbW9kZWxfaWQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBzeDogZS5ib2tlaFsnc3gnXSxcbiAgICAgICAgICAgIHN5OiBlLmJva2VoWydzeSddLFxuICAgICAgICAgICAgZGVsdGFfeDogZS5kZWx0YVgsXG4gICAgICAgICAgICBkZWx0YV95OiBlLmRlbHRhWSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZS5kaXJlY3Rpb24sXG4gICAgICAgICAgICBtb2RlbF9pZDogbW9kZWxfaWRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuO1xufShQb2ludEV2ZW50KSk7XG5QYW4gPSBfX2RlY29yYXRlKFtcbiAgICByZWdpc3Rlcl9ldmVudF9jbGFzcyhcInBhblwiKVxuXSwgUGFuKTtcbmV4cG9ydHMuUGFuID0gUGFuO1xudmFyIFBpbmNoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGluY2gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGluY2gob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGluY2guZnJvbV9ldmVudCA9IGZ1bmN0aW9uIChlLCBtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgPT09IHZvaWQgMCkgeyBtb2RlbF9pZCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHN4OiBlLmJva2VoWydzeCddLFxuICAgICAgICAgICAgc3k6IGUuYm9rZWhbJ3N5J10sXG4gICAgICAgICAgICBzY2FsZTogZS5zY2FsZSxcbiAgICAgICAgICAgIG1vZGVsX2lkOiBtb2RlbF9pZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGluY2g7XG59KFBvaW50RXZlbnQpKTtcblBpbmNoID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJwaW5jaFwiKVxuXSwgUGluY2gpO1xuZXhwb3J0cy5QaW5jaCA9IFBpbmNoO1xudmFyIE1vdXNlV2hlZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb3VzZVdoZWVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vdXNlV2hlZWwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWx0YSA9IG9wdGlvbnMuZGVsdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW91c2VXaGVlbC5mcm9tX2V2ZW50ID0gZnVuY3Rpb24gKGUsIG1vZGVsX2lkKSB7XG4gICAgICAgIGlmIChtb2RlbF9pZCA9PT0gdm9pZCAwKSB7IG1vZGVsX2lkID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgc3g6IGUuYm9rZWhbJ3N4J10sXG4gICAgICAgICAgICBzeTogZS5ib2tlaFsnc3knXSxcbiAgICAgICAgICAgIGRlbHRhOiBlLmRlbHRhLFxuICAgICAgICAgICAgbW9kZWxfaWQ6IG1vZGVsX2lkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNb3VzZVdoZWVsO1xufShQb2ludEV2ZW50KSk7XG5Nb3VzZVdoZWVsID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJ3aGVlbFwiKVxuXSwgTW91c2VXaGVlbCk7XG5leHBvcnRzLk1vdXNlV2hlZWwgPSBNb3VzZVdoZWVsO1xudmFyIE1vdXNlTW92ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vdXNlTW92ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VzZU1vdmUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1vdXNlTW92ZTtcbn0oUG9pbnRFdmVudCkpO1xuTW91c2VNb3ZlID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJtb3VzZW1vdmVcIilcbl0sIE1vdXNlTW92ZSk7XG5leHBvcnRzLk1vdXNlTW92ZSA9IE1vdXNlTW92ZTtcbnZhciBNb3VzZUVudGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW91c2VFbnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VzZUVudGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNb3VzZUVudGVyO1xufShQb2ludEV2ZW50KSk7XG5Nb3VzZUVudGVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJtb3VzZWVudGVyXCIpXG5dLCBNb3VzZUVudGVyKTtcbmV4cG9ydHMuTW91c2VFbnRlciA9IE1vdXNlRW50ZXI7XG52YXIgTW91c2VMZWF2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vdXNlTGVhdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTW91c2VMZWF2ZTtcbn0oUG9pbnRFdmVudCkpO1xuTW91c2VMZWF2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwibW91c2VsZWF2ZVwiKVxuXSwgTW91c2VMZWF2ZSk7XG5leHBvcnRzLk1vdXNlTGVhdmUgPSBNb3VzZUxlYXZlO1xudmFyIFRhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhcDtcbn0oUG9pbnRFdmVudCkpO1xuVGFwID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJ0YXBcIilcbl0sIFRhcCk7XG5leHBvcnRzLlRhcCA9IFRhcDtcbnZhciBEb3VibGVUYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb3VibGVUYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG91YmxlVGFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEb3VibGVUYXA7XG59KFBvaW50RXZlbnQpKTtcbkRvdWJsZVRhcCA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwiZG91YmxldGFwXCIpXG5dLCBEb3VibGVUYXApO1xuZXhwb3J0cy5Eb3VibGVUYXAgPSBEb3VibGVUYXA7XG52YXIgUHJlc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJlc3M7XG59KFBvaW50RXZlbnQpKTtcblByZXNzID0gX19kZWNvcmF0ZShbXG4gICAgcmVnaXN0ZXJfZXZlbnRfY2xhc3MoXCJwcmVzc1wiKVxuXSwgUHJlc3MpO1xuZXhwb3J0cy5QcmVzcyA9IFByZXNzO1xudmFyIFBhblN0YXJ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuU3RhcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhblN0YXJ0O1xufShQb2ludEV2ZW50KSk7XG5QYW5TdGFydCA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwicGFuc3RhcnRcIilcbl0sIFBhblN0YXJ0KTtcbmV4cG9ydHMuUGFuU3RhcnQgPSBQYW5TdGFydDtcbnZhciBQYW5FbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYW5FbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuRW5kKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYW5FbmQ7XG59KFBvaW50RXZlbnQpKTtcblBhbkVuZCA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwicGFuZW5kXCIpXG5dLCBQYW5FbmQpO1xuZXhwb3J0cy5QYW5FbmQgPSBQYW5FbmQ7XG52YXIgUGluY2hTdGFydCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpbmNoU3RhcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGluY2hTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGluY2hTdGFydDtcbn0oUG9pbnRFdmVudCkpO1xuUGluY2hTdGFydCA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwicGluY2hzdGFydFwiKVxuXSwgUGluY2hTdGFydCk7XG5leHBvcnRzLlBpbmNoU3RhcnQgPSBQaW5jaFN0YXJ0O1xudmFyIFBpbmNoRW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGluY2hFbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGluY2hFbmQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBpbmNoRW5kO1xufShQb2ludEV2ZW50KSk7XG5QaW5jaEVuZCA9IF9fZGVjb3JhdGUoW1xuICAgIHJlZ2lzdGVyX2V2ZW50X2NsYXNzKFwicGluY2hlbmRcIilcbl0sIFBpbmNoRW5kKTtcbmV4cG9ydHMuUGluY2hFbmQgPSBQaW5jaEVuZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoXCIuL2JhY2tib25lXCIpO1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vdXRpbC9zdHJpbmdcIik7XG5leHBvcnRzLkJva2VoVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb2tlaFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJva2VoVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJva2VoVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm9rZWhWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQgPSBzdHJpbmdfMS51bmlxdWVJZCgnQm9rZWhWaWV3Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJva2VoVmlldy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnR5cGUgKyBcIlZpZXcoXCIgKyB0aGlzLmlkICsgXCIpXCI7XG4gICAgfTtcbiAgICBCb2tlaFZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEJva2VoVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHRoaXMpO1xuICAgICAgICByZXR1cm4gQm9rZWhWaWV3Ll9fc3VwZXJfXy5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBCb2tlaFZpZXc7XG59KShCYWNrYm9uZS5WaWV3KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vdXRpbC9vYmplY3RcIik7XG5leHBvcnRzLmJ1aWxkX3ZpZXdzID0gZnVuY3Rpb24gKHZpZXdfc3RvcmFnZSwgdmlld19tb2RlbHMsIG9wdGlvbnMsIHZpZXdfdHlwZXMpIHtcbiAgICB2YXIgY2xzLCBjcmVhdGVkX3ZpZXdzLCBpLCBpX21vZGVsLCBqLCBrZXksIGxlbiwgbGVuMSwgbW9kZWwsIG5ld21vZGVscywgcmVmLCB0b19yZW1vdmUsIHZpZXcsIHZpZXdfb3B0aW9ucztcbiAgICBpZiAodmlld190eXBlcyA9PSBudWxsKSB7XG4gICAgICAgIHZpZXdfdHlwZXMgPSBbXTtcbiAgICB9XG4gICAgY3JlYXRlZF92aWV3cyA9IFtdO1xuICAgIG5ld21vZGVscyA9IHZpZXdfbW9kZWxzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdmlld19zdG9yYWdlW3guaWRdID09IG51bGw7XG4gICAgfSk7XG4gICAgZm9yIChpX21vZGVsID0gaSA9IDAsIGxlbiA9IG5ld21vZGVscy5sZW5ndGg7IGkgPCBsZW47IGlfbW9kZWwgPSArK2kpIHtcbiAgICAgICAgbW9kZWwgPSBuZXdtb2RlbHNbaV9tb2RlbF07XG4gICAgICAgIGNscyA9IChyZWYgPSB2aWV3X3R5cGVzW2lfbW9kZWxdKSAhPSBudWxsID8gcmVmIDogbW9kZWwuZGVmYXVsdF92aWV3O1xuICAgICAgICB2aWV3X29wdGlvbnMgPSBvYmplY3RfMS5leHRlbmQoe1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2aWV3X3N0b3JhZ2VbbW9kZWwuaWRdID0gdmlldyA9IG5ldyBjbHModmlld19vcHRpb25zKTtcbiAgICAgICAgY3JlYXRlZF92aWV3cy5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICB0b19yZW1vdmUgPSBhcnJheV8xLmRpZmZlcmVuY2UoT2JqZWN0LmtleXModmlld19zdG9yYWdlKSwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGosIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHZpZXdfbW9kZWxzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdfbW9kZWxzW2pdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZpZXcuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pKCkpO1xuICAgIGZvciAoaiA9IDAsIGxlbjEgPSB0b19yZW1vdmUubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgIGtleSA9IHRvX3JlbW92ZVtqXTtcbiAgICAgICAgdmlld19zdG9yYWdlW2tleV0ucmVtb3ZlKCk7XG4gICAgICAgIGRlbGV0ZSB2aWV3X3N0b3JhZ2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZWRfdmlld3M7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvdHlwZXNcIik7XG52YXIgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMgPT09IHZvaWQgMCkgeyBhdHRycyA9IHt9OyB9XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBlbGVtZW50O1xuICAgIGlmICh0YWcgPT09IFwiZnJhZ21lbnRcIikge1xuICAgICAgICAvLyBYWFg6IHRoaXMgaXMgd3JvbmcsIGJ1dCB0aGUgdGhlIGNvbW1vbiBzdXBlciB0eXBlIG9mIERvY3VtZW50RnJhZ21lbnQgYW5kIEhUTUxFbGVtZW50IGlzXG4gICAgICAgIC8vIE5vZGUsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBjbGFzc0xpc3QsIHN0eWxlLCBldGMuIGF0dHJpYnV0ZXMuXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVzXzEuaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gXCJjbGFzc1wiICYmIHR5cGVzXzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdmFsdWU7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbHMgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyID09PSBcInN0eWxlXCIgJiYgdHlwZXNfMS5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNTdHJpbmcoY2hpbGQpKVxuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpO1xuICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGFuIEhUTUxFbGVtZW50LCBzdHJpbmcsIGZhbHNlIG9yIG51bGwsIGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KGNoaWxkKSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9jID0gMCwgY2hpbGRyZW5fMSA9IGNoaWxkcmVuOyBfYyA8IGNoaWxkcmVuXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuXzFbX2NdO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBjaGlsZF8xID0gY2hpbGQ7IF9kIDwgY2hpbGRfMS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NoaWxkID0gY2hpbGRfMVtfZF07XG4gICAgICAgICAgICAgICAgYXBwZW5kKF9jaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXBwZW5kKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59OyB9O1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlRWxlbWVudCh0YWcpLmFwcGx5KHZvaWQgMCwgW2F0dHJzXS5jb25jYXQoY2hpbGRyZW4pKTtcbn1cbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG5leHBvcnRzLmRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBleHBvcnRzLnNwYW4gPSBfY3JlYXRlRWxlbWVudChcInNwYW5cIiksIGV4cG9ydHMubGluayA9IF9jcmVhdGVFbGVtZW50KFwibGlua1wiKSwgZXhwb3J0cy5zdHlsZSA9IF9jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIGV4cG9ydHMuYSA9IF9jcmVhdGVFbGVtZW50KFwiYVwiKSwgZXhwb3J0cy5wID0gX2NyZWF0ZUVsZW1lbnQoXCJwXCIpLCBleHBvcnRzLnByZSA9IF9jcmVhdGVFbGVtZW50KFwicHJlXCIpLCBleHBvcnRzLmlucHV0ID0gX2NyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgZXhwb3J0cy5sYWJlbCA9IF9jcmVhdGVFbGVtZW50KFwibGFiZWxcIiksIGV4cG9ydHMuY2FudmFzID0gX2NyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIGV4cG9ydHMudWwgPSBfY3JlYXRlRWxlbWVudChcInVsXCIpLCBleHBvcnRzLm9sID0gX2NyZWF0ZUVsZW1lbnQoXCJvbFwiKSwgZXhwb3J0cy5saSA9IF9jcmVhdGVFbGVtZW50KFwibGlcIik7XG5mdW5jdGlvbiBzaG93KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xufVxuZXhwb3J0cy5zaG93ID0gc2hvdztcbmZ1bmN0aW9uIGhpZGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xufVxuZXhwb3J0cy5oaWRlID0gaGlkZTtcbmZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmZ1bmN0aW9uIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgfTtcbn1cbmV4cG9ydHMucG9zaXRpb24gPSBwb3NpdGlvbjtcbmZ1bmN0aW9uIG9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCxcbiAgICB9O1xufVxuZXhwb3J0cy5vZmZzZXQgPSBvZmZzZXQ7XG5mdW5jdGlvbiByZXBsYWNlV2l0aChlbGVtZW50LCByZXBsYWNlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnQsIGVsZW1lbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmdsZVVuaXRzID0gW1wiZGVnXCIsIFwicmFkXCJdO1xuZXhwb3J0cy5EaW1lbnNpb24gPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcbmV4cG9ydHMuRGltZW5zaW9ucyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiYm90aFwiXTtcbmV4cG9ydHMuRGlyZWN0aW9uID0gW1wiY2xvY2tcIiwgXCJhbnRpY2xvY2tcIl07XG5leHBvcnRzLkZvbnRTdHlsZSA9IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiLCBcImJvbGRcIl07XG5leHBvcnRzLkxhdExvbiA9IFtcImxhdFwiLCBcImxvblwiXTtcbmV4cG9ydHMuTGluZUNhcCA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmV4cG9ydHMuTGluZUpvaW4gPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5leHBvcnRzLkxvY2F0aW9uID0gW1wiYWJvdmVcIiwgXCJiZWxvd1wiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcbmV4cG9ydHMuTGVnZW5kTG9jYXRpb24gPSBbXCJ0b3BfbGVmdFwiLCBcInRvcF9jZW50ZXJcIiwgXCJ0b3BfcmlnaHRcIiwgXCJjZW50ZXJfbGVmdFwiLCBcImNlbnRlclwiLCBcImNlbnRlcl9yaWdodFwiLCBcImJvdHRvbV9sZWZ0XCIsIFwiYm90dG9tX2NlbnRlclwiLCBcImJvdHRvbV9yaWdodFwiXTtcbmV4cG9ydHMuT3JpZW50YXRpb24gPSBbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl07XG5leHBvcnRzLlJlbmRlckxldmVsID0gW1wiaW1hZ2VcIiwgXCJ1bmRlcmxheVwiLCBcImdseXBoXCIsIFwiYW5ub3RhdGlvblwiLCBcIm92ZXJsYXlcIl07XG5leHBvcnRzLlJlbmRlck1vZGUgPSBbXCJjYW52YXNcIiwgXCJjc3NcIl07XG5leHBvcnRzLlNpZGUgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl07XG5leHBvcnRzLlNwYXRpYWxVbml0cyA9IFtcInNjcmVlblwiLCBcImRhdGFcIl07XG5leHBvcnRzLlN0YXJ0RW5kID0gW1wic3RhcnRcIiwgXCJlbmRcIl07XG5leHBvcnRzLlRleHRBbGlnbiA9IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiXTtcbmV4cG9ydHMuVGV4dEJhc2VsaW5lID0gW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCIsIFwiYWxwaGFiZXRpY1wiLCBcImhhbmdpbmdcIiwgXCJpZGVvZ3JhcGhpY1wiXTtcbmV4cG9ydHMuRGlzdHJpYnV0aW9uVHlwZXMgPSBbXCJ1bmlmb3JtXCIsIFwibm9ybWFsXCJdO1xuZXhwb3J0cy5UcmFuc2Zvcm1TdGVwTW9kZXMgPSBbXCJhZnRlclwiLCBcImJlZm9yZVwiLCBcImNlbnRlclwiXTtcbmV4cG9ydHMuU2l6aW5nTW9kZSA9IFtcInN0cmV0Y2hfYm90aFwiLCBcInNjYWxlX3dpZHRoXCIsIFwic2NhbGVfaGVpZ2h0XCIsIFwic2NhbGVfYm90aFwiLCBcImZpeGVkXCJdO1xuIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMy4zXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vICAgICAoYykgMjAxMC0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vdXRpbC9zdHJpbmdcIik7XG52YXIgY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCIuL3V0aWwvY2FsbGJhY2tcIik7XG4vLyBCYWNrYm9uZS5FdmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLVxuLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuLy8gYSBjdXN0b20gZXZlbnQgY2hhbm5lbC4gWW91IG1heSBiaW5kIGEgY2FsbGJhY2sgdG8gYW4gZXZlbnQgd2l0aCBgb25gIG9yXG4vLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4vLyBzdWNjZXNzaW9uLlxuLy9cbi8vICAgICB2YXIgb2JqZWN0ID0ge307XG4vLyAgICAgZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbi8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbi8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4vL1xuZXhwb3J0cy5FdmVudHMgPSB7fTtcbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG52YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcbi8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuLy8gbWFwcyBge2V2ZW50OiBjYWxsYmFja31gKS5cbnZhciBldmVudHNBcGkgPSBmdW5jdGlvbiAoaXRlcmF0ZWUsIGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB2b2lkIDAgJiYgJ2NvbnRleHQnIGluIG9wdHMgJiYgb3B0cy5jb250ZXh0ID09PSB2b2lkIDApXG4gICAgICAgICAgICBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50c0FwaShpdGVyYXRlZSwgZXZlbnRzLCBuYW1lc1tpXSwgbmFtZVtuYW1lc1tpXV0sIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgJiYgZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXMgYnkgZGVsZWdhdGluZyB0aGVtIGluZGl2aWR1YWxseS5cbiAgICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXZlbnRzID0gaXRlcmF0ZWUoZXZlbnRzLCBuYW1lc1tpXSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGaW5hbGx5LCBzdGFuZGFyZCBldmVudHMuXG4gICAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xufTtcbi8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbi8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuZXhwb3J0cy5FdmVudHMub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxPbih0aGlzLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuLy8gR3VhcmQgdGhlIGBsaXN0ZW5pbmdgIGFyZ3VtZW50IGZyb20gdGhlIHB1YmxpYyBBUEkuXG52YXIgaW50ZXJuYWxPbiA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0LCBsaXN0ZW5pbmcpIHtcbiAgICBvYmouX2V2ZW50cyA9IGV2ZW50c0FwaShvbkFwaSwgb2JqLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGN0eDogb2JqLFxuICAgICAgICBsaXN0ZW5pbmc6IGxpc3RlbmluZ1xuICAgIH0pO1xuICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IG9iai5fbGlzdGVuZXJzIHx8IChvYmouX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgICAgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF0gPSBsaXN0ZW5pbmc7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvIGxpc3RlbiB0b1xuLy8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3MgbGlzdGVuaW5nIHRvXG4vLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbmV4cG9ydHMuRXZlbnRzLmxpc3RlblRvID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9iailcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IHN0cmluZ18xLnVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdO1xuICAgIC8vIFRoaXMgb2JqZWN0IGlzIG5vdCBsaXN0ZW5pbmcgdG8gYW55IG90aGVyIGV2ZW50cyBvbiBgb2JqYCB5ZXQuXG4gICAgLy8gU2V0dXAgdGhlIG5lY2Vzc2FyeSByZWZlcmVuY2VzIHRvIHRyYWNrIHRoZSBsaXN0ZW5pbmcgY2FsbGJhY2tzLlxuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICAgIHZhciB0aGlzSWQgPSB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSBzdHJpbmdfMS51bmlxdWVJZCgnbCcpKTtcbiAgICAgICAgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdID0geyBvYmo6IG9iaiwgb2JqSWQ6IGlkLCBpZDogdGhpc0lkLCBsaXN0ZW5pbmdUbzogbGlzdGVuaW5nVG8sIGNvdW50OiAwIH07XG4gICAgfVxuICAgIC8vIEJpbmQgY2FsbGJhY2tzIG9uIG9iaiwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlbSBvbiBsaXN0ZW5pbmcuXG4gICAgaW50ZXJuYWxPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzLCBsaXN0ZW5pbmcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbi8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbnZhciBvbkFwaSA9IGZ1bmN0aW9uIChldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXSB8fCAoZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgICBpZiAobGlzdGVuaW5nKVxuICAgICAgICAgICAgbGlzdGVuaW5nLmNvdW50Kys7XG4gICAgICAgIGhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xufTtcbi8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuLy8gY2FsbGJhY2tzIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbFxuLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuZXhwb3J0cy5FdmVudHMub2ZmID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4vLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuZXhwb3J0cy5FdmVudHMuc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG87XG4gICAgaWYgKCFsaXN0ZW5pbmdUbylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IE9iamVjdC5rZXlzKGxpc3RlbmluZ1RvKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRzW2ldXTtcbiAgICAgICAgLy8gSWYgbGlzdGVuaW5nIGRvZXNuJ3QgZXhpc3QsIHRoaXMgb2JqZWN0IGlzIG5vdCBjdXJyZW50bHlcbiAgICAgICAgLy8gbGlzdGVuaW5nIHRvIG9iai4gQnJlYWsgb3V0IGVhcmx5LlxuICAgICAgICBpZiAoIWxpc3RlbmluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsaXN0ZW5pbmcub2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbi8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxudmFyIG9mZkFwaSA9IGZ1bmN0aW9uIChldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgaSA9IDAsIGxpc3RlbmluZztcbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgbGlzdGVuZXJzID0gb3B0aW9ucy5saXN0ZW5lcnM7XG4gICAgLy8gRGVsZXRlIGFsbCBldmVudHMgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobGlzdGVuZXJzKTtcbiAgICAgICAgZm9yICg7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmluZyA9IGxpc3RlbmVyc1tpZHNbaV1dO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgdGhlcmUgYXJlIG5vIGV2ZW50cyBzdG9yZWQuXG4gICAgICAgIGlmICghaGFuZGxlcnMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUmVwbGFjZSBldmVudHMgaWYgdGhlcmUgYXJlIGFueSByZW1haW5pbmcuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjay5fY2FsbGJhY2sgfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQgIT09IGhhbmRsZXIuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmluZyAmJiAtLWxpc3RlbmluZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5pbmcubGlzdGVuaW5nVG9bbGlzdGVuaW5nLm9iaklkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRhaWwgZXZlbnQgaWYgdGhlIGxpc3QgaGFzIGFueSBldmVudHMuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgZXZlbnRzW25hbWVdID0gcmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xufTtcbi8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbi8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdHMgbGlzdGVuZXIgd2lsbCBiZSByZW1vdmVkLiBJZiBtdWx0aXBsZSBldmVudHNcbi8vIGFyZSBwYXNzZWQgaW4gdXNpbmcgdGhlIHNwYWNlLXNlcGFyYXRlZCBzeW50YXgsIHRoZSBoYW5kbGVyIHdpbGwgZmlyZVxuLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbmV4cG9ydHMuRXZlbnRzLm9uY2UgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCB0aGlzLm9mZi5iaW5kKHRoaXMpKTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIGNvbnRleHQgPT0gbnVsbClcbiAgICAgICAgY2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uY2VgLlxuZXhwb3J0cy5FdmVudHMubGlzdGVuVG9PbmNlID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCB0aGlzLnN0b3BMaXN0ZW5pbmcuYmluZCh0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG59O1xuLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbi8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG52YXIgb25jZU1hcCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBtYXBbbmFtZV0gPSBjYWxsYmFja18xLm9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb2ZmZXIobmFtZSwgZm4pO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZuLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufTtcbi8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbi8vICh1bmxlc3MgeW91J3JlIGxpc3RlbmluZyBvbiBgXCJhbGxcImAsIHdoaWNoIHdpbGwgY2F1c2UgeW91ciBjYWxsYmFjayB0b1xuLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuZXhwb3J0cy5FdmVudHMudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heCgwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgIGV2ZW50c0FwaSh0cmlnZ2VyQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIHZvaWQgMCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLy8gSGFuZGxlcyB0cmlnZ2VyaW5nIHRoZSBhcHByb3ByaWF0ZSBldmVudCBjYWxsYmFja3MuXG52YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uIChvYmpFdmVudHMsIG5hbWUsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgaWYgKG9iakV2ZW50cykge1xuICAgICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgICB2YXIgYWxsRXZlbnRzID0gb2JqRXZlbnRzLmFsbDtcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBhbGxFdmVudHMpXG4gICAgICAgICAgICBhbGxFdmVudHMgPSBhbGxFdmVudHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKGV2ZW50cylcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgICAgaWYgKGFsbEV2ZW50cylcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoYWxsRXZlbnRzLCBbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iakV2ZW50cztcbn07XG4vLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxudmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpXG4gICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpXG4gICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpXG4gICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbClcbiAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIHNsaWNlID0gW10uc2xpY2U7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiLi9iYWNrYm9uZVwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xudmFyIHByb3BlcnR5X21peGlucyA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5X21peGluc1wiKTtcbnZhciByZWZzID0gcmVxdWlyZShcIi4vdXRpbC9yZWZzXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vdXRpbC9zdHJpbmdcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi91dGlsL29iamVjdFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuSGFzUHJvcHMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKEhhc1Byb3BzLCBzdXBlckNsYXNzKTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUucHJvcHMgPSB7fTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUubWl4aW5zID0gW107XG4gICAgSGFzUHJvcHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB2YXIgbmFtZSwgcHJvcCwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBwcm9wID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRfdmFsdWUsIGludGVybmFsLCBwcm9wcywgcmVmaW5lZF9wcm9wLCB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvdG90eXBlLnByb3BzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHRlZCB0byByZWRlZmluZSBwcm9wZXJ0eSAnXCIgKyBfdGhpcy5uYW1lICsgXCIuXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm90b3R5cGVbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIHJlZGVmaW5lIGF0dHJpYnV0ZSAnXCIgKyBfdGhpcy5uYW1lICsgXCIuXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0dihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHYobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHByb3BbMF0sIGRlZmF1bHRfdmFsdWUgPSBwcm9wWzFdLCBpbnRlcm5hbCA9IHByb3BbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRfcHJvcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3ZhbHVlOiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWw6IGludGVybmFsICE9IG51bGwgPyBpbnRlcm5hbCA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gb2JqZWN0XzEuY2xvbmUoX3RoaXMucHJvdG90eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSByZWZpbmVkX3Byb3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm90b3R5cGUucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykobmFtZSwgcHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSGFzUHJvcHMuaW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBfb2JqZWN0LCBmbiwgbmFtZSwgcHJvcDtcbiAgICAgICAgX29iamVjdCA9IHt9O1xuICAgICAgICBmbiA9IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgcHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0X3ZhbHVlLCB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBwcm9wWzBdLCBkZWZhdWx0X3ZhbHVlID0gcHJvcFsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFtuYW1lXSA9IFt0eXBlLCBkZWZhdWx0X3ZhbHVlLCB0cnVlXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBwcm9wID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgZm4obmFtZSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lKF9vYmplY3QpO1xuICAgIH07XG4gICAgSGFzUHJvcHMubWl4aW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaXhpbnMsIG5hbWVzO1xuICAgICAgICBuYW1lcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgICB0aGlzLmRlZmluZShwcm9wZXJ0eV9taXhpbnMuY3JlYXRlKG5hbWVzKSk7XG4gICAgICAgIG1peGlucyA9IHRoaXMucHJvdG90eXBlLm1peGlucy5jb25jYXQobmFtZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUubWl4aW5zID0gbWl4aW5zO1xuICAgIH07XG4gICAgSGFzUHJvcHMubWl4aW5zID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1peGluLmFwcGx5KHRoaXMsIG5hbWVzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLm92ZXJyaWRlID0gZnVuY3Rpb24gKG5hbWVfb3Jfb2JqZWN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgIHZhciBuYW1lLCBvYmplY3QsIHJlc3VsdHM7XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKG5hbWVfb3Jfb2JqZWN0KSkge1xuICAgICAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvYmplY3RbbmFtZV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0ID0gbmFtZV9vcl9vYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzLCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5wcm90b3R5cGUucHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0ZWQgdG8gb3ZlcnJpZGUgbm9uZXhpc3RlbnQgJ1wiICsgX3RoaXMubmFtZSArIFwiLlwiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IG9iamVjdF8xLmNsb25lKF90aGlzLnByb3RvdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW25hbWVdID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCB2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZTogZGVmYXVsdF92YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3RvdHlwZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKShuYW1lLCBkZWZhdWx0X3ZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5kZWZpbmUoe1xuICAgICAgICBpZDogW3AuQW55XVxuICAgIH0pO1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArIFwiKFwiICsgdGhpcy5pZCArIFwiKVwiO1xuICAgIH07XG4gICAgZnVuY3Rpb24gSGFzUHJvcHMoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXR0cnMsIGRlZmF1bHRfdmFsdWUsIG5hbWUsIHJlZiwgcmVmMSwgdHlwZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IG51bGw7XG4gICAgICAgIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnByb3BzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICByZWYxID0gcmVmW25hbWVdLCB0eXBlID0gcmVmMS50eXBlLCBkZWZhdWx0X3ZhbHVlID0gcmVmMS5kZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCBwcm9wZXJ0eSB0eXBlIGZvciBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBuZXcgdHlwZSh7XG4gICAgICAgICAgICAgICAgb2JqOiB0aGlzLFxuICAgICAgICAgICAgICAgIGF0dHI6IG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdF92YWx1ZTogZGVmYXVsdF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0X2FmdGVyX2RlZmF1bHRzID0ge307XG4gICAgICAgIHRoaXMuc2V0dihhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuICAgICAgICBpZiAoYXR0cnMuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHN0cmluZ18xLnVuaXF1ZUlkKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZmVyX2luaXRpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYW1lLCBwcm9wLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBwcm9wID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgcHJvcC51cGRhdGUoKTtcbiAgICAgICAgICAgIGlmIChwcm9wLnNwZWMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMubGlzdGVuVG8ocHJvcC5zcGVjLnRyYW5zZm9ybSwgXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCd0cmFuc2Zvcm1jaGFuZ2UnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5zZXR2ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGF0dHJzLCBvbGQsIHByb3BfbmFtZSwgcmVzdWx0cywgdmFsO1xuICAgICAgICBpZiAodHlwZXNfMS5pc09iamVjdChrZXkpIHx8IGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChhdHRycywga2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBwcm9wX25hbWUgPSBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wc1twcm9wX25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wZXJ0eSBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgcHJvcF9uYW1lICsgXCIgd2Fzbid0IGRlY2xhcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKG9wdGlvbnMgIT0gbnVsbCkgJiYgb3B0aW9ucy5kZWZhdWx0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRfYWZ0ZXJfZGVmYXVsdHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmplY3RfMS5pc0VtcHR5KGF0dHJzKSkge1xuICAgICAgICAgICAgb2xkID0ge307XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBvbGRba2V5XSA9IHRoaXMuZ2V0dihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSGFzUHJvcHMuX19zdXBlcl9fLnNldHYuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuc2lsZW50IDogdm9pZCAwKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX3RlbGxfZG9jdW1lbnRfYWJvdXRfY2hhbmdlKGtleSwgb2xkW2tleV0sIHRoaXMuZ2V0dihrZXkpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuYWRkX2RlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChwcm9wX25hbWUsIG9iamVjdCwgZmllbGRzKSB7XG4gICAgICAgIHZhciBmbGQsIGosIGxlbiwgcHJvcF9zcGVjLCByZXN1bHRzO1xuICAgICAgICBpZiAoIXR5cGVzXzEuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSBbZmllbGRzXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wX3NwZWMgPSB0aGlzLl9jb21wdXRlZFtwcm9wX25hbWVdO1xuICAgICAgICBwcm9wX3NwZWMuZGVwZW5kZW5jaWVzID0gcHJvcF9zcGVjLmRlcGVuZGVuY2llcy5jb25jYXQoe1xuICAgICAgICAgICAgb2JqOiBvYmplY3QsXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGZsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmxpc3RlblRvKG9iamVjdCwgXCJjaGFuZ2U6XCIgKyBmbGQsIHByb3Bfc3BlY1snY2FsbGJhY2tzJ11bJ2NoYW5nZWRlcCddKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuZGVmaW5lX2NvbXB1dGVkX3Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BfbmFtZSwgZ2V0dGVyLCB1c2VfY2FjaGUpIHtcbiAgICAgICAgdmFyIGNoYW5nZWRlcCwgcHJvcF9zcGVjLCBwcm9wY2hhbmdlO1xuICAgICAgICBpZiAodXNlX2NhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHVzZV9jYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHNbcHJvcF9uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImF0dGVtcHRlZCB0byByZWRlZmluZSBleGlzdGluZyBwcm9wZXJ0eSBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgcHJvcF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29tcHV0ZWRbcHJvcF9uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0ZWQgdG8gcmVkZWZpbmUgZXhpc3RpbmcgY29tcHV0ZWQgcHJvcGVydHkgXCIgKyB0aGlzLnR5cGUgKyBcIi5cIiArIHByb3BfbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZGVwID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJpZ2dlcignY2hhbmdlZGVwOicgKyBwcm9wX25hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIHByb3BjaGFuZ2UgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJlY2hhbmdlLCBuZXdfdmFsLCBvbGRfdmFsO1xuICAgICAgICAgICAgICAgIGZpcmVjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wX3NwZWNbJ3VzZV9jYWNoZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZF92YWwgPSBwcm9wX3NwZWMuY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHByb3Bfc3BlYy5jYWNoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3ZhbCA9IF90aGlzLl9nZXRfY29tcHV0ZWQocHJvcF9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZWNoYW5nZSA9IG5ld192YWwgIT09IG9sZF92YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJlY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgcHJvcF9uYW1lLCBfdGhpcywgX3RoaXMuX2dldF9jb21wdXRlZChwcm9wX25hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyaWdnZXIoJ2NoYW5nZScsIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgcHJvcF9zcGVjID0ge1xuICAgICAgICAgICAgJ2dldHRlcic6IGdldHRlcixcbiAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiBbXSxcbiAgICAgICAgICAgICd1c2VfY2FjaGUnOiB1c2VfY2FjaGUsXG4gICAgICAgICAgICAnY2FsbGJhY2tzJzoge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRlcDogY2hhbmdlZGVwLFxuICAgICAgICAgICAgICAgIHByb3BjaGFuZ2U6IHByb3BjaGFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZWRbcHJvcF9uYW1lXSA9IHByb3Bfc3BlYztcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNoYW5nZWRlcDpcIiArIHByb3BfbmFtZSwgcHJvcF9zcGVjWydjYWxsYmFja3MnXVsncHJvcGNoYW5nZSddKTtcbiAgICAgICAgcmV0dXJuIHByb3Bfc3BlYztcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJIYXNQcm9wcy5zZXQoJ3Byb3BfbmFtZScsIHZhbHVlKSBpcyBkZXByZWNhdGVkLCB1c2UgSGFzUHJvcHMucHJvcF9uYW1lID0gdmFsdWUgaW5zdGVhZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dihrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcF9uYW1lKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIkhhc1Byb3BzLmdldCgncHJvcF9uYW1lJykgaXMgZGVwcmVjYXRlZCwgdXNlIEhhc1Byb3BzLnByb3BfbmFtZSBpbnN0ZWFkXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR2KHByb3BfbmFtZSk7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuZ2V0diA9IGZ1bmN0aW9uIChwcm9wX25hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHNbcHJvcF9uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wZXJ0eSBcIiArIHRoaXMudHlwZSArIFwiLlwiICsgcHJvcF9uYW1lICsgXCIgd2Fzbid0IGRlY2xhcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhhc1Byb3BzLl9fc3VwZXJfXy5nZXR2LmNhbGwodGhpcywgcHJvcF9uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLl9nZXRfY29tcHV0ZWQgPSBmdW5jdGlvbiAocHJvcF9uYW1lKSB7XG4gICAgICAgIHZhciBjb21wdXRlZCwgZ2V0dGVyLCBwcm9wX3NwZWM7XG4gICAgICAgIHByb3Bfc3BlYyA9IHRoaXMuX2NvbXB1dGVkW3Byb3BfbmFtZV07XG4gICAgICAgIGlmIChwcm9wX3NwZWMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZWQgcHJvcGVydHkgXCIgKyB0aGlzLnR5cGUgKyBcIi5cIiArIHByb3BfbmFtZSArIFwiIHdhc24ndCBkZWNsYXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcF9zcGVjLnVzZV9jYWNoZSAmJiBwcm9wX3NwZWMuY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wX3NwZWMuY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBwcm9wX3NwZWMuZ2V0dGVyO1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBnZXR0ZXIuYXBwbHkodGhpcywgW3Byb3BfbmFtZV0pO1xuICAgICAgICAgICAgaWYgKHByb3Bfc3BlYy51c2VfY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBwcm9wX3NwZWMuY2FjaGUgPSBjb21wdXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlZnMuY3JlYXRlX3JlZih0aGlzKTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5zZXRfc3VidHlwZSA9IGZ1bmN0aW9uIChzdWJ0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlID0gc3VidHlwZTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5hdHRyaWJ1dGVfaXNfc2VyaWFsaXphYmxlID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIHByb3AgPSB0aGlzLnByb3BzW2F0dHJdO1xuICAgICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50eXBlICsgXCIuYXR0cmlidXRlX2lzX3NlcmlhbGl6YWJsZSgnXCIgKyBhdHRyICsgXCInKTogXCIgKyBhdHRyICsgXCIgd2Fzbid0IGRlY2xhcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICFwcm9wLmludGVybmFsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuc2VyaWFsaXphYmxlX2F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRycywgbmFtZSwgcmVmLCB2YWx1ZTtcbiAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZV9pc19zZXJpYWxpemFibGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9O1xuICAgIEhhc1Byb3BzLl92YWx1ZV90b19qc29uID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbmFsX3BhcmVudF9vYmplY3QpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVmX2FycmF5LCByZWZfb2JqLCBzdWJrZXksIHY7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhhc1Byb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVmX2FycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICAgICAgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHJlZl9hcnJheS5wdXNoKEhhc1Byb3BzLl92YWx1ZV90b19qc29uKGksIHYsIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmX2FycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZWZfb2JqID0ge307XG4gICAgICAgICAgICBmb3IgKHN1YmtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHZhbHVlLCBzdWJrZXkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZWZfb2JqW3N1YmtleV0gPSBIYXNQcm9wcy5fdmFsdWVfdG9fanNvbihzdWJrZXksIHZhbHVlW3N1YmtleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWZfb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuYXR0cmlidXRlc19hc19qc29uID0gZnVuY3Rpb24gKGluY2x1ZGVfZGVmYXVsdHMsIHZhbHVlX3RvX2pzb24pIHtcbiAgICAgICAgdmFyIGF0dHJzLCBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZV90b19qc29uID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlX3RvX2pzb24gPSBIYXNQcm9wcy5fdmFsdWVfdG9fanNvbjtcbiAgICAgICAgfVxuICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHRoaXMuX3NldF9hZnRlcl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVfdG9fanNvbihcImF0dHJpYnV0ZXNcIiwgYXR0cnMsIHRoaXMpO1xuICAgIH07XG4gICAgSGFzUHJvcHMuX2pzb25fcmVjb3JkX3JlZmVyZW5jZXMgPSBmdW5jdGlvbiAoZG9jLCB2LCByZXN1bHQsIHJlY3Vyc2UpIHtcbiAgICAgICAgdmFyIGVsZW0sIGosIGssIGxlbiwgbW9kZWwsIHJlc3VsdHMsIHJlc3VsdHMxO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmcy5pc19yZWYodikpIHtcbiAgICAgICAgICAgIGlmICghKHYuaWQgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZG9jLmdldF9tb2RlbF9ieV9pZCh2LmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzKG1vZGVsLCByZXN1bHQsIHJlY3Vyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gdi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW0gPSB2W2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChIYXNQcm9wcy5fanNvbl9yZWNvcmRfcmVmZXJlbmNlcyhkb2MsIGVsZW0sIHJlc3VsdCwgcmVjdXJzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoayBpbiB2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwodiwgaykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVsZW0gPSB2W2tdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goSGFzUHJvcHMuX2pzb25fcmVjb3JkX3JlZmVyZW5jZXMoZG9jLCBlbGVtLCByZXN1bHQsIHJlY3Vyc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzID0gZnVuY3Rpb24gKHYsIHJlc3VsdCwgcmVjdXJzZSkge1xuICAgICAgICB2YXIgZWxlbSwgaW1tZWRpYXRlLCBqLCBrLCBsLCBsZW4sIGxlbjEsIG9iaiwgcmVzdWx0cywgcmVzdWx0czEsIHJlc3VsdHMyO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEhhc1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAoISh2LmlkIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdi5pZF0gPSB2O1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZSA9IHYuX2ltbWVkaWF0ZV9yZWZlcmVuY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW1tZWRpYXRlLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBpbW1lZGlhdGVbal07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzKG9iaiwgcmVzdWx0LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gdi5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gdltsXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKEhhc1Byb3BzLl92YWx1ZV9yZWNvcmRfcmVmZXJlbmNlcyhlbGVtLCByZXN1bHQsIHJlY3Vyc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICByZXN1bHRzMiA9IFtdO1xuICAgICAgICAgICAgZm9yIChrIGluIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh2LCBrKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZWxlbSA9IHZba107XG4gICAgICAgICAgICAgICAgcmVzdWx0czIucHVzaChIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMoZWxlbSwgcmVzdWx0LCByZWN1cnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5faW1tZWRpYXRlX3JlZmVyZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRycywga2V5LCByZXN1bHQsIHZhbHVlO1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgYXR0cnMgPSB0aGlzLnNlcmlhbGl6YWJsZV9hdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModmFsdWUsIHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXMocmVzdWx0KTtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5yZWZlcmVuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmZXJlbmNlcztcbiAgICAgICAgcmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXModGhpcywgcmVmZXJlbmNlcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXMocmVmZXJlbmNlcyk7XG4gICAgfTtcbiAgICBIYXNQcm9wcy5wcm90b3R5cGUuYXR0YWNoX2RvY3VtZW50ID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCAhPT0gbnVsbCAmJiB0aGlzLmRvY3VtZW50ICE9PSBkb2MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGVscyBtdXN0IGJlIG93bmVkIGJ5IG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvYztcbiAgICAgICAgaWYgKHRoaXMuX2RvY19hdHRhY2hlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9jX2F0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5kZXRhY2hfZG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIEhhc1Byb3BzLnByb3RvdHlwZS5fdGVsbF9kb2N1bWVudF9hYm91dF9jaGFuZ2UgPSBmdW5jdGlvbiAoYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZWVkX2ludmFsaWRhdGUsIG5ld19pZCwgbmV3X3JlZiwgbmV3X3JlZnMsIG9sZF9pZCwgb2xkX3JlZiwgb2xkX3JlZnM7XG4gICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVfaXNfc2VyaWFsaXphYmxlKGF0dHIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld19yZWZzID0ge307XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMobmV3XywgbmV3X3JlZnMsIGZhbHNlKTtcbiAgICAgICAgICAgIG9sZF9yZWZzID0ge307XG4gICAgICAgICAgICBIYXNQcm9wcy5fdmFsdWVfcmVjb3JkX3JlZmVyZW5jZXMob2xkLCBvbGRfcmVmcywgZmFsc2UpO1xuICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKG5ld19pZCBpbiBuZXdfcmVmcykge1xuICAgICAgICAgICAgICAgIG5ld19yZWYgPSBuZXdfcmVmc1tuZXdfaWRdO1xuICAgICAgICAgICAgICAgIGlmICghKG5ld19pZCBpbiBvbGRfcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZWVkX2ludmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG9sZF9pZCBpbiBvbGRfcmVmcykge1xuICAgICAgICAgICAgICAgICAgICBvbGRfcmVmID0gb2xkX3JlZnNbb2xkX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEob2xkX2lkIGluIG5ld19yZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZF9pbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRfaW52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuX2ludmFsaWRhdGVfYWxsX21vZGVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuX25vdGlmeV9jaGFuZ2UodGhpcywgYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGFzUHJvcHMucHJvdG90eXBlLm1hdGVyaWFsaXplX2RhdGFzcGVjcyA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIGRhdGEsIG5hbWUsIHByb3AsIHJlZjtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIHByb3AgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXByb3AuZGF0YXNwZWMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocHJvcC5vcHRpb25hbCB8fCBmYWxzZSkgJiYgcHJvcC5zcGVjLnZhbHVlID09PSBudWxsICYmICghKG5hbWUgaW4gdGhpcy5fc2V0X2FmdGVyX2RlZmF1bHRzKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFbXCJfXCIgKyBuYW1lXSA9IHByb3AuYXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgIGlmICgocHJvcC5zcGVjLmZpZWxkICE9IG51bGwpICYmIHByb3Auc3BlYy5maWVsZCBpbiBzb3VyY2UuX3NoYXBlcykge1xuICAgICAgICAgICAgICAgIGRhdGFbXCJfXCIgKyBuYW1lICsgXCJfc2hhcGVcIl0gPSBzb3VyY2UuX3NoYXBlc1twcm9wLnNwZWMuZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBwLkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtcIm1heF9cIiArIG5hbWVdID0gYXJyYXlfMS5tYXgoZGF0YVtcIl9cIiArIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBIYXNQcm9wcztcbn0pKEJhY2tib25lLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRpc3RfdG9fc2VnbWVudF9zcXVhcmVkLCBudWxscmV0dXJuZXIsIHNxcjtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbC9hcnJheVwiKTtcbmV4cG9ydHMucG9pbnRfaW5fcG9seSA9IGZ1bmN0aW9uICh4LCB5LCBweCwgcHkpIHtcbiAgICB2YXIgaSwgaW5zaWRlLCBqLCByZWYsIHgxLCB4MiwgeTEsIHkyO1xuICAgIGluc2lkZSA9IGZhbHNlO1xuICAgIHgxID0gcHhbcHgubGVuZ3RoIC0gMV07XG4gICAgeTEgPSBweVtweS5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgeDIgPSBweFtpXTtcbiAgICAgICAgeTIgPSBweVtpXTtcbiAgICAgICAgaWYgKCh5MSA8IHkpICE9PSAoeTIgPCB5KSkge1xuICAgICAgICAgICAgaWYgKHgxICsgKHkgLSB5MSkgLyAoeTIgLSB5MSkgKiAoeDIgLSB4MSkgPCB4KSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB5MSA9IHkyO1xuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xufTtcbm51bGxyZXR1cm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLkhpdFRlc3RSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpdFRlc3RSZXN1bHQoKSB7XG4gICAgICAgIHRoaXNbJzBkJ10gPSB7XG4gICAgICAgICAgICBnbHlwaDogbnVsbCxcbiAgICAgICAgICAgIGdldF92aWV3OiBudWxscmV0dXJuZXIsXG4gICAgICAgICAgICBpbmRpY2VzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzWycxZCddID0ge1xuICAgICAgICAgICAgaW5kaWNlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1snMmQnXSA9IHtcbiAgICAgICAgICAgIGluZGljZXM6IHt9XG4gICAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18wZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMGQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18xZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMWQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaXRUZXN0UmVzdWx0LnByb3RvdHlwZSwgJ18yZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snMmQnXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEhpdFRlc3RSZXN1bHQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fMGQuaW5kaWNlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fMWQuaW5kaWNlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICByZXR1cm4gSGl0VGVzdFJlc3VsdDtcbn0pKCk7XG5leHBvcnRzLmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkhpdFRlc3RSZXN1bHQoKTtcbn07XG5leHBvcnRzLmNyZWF0ZV8xZF9oaXRfdGVzdF9yZXN1bHQgPSBmdW5jdGlvbiAoaGl0cykge1xuICAgIHZhciBfZGlzdCwgaSwgcmVzdWx0O1xuICAgIHJlc3VsdCA9IG5ldyBleHBvcnRzLkhpdFRlc3RSZXN1bHQoKTtcbiAgICByZXN1bHRbJzFkJ10uaW5kaWNlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gYXJyYXlfMS5zb3J0QnkoaGl0cywgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgdmFyIF9pLCBkaXN0O1xuICAgICAgICAgICAgX2kgPSBhcmdbMF0sIGRpc3QgPSBhcmdbMV07XG4gICAgICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZWYxID0gcmVmW2pdLCBpID0gcmVmMVswXSwgX2Rpc3QgPSByZWYxWzFdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnZhbGlkYXRlX2Jib3hfY29vcmRzID0gZnVuY3Rpb24gKGFyZywgYXJnMSkge1xuICAgIHZhciByZWYsIHJlZjEsIHgwLCB4MSwgeTAsIHkxO1xuICAgIHgwID0gYXJnWzBdLCB4MSA9IGFyZ1sxXTtcbiAgICB5MCA9IGFyZzFbMF0sIHkxID0gYXJnMVsxXTtcbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICByZWYgPSBbeDEsIHgwXSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgIH1cbiAgICBpZiAoeTAgPiB5MSkge1xuICAgICAgICByZWYxID0gW3kxLCB5MF0sIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiB4MCxcbiAgICAgICAgbWluWTogeTAsXG4gICAgICAgIG1heFg6IHgxLFxuICAgICAgICBtYXhZOiB5MVxuICAgIH07XG59O1xuc3FyID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCAqIHg7XG59O1xuZXhwb3J0cy5kaXN0XzJfcHRzID0gZnVuY3Rpb24gKHZ4LCB2eSwgd3gsIHd5KSB7XG4gICAgcmV0dXJuIHNxcih2eCAtIHd4KSArIHNxcih2eSAtIHd5KTtcbn07XG5kaXN0X3RvX3NlZ21lbnRfc3F1YXJlZCA9IGZ1bmN0aW9uIChwLCB2LCB3KSB7XG4gICAgdmFyIGwyLCB0O1xuICAgIGwyID0gZXhwb3J0cy5kaXN0XzJfcHRzKHYueCwgdi55LCB3LngsIHcueSk7XG4gICAgaWYgKGwyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRpc3RfMl9wdHMocC54LCBwLnksIHYueCwgdi55KTtcbiAgICB9XG4gICAgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGlzdF8yX3B0cyhwLngsIHAueSwgdi54LCB2LnkpO1xuICAgIH1cbiAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGlzdF8yX3B0cyhwLngsIHAueSwgdy54LCB3LnkpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5kaXN0XzJfcHRzKHAueCwgcC55LCB2LnggKyB0ICogKHcueCAtIHYueCksIHYueSArIHQgKiAody55IC0gdi55KSk7XG59O1xuZXhwb3J0cy5kaXN0X3RvX3NlZ21lbnQgPSBmdW5jdGlvbiAocCwgdiwgdykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdF90b19zZWdtZW50X3NxdWFyZWQocCwgdiwgdykpO1xufTtcbmV4cG9ydHMuY2hlY2tfMl9zZWdtZW50c19pbnRlcnNlY3QgPSBmdW5jdGlvbiAobDBfeDAsIGwwX3kwLCBsMF94MSwgbDBfeTEsIGwxX3gwLCBsMV95MCwgbDFfeDEsIGwxX3kxKSB7XG4gICAgLyogQ2hlY2sgaWYgMiBzZWdtZW50cyAobDAgYW5kIGwxKSBpbnRlcnNlY3QuIFJldHVybnMgYSBzdHJ1Y3R1cmUgd2l0aFxuICAgICAgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgICAgICAqIGhpdCAoYm9vbGVhbik6IHdoZXRoZXIgdGhlIDIgc2VnbWVudHMgaW50ZXJzZWN0XG4gICAgICAgICogeCAoZmxvYXQpOiB4IGNvb3JkaW5hdGUgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAqIHkgKGZsb2F0KTogeSBjb29yZGluYXRlIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgKi9cbiAgICB2YXIgYSwgYiwgZGVuLCBudW0xLCBudW0yLCB4LCB5O1xuICAgIGRlbiA9ICgobDFfeTEgLSBsMV95MCkgKiAobDBfeDEgLSBsMF94MCkpIC0gKChsMV94MSAtIGwxX3gwKSAqIChsMF95MSAtIGwwX3kwKSk7XG4gICAgaWYgKGRlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGl0OiBmYWxzZSxcbiAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICB5OiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhID0gbDBfeTAgLSBsMV95MDtcbiAgICAgICAgYiA9IGwwX3gwIC0gbDFfeDA7XG4gICAgICAgIG51bTEgPSAoKGwxX3gxIC0gbDFfeDApICogYSkgLSAoKGwxX3kxIC0gbDFfeTApICogYik7XG4gICAgICAgIG51bTIgPSAoKGwwX3gxIC0gbDBfeDApICogYSkgLSAoKGwwX3kxIC0gbDBfeTApICogYik7XG4gICAgICAgIGEgPSBudW0xIC8gZGVuO1xuICAgICAgICBiID0gbnVtMiAvIGRlbjtcbiAgICAgICAgeCA9IGwwX3gwICsgKGEgKiAobDBfeDEgLSBsMF94MCkpO1xuICAgICAgICB5ID0gbDBfeTAgKyAoYSAqIChsMF95MSAtIGwwX3kwKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaXQ6IChhID4gMCAmJiBhIDwgMSkgJiYgKGIgPiAwICYmIGIgPCAxKSxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3NvbHZlclwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTGF5b3V0Q2FudmFzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExheW91dENhbnZhcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGF5b3V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gTGF5b3V0Q2FudmFzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLnR5cGUgPSAnTGF5b3V0Q2FudmFzJztcbiAgICBMYXlvdXRDYW52YXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgTGF5b3V0Q2FudmFzLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJ0b3AgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcImxlZnQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJ3aWR0aCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJoZWlnaHQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJyaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYm90dG9tID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiYm90dG9tIFwiICsgdGhpcy5pZCk7XG4gICAgfTtcbiAgICBMYXlvdXRDYW52YXMuZ2V0dGVycyh7XG4gICAgICAgIGhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodC52YWx1ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB3aWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoLnZhbHVlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQudmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQudmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9wLnZhbHVlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdHRvbS52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgTGF5b3V0Q2FudmFzLmludGVybmFsKHtcbiAgICAgICAgbGF5b3V0X2xvY2F0aW9uOiBbcC5BbnldXG4gICAgfSk7XG4gICAgTGF5b3V0Q2FudmFzLnByb3RvdHlwZS5nZXRfZWRpdF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlZGl0YWJsZXM7XG4gICAgICAgIGVkaXRhYmxlcyA9IFtdO1xuICAgICAgICBlZGl0YWJsZXMucHVzaCh7XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlOiB0aGlzLl90b3AsXG4gICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0YWJsZXMucHVzaCh7XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlOiB0aGlzLl9sZWZ0LFxuICAgICAgICAgICAgc3RyZW5ndGg6IHNvbHZlcl8xLlN0cmVuZ3RoLnN0cm9uZ1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdGFibGVzLnB1c2goe1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0YWJsZXMucHVzaCh7XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlOiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWRpdGFibGVzO1xuICAgIH07XG4gICAgTGF5b3V0Q2FudmFzLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXRDYW52YXM7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFMUEhBQkVUSUMsIEJPVFRPTSwgQ0VOVEVSLCBIQU5HSU5HLCBMRUZULCBNSURETEUsIFJJR0hULCBUT1AsIF9hbGlnbl9sb29rdXAsIF9hbGlnbl9sb29rdXBfbmVnYXRpdmUsIF9hbGlnbl9sb29rdXBfcG9zaXRpdmUsIF9hbmdsZV9sb29rdXAsIF9iYXNlbGluZV9sb29rdXAsIHBpMiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcIi4vc29sdmVyXCIpO1xudmFyIGxheW91dF9jYW52YXNfMSA9IHJlcXVpcmUoXCIuL2xheW91dF9jYW52YXNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnBpMiA9IE1hdGguUEkgLyAyO1xuQUxQSEFCRVRJQyA9ICdhbHBoYWJldGljJztcblRPUCA9ICd0b3AnO1xuQk9UVE9NID0gJ2JvdHRvbSc7XG5NSURETEUgPSAnbWlkZGxlJztcbkhBTkdJTkcgPSAnaGFuZ2luZyc7XG5MRUZUID0gJ2xlZnQnO1xuUklHSFQgPSAncmlnaHQnO1xuQ0VOVEVSID0gJ2NlbnRlcic7XG5fYW5nbGVfbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIHBhcmFsbGVsOiAwLFxuICAgICAgICBub3JtYWw6IC1waTIsXG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiAtcGkyXG4gICAgfSxcbiAgICBiZWxvdzoge1xuICAgICAgICBwYXJhbGxlbDogMCxcbiAgICAgICAgbm9ybWFsOiBwaTIsXG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiBwaTJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAgcGFyYWxsZWw6IC1waTIsXG4gICAgICAgIG5vcm1hbDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgdmVydGljYWw6IC1waTJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIHBhcmFsbGVsOiBwaTIsXG4gICAgICAgIG5vcm1hbDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgdmVydGljYWw6IHBpMlxuICAgIH1cbn07XG5fYmFzZWxpbmVfbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIGp1c3RpZmllZDogVE9QLFxuICAgICAgICBwYXJhbGxlbDogQUxQSEFCRVRJQyxcbiAgICAgICAgbm9ybWFsOiBNSURETEUsXG4gICAgICAgIGhvcml6b250YWw6IEFMUEhBQkVUSUMsXG4gICAgICAgIHZlcnRpY2FsOiBNSURETEVcbiAgICB9LFxuICAgIGJlbG93OiB7XG4gICAgICAgIGp1c3RpZmllZDogQk9UVE9NLFxuICAgICAgICBwYXJhbGxlbDogSEFOR0lORyxcbiAgICAgICAgbm9ybWFsOiBNSURETEUsXG4gICAgICAgIGhvcml6b250YWw6IEhBTkdJTkcsXG4gICAgICAgIHZlcnRpY2FsOiBNSURETEVcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBUT1AsXG4gICAgICAgIHBhcmFsbGVsOiBBTFBIQUJFVElDLFxuICAgICAgICBub3JtYWw6IE1JRERMRSxcbiAgICAgICAgaG9yaXpvbnRhbDogTUlERExFLFxuICAgICAgICB2ZXJ0aWNhbDogQUxQSEFCRVRJQ1xuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBUT1AsXG4gICAgICAgIHBhcmFsbGVsOiBBTFBIQUJFVElDLFxuICAgICAgICBub3JtYWw6IE1JRERMRSxcbiAgICAgICAgaG9yaXpvbnRhbDogTUlERExFLFxuICAgICAgICB2ZXJ0aWNhbDogQUxQSEFCRVRJQ1xuICAgIH1cbn07XG5fYWxpZ25fbG9va3VwID0ge1xuICAgIGFib3ZlOiB7XG4gICAgICAgIGp1c3RpZmllZDogQ0VOVEVSLFxuICAgICAgICBwYXJhbGxlbDogQ0VOVEVSLFxuICAgICAgICBub3JtYWw6IExFRlQsXG4gICAgICAgIGhvcml6b250YWw6IENFTlRFUixcbiAgICAgICAgdmVydGljYWw6IExFRlRcbiAgICB9LFxuICAgIGJlbG93OiB7XG4gICAgICAgIGp1c3RpZmllZDogQ0VOVEVSLFxuICAgICAgICBwYXJhbGxlbDogQ0VOVEVSLFxuICAgICAgICBub3JtYWw6IExFRlQsXG4gICAgICAgIGhvcml6b250YWw6IENFTlRFUixcbiAgICAgICAgdmVydGljYWw6IFJJR0hUXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICAgIGp1c3RpZmllZDogQ0VOVEVSLFxuICAgICAgICBwYXJhbGxlbDogQ0VOVEVSLFxuICAgICAgICBub3JtYWw6IFJJR0hULFxuICAgICAgICBob3Jpem9udGFsOiBSSUdIVCxcbiAgICAgICAgdmVydGljYWw6IENFTlRFUlxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgICAganVzdGlmaWVkOiBDRU5URVIsXG4gICAgICAgIHBhcmFsbGVsOiBDRU5URVIsXG4gICAgICAgIG5vcm1hbDogTEVGVCxcbiAgICAgICAgaG9yaXpvbnRhbDogTEVGVCxcbiAgICAgICAgdmVydGljYWw6IENFTlRFUlxuICAgIH1cbn07XG5fYWxpZ25fbG9va3VwX25lZ2F0aXZlID0ge1xuICAgIGFib3ZlOiBSSUdIVCxcbiAgICBiZWxvdzogTEVGVCxcbiAgICBsZWZ0OiBSSUdIVCxcbiAgICByaWdodDogTEVGVFxufTtcbl9hbGlnbl9sb29rdXBfcG9zaXRpdmUgPSB7XG4gICAgYWJvdmU6IExFRlQsXG4gICAgYmVsb3c6IFJJR0hULFxuICAgIGxlZnQ6IFJJR0hULFxuICAgIHJpZ2h0OiBMRUZUXG59O1xuZXhwb3J0cy51cGRhdGVfY29uc3RyYWludHMgPSBmdW5jdGlvbiAodmlldykge1xuICAgIHZhciBzLCBzaWRlLCBzaXplLCB2O1xuICAgIHYgPSB2aWV3O1xuICAgIGlmICh2Lm1vZGVsLnByb3BzLnZpc2libGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAodi5tb2RlbC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpemUgPSB2Ll9nZXRfc2l6ZSgpO1xuICAgIGlmICh2Ll9sYXN0X3NpemUgPT0gbnVsbCkge1xuICAgICAgICB2Ll9sYXN0X3NpemUgPSAtMTtcbiAgICB9XG4gICAgaWYgKHNpemUgPT09IHYuX2xhc3Rfc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgPSB2Lm1vZGVsLmRvY3VtZW50LnNvbHZlcigpO1xuICAgIHYuX2xhc3Rfc2l6ZSA9IHNpemU7XG4gICAgaWYgKHYuX3NpemVfY29uc3RyYWludCAhPSBudWxsKSB7XG4gICAgICAgIHMucmVtb3ZlX2NvbnN0cmFpbnQodi5fc2l6ZV9jb25zdHJhaW50LCB0cnVlKTtcbiAgICB9XG4gICAgdi5fc2l6ZV9jb25zdHJhaW50ID0gc29sdmVyXzEuR0Uodi5tb2RlbC5wYW5lbC5fc2l6ZSwgLXNpemUpO1xuICAgIHMuYWRkX2NvbnN0cmFpbnQodi5fc2l6ZV9jb25zdHJhaW50KTtcbiAgICBpZiAodi5fZnVsbF9zZXQgPT0gbnVsbCkge1xuICAgICAgICB2Ll9mdWxsX3NldCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXYuX2Z1bGxfc2V0KSB7XG4gICAgICAgIHNpZGUgPSB2Lm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSAnYWJvdmUnIHx8IHNpZGUgPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHMuYWRkX2NvbnN0cmFpbnQoc29sdmVyXzEuRVEodi5tb2RlbC5wYW5lbC5fd2lkdGgsIFstMSwgdi5wbG90X21vZGVsLmNhbnZhcy5fd2lkdGhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0JyB8fCBzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBzLmFkZF9jb25zdHJhaW50KHNvbHZlcl8xLkVRKHYubW9kZWwucGFuZWwuX2hlaWdodCwgWy0xLCB2LnBsb3RfbW9kZWwuY2FudmFzLl9oZWlnaHRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYuX2Z1bGxfc2V0ID0gdHJ1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5TaWRlUGFuZWwgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2lkZVBhbmVsLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTaWRlUGFuZWwoKSB7XG4gICAgICAgIHJldHVybiBTaWRlUGFuZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNpZGVQYW5lbC5pbnRlcm5hbCh7XG4gICAgICAgIHNpZGU6IFtwLlN0cmluZ10sXG4gICAgICAgIHBsb3Q6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIFNpZGVQYW5lbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBTaWRlUGFuZWwuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWJvdmVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9kaW0gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbHMgPSBbMCwgLTFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvciA9IHRoaXMuX2JvdHRvbTtcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFscyA9IFswLCAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaXplID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3IgPSB0aGlzLl90b3A7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFscyA9IFstMSwgMF07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3IgPSB0aGlzLl9yaWdodDtcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2RpbSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFscyA9IFsxLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaXplID0gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvciA9IHRoaXMuX2xlZnQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwidW5yZWNvZ25pemVkIHNpZGU6ICdcIiArIHRoaXMuc2lkZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2lkZVBhbmVsLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cztcbiAgICAgICAgY29uc3RyYWludHMgPSBbXTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl90b3ApKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9ib3R0b20pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9sZWZ0KSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5fcmlnaHQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl93aWR0aCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2hlaWdodCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX2xlZnQsIHRoaXMuX3dpZHRoLCBbLTEsIHRoaXMuX3JpZ2h0XSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX2JvdHRvbSwgdGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMuX3RvcF0pKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgU2lkZVBhbmVsLnByb3RvdHlwZS5hcHBseV9sYWJlbF90ZXh0X2hldXJpc3RpY3MgPSBmdW5jdGlvbiAoY3R4LCBvcmllbnQpIHtcbiAgICAgICAgdmFyIGFsaWduLCBiYXNlbGluZSwgc2lkZTtcbiAgICAgICAgc2lkZSA9IHRoaXMuc2lkZTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcob3JpZW50KSkge1xuICAgICAgICAgICAgYmFzZWxpbmUgPSBfYmFzZWxpbmVfbG9va3VwW3NpZGVdW29yaWVudF07XG4gICAgICAgICAgICBhbGlnbiA9IF9hbGlnbl9sb29rdXBbc2lkZV1bb3JpZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmllbnQgPT09IDApIHtcbiAgICAgICAgICAgIGJhc2VsaW5lID0gX2Jhc2VsaW5lX2xvb2t1cFtzaWRlXVtvcmllbnRdO1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ25fbG9va3VwW3NpZGVdW29yaWVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3JpZW50IDwgMCkge1xuICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduX2xvb2t1cF9uZWdhdGl2ZVtzaWRlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmllbnQgPiAwKSB7XG4gICAgICAgICAgICBiYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYWxpZ24gPSBfYWxpZ25fbG9va3VwX3Bvc2l0aXZlW3NpZGVdO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWduO1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gICAgU2lkZVBhbmVsLnByb3RvdHlwZS5nZXRfbGFiZWxfYW5nbGVfaGV1cmlzdGljID0gZnVuY3Rpb24gKG9yaWVudCkge1xuICAgICAgICB2YXIgc2lkZTtcbiAgICAgICAgc2lkZSA9IHRoaXMuc2lkZTtcbiAgICAgICAgcmV0dXJuIF9hbmdsZV9sb29rdXBbc2lkZV1bb3JpZW50XTtcbiAgICB9O1xuICAgIHJldHVybiBTaWRlUGFuZWw7XG59KShsYXlvdXRfY2FudmFzXzEuTGF5b3V0Q2FudmFzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9jb25zdHJhaW5lciwgX3dlYWtfY29uc3RyYWluZXIsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBraXdpXzEgPSByZXF1aXJlKFwia2l3aVwiKTtcbmV4cG9ydHMuVmFyaWFibGUgPSBraXdpXzEuVmFyaWFibGU7XG5leHBvcnRzLkV4cHJlc3Npb24gPSBraXdpXzEuRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ29uc3RyYWludCA9IGtpd2lfMS5Db25zdHJhaW50O1xuZXhwb3J0cy5PcGVyYXRvciA9IGtpd2lfMS5PcGVyYXRvcjtcbmV4cG9ydHMuU3RyZW5ndGggPSBraXdpXzEuU3RyZW5ndGg7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi4vZXZlbnRzXCIpO1xuX2NvbnN0cmFpbmVyID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHByO1xuICAgICAgICAgICAgZXhwciA9IE9iamVjdC5jcmVhdGUoa2l3aV8xLkV4cHJlc3Npb24ucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGtpd2lfMS5FeHByZXNzaW9uLmFwcGx5KGV4cHIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGtpd2lfMS5Db25zdHJhaW50KGV4cHIsIG9wKTtcbiAgICAgICAgfTtcbiAgICB9KSh0aGlzKTtcbn07XG5fd2Vha19jb25zdHJhaW5lciA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmcsIGFyZ3MsIGksIGxlbjtcbiAgICAgICAgYXJncyA9IFtudWxsXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGtpd2lfMS5Db25zdHJhaW50KG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoa2l3aV8xLkV4cHJlc3Npb24sIGFyZ3MpKSwgb3AsIGtpd2lfMS5TdHJlbmd0aC53ZWFrKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuRVEgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkVxKTtcbmV4cG9ydHMuTEUgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkxlKTtcbmV4cG9ydHMuR0UgPSBfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkdlKTtcbmV4cG9ydHMuV0VBS19FUSA9IF93ZWFrX2NvbnN0cmFpbmVyKGtpd2lfMS5PcGVyYXRvci5FcSk7XG5leHBvcnRzLldFQUtfTEUgPSBfd2Vha19jb25zdHJhaW5lcihraXdpXzEuT3BlcmF0b3IuTGUpO1xuZXhwb3J0cy5XRUFLX0dFID0gX3dlYWtfY29uc3RyYWluZXIoa2l3aV8xLk9wZXJhdG9yLkdlKTtcbmV4cG9ydHMuU29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBleHRlbmQoU29sdmVyLnByb3RvdHlwZSwgZXZlbnRzXzEuRXZlbnRzKTtcbiAgICBmdW5jdGlvbiBTb2x2ZXIoKSB7XG4gICAgICAgIHRoaXMuc29sdmVyID0gbmV3IGtpd2lfMS5Tb2x2ZXIoKTtcbiAgICB9XG4gICAgU29sdmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVyID0gbmV3IGtpd2lfMS5Tb2x2ZXIoKTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNvbHZlcltudW1fY29uc3RyYWludHM9XCIgKyAodGhpcy5udW1fY29uc3RyYWludHMoKSkgKyBcIiwgbnVtX2VkaXRfdmFyaWFibGVzPVwiICsgKHRoaXMubnVtX2VkaXRfdmFyaWFibGVzKCkpICsgXCJdXCI7XG4gICAgfTtcbiAgICBTb2x2ZXIucHJvdG90eXBlLm51bV9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVyLl9jbk1hcC5fYXJyYXkubGVuZ3RoO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5udW1fZWRpdF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHZlci5fZWRpdE1hcC5fYXJyYXkubGVuZ3RoO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS51cGRhdGVfdmFyaWFibGVzID0gZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRyaWdnZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJpZ2dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2x2ZXIudXBkYXRlVmFyaWFibGVzKCk7XG4gICAgICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdsYXlvdXRfdXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkX2NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZXIuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlX2NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCwgc2lsZW50KSB7XG4gICAgICAgIGlmIChzaWxlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVyLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludCwgc2lsZW50KTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkX2VkaXRfdmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUsIHN0cmVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHZlci5hZGRFZGl0VmFyaWFibGUodmFyaWFibGUsIHN0cmVuZ3RoKTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlX2VkaXRfdmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUsIHNpbGVudCkge1xuICAgICAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHNpbGVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHZlci5yZW1vdmVFZGl0VmFyaWFibGUodmFyaWFibGUsIHN0cmVuZ3RoLCBzaWxlbnQpO1xuICAgIH07XG4gICAgU29sdmVyLnByb3RvdHlwZS5zdWdnZXN0X3ZhbHVlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2x2ZXIuc3VnZ2VzdFZhbHVlKHZhcmlhYmxlLCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU29sdmVyO1xufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ0xldmVsLCBfbG9nZ2VycywgX21ldGhvZF9mYWN0b3J5LCBub29wLCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi91dGlsL3R5cGVzXCIpO1xubm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbl9tZXRob2RfZmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2RfbmFtZSwgbG9nZ2VyX25hbWUpIHtcbiAgICBpZiAoY29uc29sZVttZXRob2RfbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29uc29sZVttZXRob2RfbmFtZV0uYmluZChjb25zb2xlLCBsb2dnZXJfbmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnNvbGUubG9nICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSwgbG9nZ2VyX25hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxufTtcbl9sb2dnZXJzID0ge307XG5Mb2dMZXZlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nTGV2ZWwobmFtZSwgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gTG9nTGV2ZWw7XG59KSgpO1xuZXhwb3J0cy5Mb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIExvZ2dlci5UUkFDRSA9IG5ldyBMb2dMZXZlbChcInRyYWNlXCIsIDApO1xuICAgIExvZ2dlci5ERUJVRyA9IG5ldyBMb2dMZXZlbChcImRlYnVnXCIsIDEpO1xuICAgIExvZ2dlci5JTkZPID0gbmV3IExvZ0xldmVsKFwiaW5mb1wiLCAyKTtcbiAgICBMb2dnZXIuV0FSTiA9IG5ldyBMb2dMZXZlbChcIndhcm5cIiwgNik7XG4gICAgTG9nZ2VyLkVSUk9SID0gbmV3IExvZ0xldmVsKFwiZXJyb3JcIiwgNyk7XG4gICAgTG9nZ2VyLkZBVEFMID0gbmV3IExvZ0xldmVsKFwiZmF0YWxcIiwgOCk7XG4gICAgTG9nZ2VyLk9GRiA9IG5ldyBMb2dMZXZlbChcIm9mZlwiLCA5KTtcbiAgICBMb2dnZXIubG9nX2xldmVscyA9IHtcbiAgICAgICAgdHJhY2U6IExvZ2dlci5UUkFDRSxcbiAgICAgICAgZGVidWc6IExvZ2dlci5ERUJVRyxcbiAgICAgICAgaW5mbzogTG9nZ2VyLklORk8sXG4gICAgICAgIHdhcm46IExvZ2dlci5XQVJOLFxuICAgICAgICBlcnJvcjogTG9nZ2VyLkVSUk9SLFxuICAgICAgICBmYXRhbDogTG9nZ2VyLkZBVEFMLFxuICAgICAgICBvZmY6IExvZ2dlci5PRkZcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXIsICdsZXZlbHMnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKExvZ2dlci5sb2dfbGV2ZWxzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIExvZ2dlci5nZXQgPSBmdW5jdGlvbiAobmFtZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGxvZ2dlcjtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldmVsID0gTG9nZ2VyLklORk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcobmFtZSkgJiYgbmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzW25hbWVdID0gbmV3IExvZ2dlcihuYW1lLCBsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxvZ2dlci5nZXQoKSBleHBlY3RzIGEgc3RyaW5nIG5hbWUgYW5kIGFuIG9wdGlvbmFsIGxvZy1sZXZlbFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXZlbCA9IExvZ2dlci5JTkZPO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNldF9sZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXIucHJvdG90eXBlLCAnbGV2ZWwnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2xldmVsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdldF9sZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ19sZXZlbDtcbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuc2V0X2xldmVsID0gZnVuY3Rpb24gKGxvZ19sZXZlbCkge1xuICAgICAgICB2YXIgX18sIGxvZ2dlcl9uYW1lLCBtZXRob2RfbmFtZSwgcmVmLCByZXN1bHRzO1xuICAgICAgICBpZiAobG9nX2xldmVsIGluc3RhbmNlb2YgTG9nTGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ19sZXZlbCA9IGxvZ19sZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzU3RyaW5nKGxvZ19sZXZlbCkgJiYgKExvZ2dlci5sb2dfbGV2ZWxzW2xvZ19sZXZlbF0gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ19sZXZlbCA9IExvZ2dlci5sb2dfbGV2ZWxzW2xvZ19sZXZlbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dnZXIuc2V0X2xldmVsKCkgZXhwZWN0cyBhIGxvZy1sZXZlbCBvYmplY3Qgb3IgYSBzdHJpbmcgbmFtZSBvZiBhIGxvZy1sZXZlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfbmFtZSA9IFwiW1wiICsgdGhpcy5fbmFtZSArIFwiXVwiO1xuICAgICAgICByZWYgPSBMb2dnZXIubG9nX2xldmVscztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9fIGluIHJlZikge1xuICAgICAgICAgICAgbG9nX2xldmVsID0gcmVmW19fXTtcbiAgICAgICAgICAgIGlmIChsb2dfbGV2ZWwgPT09IExvZ2dlci5PRkYpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZF9uYW1lID0gbG9nX2xldmVsLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ19sZXZlbC5sZXZlbCA8IHRoaXMuX2xvZ19sZXZlbC5sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpc1ttZXRob2RfbmFtZV0gPSBub29wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzW21ldGhvZF9uYW1lXSA9IF9tZXRob2RfZmFjdG9yeShtZXRob2RfbmFtZSwgbG9nZ2VyX25hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSkoKTtcbmV4cG9ydHMubG9nZ2VyID0gZXhwb3J0cy5Mb2dnZXIuZ2V0KFwiYm9rZWhcIik7XG5leHBvcnRzLnNldF9sb2dfbGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICBpZiAoaW5kZXhPZi5jYWxsKGV4cG9ydHMuTG9nZ2VyLmxldmVscywgbGV2ZWwpIDwgMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltib2tlaF0gdW5yZWNvZ25pemVkIGxvZ2dpbmcgbGV2ZWwgJ1wiICsgbGV2ZWwgKyBcIicgcGFzc2VkIHRvIEJva2VoLnNldF9sb2dfbGV2ZWwoKSwgaWdub3JpbmdcIik7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIltib2tlaF0gdmFsaWQgbG9nIGxldmVscyBhcmU6IFwiICsgKGV4cG9ydHMuTG9nZ2VyLmxldmVscy5qb2luKCcsICcpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltib2tlaF0gc2V0dGluZyBsb2cgbGV2ZWwgdG86ICdcIiArIGxldmVsICsgXCInXCIpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5sb2dnZXIuc2V0X2xldmVsKGxldmVsKTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xudmFyIGVudW1zID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG52YXIgc3ZnX2NvbG9ycyA9IHJlcXVpcmUoXCIuL3V0aWwvc3ZnX2NvbG9yc1wiKTtcbnZhciBjb2xvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9jb2xvclwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbC9hcnJheVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGV4dGVuZChQcm9wZXJ0eS5wcm90b3R5cGUsIGV2ZW50c18xLkV2ZW50cyk7XG4gICAgUHJvcGVydHkucHJvdG90eXBlLmRhdGFzcGVjID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gUHJvcGVydHkoYXJnKSB7XG4gICAgICAgIHRoaXMub2JqID0gYXJnLm9iaiwgdGhpcy5hdHRyID0gYXJnLmF0dHIsIHRoaXMuZGVmYXVsdF92YWx1ZSA9IGFyZy5kZWZhdWx0X3ZhbHVlO1xuICAgICAgICB0aGlzLl9pbml0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm9iaiwgXCJjaGFuZ2U6XCIgKyB0aGlzLmF0dHIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luaXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub2JqLnRyaWdnZXIoXCJwcm9wY2hhbmdlXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdCgpO1xuICAgIH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChkb19zcGVjX3RyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoZG9fc3BlY190cmFuc2Zvcm0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9fc3BlY190cmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNwZWMudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIHJldHJpZXZlIHByb3BlcnR5IHZhbHVlIGZvciBwcm9wZXJ0eSB3aXRob3V0IHZhbHVlIHNwZWNpZmljYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gdGhpcy50cmFuc2Zvcm0oW3RoaXMuc3BlYy52YWx1ZV0pWzBdO1xuICAgICAgICBpZiAoKHRoaXMuc3BlYy50cmFuc2Zvcm0gIT0gbnVsbCkgJiYgZG9fc3BlY190cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuc3BlYy50cmFuc2Zvcm0uY29tcHV0ZShyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBkYXRhLCBpLCBsZW5ndGgsIHJldCwgdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5kYXRhc3BlYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIHJldHJpZXZlIHByb3BlcnR5IGFycmF5IGZvciBub24tZGF0YXNwZWMgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHNvdXJjZS5kYXRhO1xuICAgICAgICBpZiAodGhpcy5zcGVjLmZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMuZmllbGQgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMudHJhbnNmb3JtKHNvdXJjZS5nZXRfY29sdW1uKHRoaXMuc3BlYy5maWVsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIHJldHJpZXZlIHByb3BlcnR5IGFycmF5IGZvciBub25leGlzdGVudCBmaWVsZCAnXCIgKyB0aGlzLnNwZWMuZmllbGQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2UuZ2V0X2xlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZShmYWxzZSk7XG4gICAgICAgICAgICByZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBsZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3BlYy50cmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5zcGVjLnRyYW5zZm9ybS52X2NvbXB1dGUocmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIGF0dHIsIGF0dHJfdmFsdWUsIGRlZmF1bHRfdmFsdWUsIG9iajtcbiAgICAgICAgaWYgKHRyaWdnZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJpZ2dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm9wZXJ0eSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3BlcnR5IG9iamVjdCBtdXN0IGJlIGEgSGFzUHJvcHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IHRoaXMuYXR0cjtcbiAgICAgICAgaWYgKGF0dHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm9wZXJ0eSBhdHRyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJfdmFsdWUgPSBvYmouZ2V0dihhdHRyKTtcbiAgICAgICAgaWYgKGF0dHJfdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSA9IHRoaXMuZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgIGF0dHJfdmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkZWZhdWx0X3ZhbHVlICE9PSB2b2lkIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhdHlwZXNfMS5pc0FycmF5KGRlZmF1bHRfdmFsdWUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5XzEuY29weShkZWZhdWx0X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhdHlwZXNfMS5pc0Z1bmN0aW9uKGRlZmF1bHRfdmFsdWUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRfdmFsdWUob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBvYmouc2V0dihhdHRyLCBhdHRyX3ZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGF0dHJfdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWMgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJfdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc09iamVjdChhdHRyX3ZhbHVlKSAmJiAoKGF0dHJfdmFsdWUudmFsdWUgPT09IHZvaWQgMCkgIT09IChhdHRyX3ZhbHVlLmZpZWxkID09PSB2b2lkIDApKSkge1xuICAgICAgICAgICAgdGhpcy5zcGVjID0gYXR0cl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BlYyA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXR0cl92YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuc3BlYy5maWVsZCAhPSBudWxsKSAmJiAhdHlwZXNfMS5pc1N0cmluZyh0aGlzLnNwZWMuZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCB2YWx1ZSBmb3IgcHJvcGVydHkgJ1wiICsgYXR0ciArIFwiJyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3BlYy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKHRoaXMuc3BlYy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHk7XG59KSgpO1xuZXhwb3J0cy5zaW1wbGVfcHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBwcmVkKSB7XG4gICAgdmFyIFByb3A7XG4gICAgcmV0dXJuIFByb3AgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgZXh0ZW5kKFByb3AsIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiBQcm9wKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb3AuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSArIFwiKG9iajogXCIgKyB0aGlzLm9iai5pZCArIFwiLCBzcGVjOiBcIiArIChKU09OLnN0cmluZ2lmeSh0aGlzLnNwZWMpKSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICBQcm9wLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFwcmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgcHJvcGVydHkgJ1wiICsgdGhpcy5hdHRyICsgXCInIGdpdmVuIGludmFsaWQgdmFsdWU6IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvcDtcbiAgICB9KShleHBvcnRzLlByb3BlcnR5KTtcbn07XG5leHBvcnRzLkFueSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbnksIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFueSgpIHtcbiAgICAgICAgcmV0dXJuIEFueS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEFueTtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJBbnlcIiwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmV4cG9ydHMuQXJyYXkgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXJyYXksIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFycmF5KCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheTtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJBcnJheVwiLCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB0eXBlc18xLmlzQXJyYXkoeCkgfHwgeCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheTtcbn0pKTtcbmV4cG9ydHMuQm9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb29sKCkge1xuICAgICAgICByZXR1cm4gQm9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2w7XG59KShleHBvcnRzLnNpbXBsZV9wcm9wKFwiQm9vbFwiLCB0eXBlc18xLmlzQm9vbGVhbikpO1xuZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy5Cb29sO1xuZXhwb3J0cy5Db2xvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2xvciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiBDb2xvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbG9yO1xufSkoZXhwb3J0cy5zaW1wbGVfcHJvcChcIkNvbG9yXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIChzdmdfY29sb3JzW3gudG9Mb3dlckNhc2UoKV0gIT0gbnVsbCkgfHwgeC5zdWJzdHJpbmcoMCwgMSkgPT09IFwiI1wiIHx8IGNvbG9yXzEudmFsaWRfcmdiKHgpO1xufSkpO1xuZXhwb3J0cy5JbnN0YW5jZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnN0YW5jZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBJbnN0YW5jZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEluc3RhbmNlO1xufSkoZXhwb3J0cy5zaW1wbGVfcHJvcChcIkluc3RhbmNlXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHgucHJvcGVydGllcyAhPSBudWxsO1xufSkpO1xuZXhwb3J0cy5OdW1iZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTnVtYmVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXI7XG59KShleHBvcnRzLnNpbXBsZV9wcm9wKFwiTnVtYmVyXCIsIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHR5cGVzXzEuaXNOdW1iZXIoeCkgfHwgdHlwZXNfMS5pc0Jvb2xlYW4oeCk7XG59KSk7XG5leHBvcnRzLkludCA9IGV4cG9ydHMuTnVtYmVyO1xuZXhwb3J0cy5QZXJjZW50ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBlcmNlbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBlcmNlbnQoKSB7XG4gICAgICAgIHJldHVybiBQZXJjZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUGVyY2VudDtcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJOdW1iZXJcIiwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKHR5cGVzXzEuaXNOdW1iZXIoeCkgfHwgdHlwZXNfMS5pc0Jvb2xlYW4oeCkpICYmICgoMCA8PSB4ICYmIHggPD0gMS4wKSk7XG59KSk7XG5leHBvcnRzLlN0cmluZyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZztcbn0pKGV4cG9ydHMuc2ltcGxlX3Byb3AoXCJTdHJpbmdcIiwgdHlwZXNfMS5pc1N0cmluZykpO1xuZXhwb3J0cy5Gb250ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZvbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICAgIHJldHVybiBGb250Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRm9udDtcbn0pKGV4cG9ydHMuU3RyaW5nKTtcbmV4cG9ydHMuZW51bV9wcm9wID0gZnVuY3Rpb24gKG5hbWUsIGVudW1fdmFsdWVzKSB7XG4gICAgdmFyIEVudW07XG4gICAgcmV0dXJuIEVudW0gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgZXh0ZW5kKEVudW0sIHN1cGVyQ2xhc3MpO1xuICAgICAgICBmdW5jdGlvbiBFbnVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIEVudW0uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgRW51bS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSArIFwiKG9iajogXCIgKyB0aGlzLm9iai5pZCArIFwiLCBzcGVjOiBcIiArIChKU09OLnN0cmluZ2lmeSh0aGlzLnNwZWMpKSArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW51bTtcbiAgICB9KShleHBvcnRzLnNpbXBsZV9wcm9wKG5hbWUsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoZW51bV92YWx1ZXMsIHgpID49IDA7XG4gICAgfSkpO1xufTtcbmV4cG9ydHMuQW5jaG9yID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFuY2hvciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5jaG9yKCkge1xuICAgICAgICByZXR1cm4gQW5jaG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gQW5jaG9yO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJBbmNob3JcIiwgZW51bXMuTGVnZW5kTG9jYXRpb24pKTtcbmV4cG9ydHMuQW5nbGVVbml0cyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbmdsZVVuaXRzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbmdsZVVuaXRzKCkge1xuICAgICAgICByZXR1cm4gQW5nbGVVbml0cy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEFuZ2xlVW5pdHM7XG59KShleHBvcnRzLmVudW1fcHJvcChcIkFuZ2xlVW5pdHNcIiwgZW51bXMuQW5nbGVVbml0cykpO1xuZXhwb3J0cy5EaXJlY3Rpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGlyZWN0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpcmVjdGlvbi5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdmFsdWVzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb2NrJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FudGljbG9jayc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3Rpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIkRpcmVjdGlvblwiLCBlbnVtcy5EaXJlY3Rpb24pKTtcbmV4cG9ydHMuRGltZW5zaW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERpbWVuc2lvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gRGltZW5zaW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRGltZW5zaW9uO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJEaW1lbnNpb25cIiwgZW51bXMuRGltZW5zaW9uKSk7XG5leHBvcnRzLkRpbWVuc2lvbnMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGltZW5zaW9ucywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIERpbWVuc2lvbnMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBEaW1lbnNpb25zO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJEaW1lbnNpb25zXCIsIGVudW1zLkRpbWVuc2lvbnMpKTtcbmV4cG9ydHMuRm9udFN0eWxlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZvbnRTdHlsZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRm9udFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gRm9udFN0eWxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRm9udFN0eWxlO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJGb250U3R5bGVcIiwgZW51bXMuRm9udFN0eWxlKSk7XG5leHBvcnRzLkxhdExvbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYXRMb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExhdExvbigpIHtcbiAgICAgICAgcmV0dXJuIExhdExvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIExhdExvbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiTGF0TG9uXCIsIGVudW1zLkxhdExvbikpO1xuZXhwb3J0cy5MaW5lQ2FwID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVDYXAsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVDYXAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lQ2FwLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTGluZUNhcDtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiTGluZUNhcFwiLCBlbnVtcy5MaW5lQ2FwKSk7XG5leHBvcnRzLkxpbmVKb2luID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVKb2luLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lSm9pbigpIHtcbiAgICAgICAgcmV0dXJuIExpbmVKb2luLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTGluZUpvaW47XG59KShleHBvcnRzLmVudW1fcHJvcChcIkxpbmVKb2luXCIsIGVudW1zLkxpbmVKb2luKSk7XG5leHBvcnRzLkxlZ2VuZExvY2F0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExlZ2VuZExvY2F0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMZWdlbmRMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIExlZ2VuZExvY2F0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTGVnZW5kTG9jYXRpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIkxlZ2VuZExvY2F0aW9uXCIsIGVudW1zLkxlZ2VuZExvY2F0aW9uKSk7XG5leHBvcnRzLkxvY2F0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExvY2F0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gTG9jYXRpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIkxvY2F0aW9uXCIsIGVudW1zLkxvY2F0aW9uKSk7XG5leHBvcnRzLk9yaWVudGF0aW9uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE9yaWVudGF0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBPcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gT3JpZW50YXRpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIk9yaWVudGF0aW9uXCIsIGVudW1zLk9yaWVudGF0aW9uKSk7XG5leHBvcnRzLlRleHRBbGlnbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0QWxpZ24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHRBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIFRleHRBbGlnbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHRBbGlnbjtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiVGV4dEFsaWduXCIsIGVudW1zLlRleHRBbGlnbikpO1xuZXhwb3J0cy5UZXh0QmFzZWxpbmUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGV4dEJhc2VsaW5lLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0QmFzZWxpbmUoKSB7XG4gICAgICAgIHJldHVybiBUZXh0QmFzZWxpbmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0QmFzZWxpbmU7XG59KShleHBvcnRzLmVudW1fcHJvcChcIlRleHRCYXNlbGluZVwiLCBlbnVtcy5UZXh0QmFzZWxpbmUpKTtcbmV4cG9ydHMuUmVuZGVyTGV2ZWwgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVuZGVyTGV2ZWwsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlbmRlckxldmVsKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyTGV2ZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBSZW5kZXJMZXZlbDtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiUmVuZGVyTGV2ZWxcIiwgZW51bXMuUmVuZGVyTGV2ZWwpKTtcbmV4cG9ydHMuUmVuZGVyTW9kZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSZW5kZXJNb2RlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJNb2RlKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyTW9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlbmRlck1vZGU7XG59KShleHBvcnRzLmVudW1fcHJvcChcIlJlbmRlck1vZGVcIiwgZW51bXMuUmVuZGVyTW9kZSkpO1xuZXhwb3J0cy5TaXppbmdNb2RlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNpemluZ01vZGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNpemluZ01vZGUoKSB7XG4gICAgICAgIHJldHVybiBTaXppbmdNb2RlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gU2l6aW5nTW9kZTtcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiU2l6aW5nTW9kZVwiLCBlbnVtcy5TaXppbmdNb2RlKSk7XG5leHBvcnRzLlNwYXRpYWxVbml0cyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTcGF0aWFsVW5pdHMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNwYXRpYWxVbml0cygpIHtcbiAgICAgICAgcmV0dXJuIFNwYXRpYWxVbml0cy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFNwYXRpYWxVbml0cztcbn0pKGV4cG9ydHMuZW51bV9wcm9wKFwiU3BhdGlhbFVuaXRzXCIsIGVudW1zLlNwYXRpYWxVbml0cykpO1xuZXhwb3J0cy5EaXN0cmlidXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGlzdHJpYnV0aW9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaXN0cmlidXRpb24oKSB7XG4gICAgICAgIHJldHVybiBEaXN0cmlidXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBEaXN0cmlidXRpb247XG59KShleHBvcnRzLmVudW1fcHJvcChcIkRpc3RyaWJ1dGlvblwiLCBlbnVtcy5EaXN0cmlidXRpb25UeXBlcykpO1xuZXhwb3J0cy5UcmFuc2Zvcm1TdGVwTW9kZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUcmFuc2Zvcm1TdGVwTW9kZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RlcE1vZGUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdGVwTW9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0ZXBNb2RlO1xufSkoZXhwb3J0cy5lbnVtX3Byb3AoXCJUcmFuc2Zvcm1TdGVwTW9kZVwiLCBlbnVtcy5UcmFuc2Zvcm1TdGVwTW9kZXMpKTtcbmV4cG9ydHMudW5pdHNfcHJvcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWxpZF91bml0cywgZGVmYXVsdF91bml0cykge1xuICAgIHZhciBVbml0c1Byb3A7XG4gICAgcmV0dXJuIFVuaXRzUHJvcCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgICAgICBleHRlbmQoVW5pdHNQcm9wLCBzdXBlckNsYXNzKTtcbiAgICAgICAgZnVuY3Rpb24gVW5pdHNQcm9wKCkge1xuICAgICAgICAgICAgcmV0dXJuIFVuaXRzUHJvcC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBVbml0c1Byb3AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIihvYmo6IFwiICsgdGhpcy5vYmouaWQgKyBcIiwgc3BlYzogXCIgKyAoSlNPTi5zdHJpbmdpZnkodGhpcy5zcGVjKSkgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgVW5pdHNQcm9wLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHVuaXRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYy51bml0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjLnVuaXRzID0gZGVmYXVsdF91bml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5pdHMgPSB0aGlzLnNwZWMudW5pdHM7XG4gICAgICAgICAgICB1bml0cyA9IHRoaXMuc3BlYy51bml0cztcbiAgICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwodmFsaWRfdW5pdHMsIHVuaXRzKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIHVuaXRzIG11c3QgYmUgb25lIG9mIFwiICsgdmFsaWRfdW5pdHMgKyBcIiwgZ2l2ZW4gaW52YWxpZCB2YWx1ZTogXCIgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBVbml0c1Byb3A7XG4gICAgfSkoZXhwb3J0cy5OdW1iZXIpO1xufTtcbmV4cG9ydHMuQW5nbGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5nbGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gQW5nbGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFuZ2xlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICBpZiAodGhpcy5zcGVjLnVuaXRzID09PSBcImRlZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdmFsdWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCAqIE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHggPSB2YWx1ZXNbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKC14KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gQW5nbGUuX19zdXBlcl9fLnRyYW5zZm9ybS5jYWxsKHRoaXMsIHZhbHVlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5nbGU7XG59KShleHBvcnRzLnVuaXRzX3Byb3AoXCJBbmdsZVwiLCBlbnVtcy5BbmdsZVVuaXRzLCBcInJhZFwiKSk7XG5leHBvcnRzLkRpc3RhbmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERpc3RhbmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIERpc3RhbmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gRGlzdGFuY2U7XG59KShleHBvcnRzLnVuaXRzX3Byb3AoXCJEaXN0YW5jZVwiLCBlbnVtcy5TcGF0aWFsVW5pdHMsIFwiZGF0YVwiKSk7XG5leHBvcnRzLkFuZ2xlU3BlYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbmdsZVNwZWMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFuZ2xlU3BlYygpIHtcbiAgICAgICAgcmV0dXJuIEFuZ2xlU3BlYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5nbGVTcGVjLnByb3RvdHlwZS5kYXRhc3BlYyA9IHRydWU7XG4gICAgcmV0dXJuIEFuZ2xlU3BlYztcbn0pKGV4cG9ydHMuQW5nbGUpO1xuZXhwb3J0cy5Db2xvclNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sb3JTcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb2xvclNwZWMoKSB7XG4gICAgICAgIHJldHVybiBDb2xvclNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbG9yU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBDb2xvclNwZWM7XG59KShleHBvcnRzLkNvbG9yKTtcbmV4cG9ydHMuRGlyZWN0aW9uU3BlYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaXJlY3Rpb25TcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEaXJlY3Rpb25TcGVjKCkge1xuICAgICAgICByZXR1cm4gRGlyZWN0aW9uU3BlYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlyZWN0aW9uU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBEaXJlY3Rpb25TcGVjO1xufSkoZXhwb3J0cy5EaXN0YW5jZSk7XG5leHBvcnRzLkRpc3RhbmNlU3BlYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaXN0YW5jZVNwZWMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERpc3RhbmNlU3BlYygpIHtcbiAgICAgICAgcmV0dXJuIERpc3RhbmNlU3BlYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlzdGFuY2VTcGVjLnByb3RvdHlwZS5kYXRhc3BlYyA9IHRydWU7XG4gICAgcmV0dXJuIERpc3RhbmNlU3BlYztcbn0pKGV4cG9ydHMuRGlzdGFuY2UpO1xuZXhwb3J0cy5Gb250U2l6ZVNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRm9udFNpemVTcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBGb250U2l6ZVNwZWMoKSB7XG4gICAgICAgIHJldHVybiBGb250U2l6ZVNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEZvbnRTaXplU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBGb250U2l6ZVNwZWM7XG59KShleHBvcnRzLlN0cmluZyk7XG5leHBvcnRzLk51bWJlclNwZWMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTnVtYmVyU3BlYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTnVtYmVyU3BlYygpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclNwZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE51bWJlclNwZWMucHJvdG90eXBlLmRhdGFzcGVjID0gdHJ1ZTtcbiAgICByZXR1cm4gTnVtYmVyU3BlYztcbn0pKGV4cG9ydHMuTnVtYmVyKTtcbmV4cG9ydHMuU3RyaW5nU3BlYyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmdTcGVjLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTdHJpbmdTcGVjKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nU3BlYy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RyaW5nU3BlYy5wcm90b3R5cGUuZGF0YXNwZWMgPSB0cnVlO1xuICAgIHJldHVybiBTdHJpbmdTcGVjO1xufSkoZXhwb3J0cy5TdHJpbmcpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2ZpbGxfbWl4aW4sIF9nZW5fbWl4aW4sIF9saW5lX21peGluLCBfdGV4dF9taXhpbjtcbnZhciBwID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvb2JqZWN0XCIpO1xuX2dlbl9taXhpbiA9IGZ1bmN0aW9uIChtaXhpbiwgcHJlZml4KSB7XG4gICAgdmFyIG5hbWUsIHJlc3VsdCwgdHlwZTtcbiAgICByZXN1bHQgPSB7fTtcbiAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4ID0gXCJcIjtcbiAgICB9XG4gICAgZm9yIChuYW1lIGluIG1peGluKSB7XG4gICAgICAgIHR5cGUgPSBtaXhpbltuYW1lXTtcbiAgICAgICAgcmVzdWx0W3ByZWZpeCArIG5hbWVdID0gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5fbGluZV9taXhpbiA9IHtcbiAgICBsaW5lX2NvbG9yOiBbcC5Db2xvclNwZWMsICdibGFjayddLFxuICAgIGxpbmVfd2lkdGg6IFtwLk51bWJlclNwZWMsIDFdLFxuICAgIGxpbmVfYWxwaGE6IFtwLk51bWJlclNwZWMsIDEuMF0sXG4gICAgbGluZV9qb2luOiBbcC5MaW5lSm9pbiwgJ21pdGVyJ10sXG4gICAgbGluZV9jYXA6IFtwLkxpbmVDYXAsICdidXR0J10sXG4gICAgbGluZV9kYXNoOiBbcC5BcnJheSwgW11dLFxuICAgIGxpbmVfZGFzaF9vZmZzZXQ6IFtwLk51bWJlciwgMF1cbn07XG5leHBvcnRzLmxpbmUgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcmV0dXJuIF9nZW5fbWl4aW4oX2xpbmVfbWl4aW4sIHByZWZpeCk7XG59O1xuX2ZpbGxfbWl4aW4gPSB7XG4gICAgZmlsbF9jb2xvcjogW3AuQ29sb3JTcGVjLCAnZ3JheSddLFxuICAgIGZpbGxfYWxwaGE6IFtwLk51bWJlclNwZWMsIDEuMF1cbn07XG5leHBvcnRzLmZpbGwgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcmV0dXJuIF9nZW5fbWl4aW4oX2ZpbGxfbWl4aW4sIHByZWZpeCk7XG59O1xuX3RleHRfbWl4aW4gPSB7XG4gICAgdGV4dF9mb250OiBbcC5Gb250LCAnaGVsdmV0aWNhJ10sXG4gICAgdGV4dF9mb250X3NpemU6IFtwLkZvbnRTaXplU3BlYywgJzEycHQnXSxcbiAgICB0ZXh0X2ZvbnRfc3R5bGU6IFtwLkZvbnRTdHlsZSwgJ25vcm1hbCddLFxuICAgIHRleHRfY29sb3I6IFtwLkNvbG9yU3BlYywgJyM0NDQ0NDQnXSxcbiAgICB0ZXh0X2FscGhhOiBbcC5OdW1iZXJTcGVjLCAxLjBdLFxuICAgIHRleHRfYWxpZ246IFtwLlRleHRBbGlnbiwgJ2xlZnQnXSxcbiAgICB0ZXh0X2Jhc2VsaW5lOiBbcC5UZXh0QmFzZWxpbmUsICdib3R0b20nXVxufTtcbmV4cG9ydHMudGV4dCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICByZXR1cm4gX2dlbl9taXhpbihfdGV4dF9taXhpbiwgcHJlZml4KTtcbn07XG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgdmFyIGNvbmZpZywgaSwga2luZCwgbGVuLCBwcmVmaXgsIHJlZiwgcmVzdWx0O1xuICAgIHJlc3VsdCA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbmZpZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnc1tpXTtcbiAgICAgICAgcmVmID0gY29uZmlnLnNwbGl0KFwiOlwiKSwga2luZCA9IHJlZlswXSwgcHJlZml4ID0gcmVmWzFdO1xuICAgICAgICBpZiAodGhpc1traW5kXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByb3BlcnR5IG1peGluIGtpbmQgJ1wiICsga2luZCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBvYmplY3RfMS5leHRlbmQocmVzdWx0LCB0aGlzW2tpbmRdKHByZWZpeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNfcHJvcHNfMSA9IHJlcXVpcmUoXCIuL2hhc19wcm9wc1wiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xudmFyIHNlbGVjdG9yXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcIi4vaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuU2VsZWN0aW9uTWFuYWdlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWxlY3Rpb25NYW5hZ2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25NYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uTWFuYWdlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudHlwZSA9ICdTZWxlY3Rpb25NYW5hZ2VyJztcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLmludGVybmFsKHtcbiAgICAgICAgc291cmNlOiBbcC5BbnldXG4gICAgfSk7XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBTZWxlY3Rpb25NYW5hZ2VyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmluc3BlY3RvcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdF9pbnNwZWN0aW9uX3dhc19lbXB0eSA9IHt9O1xuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHRvb2wsIHJlbmRlcmVyX3ZpZXcsIGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKSB7XG4gICAgICAgIHZhciBpbmRpY2VzLCBzZWxlY3Rvciwgc291cmNlO1xuICAgICAgICBpZiAoYXBwZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGVuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9PSByZW5kZXJlcl92aWV3Lm1vZGVsLmRhdGFfc291cmNlKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ3NlbGVjdCBjYWxsZWQgd2l0aCBtaXMtbWF0Y2hlZCBkYXRhIHNvdXJjZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzID0gcmVuZGVyZXJfdmlldy5oaXRfdGVzdChnZW9tZXRyeSk7XG4gICAgICAgIGlmIChpbmRpY2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fZ2V0X3NlbGVjdG9yKHJlbmRlcmVyX3ZpZXcpO1xuICAgICAgICAgICAgc2VsZWN0b3IudXBkYXRlKGluZGljZXMsIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc2VsZWN0ZWQgPSBzZWxlY3Rvci5pbmRpY2VzO1xuICAgICAgICAgICAgc291cmNlLnRyaWdnZXIoJ3NlbGVjdCcpO1xuICAgICAgICAgICAgc291cmNlLnRyaWdnZXIoJ3NlbGVjdC0nICsgcmVuZGVyZXJfdmlldy5tb2RlbC5pZCk7XG4gICAgICAgICAgICByZXR1cm4gIWluZGljZXMuaXNfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICh0b29sLCByZW5kZXJlcl92aWV3LCBnZW9tZXRyeSwgZGF0YSkge1xuICAgICAgICB2YXIgaW5kaWNlcywgaW5zcGVjdG9yLCByX2lkLCBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9PSByZW5kZXJlcl92aWV3Lm1vZGVsLmRhdGFfc291cmNlKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ2luc3BlY3QgY2FsbGVkIHdpdGggbWlzLW1hdGNoZWQgZGF0YSBzb3VyY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kaWNlcyA9IHJlbmRlcmVyX3ZpZXcuaGl0X3Rlc3QoZ2VvbWV0cnkpO1xuICAgICAgICBpZiAoaW5kaWNlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByX2lkID0gcmVuZGVyZXJfdmlldy5tb2RlbC5pZDtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfaW5zcGVjdGlvbl93YXNfZW1wdHlbcl9pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X2luc3BlY3Rpb25fd2FzX2VtcHR5W3JfaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RfaW5zcGVjdGlvbl93YXNfZW1wdHlbcl9pZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3BlY3RvciA9IHRoaXMuX2dldF9pbnNwZWN0b3IocmVuZGVyZXJfdmlldyk7XG4gICAgICAgICAgICBpbnNwZWN0b3IudXBkYXRlKGluZGljZXMsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNldHYoe1xuICAgICAgICAgICAgICAgIGluc3BlY3RlZDogaW5zcGVjdG9yLmluZGljZXNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInNpbGVudFwiOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvdXJjZS50cmlnZ2VyKCdpbnNwZWN0JywgaW5kaWNlcywgdG9vbCwgcmVuZGVyZXJfdmlldywgc291cmNlLCBkYXRhKTtcbiAgICAgICAgICAgIHNvdXJjZS50cmlnZ2VyKFwiaW5zcGVjdFwiICsgcmVuZGVyZXJfdmlldy5tb2RlbC5pZCwgaW5kaWNlcywgdG9vbCwgcmVuZGVyZXJfdmlldywgc291cmNlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiAhaW5kaWNlcy5pc19lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChydmlldykge1xuICAgICAgICB2YXIgaywgcmVmLCBzLCBzZWxlY3RvcjtcbiAgICAgICAgaWYgKHJ2aWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fZ2V0X3NlbGVjdG9yKHJ2aWV3KTtcbiAgICAgICAgICAgIHNlbGVjdG9yLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnNlbGVjdG9ycztcbiAgICAgICAgICAgIGZvciAoayBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICBzID0gcmVmW2tdO1xuICAgICAgICAgICAgICAgIHMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2VsZWN0ZWQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9nZXRfc2VsZWN0b3JfZnJvbSA9IGZ1bmN0aW9uIChydmlldywgc2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWQgPSBydmlldy5tb2RlbC5pZDtcbiAgICAgICAgaWYgKHNlbGVjdG9yc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yc1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JzW2lkXSA9IG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9nZXRfc2VsZWN0b3IgPSBmdW5jdGlvbiAocnZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9zZWxlY3Rvcl9mcm9tKHJ2aWV3LCB0aGlzLnNlbGVjdG9ycyk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5fZ2V0X2luc3BlY3RvciA9IGZ1bmN0aW9uIChydmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X3NlbGVjdG9yX2Zyb20ocnZpZXcsIHRoaXMuaW5zcGVjdG9ycyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0aW9uTWFuYWdlcjtcbn0pKGhhc19wcm9wc18xLkhhc1Byb3BzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1lcmdlLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi9oYXNfcHJvcHNcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCIuL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWwvYXJyYXlcIik7XG5tZXJnZSA9IGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgdmFyIGFycjEsIGFycjIsIGksIGtleSwga2V5cywgbGVuLCByZXN1bHQ7XG4gICAgcmVzdWx0ID0ge307XG4gICAga2V5cyA9IGFycmF5XzEuY29uY2F0KE9iamVjdC5rZXlzKG9iajEpLCBPYmplY3Qua2V5cyhvYmoyKSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBhcnIxID0gb2JqMVtrZXldIHx8IFtdO1xuICAgICAgICBhcnIyID0gb2JqMltrZXldIHx8IFtdO1xuICAgICAgICByZXN1bHRba2V5XSA9IGFycmF5XzEudW5pb24oYXJyMSwgYXJyMik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5TZWxlY3RvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWxlY3Rvciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VsZWN0b3IucHJvdG90eXBlLnR5cGUgPSAnU2VsZWN0b3InO1xuICAgIFNlbGVjdG9yLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5kaWNlcywgZmluYWwsIGFwcGVuZCwgc2lsZW50KSB7XG4gICAgICAgIGlmIChzaWxlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2lsZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR2KCd0aW1lc3RhbXAnLCBuZXcgRGF0ZSgpLCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHNpbGVudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXR2KCdmaW5hbCcsIGZpbmFsLCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHNpbGVudFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgaW5kaWNlc1snMGQnXS5pbmRpY2VzID0gYXJyYXlfMS51bmlvbih0aGlzLmluZGljZXNbJzBkJ10uaW5kaWNlcywgaW5kaWNlc1snMGQnXS5pbmRpY2VzKTtcbiAgICAgICAgICAgIGluZGljZXNbJzBkJ10uZ2x5cGggPSB0aGlzLmluZGljZXNbJzBkJ10uZ2x5cGggfHwgaW5kaWNlc1snMGQnXS5nbHlwaDtcbiAgICAgICAgICAgIGluZGljZXNbJzFkJ10uaW5kaWNlcyA9IGFycmF5XzEudW5pb24odGhpcy5pbmRpY2VzWycxZCddLmluZGljZXMsIGluZGljZXNbJzFkJ10uaW5kaWNlcyk7XG4gICAgICAgICAgICBpbmRpY2VzWycyZCddLmluZGljZXMgPSBtZXJnZSh0aGlzLmluZGljZXNbJzJkJ10uaW5kaWNlcywgaW5kaWNlc1snMmQnXS5pbmRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXR2KCdpbmRpY2VzJywgaW5kaWNlcywge1xuICAgICAgICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5maW5hbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGljZXMgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICB9O1xuICAgIFNlbGVjdG9yLmludGVybmFsKHtcbiAgICAgICAgaW5kaWNlczogW1xuICAgICAgICAgICAgcC5BbnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGZpbmFsOiBbcC5Cb29sZWFuXSxcbiAgICAgICAgdGltZXN0YW1wOiBbcC5BbnldXG4gICAgfSk7XG4gICAgcmV0dXJuIFNlbGVjdG9yO1xufSkoaGFzX3Byb3BzXzEuSGFzUHJvcHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKFwiaGFtbWVyanNcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcbnZhciB3aGVlbF8xID0gcmVxdWlyZShcIi4vdXRpbC93aGVlbFwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvb2JqZWN0XCIpO1xudmFyIGJva2VoX2V2ZW50c18xID0gcmVxdWlyZShcIi4vYm9rZWhfZXZlbnRzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi91dGlsL2FycmF5XCIpO1xuZXhwb3J0cy5VSUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZXh0ZW5kMShVSUV2ZW50cy5wcm90b3R5cGUsIGV2ZW50c18xLkV2ZW50cyk7XG4gICAgZnVuY3Rpb24gVUlFdmVudHMocGxvdF92aWV3LCB0b29sYmFyLCBoaXRfYXJlYSwgcGxvdCkge1xuICAgICAgICB0aGlzLnBsb3RfdmlldyA9IHBsb3RfdmlldztcbiAgICAgICAgdGhpcy50b29sYmFyID0gdG9vbGJhcjtcbiAgICAgICAgdGhpcy5oaXRfYXJlYSA9IGhpdF9hcmVhO1xuICAgICAgICB0aGlzLnBsb3QgPSBwbG90O1xuICAgICAgICB0aGlzLl9jb25maWd1cmVfaGFtbWVyanMoKTtcbiAgICB9XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9jb25maWd1cmVfaGFtbWVyanMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmhpdF9hcmVhKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCdkb3VibGV0YXAnKS5yZWNvZ25pemVXaXRoKCd0YXAnKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCd0YXAnKS5yZXF1aXJlRmFpbHVyZSgnZG91YmxldGFwJyk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgnZG91YmxldGFwJykuZHJvcFJlcXVpcmVGYWlsdXJlKCd0YXAnKTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG91YmxldGFwKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigndGFwJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl90YXAoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcHJlc3MoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTExcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGFuX3N0YXJ0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wYW4oZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3Bhbl9lbmQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoe1xuICAgICAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGluY2hzdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2hfc3RhcnQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwaW5jaCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2goZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwaW5jaGVuZCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGluY2hfZW5kKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5nZXQoJ3JvdGF0ZScpLnNldCh7XG4gICAgICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdyb3RhdGVzdGFydCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcm90YXRlX3N0YXJ0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncm90YXRlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yb3RhdGUoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdyb3RhdGVlbmQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JvdGF0ZV9lbmQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21vdXNlX21vdmUoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tb3VzZV9lbnRlcihlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5oaXRfYXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21vdXNlX2V4aXQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGl0X2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbW91c2Vfd2hlZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fa2V5X2Rvd24oZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9rZXlfdXAoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUucmVnaXN0ZXJfdG9vbCA9IGZ1bmN0aW9uICh0b29sX3ZpZXcpIHtcbiAgICAgICAgdmFyIGV0LCBpZCwgdHlwZTtcbiAgICAgICAgZXQgPSB0b29sX3ZpZXcubW9kZWwuZXZlbnRfdHlwZTtcbiAgICAgICAgaWQgPSB0b29sX3ZpZXcubW9kZWwuaWQ7XG4gICAgICAgIHR5cGUgPSB0b29sX3ZpZXcubW9kZWwudHlwZTtcbiAgICAgICAgaWYgKGV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJCdXR0b24gdG9vbDogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXQgPT09ICdwYW4nIHx8IGV0ID09PSAncGluY2gnIHx8IGV0ID09PSAncm90YXRlJykge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlJlZ2lzdGVyaW5nIHRvb2w6IFwiICsgdHlwZSArIFwiIGZvciBldmVudCAnXCIgKyBldCArIFwiJ1wiKTtcbiAgICAgICAgICAgIGlmICh0b29sX3ZpZXdbXCJfXCIgKyBldCArIFwiX3N0YXJ0XCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b29sX3ZpZXcubGlzdGVuVG8odGhpcywgZXQgKyBcIjpzdGFydDpcIiArIGlkLCB0b29sX3ZpZXdbXCJfXCIgKyBldCArIFwiX3N0YXJ0XCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sX3ZpZXdbXCJfXCIgKyBldF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvb2xfdmlldy5saXN0ZW5Ubyh0aGlzLCBldCArIFwiOlwiICsgaWQsIHRvb2xfdmlld1tcIl9cIiArIGV0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbF92aWV3W1wiX1wiICsgZXQgKyBcIl9lbmRcIl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvb2xfdmlldy5saXN0ZW5Ubyh0aGlzLCBldCArIFwiOmVuZDpcIiArIGlkLCB0b29sX3ZpZXdbXCJfXCIgKyBldCArIFwiX2VuZFwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXQgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgdG9vbDogXCIgKyB0eXBlICsgXCIgZm9yIGV2ZW50ICdcIiArIGV0ICsgXCInXCIpO1xuICAgICAgICAgICAgaWYgKHRvb2xfdmlldy5fbW92ZV9lbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9vbF92aWV3Lmxpc3RlblRvKHRoaXMsIFwibW92ZTplbnRlclwiLCB0b29sX3ZpZXcuX21vdmVfZW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbF92aWV3Lmxpc3RlblRvKHRoaXMsIFwibW92ZVwiLCB0b29sX3ZpZXdbXCJfbW92ZVwiXSk7XG4gICAgICAgICAgICBpZiAodG9vbF92aWV3Ll9tb3ZlX2V4aXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvb2xfdmlldy5saXN0ZW5Ubyh0aGlzLCBcIm1vdmU6ZXhpdFwiLCB0b29sX3ZpZXcuX21vdmVfZXhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgdG9vbDogXCIgKyB0eXBlICsgXCIgZm9yIGV2ZW50ICdcIiArIGV0ICsgXCInXCIpO1xuICAgICAgICAgICAgdG9vbF92aWV3Lmxpc3RlblRvKHRoaXMsIGV0ICsgXCI6XCIgKyBpZCwgdG9vbF92aWV3W1wiX1wiICsgZXRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbF92aWV3Ll9rZXlkb3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmluZyB0b29sOiBcIiArIHR5cGUgKyBcIiBmb3IgZXZlbnQgJ2tleWRvd24nXCIpO1xuICAgICAgICAgICAgdG9vbF92aWV3Lmxpc3RlblRvKHRoaXMsIFwia2V5ZG93blwiLCB0b29sX3ZpZXcuX2tleWRvd24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sX3ZpZXcuX2tleXVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmluZyB0b29sOiBcIiArIHR5cGUgKyBcIiBmb3IgZXZlbnQgJ2tleXVwJ1wiKTtcbiAgICAgICAgICAgIHRvb2xfdmlldy5saXN0ZW5Ubyh0aGlzLCBcImtleXVwXCIsIHRvb2xfdmlldy5fa2V5dXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sX3ZpZXcuX2RvdWJsZXRhcCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgdG9vbDogXCIgKyB0eXBlICsgXCIgZm9yIGV2ZW50ICdkb3VibGV0YXAnXCIpO1xuICAgICAgICAgICAgdG9vbF92aWV3Lmxpc3RlblRvKHRoaXMsIFwiZG91YmxldGFwXCIsIHRvb2xfdmlldy5fZG91YmxldGFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApIHtcbiAgICAgICAgICAgIGlmIChldCA9PT0gJ3BpbmNoJykge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmluZyBzY3JvbGwgb24gdG91Y2ggc2NyZWVuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sX3ZpZXcubGlzdGVuVG8odGhpcywgXCJzY3JvbGw6XCIgKyBpZCwgdG9vbF92aWV3W1wiX3Njcm9sbFwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5faGl0X3Rlc3RfcmVuZGVyZXJzID0gZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICB2YXIgaSwgcmVmLCByZWYxLCB2aWV3O1xuICAgICAgICByZWYgPSB0aGlzLnBsb3Rfdmlldy5nZXRfcmVuZGVyZXJfdmlld3MoKTtcbiAgICAgICAgZm9yIChpID0gcmVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSArPSAtMSkge1xuICAgICAgICAgICAgdmlldyA9IHJlZltpXTtcbiAgICAgICAgICAgIGlmICgoKHJlZjEgPSB2aWV3Lm1vZGVsLmxldmVsKSA9PT0gJ2Fubm90YXRpb24nIHx8IHJlZjEgPT09ICdvdmVybGF5JykgJiYgKHZpZXcuYmJveCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmJib3goKS5jb250YWlucyhzeCwgc3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5faGl0X3Rlc3RfZnJhbWUgPSBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgIHZhciBjYW52YXMsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChzeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KHN5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LmZyYW1lLmNvbnRhaW5zKHZ4LCB2eSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRfdHlwZSwgZSkge1xuICAgICAgICB2YXIgYWN0aXZlX2dlc3R1cmUsIGJhc2UsIGJhc2VfdHlwZSwgY3Vyc29yLCBoYXNfYWN0aXZlX2luc3BlY3RvcnMsIHZpZXc7XG4gICAgICAgIGJhc2VfdHlwZSA9IGV2ZW50X3R5cGUuc3BsaXQoXCI6XCIpWzBdO1xuICAgICAgICB2aWV3ID0gdGhpcy5faGl0X3Rlc3RfcmVuZGVyZXJzKGUuYm9rZWguc3gsIGUuYm9rZWguc3kpO1xuICAgICAgICBzd2l0Y2ggKGJhc2VfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1vdmVcIjpcbiAgICAgICAgICAgICAgICBoYXNfYWN0aXZlX2luc3BlY3RvcnMgPSBhcnJheV8xLmFueSh0aGlzLnRvb2xiYXIuaW5zcGVjdG9ycywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuYWN0aXZlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcubW9kZWwuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IHZpZXcubW9kZWwuY3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19hY3RpdmVfaW5zcGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfdHlwZSA9IFwibW92ZTpleGl0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faGl0X3Rlc3RfZnJhbWUoZS5ib2tlaC5zeCwgZS5ib2tlaC5zeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc19hY3RpdmVfaW5zcGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gXCJjcm9zc2hhaXJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBsb3Rfdmlldy5zZXRfY3Vyc29yKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudF90eXBlLCBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0YXBcIjpcbiAgICAgICAgICAgICAgICBpZiAodmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygdmlldy5vbl9oaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5vbl9oaXQoZS5ib2tlaC5zeCwgZS5ib2tlaC5zeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aXZlX2dlc3R1cmUgPSB0aGlzLnRvb2xiYXIuZ2VzdHVyZXNbYmFzZV90eXBlXS5hY3RpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZV9nZXN0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudF90eXBlICsgXCI6XCIgKyBhY3RpdmVfZ2VzdHVyZS5pZCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgIGJhc2UgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCA/IFwicGluY2hcIiA6IFwic2Nyb2xsXCI7XG4gICAgICAgICAgICAgICAgYWN0aXZlX2dlc3R1cmUgPSB0aGlzLnRvb2xiYXIuZ2VzdHVyZXNbYmFzZV0uYWN0aXZlO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVfZ2VzdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudF90eXBlICsgXCI6XCIgKyBhY3RpdmVfZ2VzdHVyZS5pZCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhY3RpdmVfZ2VzdHVyZSA9IHRoaXMudG9vbGJhci5nZXN0dXJlc1tiYXNlX3R5cGVdLmFjdGl2ZTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlX2dlc3R1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKGV2ZW50X3R5cGUgKyBcIjpcIiArIGFjdGl2ZV9nZXN0dXJlLmlkLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fYm9raWZ5X2hhbW1lciA9IGZ1bmN0aW9uIChlLCBleHRyYXMpIHtcbiAgICAgICAgdmFyIGV2ZW50X2NscywgbGVmdCwgcmVmLCB0b3AsIHgsIHk7XG4gICAgICAgIGlmIChleHRyYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0cmFzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgICAgIHggPSBlLnNyY0V2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgeSA9IGUuc3JjRXZlbnQucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gZS5wb2ludGVyc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHkgPSBlLnBvaW50ZXJzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IGRvbV8xLm9mZnNldChlLnRhcmdldCksIGxlZnQgPSByZWYubGVmdCwgdG9wID0gcmVmLnRvcDtcbiAgICAgICAgZS5ib2tlaCA9IHtcbiAgICAgICAgICAgIHN4OiB4IC0gbGVmdCxcbiAgICAgICAgICAgIHN5OiB5IC0gdG9wXG4gICAgICAgIH07XG4gICAgICAgIGUuYm9rZWggPSBvYmplY3RfMS5leHRlbmQoZS5ib2tlaCwgZXh0cmFzKTtcbiAgICAgICAgZXZlbnRfY2xzID0gYm9rZWhfZXZlbnRzXzEuQm9rZWhFdmVudC5ldmVudF9jbGFzcyhlKTtcbiAgICAgICAgaWYgKGV2ZW50X2NscyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90LnRyaWdnZXJfZXZlbnQoZXZlbnRfY2xzLmZyb21fZXZlbnQoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoJ1VuaGFuZGxlZCBldmVudCBvZiB0eXBlICcgKyBlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX2Jva2lmeV9wb2ludF9ldmVudCA9IGZ1bmN0aW9uIChlLCBleHRyYXMpIHtcbiAgICAgICAgdmFyIGV2ZW50X2NscywgbGVmdCwgcmVmLCB0b3A7XG4gICAgICAgIGlmIChleHRyYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0cmFzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gZG9tXzEub2Zmc2V0KGUuY3VycmVudFRhcmdldCksIGxlZnQgPSByZWYubGVmdCwgdG9wID0gcmVmLnRvcDtcbiAgICAgICAgZS5ib2tlaCA9IHtcbiAgICAgICAgICAgIHN4OiBlLnBhZ2VYIC0gbGVmdCxcbiAgICAgICAgICAgIHN5OiBlLnBhZ2VZIC0gdG9wXG4gICAgICAgIH07XG4gICAgICAgIGUuYm9rZWggPSBvYmplY3RfMS5leHRlbmQoZS5ib2tlaCwgZXh0cmFzKTtcbiAgICAgICAgZXZlbnRfY2xzID0gYm9rZWhfZXZlbnRzXzEuQm9rZWhFdmVudC5ldmVudF9jbGFzcyhlKTtcbiAgICAgICAgaWYgKGV2ZW50X2NscyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90LnRyaWdnZXJfZXZlbnQoZXZlbnRfY2xzLmZyb21fZXZlbnQoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoJ1VuaGFuZGxlZCBldmVudCBvZiB0eXBlICcgKyBlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3RhcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKCd0YXAnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fZG91YmxldGFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignZG91YmxldGFwJywgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3ByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoJ3ByZXNzJywgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3Bhbl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIGUuYm9rZWguc3ggLT0gZS5kZWx0YVg7XG4gICAgICAgIGUuYm9rZWguc3kgLT0gZS5kZWx0YVk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKCdwYW46c3RhcnQnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcGFuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoJ3BhbicsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9wYW5fZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoJ3BhbjplbmQnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcGluY2hfc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcigncGluY2g6c3RhcnQnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcGluY2ggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcigncGluY2gnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcGluY2hfZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X2hhbW1lcihlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoJ3BpbmNoOmVuZCcsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9yb3RhdGVfc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9ib2tpZnlfaGFtbWVyKGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcigncm90YXRlOnN0YXJ0JywgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX3JvdGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKCdyb3RhdGUnLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fcm90YXRlX2VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2Jva2lmeV9oYW1tZXIoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKCdyb3RhdGU6ZW5kJywgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX21vdXNlX2VudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X3BvaW50X2V2ZW50KGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcignbW92ZTplbnRlcicsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9tb3VzZV9tb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X3BvaW50X2V2ZW50KGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcignbW92ZScsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9tb3VzZV9leGl0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X3BvaW50X2V2ZW50KGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcignbW92ZTpleGl0JywgZSk7XG4gICAgfTtcbiAgICBVSUV2ZW50cy5wcm90b3R5cGUuX21vdXNlX3doZWVsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fYm9raWZ5X3BvaW50X2V2ZW50KGUsIHtcbiAgICAgICAgICAgIGRlbHRhOiB3aGVlbF8xLmdldERlbHRhWShlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoJ3Njcm9sbCcsIGUpO1xuICAgIH07XG4gICAgVUlFdmVudHMucHJvdG90eXBlLl9rZXlfZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2tleWRvd24nLCBlKTtcbiAgICB9O1xuICAgIFVJRXZlbnRzLnByb3RvdHlwZS5fa2V5X3VwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcigna2V5dXAnLCBlKTtcbiAgICB9O1xuICAgIHJldHVybiBVSUV2ZW50cztcbn0pKCk7XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmZ1bmN0aW9uIGNvcHkoYXJyYXkgLyp8IFR5cGVkQXJyYXkqLykge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5KTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG5mdW5jdGlvbiBjb25jYXQoYXJyYXlzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgYXJyYXlzKTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpID49IDA7XG59XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG5mdW5jdGlvbiBudGgoYXJyYXksIGluZGV4KSB7XG4gICAgcmV0dXJuIGFycmF5W2luZGV4ID49IDAgPyBpbmRleCA6IGFycmF5Lmxlbmd0aCArIGluZGV4XTtcbn1cbmV4cG9ydHMubnRoID0gbnRoO1xuZnVuY3Rpb24gemlwKEFzLCBCcykge1xuICAgIHZhciBuID0gTWF0aC5taW4oQXMubGVuZ3RoLCBCcy5sZW5ndGgpO1xuICAgIHZhciBBQnMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgQUJzW2ldID0gW0FzW2ldLCBCc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBBQnM7XG59XG5leHBvcnRzLnppcCA9IHppcDtcbmZ1bmN0aW9uIHVuemlwKEFCcykge1xuICAgIHZhciBuID0gQUJzLmxlbmd0aDtcbiAgICB2YXIgQXMgPSBuZXcgQXJyYXkobik7XG4gICAgdmFyIEJzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIF9hID0gQUJzW2ldLCBBc1tpXSA9IF9hWzBdLCBCc1tpXSA9IF9hWzFdO1xuICAgIH1cbiAgICByZXR1cm4gW0FzLCBCc107XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy51bnppcCA9IHVuemlwO1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAxOyB9XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgICAgcmFuZ2VbaV0gPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuZnVuY3Rpb24gbGluc3BhY2Uoc3RhcnQsIHN0b3AsIG51bSkge1xuICAgIGlmIChudW0gPT09IHZvaWQgMCkgeyBudW0gPSAxMDA7IH1cbiAgICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKG51bSAtIDEpO1xuICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShudW0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdGFydCArIHN0ZXAgKiBpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmxpbnNwYWNlID0gbGluc3BhY2U7XG5mdW5jdGlvbiB0cmFuc3Bvc2UoYXJyYXkpIHtcbiAgICB2YXIgcm93cyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgY29scyA9IGFycmF5WzBdLmxlbmd0aDtcbiAgICB2YXIgdHJhbnNwb3NlZCA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sczsgaisrKSB7XG4gICAgICAgIHRyYW5zcG9zZWRbal0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zcG9zZWRbal1baV0gPSBhcnJheVtpXVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlZDtcbn1cbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xufVxuZXhwb3J0cy5zdW0gPSBzdW07XG5mdW5jdGlvbiBjdW1zdW0oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhLCBiLCBpKSB7IHJldHVybiByZXN1bHRbaV0gPSBhICsgYjsgfSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY3Vtc3VtID0gY3Vtc3VtO1xuZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWluID0gbWluO1xuZnVuY3Rpb24gbWluQnkoYXJyYXksIGtleSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBjb21wdXRlZDtcbiAgICB2YXIgcmVzdWx0Q29tcHV0ZWQgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzIgPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGhfMjsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIGNvbXB1dGVkID0ga2V5KHZhbHVlKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgcmVzdWx0Q29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5taW5CeSA9IG1pbkJ5O1xuZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8zID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoXzM7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1heCA9IG1heDtcbmZ1bmN0aW9uIG1heEJ5KGFycmF5LCBrZXkpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgY29tcHV0ZWQ7XG4gICAgdmFyIHJlc3VsdENvbXB1dGVkID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfNCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aF80OyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgY29tcHV0ZWQgPSBrZXkodmFsdWUpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiByZXN1bHRDb21wdXRlZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXN1bHRDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1heEJ5ID0gbWF4Qnk7XG5mdW5jdGlvbiBhcmdtaW4oYXJyYXkpIHtcbiAgICByZXR1cm4gbWluQnkocmFuZ2UoYXJyYXkubGVuZ3RoKSwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KTtcbn1cbmV4cG9ydHMuYXJnbWluID0gYXJnbWluO1xuZnVuY3Rpb24gYXJnbWF4KGFycmF5KSB7XG4gICAgcmV0dXJuIG1heEJ5KHJhbmdlKGFycmF5Lmxlbmd0aCksIGZ1bmN0aW9uIChpKSB7IHJldHVybiBhcnJheVtpXTsgfSk7XG59XG5leHBvcnRzLmFyZ21heCA9IGFyZ21heDtcbmZ1bmN0aW9uIGFsbChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJheV8xID0gYXJyYXk7IF9pIDwgYXJyYXlfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJheV8xW19pXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlfMiA9IGFycmF5OyBfaSA8IGFycmF5XzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyYXlfMltfaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5hbnkgPSBhbnk7XG5mdW5jdGlvbiBmaW5kSW5kZXhGYWN0b3J5KGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5leHBvcnRzLmZpbmRJbmRleCA9IGZpbmRJbmRleEZhY3RvcnkoMSk7XG5leHBvcnRzLmZpbmRMYXN0SW5kZXggPSBmaW5kSW5kZXhGYWN0b3J5KC0xKTtcbmZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsb3cgPSAwO1xuICAgIHZhciBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgICBpZiAoYXJyYXlbbWlkXSA8IHZhbHVlKVxuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmV4cG9ydHMuc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbmZ1bmN0aW9uIHNvcnRCeShhcnJheSwga2V5KSB7XG4gICAgdmFyIHRtcCA9IGFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgaW5kZXg6IGluZGV4LCBrZXk6IGtleSh2YWx1ZSkgfTtcbiAgICB9KTtcbiAgICB0bXAuc29ydChmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGEgPSBsZWZ0LmtleTtcbiAgICAgICAgdmFyIGIgPSByaWdodC5rZXk7XG4gICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG1wLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS52YWx1ZTsgfSk7XG59XG5leHBvcnRzLnNvcnRCeSA9IHNvcnRCeTtcbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJheV8zID0gYXJyYXk7IF9pIDwgYXJyYXlfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlfM1tfaV07XG4gICAgICAgIGlmICghY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51bmlxID0gdW5pcTtcbmZ1bmN0aW9uIHVuaXFCeShhcnJheSwga2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcnJheV80ID0gYXJyYXk7IF9pIDwgYXJyYXlfNC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlfNFtfaV07XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGtleSh2YWx1ZSk7XG4gICAgICAgIGlmICghY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVuaXFCeSA9IHVuaXFCeTtcbmZ1bmN0aW9uIHVuaW9uKCkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcnJheXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXEoY29uY2F0KGFycmF5cykpO1xufVxuZXhwb3J0cy51bmlvbiA9IHVuaW9uO1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGFycmF5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRvcDogZm9yICh2YXIgX2EgPSAwLCBhcnJheV81ID0gYXJyYXk7IF9hIDwgYXJyYXlfNS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJheV81W19hXTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBhcnJheXNfMSA9IGFycmF5czsgX2IgPCBhcnJheXNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGFycmF5c18xW19iXTtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMob3RoZXIsIGl0ZW0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcnJheXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN0ID0gY29uY2F0KGFycmF5cyk7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFjb250YWlucyhyZXN0LCB2YWx1ZSk7IH0pO1xufVxuZXhwb3J0cy5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuZnVuY3Rpb24gcG9zaXRpdmVfeCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICBtaW5ZOiAtSW5maW5pdHksXG4gICAgICAgIG1heFg6IEluZmluaXR5LFxuICAgICAgICBtYXhZOiBJbmZpbml0eSxcbiAgICB9O1xufVxuZXhwb3J0cy5wb3NpdGl2ZV94ID0gcG9zaXRpdmVfeDtcbmZ1bmN0aW9uIHBvc2l0aXZlX3koKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogLUluZmluaXR5LFxuICAgICAgICBtaW5ZOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICBtYXhYOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WTogSW5maW5pdHksXG4gICAgfTtcbn1cbmV4cG9ydHMucG9zaXRpdmVfeSA9IHBvc2l0aXZlX3k7XG5mdW5jdGlvbiB1bmlvbihhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogTWF0aC5taW4oYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtYXhYOiBNYXRoLm1heChhLm1heFgsIGIubWF4WCksXG4gICAgICAgIG1pblk6IE1hdGgubWluKGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WTogTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpLFxuICAgIH07XG59XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG52YXIgQkJveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQkJveChiYm94KSB7XG4gICAgICAgIGlmIChiYm94ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMueDAgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMueTAgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLngxID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnkxID0gLUluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54MCA9IGJib3gueDA7XG4gICAgICAgICAgICB0aGlzLnkwID0gYmJveC55MDtcbiAgICAgICAgICAgIHRoaXMueDEgPSBiYm94LngxO1xuICAgICAgICAgICAgdGhpcy55MSA9IGJib3gueTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcIm1pblhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJtaW5ZXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnkwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwibWF4WFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy54MTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcIm1heFlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueTE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJwdDBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt0aGlzLngwLCB0aGlzLnkwXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcInB0MVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3RoaXMueDEsIHRoaXMueTFdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQkJveC5wcm90b3R5cGUsIFwieFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy54MDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJCb3gucHJvdG90eXBlLCBcInlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueDE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy54MSAtIHRoaXMueDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCQm94LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueTEgLSB0aGlzLnkwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCQm94LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4ID49IHRoaXMueDAgJiYgeCA8PSB0aGlzLngxICYmIHkgPj0gdGhpcy55MCAmJiB5IDw9IHRoaXMueTE7XG4gICAgfTtcbiAgICBCQm94LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQkJveCh7XG4gICAgICAgICAgICB4MDogTWF0aC5taW4odGhpcy54MCwgdGhhdC54MCksXG4gICAgICAgICAgICB5MDogTWF0aC5taW4odGhpcy55MCwgdGhhdC55MCksXG4gICAgICAgICAgICB4MTogTWF0aC5tYXgodGhpcy54MSwgdGhhdC54MSksXG4gICAgICAgICAgICB5MTogTWF0aC5tYXgodGhpcy55MSwgdGhhdC55MSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJCb3g7XG59KCkpO1xuZXhwb3J0cy5CQm94ID0gQkJveDtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgIHJldHVybiBkZWxheShmdW5jLCAxKTtcbn1cbmV4cG9ydHMuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIG1lbW8gPSBmdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn1cbmV4cG9ydHMub25jZSA9IG9uY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZml4dXBfbGluZV9kYXNoID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIGlmICghY3R4LnNldExpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uIChkYXNoKSB7XG4gICAgICAgICAgICBjdHgubW96RGFzaCA9IGRhc2g7XG4gICAgICAgICAgICByZXR1cm4gY3R4LndlYmtpdExpbmVEYXNoID0gZGFzaDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjdHguZ2V0TGluZURhc2gpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5nZXRMaW5lRGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHgubW96RGFzaDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5maXh1cF9saW5lX2Rhc2hfb2Zmc2V0ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uIChkYXNoX29mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoX29mZnNldDtcbiAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoX29mZnNldDtcbiAgICAgICAgcmV0dXJuIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IGRhc2hfb2Zmc2V0O1xuICAgIH07XG4gICAgcmV0dXJuIGN0eC5nZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5tb3pEYXNoT2Zmc2V0O1xuICAgIH07XG59O1xuZXhwb3J0cy5maXh1cF9pbWFnZV9zbW9vdGhpbmcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgY3R4LnNldEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gICAgICAgIGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBjdHguZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gKHJlZiA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQpICE9IG51bGwgPyByZWYgOiB0cnVlO1xuICAgIH07XG59O1xuZXhwb3J0cy5maXh1cF9tZWFzdXJlX3RleHQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgaWYgKGN0eC5tZWFzdXJlVGV4dCAmJiAoY3R4Lmh0bWw1TWVhc3VyZVRleHQgPT0gbnVsbCkpIHtcbiAgICAgICAgY3R4Lmh0bWw1TWVhc3VyZVRleHQgPSBjdHgubWVhc3VyZVRleHQ7XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHRleHRNZXRyaWNzO1xuICAgICAgICAgICAgdGV4dE1ldHJpY3MgPSBjdHguaHRtbDVNZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHRleHRNZXRyaWNzLmFzY2VudCA9IGN0eC5odG1sNU1lYXN1cmVUZXh0KFwibVwiKS53aWR0aCAqIDEuNjtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0TWV0cmljcztcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRfc2NhbGVfcmF0aW8gPSBmdW5jdGlvbiAoY3R4LCBoaWRwaSkge1xuICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbywgZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBpZiAoaGlkcGkpIHtcbiAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn07XG5leHBvcnRzLmZpeHVwX2VsbGlwc2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGVsbGlwc2VfYmV6aWVyO1xuICAgIGVsbGlwc2VfYmV6aWVyID0gZnVuY3Rpb24gKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICB2YXIgYywgcngsIHJ5O1xuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbnRpY2xvY2t3aXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IDAuNTUxNzg0O1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgcnggPSByYWRpdXNYO1xuICAgICAgICByeSA9IHJhZGl1c1k7XG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICByeCA9IC1yYWRpdXNYO1xuICAgICAgICAgICAgcnkgPSAtcmFkaXVzWTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubW92ZVRvKC1yeCwgMCk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKC1yeCwgcnkgKiBjLCAtcnggKiBjLCByeSwgMCwgcnkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhyeCAqIGMsIHJ5LCByeCwgcnkgKiBjLCByeCwgMCk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHJ4LCAtcnkgKiBjLCByeCAqIGMsIC1yeSwgMCwgLXJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oLXJ4ICogYywgLXJ5LCAtcngsIC1yeSAqIGMsIC1yeCwgMCk7XG4gICAgICAgIGN0eC5yb3RhdGUoLXJvdGF0aW9uKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH07XG4gICAgaWYgKCFjdHguZWxsaXBzZSkge1xuICAgICAgICByZXR1cm4gY3R4LmVsbGlwc2UgPSBlbGxpcHNlX2JlemllcjtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2NvbXBvbmVudDJoZXgsIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgc3ZnX2NvbG9ycyA9IHJlcXVpcmUoXCIuL3N2Z19jb2xvcnNcIik7XG5fY29tcG9uZW50MmhleCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGg7XG4gICAgaCA9IE51bWJlcih2KS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGggPSBoLmxlbmd0aCA9PT0gMSA/ICcwJyArIGggOiBoO1xufTtcbmV4cG9ydHMuY29sb3IyaGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGhleCwgcmdiLCB2O1xuICAgIGNvbG9yID0gY29sb3IgKyAnJztcbiAgICBpZiAoY29sb3IuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3ZnX2NvbG9yc1tjb2xvcl0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3ZnX2NvbG9yc1tjb2xvcl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoJ3JnYicpID09PSAwKSB7XG4gICAgICAgIHJnYiA9IGNvbG9yLm1hdGNoKC9cXGQrL2cpO1xuICAgICAgICBoZXggPSAoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZ2IubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gcmdiW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChfY29tcG9uZW50MmhleCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiAnIycgKyBoZXguc2xpY2UoMCwgOCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxufTtcbmV4cG9ydHMuY29sb3IycmdiYSA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpIHtcbiAgICB2YXIgaGV4LCBpLCByZ2JhO1xuICAgIGlmIChhbHBoYSA9PSBudWxsKSB7XG4gICAgICAgIGFscGhhID0gMTtcbiAgICB9XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBoZXggPSBleHBvcnRzLmNvbG9yMmhleChjb2xvcik7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoLyB8Iy9nLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPD0gNCkge1xuICAgICAgICBoZXggPSBoZXgucmVwbGFjZSgvKC4pL2csICckMSQxJyk7XG4gICAgfVxuICAgIGhleCA9IGhleC5tYXRjaCgvLi4vZyk7XG4gICAgcmdiYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaGV4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaGV4W2pdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50KGksIDE2KSAvIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICB3aGlsZSAocmdiYS5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJnYmEucHVzaCgwKTtcbiAgICB9XG4gICAgaWYgKHJnYmEubGVuZ3RoIDwgNCkge1xuICAgICAgICByZ2JhLnB1c2goYWxwaGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmdiYS5zbGljZSgwLCA0KTtcbn07XG5leHBvcnRzLnZhbGlkX3JnYiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjb250ZW50cywgcGFyYW1zLCByZWYsIHJnYjtcbiAgICBzd2l0Y2ggKHZhbHVlLnN1YnN0cmluZygwLCA0KSkge1xuICAgICAgICBjYXNlIFwicmdiYVwiOlxuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBcInJnYmEoXCIsXG4gICAgICAgICAgICAgICAgbGVuOiA0LFxuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZ2IoXCI6XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFwicmdiKFwiLFxuICAgICAgICAgICAgICAgIGxlbjogMyxcbiAgICAgICAgICAgICAgICBhbHBoYTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5ldyBSZWdFeHAoXCIuKj8oXFxcXC4pLiooLClcIikudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sb3IgZXhwZWN0cyBpbnRlZ2VycyBmb3IgcmdiIGluIHJnYi9yZ2JhIHR1cGxlLCByZWNlaXZlZCBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgY29udGVudHMgPSB2YWx1ZS5yZXBsYWNlKHBhcmFtcy5zdGFydCwgXCJcIikucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoJywnKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgaWYgKGNvbnRlbnRzLmxlbmd0aCAhPT0gcGFyYW1zLmxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvciBleHBlY3RzIHJnYmEgXCIgKyBleHBlY3RfbGVuICsgXCItdHVwbGUsIHJlY2VpdmVkIFwiICsgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmFscGhhICYmICEoKDAgPD0gKHJlZiA9IGNvbnRlbnRzWzNdKSAmJiByZWYgPD0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbG9yIGV4cGVjdHMgcmdiYSA0LXR1cGxlIHRvIGhhdmUgYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXhPZi5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgIHJlZjEgPSBjb250ZW50cy5zbGljZSgwLCAzKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZ2IgPSByZWYxW2pdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCgwIDw9IHJnYiAmJiByZ2IgPD0gMjU1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKSwgZmFsc2UpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sb3IgZXhwZWN0cyByZ2IgdG8gaGF2ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xudmFyIGVxXzEgPSByZXF1aXJlKFwiLi9lcVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5leHBvcnRzLk11bHRpRGljdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlEaWN0KCkge1xuICAgICAgICB0aGlzLl9kaWN0ID0ge307XG4gICAgfVxuICAgIE11bHRpRGljdC5wcm90b3R5cGUuX2V4aXN0aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2RpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlEaWN0LnByb3RvdHlwZS5hZGRfdmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3Rpbmc7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcHV0IG51bGwgaW4gdGhpcyBkaWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwdXQgYXJyYXlzIGluIHRoaXMgZGljdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZyA9IHRoaXMuX2V4aXN0aW5nKGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV0gPSBbZXhpc3RpbmcsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGlEaWN0LnByb3RvdHlwZS5yZW1vdmVfdmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcsIG5ld19hcnJheTtcbiAgICAgICAgZXhpc3RpbmcgPSB0aGlzLl9leGlzdGluZyhrZXkpO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgbmV3X2FycmF5ID0gYXJyYXlfMS5kaWZmZXJlbmNlKGV4aXN0aW5nLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIGlmIChuZXdfYXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWN0W2tleV0gPSBuZXdfYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX2RpY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcV8xLmlzRXF1YWwoZXhpc3RpbmcsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9kaWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11bHRpRGljdC5wcm90b3R5cGUuZ2V0X29uZSA9IGZ1bmN0aW9uIChrZXksIGR1cGxpY2F0ZV9lcnJvcikge1xuICAgICAgICB2YXIgZXhpc3Rpbmc7XG4gICAgICAgIGV4aXN0aW5nID0gdGhpcy5fZXhpc3Rpbmcoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZHVwbGljYXRlX2Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE11bHRpRGljdDtcbn0pKCk7XG5leHBvcnRzLlNldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkuY29uc3RydWN0b3IgPT09IFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KGFycmF5LnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyYXkuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBTZXQuY29tcGFjdChhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFthcnJheV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0LmNvbXBhY3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGl0ZW0sIGosIGxlbiwgbmV3QXJyYXk7XG4gICAgICAgIG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gYXJyYXlbal07XG4gICAgICAgICAgICBpZiAobmV3QXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdBcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLm1pc3NpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy52YWx1ZXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoMCwgaSkuY29uY2F0KHRoaXMudmFsdWVzLnNsaWNlKGkgKyAxKSk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aDtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLm1pc3NpbmcgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaW5jbHVkZXMoaXRlbSk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5qb2luKHN0cik7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKCcsICcpO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy52YWx1ZXMuY29uY2F0KHNldC52YWx1ZXMpKTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB2YXIgaXRlbSwgaiwgbGVuLCBuZXdTZXQsIHJlZjtcbiAgICAgICAgc2V0ID0gbmV3IFNldChzZXQpO1xuICAgICAgICBuZXdTZXQgPSBuZXcgU2V0O1xuICAgICAgICByZWYgPSBzZXQudmFsdWVzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWZbal07XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlcyhpdGVtKSAmJiBzZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB2YXIgaXRlbSwgaiwgbGVuLCBuZXdTZXQsIHJlZjtcbiAgICAgICAgc2V0ID0gbmV3IFNldChzZXQpO1xuICAgICAgICBuZXdTZXQgPSBuZXcgU2V0O1xuICAgICAgICByZWYgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVmW2pdO1xuICAgICAgICAgICAgaWYgKHNldC5taXNzaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICB9O1xuICAgIHJldHVybiBTZXQ7XG59KSgpO1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbmZ1bmN0aW9uIGVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgICAgIGlmICgrYSAhPT0gK2EpXG4gICAgICAgICAgICAgICAgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKHR5cGVzXzEuaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgdHlwZXNfMS5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKVxuICAgICAgICAgICAgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgICAgICBpZiAoIShiLmhhc093blByb3BlcnR5KGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbn1cbmV4cG9ydHMuaXNFcXVhbCA9IGlzRXF1YWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGFuZ2xlX25vcm0oYW5nbGUpIHtcbiAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICB3aGlsZSAoYW5nbGUgPiAyICogTWF0aC5QSSkge1xuICAgICAgICBhbmdsZSAtPSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgcmV0dXJuIGFuZ2xlO1xufVxuZXhwb3J0cy5hbmdsZV9ub3JtID0gYW5nbGVfbm9ybTtcbmZ1bmN0aW9uIGFuZ2xlX2Rpc3QobGhzLCByaHMpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW5nbGVfbm9ybShsaHMgLSByaHMpKTtcbn1cbmV4cG9ydHMuYW5nbGVfZGlzdCA9IGFuZ2xlX2Rpc3Q7XG5mdW5jdGlvbiBhbmdsZV9iZXR3ZWVuKG1pZCwgbGhzLCByaHMsIGRpcmVjdGlvbikge1xuICAgIHZhciBub3JtX21pZCA9IGFuZ2xlX25vcm0obWlkKTtcbiAgICB2YXIgZCA9IGFuZ2xlX2Rpc3QobGhzLCByaHMpO1xuICAgIHZhciBjb25kID0gYW5nbGVfZGlzdChsaHMsIG5vcm1fbWlkKSA8PSBkICYmIGFuZ2xlX2Rpc3Qobm9ybV9taWQsIHJocykgPD0gZDtcbiAgICBpZiAoZGlyZWN0aW9uID09IFwiYW50aWNsb2NrXCIpXG4gICAgICAgIHJldHVybiBjb25kO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICFjb25kO1xufVxuZXhwb3J0cy5hbmdsZV9iZXR3ZWVuID0gYW5nbGVfYmV0d2VlbjtcbmZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbn1cbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZnVuY3Rpb24gYXRhbjIoc3RhcnQsIGVuZCkge1xuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIGEgbGluZSBjb250YWluaW5nIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIChjb21wb3NlZFxuICAgICAqIG9mIFt4LCB5XSBhcnJheXMpIGFuZCB0aGUgcG9zaXRpdmUgeC1heGlzLlxuICAgICAqL1xuICAgIHJldHVybiBNYXRoLmF0YW4yKGVuZFsxXSAtIHN0YXJ0WzFdLCBlbmRbMF0gLSBzdGFydFswXSk7XG59XG5leHBvcnRzLmF0YW4yID0gYXRhbjI7XG4vLyBodHRwOi8vd3d3Mi5lY29uLm9zYWthLXUuYWMuanAvfnRhbml6YWtpL2NsYXNzLzIwMTMvZWNvbm9tZTMvMTMucGRmIChQYWdlIDQzMilcbmZ1bmN0aW9uIHJub3JtKG11LCBzaWdtYSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIG5vcm1hbCB3aXRoIGEgbWVhbiBvZiAwIGFuZCBhIHNpZ21hIG9mIDFcbiAgICB2YXIgcjE7XG4gICAgdmFyIHIyO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHIxID0gcmFuZG9tKCk7XG4gICAgICAgIHIyID0gcmFuZG9tKCk7XG4gICAgICAgIHIyID0gKDIgKiByMiAtIDEpICogTWF0aC5zcXJ0KDIgKiAoMSAvIE1hdGguRSkpO1xuICAgICAgICBpZiAoLTQgKiByMSAqIHIxICogTWF0aC5sb2cocjEpID49IHIyICogcjIpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJuID0gcjIgLyByMTtcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHN0YW5kYXJkIG5vcm1hbCB0byBtZWV0IHRoZSBjaGFyYWN0ZXJpc3RpY3MgdGhhdCB3ZSB3YW50IChtdSwgc2lnbWEpXG4gICAgcm4gPSBtdSArIHNpZ21hICogcm47XG4gICAgcmV0dXJuIHJuO1xufVxuZXhwb3J0cy5ybm9ybSA9IHJub3JtO1xuZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xuICAgIGlmICh2YWwgPiBtYXgpXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgaWYgKHZhbCA8IG1pbilcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IG9iamVjdFtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgc291cmNlc18xID0gc291cmNlczsgX2EgPCBzb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzXzFbX2FdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByb2o0ID0gcmVxdWlyZShcInByb2o0L2xpYi9jb3JlXCIpO1xuZXhwb3J0cy5wcm9qNCA9IHByb2o0O1xudmFyIFByb2ogPSByZXF1aXJlKFwicHJvajQvbGliL1Byb2pcIik7XG52YXIgdG9Qb2ludCA9IHJlcXVpcmUoXCJwcm9qNC9saWIvY29tbW9uL3RvUG9pbnRcIik7XG52YXIgZGVmcyA9IHJlcXVpcmUoXCJwcm9qNC9saWIvZGVmc1wiKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKFwicHJvajQvbGliL3RyYW5zZm9ybVwiKTtcbnByb2o0LmRlZmF1bHREYXR1bSA9ICdXR1M4NCc7XG5wcm9qNC5XR1M4NCA9IG5ldyBQcm9qKCdXR1M4NCcpO1xucHJvajQuUHJvaiA9IFByb2o7XG5wcm9qNC50b1BvaW50ID0gdG9Qb2ludDtcbnByb2o0LmRlZnMgPSBkZWZzO1xucHJvajQudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy5tZXJjYXRvciA9IGRlZnMoJ0dPT0dMRScpO1xuZXhwb3J0cy53Z3M4NCA9IGRlZnMoJ1dHUzg0Jyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9qNF8xID0gcmVxdWlyZShcIi4vcHJvajRcIik7XG5leHBvcnRzLnByb2plY3RfeHkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBpLCBqLCBtZXJjX3gsIG1lcmNfeF9zLCBtZXJjX3ksIG1lcmNfeV9zLCByZWYsIHJlZjE7XG4gICAgbWVyY194X3MgPSBbXTtcbiAgICBtZXJjX3lfcyA9IFtdO1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgIHJlZjEgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IsIFt4W2ldLCB5W2ldXSksIG1lcmNfeCA9IHJlZjFbMF0sIG1lcmNfeSA9IHJlZjFbMV07XG4gICAgICAgIG1lcmNfeF9zW2ldID0gbWVyY194O1xuICAgICAgICBtZXJjX3lfc1tpXSA9IG1lcmNfeTtcbiAgICB9XG4gICAgcmV0dXJuIFttZXJjX3hfcywgbWVyY195X3NdO1xufTtcbmV4cG9ydHMucHJvamVjdF94c3lzID0gZnVuY3Rpb24gKHhzLCB5cykge1xuICAgIHZhciBpLCBqLCBtZXJjX3hfcywgbWVyY194c19zLCBtZXJjX3lfcywgbWVyY195c19zLCByZWYsIHJlZjE7XG4gICAgbWVyY194c19zID0gW107XG4gICAgbWVyY195c19zID0gW107XG4gICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHhzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgIHJlZjEgPSBleHBvcnRzLnByb2plY3RfeHkoeHNbaV0sIHlzW2ldKSwgbWVyY194X3MgPSByZWYxWzBdLCBtZXJjX3lfcyA9IHJlZjFbMV07XG4gICAgICAgIG1lcmNfeHNfc1tpXSA9IG1lcmNfeF9zO1xuICAgICAgICBtZXJjX3lzX3NbaV0gPSBtZXJjX3lfcztcbiAgICB9XG4gICAgcmV0dXJuIFttZXJjX3hzX3MsIG1lcmNfeXNfc107XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFzX3Byb3BzXzEgPSByZXF1aXJlKFwiLi4vaGFzX3Byb3BzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuY3JlYXRlX3JlZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVmO1xuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIGhhc19wcm9wc18xLkhhc1Byb3BzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gb25seSBjcmVhdGUgcmVmcyBmb3IgSGFzUHJvcHMgc3ViY2xhc3Nlc1wiKTtcbiAgICB9XG4gICAgcmVmID0ge1xuICAgICAgICAndHlwZSc6IG9iai50eXBlLFxuICAgICAgICAnaWQnOiBvYmouaWRcbiAgICB9O1xuICAgIGlmIChvYmouX3N1YnR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZWZbJ3N1YnR5cGUnXSA9IG9iai5fc3VidHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn07XG5leHBvcnRzLmlzX3JlZiA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIga2V5cztcbiAgICBpZiAodHlwZXNfMS5pc09iamVjdChhcmcpKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5c1swXSA9PT0gJ2lkJyAmJiBrZXlzWzFdID09PSAndHlwZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5c1swXSA9PT0gJ2lkJyAmJiBrZXlzWzFdID09PSAnc3VidHlwZScgJiYga2V5c1syXSA9PT0gJ3R5cGUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLmNvbnZlcnRfdG9fcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVzXzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChleHBvcnRzLmNvbnZlcnRfdG9fcmVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGhhc19wcm9wc18xLkhhc1Byb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldF9pbmRpY2VzID0gZnVuY3Rpb24gKGRhdGFfc291cmNlKSB7XG4gICAgdmFyIHNlbGVjdGVkO1xuICAgIHNlbGVjdGVkID0gZGF0YV9zb3VyY2Uuc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkWycwZCddLmdseXBoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFsnMGQnXS5pbmRpY2VzO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3RlZFsnMWQnXS5pbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkWycxZCddLmluZGljZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdGVkWycyZCddLmluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRbJzJkJ10uaW5kaWNlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQVJSQVlfVFlQRVMsIERUWVBFUywgX2FycmF5QnVmZmVyVG9CYXNlNjQsIF9iYXNlNjRUb0FycmF5QnVmZmVyLCBrLCB2O1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbkFSUkFZX1RZUEVTID0ge1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheSxcbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXksXG4gICAgdWludDg6IFVpbnQ4QXJyYXksXG4gICAgaW50ODogSW50OEFycmF5LFxuICAgIHVpbnQxNjogVWludDE2QXJyYXksXG4gICAgaW50MTY6IEludDE2QXJyYXksXG4gICAgdWludDMyOiBVaW50MzJBcnJheSxcbiAgICBpbnQzMjogSW50MzJBcnJheVxufTtcbkRUWVBFUyA9IHt9O1xuZm9yIChrIGluIEFSUkFZX1RZUEVTKSB7XG4gICAgdiA9IEFSUkFZX1RZUEVTW2tdO1xuICAgIERUWVBFU1t2Lm5hbWVdID0gaztcbn1cbl9hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciBiLCBiaW5hcnksIGJ5dGVzO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBiaW5hcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gYnl0ZXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICBiID0gYnl0ZXNbal07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gYnRvYShiaW5hcnkuam9pbihcIlwiKSk7XG59O1xuX2Jhc2U2NFRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYmFzZTY0KSB7XG4gICAgdmFyIGJpbmFyeV9zdHJpbmcsIGJ5dGVzLCBpLCBqLCBsZW4sIHJlZjtcbiAgICBiaW5hcnlfc3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gbGVuOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5idWZmZXI7XG59O1xuZXhwb3J0cy5kZWNvZGVfYmFzZTY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGFycmF5LCBieXRlcywgZHR5cGUsIHNoYXBlO1xuICAgIGJ5dGVzID0gX2Jhc2U2NFRvQXJyYXlCdWZmZXIoaW5wdXRbJ19fbmRhcnJheV9fJ10pO1xuICAgIGR0eXBlID0gaW5wdXRbJ2R0eXBlJ107XG4gICAgaWYgKGR0eXBlIGluIEFSUkFZX1RZUEVTKSB7XG4gICAgICAgIGFycmF5ID0gbmV3IEFSUkFZX1RZUEVTW2R0eXBlXShieXRlcyk7XG4gICAgfVxuICAgIHNoYXBlID0gaW5wdXRbJ3NoYXBlJ107XG4gICAgcmV0dXJuIFthcnJheSwgc2hhcGVdO1xufTtcbmV4cG9ydHMuZW5jb2RlX2Jhc2U2NCA9IGZ1bmN0aW9uIChhcnJheSwgc2hhcGUpIHtcbiAgICB2YXIgYjY0LCBkYXRhLCBkdHlwZTtcbiAgICBiNjQgPSBfYXJyYXlCdWZmZXJUb0Jhc2U2NChhcnJheS5idWZmZXIpO1xuICAgIGR0eXBlID0gRFRZUEVTW2FycmF5LmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgIGRhdGEgPSB7XG4gICAgICAgIF9fbmRhcnJheV9fOiBiNjQsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgZHR5cGU6IGR0eXBlXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5leHBvcnRzLmRlY29kZV9jb2x1bW5fZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGFyciwgYXJyYXlzLCBkYXRhX3NoYXBlcywgaiwgbGVuMSwgbmV3X2RhdGEsIHJlZiwgcmVmMSwgc2hhcGUsIHNoYXBlcztcbiAgICBuZXdfZGF0YSA9IHt9O1xuICAgIGRhdGFfc2hhcGVzID0ge307XG4gICAgZm9yIChrIGluIGRhdGEpIHtcbiAgICAgICAgdiA9IGRhdGFba107XG4gICAgICAgIGlmICh0eXBlc18xLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGFycmF5cyA9IFtdO1xuICAgICAgICAgICAgc2hhcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gdi5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhcnIgPSB2W2pdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc18xLmlzT2JqZWN0KGFycikgJiYgJ19fbmRhcnJheV9fJyBpbiBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gZXhwb3J0cy5kZWNvZGVfYmFzZTY0KGFyciksIGFyciA9IHJlZlswXSwgc2hhcGUgPSByZWZbMV07XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlzLnB1c2goYXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICBhcnJheXMucHVzaChhcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5ld19kYXRhW2tdID0gYXJyYXlzO1xuICAgICAgICAgICAgICAgIGRhdGFfc2hhcGVzW2tdID0gc2hhcGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3X2RhdGFba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodikgJiYgJ19fbmRhcnJheV9fJyBpbiB2KSB7XG4gICAgICAgICAgICByZWYxID0gZXhwb3J0cy5kZWNvZGVfYmFzZTY0KHYpLCBhcnIgPSByZWYxWzBdLCBzaGFwZSA9IHJlZjFbMV07XG4gICAgICAgICAgICBuZXdfZGF0YVtrXSA9IGFycjtcbiAgICAgICAgICAgIGRhdGFfc2hhcGVzW2tdID0gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICBkYXRhX3NoYXBlc1trXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbmV3X2RhdGEsIGRhdGFfc2hhcGVzXTtcbn07XG5leHBvcnRzLmVuY29kZV9jb2x1bW5fZGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBzaGFwZXMpIHtcbiAgICB2YXIgaSwgaiwgbmV3X2FycmF5LCBuZXdfZGF0YSwgcmVmLCByZWYxLCByZWYyO1xuICAgIG5ld19kYXRhID0ge307XG4gICAgZm9yIChrIGluIGRhdGEpIHtcbiAgICAgICAgdiA9IGRhdGFba107XG4gICAgICAgIGlmICgodiAhPSBudWxsID8gdi5idWZmZXIgOiB2b2lkIDApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHYgPSBleHBvcnRzLmVuY29kZV9iYXNlNjQodiwgc2hhcGVzICE9IG51bGwgPyBzaGFwZXNba10gOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgbmV3X2FycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdi5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIGlmICgoKHJlZjEgPSB2W2ldKSAhPSBudWxsID8gcmVmMS5idWZmZXIgOiB2b2lkIDApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2FycmF5LnB1c2goZXhwb3J0cy5lbmNvZGVfYmFzZTY0KHZbaV0sIHNoYXBlcyAhPSBudWxsID8gKHJlZjIgPSBzaGFwZXNba10pICE9IG51bGwgPyByZWYyW2ldIDogdm9pZCAwIDogdm9pZCAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdfYXJyYXkucHVzaCh2W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gbmV3X2FycmF5O1xuICAgICAgICB9XG4gICAgICAgIG5ld19kYXRhW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIG5ld19kYXRhO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0eXBlcy9yYnVzaFwiIC8+XG52YXIgcmJ1c2ggPSByZXF1aXJlKFwicmJ1c2hcIik7XG52YXIgU3BhdGlhbEluZGV4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGF0aWFsSW5kZXgoKSB7XG4gICAgfVxuICAgIHJldHVybiBTcGF0aWFsSW5kZXg7XG59KCkpO1xuZXhwb3J0cy5TcGF0aWFsSW5kZXggPSBTcGF0aWFsSW5kZXg7XG52YXIgUkJ1c2ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSQnVzaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSQnVzaChwb2ludHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5kZXggPSByYnVzaCgpO1xuICAgICAgICBfdGhpcy5pbmRleC5sb2FkKHBvaW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJCdXNoLnByb3RvdHlwZSwgXCJiYm94XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmluZGV4LnRvSlNPTigpLCBtaW5YID0gX2EubWluWCwgbWluWSA9IF9hLm1pblksIG1heFggPSBfYS5tYXhYLCBtYXhZID0gX2EubWF4WTtcbiAgICAgICAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1pblk6IG1pblksIG1heFg6IG1heFgsIG1heFk6IG1heFkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUkJ1c2gucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4LnNlYXJjaChyZWN0KTtcbiAgICB9O1xuICAgIFJCdXNoLnByb3RvdHlwZS5pbmRpY2VzID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuc2VhcmNoKHJlY3QpO1xuICAgICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRpY2VzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgaW5kaWNlc1tqXSA9IHBvaW50c1tqXS5pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgIH07XG4gICAgcmV0dXJuIFJCdXNoO1xufShTcGF0aWFsSW5kZXgpKTtcbmV4cG9ydHMuUkJ1c2ggPSBSQnVzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbiA9IDA7IH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cihwb3NpdGlvbiwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT0gc2VhcmNoU3RyaW5nO1xufVxuZXhwb3J0cy5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbmZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgIC8vIGZyb20gaXB5dGhvbiBwcm9qZWN0XG4gICAgLy8gaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHRcbiAgICB2YXIgcyA9IG5ldyBBcnJheSgzMik7XG4gICAgdmFyIGhleERpZ2l0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBzW2ldID0gaGV4RGlnaXRzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwKSwgMSk7XG4gICAgfVxuICAgIHNbMTJdID0gXCI0XCI7IC8vIGJpdHMgMTItMTUgb2YgdGhlIHRpbWVfaGlfYW5kX3ZlcnNpb24gZmllbGQgdG8gMDAxMFxuICAgIHNbMTZdID0gaGV4RGlnaXRzLnN1YnN0cigoc1sxNl0uY2hhckNvZGVBdCgwKSAmIDB4MykgfCAweDgsIDEpOyAvLyBiaXRzIDYtNyBvZiB0aGUgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZCB0byAwMVxuICAgIHZhciB1dWlkID0gcy5qb2luKFwiXCIpO1xuICAgIGlmIChwcmVmaXggIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIFwiLVwiICsgdXVpZDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB1dWlkO1xufVxuZXhwb3J0cy51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oPzpbJjw+XCInYF0pL2csIGZ1bmN0aW9uIChjaCkge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcbiAgICAgICAgICAgIGNhc2UgJz4nOiByZXR1cm4gJyZndDsnO1xuICAgICAgICAgICAgY2FzZSAnXCInOiByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gJyYjeDI3Oyc7XG4gICAgICAgICAgICBjYXNlICdgJzogcmV0dXJuICcmI3g2MDsnO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmRpYW5yZWQgPSBcIiNDRDVDNUNcIjtcbmV4cG9ydHMubGlnaHRjb3JhbCA9IFwiI0YwODA4MFwiO1xuZXhwb3J0cy5zYWxtb24gPSBcIiNGQTgwNzJcIjtcbmV4cG9ydHMuZGFya3NhbG1vbiA9IFwiI0U5OTY3QVwiO1xuZXhwb3J0cy5saWdodHNhbG1vbiA9IFwiI0ZGQTA3QVwiO1xuZXhwb3J0cy5jcmltc29uID0gXCIjREMxNDNDXCI7XG5leHBvcnRzLnJlZCA9IFwiI0ZGMDAwMFwiO1xuZXhwb3J0cy5maXJlYnJpY2sgPSBcIiNCMjIyMjJcIjtcbmV4cG9ydHMuZGFya3JlZCA9IFwiIzhCMDAwMFwiO1xuZXhwb3J0cy5waW5rID0gXCIjRkZDMENCXCI7XG5leHBvcnRzLmxpZ2h0cGluayA9IFwiI0ZGQjZDMVwiO1xuZXhwb3J0cy5ob3RwaW5rID0gXCIjRkY2OUI0XCI7XG5leHBvcnRzLmRlZXBwaW5rID0gXCIjRkYxNDkzXCI7XG5leHBvcnRzLm1lZGl1bXZpb2xldHJlZCA9IFwiI0M3MTU4NVwiO1xuZXhwb3J0cy5wYWxldmlvbGV0cmVkID0gXCIjREI3MDkzXCI7XG5leHBvcnRzLmNvcmFsID0gXCIjRkY3RjUwXCI7XG5leHBvcnRzLnRvbWF0byA9IFwiI0ZGNjM0N1wiO1xuZXhwb3J0cy5vcmFuZ2VyZWQgPSBcIiNGRjQ1MDBcIjtcbmV4cG9ydHMuZGFya29yYW5nZSA9IFwiI0ZGOEMwMFwiO1xuZXhwb3J0cy5vcmFuZ2UgPSBcIiNGRkE1MDBcIjtcbmV4cG9ydHMuZ29sZCA9IFwiI0ZGRDcwMFwiO1xuZXhwb3J0cy55ZWxsb3cgPSBcIiNGRkZGMDBcIjtcbmV4cG9ydHMubGlnaHR5ZWxsb3cgPSBcIiNGRkZGRTBcIjtcbmV4cG9ydHMubGVtb25jaGlmZm9uID0gXCIjRkZGQUNEXCI7XG5leHBvcnRzLmxpZ2h0Z29sZGVucm9keWVsbG93ID0gXCIjRkFGQUQyXCI7XG5leHBvcnRzLnBhcGF5YXdoaXAgPSBcIiNGRkVGRDVcIjtcbmV4cG9ydHMubW9jY2FzaW4gPSBcIiNGRkU0QjVcIjtcbmV4cG9ydHMucGVhY2hwdWZmID0gXCIjRkZEQUI5XCI7XG5leHBvcnRzLnBhbGVnb2xkZW5yb2QgPSBcIiNFRUU4QUFcIjtcbmV4cG9ydHMua2hha2kgPSBcIiNGMEU2OENcIjtcbmV4cG9ydHMuZGFya2toYWtpID0gXCIjQkRCNzZCXCI7XG5leHBvcnRzLmxhdmVuZGVyID0gXCIjRTZFNkZBXCI7XG5leHBvcnRzLnRoaXN0bGUgPSBcIiNEOEJGRDhcIjtcbmV4cG9ydHMucGx1bSA9IFwiI0REQTBERFwiO1xuZXhwb3J0cy52aW9sZXQgPSBcIiNFRTgyRUVcIjtcbmV4cG9ydHMub3JjaGlkID0gXCIjREE3MEQ2XCI7XG5leHBvcnRzLmZ1Y2hzaWEgPSBcIiNGRjAwRkZcIjtcbmV4cG9ydHMubWFnZW50YSA9IFwiI0ZGMDBGRlwiO1xuZXhwb3J0cy5tZWRpdW1vcmNoaWQgPSBcIiNCQTU1RDNcIjtcbmV4cG9ydHMubWVkaXVtcHVycGxlID0gXCIjOTM3MERCXCI7XG5leHBvcnRzLmJsdWV2aW9sZXQgPSBcIiM4QTJCRTJcIjtcbmV4cG9ydHMuZGFya3Zpb2xldCA9IFwiIzk0MDBEM1wiO1xuZXhwb3J0cy5kYXJrb3JjaGlkID0gXCIjOTkzMkNDXCI7XG5leHBvcnRzLmRhcmttYWdlbnRhID0gXCIjOEIwMDhCXCI7XG5leHBvcnRzLnB1cnBsZSA9IFwiIzgwMDA4MFwiO1xuZXhwb3J0cy5pbmRpZ28gPSBcIiM0QjAwODJcIjtcbmV4cG9ydHMuc2xhdGVibHVlID0gXCIjNkE1QUNEXCI7XG5leHBvcnRzLmRhcmtzbGF0ZWJsdWUgPSBcIiM0ODNEOEJcIjtcbmV4cG9ydHMubWVkaXVtc2xhdGVibHVlID0gXCIjN0I2OEVFXCI7XG5leHBvcnRzLmdyZWVueWVsbG93ID0gXCIjQURGRjJGXCI7XG5leHBvcnRzLmNoYXJ0cmV1c2UgPSBcIiM3RkZGMDBcIjtcbmV4cG9ydHMubGF3bmdyZWVuID0gXCIjN0NGQzAwXCI7XG5leHBvcnRzLmxpbWUgPSBcIiMwMEZGMDBcIjtcbmV4cG9ydHMubGltZWdyZWVuID0gXCIjMzJDRDMyXCI7XG5leHBvcnRzLnBhbGVncmVlbiA9IFwiIzk4RkI5OFwiO1xuZXhwb3J0cy5saWdodGdyZWVuID0gXCIjOTBFRTkwXCI7XG5leHBvcnRzLm1lZGl1bXNwcmluZ2dyZWVuID0gXCIjMDBGQTlBXCI7XG5leHBvcnRzLnNwcmluZ2dyZWVuID0gXCIjMDBGRjdGXCI7XG5leHBvcnRzLm1lZGl1bXNlYWdyZWVuID0gXCIjM0NCMzcxXCI7XG5leHBvcnRzLnNlYWdyZWVuID0gXCIjMkU4QjU3XCI7XG5leHBvcnRzLmZvcmVzdGdyZWVuID0gXCIjMjI4QjIyXCI7XG5leHBvcnRzLmdyZWVuID0gXCIjMDA4MDAwXCI7XG5leHBvcnRzLmRhcmtncmVlbiA9IFwiIzAwNjQwMFwiO1xuZXhwb3J0cy55ZWxsb3dncmVlbiA9IFwiIzlBQ0QzMlwiO1xuZXhwb3J0cy5vbGl2ZWRyYWIgPSBcIiM2QjhFMjNcIjtcbmV4cG9ydHMub2xpdmUgPSBcIiM4MDgwMDBcIjtcbmV4cG9ydHMuZGFya29saXZlZ3JlZW4gPSBcIiM1NTZCMkZcIjtcbmV4cG9ydHMubWVkaXVtYXF1YW1hcmluZSA9IFwiIzY2Q0RBQVwiO1xuZXhwb3J0cy5kYXJrc2VhZ3JlZW4gPSBcIiM4RkJDOEZcIjtcbmV4cG9ydHMubGlnaHRzZWFncmVlbiA9IFwiIzIwQjJBQVwiO1xuZXhwb3J0cy5kYXJrY3lhbiA9IFwiIzAwOEI4QlwiO1xuZXhwb3J0cy50ZWFsID0gXCIjMDA4MDgwXCI7XG5leHBvcnRzLmFxdWEgPSBcIiMwMEZGRkZcIjtcbmV4cG9ydHMuY3lhbiA9IFwiIzAwRkZGRlwiO1xuZXhwb3J0cy5saWdodGN5YW4gPSBcIiNFMEZGRkZcIjtcbmV4cG9ydHMucGFsZXR1cnF1b2lzZSA9IFwiI0FGRUVFRVwiO1xuZXhwb3J0cy5hcXVhbWFyaW5lID0gXCIjN0ZGRkQ0XCI7XG5leHBvcnRzLnR1cnF1b2lzZSA9IFwiIzQwRTBEMFwiO1xuZXhwb3J0cy5tZWRpdW10dXJxdW9pc2UgPSBcIiM0OEQxQ0NcIjtcbmV4cG9ydHMuZGFya3R1cnF1b2lzZSA9IFwiIzAwQ0VEMVwiO1xuZXhwb3J0cy5jYWRldGJsdWUgPSBcIiM1RjlFQTBcIjtcbmV4cG9ydHMuc3RlZWxibHVlID0gXCIjNDY4MkI0XCI7XG5leHBvcnRzLmxpZ2h0c3RlZWxibHVlID0gXCIjQjBDNERFXCI7XG5leHBvcnRzLnBvd2RlcmJsdWUgPSBcIiNCMEUwRTZcIjtcbmV4cG9ydHMubGlnaHRibHVlID0gXCIjQUREOEU2XCI7XG5leHBvcnRzLnNreWJsdWUgPSBcIiM4N0NFRUJcIjtcbmV4cG9ydHMubGlnaHRza3libHVlID0gXCIjODdDRUZBXCI7XG5leHBvcnRzLmRlZXBza3libHVlID0gXCIjMDBCRkZGXCI7XG5leHBvcnRzLmRvZGdlcmJsdWUgPSBcIiMxRTkwRkZcIjtcbmV4cG9ydHMuY29ybmZsb3dlcmJsdWUgPSBcIiM2NDk1RURcIjtcbmV4cG9ydHMucm95YWxibHVlID0gXCIjNDE2OUUxXCI7XG5leHBvcnRzLmJsdWUgPSBcIiMwMDAwRkZcIjtcbmV4cG9ydHMubWVkaXVtYmx1ZSA9IFwiIzAwMDBDRFwiO1xuZXhwb3J0cy5kYXJrYmx1ZSA9IFwiIzAwMDA4QlwiO1xuZXhwb3J0cy5uYXZ5ID0gXCIjMDAwMDgwXCI7XG5leHBvcnRzLm1pZG5pZ2h0Ymx1ZSA9IFwiIzE5MTk3MFwiO1xuZXhwb3J0cy5jb3Juc2lsayA9IFwiI0ZGRjhEQ1wiO1xuZXhwb3J0cy5ibGFuY2hlZGFsbW9uZCA9IFwiI0ZGRUJDRFwiO1xuZXhwb3J0cy5iaXNxdWUgPSBcIiNGRkU0QzRcIjtcbmV4cG9ydHMubmF2YWpvd2hpdGUgPSBcIiNGRkRFQURcIjtcbmV4cG9ydHMud2hlYXQgPSBcIiNGNURFQjNcIjtcbmV4cG9ydHMuYnVybHl3b29kID0gXCIjREVCODg3XCI7XG5leHBvcnRzLnRhbiA9IFwiI0QyQjQ4Q1wiO1xuZXhwb3J0cy5yb3N5YnJvd24gPSBcIiNCQzhGOEZcIjtcbmV4cG9ydHMuc2FuZHlicm93biA9IFwiI0Y0QTQ2MFwiO1xuZXhwb3J0cy5nb2xkZW5yb2QgPSBcIiNEQUE1MjBcIjtcbmV4cG9ydHMuZGFya2dvbGRlbnJvZCA9IFwiI0I4ODYwQlwiO1xuZXhwb3J0cy5wZXJ1ID0gXCIjQ0Q4NTNGXCI7XG5leHBvcnRzLmNob2NvbGF0ZSA9IFwiI0QyNjkxRVwiO1xuZXhwb3J0cy5zYWRkbGVicm93biA9IFwiIzhCNDUxM1wiO1xuZXhwb3J0cy5zaWVubmEgPSBcIiNBMDUyMkRcIjtcbmV4cG9ydHMuYnJvd24gPSBcIiNBNTJBMkFcIjtcbmV4cG9ydHMubWFyb29uID0gXCIjODAwMDAwXCI7XG5leHBvcnRzLndoaXRlID0gXCIjRkZGRkZGXCI7XG5leHBvcnRzLnNub3cgPSBcIiNGRkZBRkFcIjtcbmV4cG9ydHMuaG9uZXlkZXcgPSBcIiNGMEZGRjBcIjtcbmV4cG9ydHMubWludGNyZWFtID0gXCIjRjVGRkZBXCI7XG5leHBvcnRzLmF6dXJlID0gXCIjRjBGRkZGXCI7XG5leHBvcnRzLmFsaWNlYmx1ZSA9IFwiI0YwRjhGRlwiO1xuZXhwb3J0cy5naG9zdHdoaXRlID0gXCIjRjhGOEZGXCI7XG5leHBvcnRzLndoaXRlc21va2UgPSBcIiNGNUY1RjVcIjtcbmV4cG9ydHMuc2Vhc2hlbGwgPSBcIiNGRkY1RUVcIjtcbmV4cG9ydHMuYmVpZ2UgPSBcIiNGNUY1RENcIjtcbmV4cG9ydHMub2xkbGFjZSA9IFwiI0ZERjVFNlwiO1xuZXhwb3J0cy5mbG9yYWx3aGl0ZSA9IFwiI0ZGRkFGMFwiO1xuZXhwb3J0cy5pdm9yeSA9IFwiI0ZGRkZGMFwiO1xuZXhwb3J0cy5hbnRpcXVld2hpdGUgPSBcIiNGQUVCRDdcIjtcbmV4cG9ydHMubGluZW4gPSBcIiNGQUYwRTZcIjtcbmV4cG9ydHMubGF2ZW5kZXJibHVzaCA9IFwiI0ZGRjBGNVwiO1xuZXhwb3J0cy5taXN0eXJvc2UgPSBcIiNGRkU0RTFcIjtcbmV4cG9ydHMuZ2FpbnNib3JvID0gXCIjRENEQ0RDXCI7XG5leHBvcnRzLmxpZ2h0Z3JheSA9IFwiI0QzRDNEM1wiO1xuZXhwb3J0cy5saWdodGdyZXkgPSBcIiNEM0QzRDNcIjtcbmV4cG9ydHMuc2lsdmVyID0gXCIjQzBDMEMwXCI7XG5leHBvcnRzLmRhcmtncmF5ID0gXCIjQTlBOUE5XCI7XG5leHBvcnRzLmRhcmtncmV5ID0gXCIjQTlBOUE5XCI7XG5leHBvcnRzLmdyYXkgPSBcIiM4MDgwODBcIjtcbmV4cG9ydHMuZ3JleSA9IFwiIzgwODA4MFwiO1xuZXhwb3J0cy5kaW1ncmF5ID0gXCIjNjk2OTY5XCI7XG5leHBvcnRzLmRpbWdyZXkgPSBcIiM2OTY5NjlcIjtcbmV4cG9ydHMubGlnaHRzbGF0ZWdyYXkgPSBcIiM3Nzg4OTlcIjtcbmV4cG9ydHMubGlnaHRzbGF0ZWdyZXkgPSBcIiM3Nzg4OTlcIjtcbmV4cG9ydHMuc2xhdGVncmF5ID0gXCIjNzA4MDkwXCI7XG5leHBvcnRzLnNsYXRlZ3JleSA9IFwiIzcwODA5MFwiO1xuZXhwb3J0cy5kYXJrc2xhdGVncmF5ID0gXCIjMkY0RjRGXCI7XG5leHBvcnRzLmRhcmtzbGF0ZWdyZXkgPSBcIiMyRjRGNEZcIjtcbmV4cG9ydHMuYmxhY2sgPSBcIiMwMDAwMDBcIjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9mb3JtYXRfbnVtYmVyO1xudmFyIFNQcmludGYgPSByZXF1aXJlKFwic3ByaW50ZlwiKTtcbnZhciBOdW1icm8gPSByZXF1aXJlKFwibnVtYnJvXCIpO1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbl9mb3JtYXRfbnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHZhciBmb3JtYXQ7XG4gICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIobnVtYmVyKSkge1xuICAgICAgICBmb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTWF0aC5mbG9vcihudW1iZXIpICE9PSBudW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAhKE1hdGguYWJzKG51bWJlcikgPiAwLjEgJiYgTWF0aC5hYnMobnVtYmVyKSA8IDEwMDApOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIlMC4zZlwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiUwLjNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBTUHJpbnRmLnNwcmludGYoZm9ybWF0LCBudW1iZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBudW1iZXI7XG4gICAgfVxufTtcbmV4cG9ydHMucmVwbGFjZV9wbGFjZWhvbGRlcnMgPSBmdW5jdGlvbiAoc3RyaW5nLCBkYXRhX3NvdXJjZSwgaSwgc3BlY2lhbF92YXJzKSB7XG4gICAgaWYgKHNwZWNpYWxfdmFycyA9PSBudWxsKSB7XG4gICAgICAgIHNwZWNpYWxfdmFycyA9IHt9O1xuICAgIH1cbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvKF58W15cXCRdKVxcJChcXHcrKS9nLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIFwiQCRcIiArIG5hbWU7XG4gICAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC8oXnxbXkBdKUAoPzooXFwkP1xcdyspfHsoW157fV0rKX0pKD86eyhbXnt9XSspfSk/L2csIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBuYW1lLCBsb25nX25hbWUsIGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVwbGFjZW1lbnQsIHZhbHVlO1xuICAgICAgICAgICAgbmFtZSA9IGxvbmdfbmFtZSAhPSBudWxsID8gbG9uZ19uYW1lIDogbmFtZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmFtZVswXSA9PT0gXCIkXCIgPyBzcGVjaWFsX3ZhcnNbbmFtZS5zdWJzdHJpbmcoMSldIDogKHJlZiA9IGRhdGFfc291cmNlLmdldF9jb2x1bW4obmFtZSkpICE9IG51bGwgPyByZWZbaV0gOiB2b2lkIDA7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gXCI/Pz9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdzYWZlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IE51bWJyby5mb3JtYXQodmFsdWUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IF9mb3JtYXRfbnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQgPSBcIlwiICsgcHJlZml4ICsgKHN0cmluZ18xLmVzY2FwZShyZXBsYWNlbWVudCkpO1xuICAgICAgICB9O1xuICAgIH0pKHRoaXMpKTtcbiAgICByZXR1cm4gc3RyaW5nO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhY2hlO1xudmFyIGRvbV8xID0gcmVxdWlyZShcIi4uL2RvbVwiKTtcbmNhY2hlID0ge307XG5leHBvcnRzLmdldF90ZXh0X2hlaWdodCA9IGZ1bmN0aW9uIChmb250KSB7XG4gICAgdmFyIGJsb2NrLCBlbGVtLCByZXN1bHQsIHRleHQ7XG4gICAgaWYgKGNhY2hlW2ZvbnRdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlW2ZvbnRdO1xuICAgIH1cbiAgICB0ZXh0ID0gZG9tXzEuc3Bhbih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250OiBmb250XG4gICAgICAgIH1cbiAgICB9LCBcIkhnXCIpO1xuICAgIGJsb2NrID0gZG9tXzEuZGl2KHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgICB3aWR0aDogXCIxcHhcIixcbiAgICAgICAgICAgIGhlaWdodDogXCIwcHhcIlxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWxlbSA9IGRvbV8xLmRpdih7fSwgdGV4dCwgYmxvY2spO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcImJhc2VsaW5lXCI7XG4gICAgICAgIHJlc3VsdC5hc2NlbnQgPSBkb21fMS5vZmZzZXQoYmxvY2spLnRvcCAtIGRvbV8xLm9mZnNldCh0ZXh0KS50b3A7XG4gICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcImJvdHRvbVwiO1xuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gZG9tXzEub2Zmc2V0KGJsb2NrKS50b3AgLSBkb21fMS5vZmZzZXQodGV4dCkudG9wO1xuICAgICAgICByZXN1bHQuZGVzY2VudCA9IHJlc3VsdC5oZWlnaHQgLSByZXN1bHQuYXNjZW50O1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICB9XG4gICAgY2FjaGVbZm9udF0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfZGVsYXlfYW5pbWF0aW9uLCBkZWxheV9hbmltYXRpb247XG5fZGVsYXlfYW5pbWF0aW9uID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZigpO1xufTtcbmRlbGF5X2FuaW1hdGlvbiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB2b2lkIDApIHx8ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB2b2lkIDApIHx8ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB2b2lkIDApIHx8ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSA6IHZvaWQgMCkgfHwgX2RlbGF5X2FuaW1hdGlvbjtcbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzLCBjb250ZXh0LCBsYXRlciwgcGVuZGluZywgcHJldmlvdXMsIHJlZiwgcmVzdWx0LCB0aW1lb3V0O1xuICAgIHJlZiA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXSwgY29udGV4dCA9IHJlZlswXSwgYXJncyA9IHJlZlsxXSwgdGltZW91dCA9IHJlZlsyXSwgcmVzdWx0ID0gcmVmWzNdO1xuICAgIHByZXZpb3VzID0gMDtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vdywgcmVtYWluaW5nO1xuICAgICAgICBub3cgPSBuZXcgRGF0ZTtcbiAgICAgICAgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgJiYgIXBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVsYXlfYW5pbWF0aW9uKGxhdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiAhcGVuZGluZykge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXlfYW5pbWF0aW9uKGxhdGVyKTtcbiAgICAgICAgICAgIH0pLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgTnVtYmVyXVwiO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzU3RyaWN0TmFOKG9iaikge1xuICAgIHJldHVybiBpc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbn1cbmV4cG9ydHMuaXNTdHJpY3ROYU4gPSBpc1N0cmljdE5hTjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICB2YXIgdHAgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0cCA9PT0gJ2Z1bmN0aW9uJyB8fCB0cCA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4iLCIvKiFcbiAqIGpRdWVyeSBNb3VzZXdoZWVsIDMuMS4xM1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBmb250U2l6ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZm9udFNpemUsIDEwKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gbGluZUhlaWdodChlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgcmV0dXJuIGZvbnRTaXplKHBhcmVudCkgfHwgZm9udFNpemUoZWxlbWVudCkgfHwgMTY7XG59XG5mdW5jdGlvbiBwYWdlSGVpZ2h0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGllbnRIZWlnaHQ7IC8vIFhYWDogc2hvdWxkIGJlIGNvbnRlbnQgaGVpZ2h0P1xufVxuZnVuY3Rpb24gZ2V0RGVsdGFZKGV2ZW50KSB7XG4gICAgdmFyIGRlbHRhWSA9IC1ldmVudC5kZWx0YVk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9MSU5FOlxuICAgICAgICAgICAgICAgIGRlbHRhWSAqPSBsaW5lSGVpZ2h0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9QQUdFOlxuICAgICAgICAgICAgICAgIGRlbHRhWSAqPSBwYWdlSGVpZ2h0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhWTtcbn1cbmV4cG9ydHMuZ2V0RGVsdGFZID0gZ2V0RGVsdGFZO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbmV4cG9ydHMuc2NhbGVfaGlnaGxvdyA9IGZ1bmN0aW9uIChyYW5nZSwgZmFjdG9yLCBjZW50ZXIpIHtcbiAgICB2YXIgaGlnaCwgbG93LCByZWYsIHgsIHgwLCB4MTtcbiAgICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICAgICAgY2VudGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmVmID0gW3JhbmdlLnN0YXJ0LCByYW5nZS5lbmRdLCBsb3cgPSByZWZbMF0sIGhpZ2ggPSByZWZbMV07XG4gICAgeCA9IGNlbnRlciAhPSBudWxsID8gY2VudGVyIDogKGhpZ2ggKyBsb3cpIC8gMi4wO1xuICAgIHgwID0gbG93IC0gKGxvdyAtIHgpICogZmFjdG9yO1xuICAgIHgxID0gaGlnaCAtIChoaWdoIC0geCkgKiBmYWN0b3I7XG4gICAgcmV0dXJuIFt4MCwgeDFdO1xufTtcbmV4cG9ydHMuZ2V0X2luZm8gPSBmdW5jdGlvbiAobWFwcGVycywgYXJnKSB7XG4gICAgdmFyIGVuZCwgaW5mbywgbWFwcGVyLCBuYW1lLCByZWYsIHN0YXJ0LCB4MCwgeDE7XG4gICAgeDAgPSBhcmdbMF0sIHgxID0gYXJnWzFdO1xuICAgIGluZm8gPSB7fTtcbiAgICBmb3IgKG5hbWUgaW4gbWFwcGVycykge1xuICAgICAgICBtYXBwZXIgPSBtYXBwZXJzW25hbWVdO1xuICAgICAgICByZWYgPSBtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3gwLCB4MV0sIHRydWUpLCBzdGFydCA9IHJlZlswXSwgZW5kID0gcmVmWzFdO1xuICAgICAgICBpbmZvW25hbWVdID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59O1xuZXhwb3J0cy5zY2FsZV9yYW5nZSA9IGZ1bmN0aW9uIChmcmFtZSwgZmFjdG9yLCBoX2F4aXMsIHZfYXhpcywgY2VudGVyKSB7XG4gICAgdmFyIGhmYWN0b3IsIHJlZiwgcmVmMSwgdmZhY3RvciwgdngwLCB2eDEsIHZ5MCwgdnkxLCB4cnMsIHlycztcbiAgICBpZiAoaF9heGlzID09IG51bGwpIHtcbiAgICAgICAgaF9heGlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZfYXhpcyA9PSBudWxsKSB7XG4gICAgICAgIHZfYXhpcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICBjZW50ZXIgPSBudWxsO1xuICAgIH1cbiAgICBcIlV0aWxpdHkgZnVuY3Rpb24gZm9yIHpvb20gdG9vbHMgdG8gY2FsY3VsYXRlL2NyZWF0ZSB0aGUgem9vbV9pbmZvIG9iamVjdFxcbm9mIHRoZSBmb3JtIHJlcXVpcmVkIGJ5IGBgUGxvdENhbnZhc1ZpZXcudXBkYXRlX3JhbmdlYGBcXG5cXG5QYXJhbWV0ZXJzOlxcbiAgZnJhbWUgOiBDYXJ0ZXNpYW5GcmFtZVxcbiAgZmFjdG9yIDogTnVtYmVyXFxuICBoX2F4aXMgOiBCb29sZWFuLCBvcHRpb25hbFxcbiAgICB3aGV0aGVyIHRvIHpvb20gdGhlIGhvcml6b250YWwgYXhpcyAoZGVmYXVsdCA9IHRydWUpXFxuICB2X2F4aXMgOiBCb29sZWFuLCBvcHRpb25hbFxcbiAgICB3aGV0aGVyIHRvIHpvb20gdGhlIGhvcml6b250YWwgYXhpcyAoZGVmYXVsdCA9IHRydWUpXFxuICBjZW50ZXIgOiBvYmplY3QsIG9wdGlvbmFsXFxuICAgIG9mIGZvcm0geyd4JzogTnVtYmVyLCAneScsIE51bWJlcn1cXG5cXG5SZXR1cm5zOlxcbiAgb2JqZWN0OlwiO1xuICAgIGZhY3RvciA9IG1hdGhfMS5jbGFtcChmYWN0b3IsIC0wLjksIDAuOSk7XG4gICAgaGZhY3RvciA9IGhfYXhpcyA/IGZhY3RvciA6IDA7XG4gICAgcmVmID0gZXhwb3J0cy5zY2FsZV9oaWdobG93KGZyYW1lLmhfcmFuZ2UsIGhmYWN0b3IsIGNlbnRlciAhPSBudWxsID8gY2VudGVyLnggOiB2b2lkIDApLCB2eDAgPSByZWZbMF0sIHZ4MSA9IHJlZlsxXTtcbiAgICB4cnMgPSBleHBvcnRzLmdldF9pbmZvKGZyYW1lLnhfbWFwcGVycywgW3Z4MCwgdngxXSk7XG4gICAgdmZhY3RvciA9IHZfYXhpcyA/IGZhY3RvciA6IDA7XG4gICAgcmVmMSA9IGV4cG9ydHMuc2NhbGVfaGlnaGxvdyhmcmFtZS52X3JhbmdlLCB2ZmFjdG9yLCBjZW50ZXIgIT0gbnVsbCA/IGNlbnRlci55IDogdm9pZCAwKSwgdnkwID0gcmVmMVswXSwgdnkxID0gcmVmMVsxXTtcbiAgICB5cnMgPSBleHBvcnRzLmdldF9pbmZvKGZyYW1lLnlfbWFwcGVycywgW3Z5MCwgdnkxXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeHJzOiB4cnMsXG4gICAgICAgIHlyczogeXJzLFxuICAgICAgICBmYWN0b3I6IGZhY3RvclxuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29udGV4dFByb3BlcnRpZXMsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtaXhpbnMgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eV9taXhpbnNcIik7XG52YXIgY29sb3JfMSA9IHJlcXVpcmUoXCIuL3V0aWwvY29sb3JcIik7XG5Db250ZXh0UHJvcGVydGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dFByb3BlcnRpZXMob2JqLCBwcmVmaXgpIHtcbiAgICAgICAgdmFyIGF0dHIsIGRvX3NwZWMsIGosIGxlbiwgcmVmO1xuICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIGRvX3NwZWMgPSBvYmoucHJvcGVydGllc1twcmVmaXggKyB0aGlzLmRvX2F0dHJdLnNwZWM7XG4gICAgICAgIHRoaXMuZG9pdCA9IGRvX3NwZWMudmFsdWUgIT09IG51bGw7XG4gICAgICAgIHJlZiA9IHRoaXMuYXR0cnM7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXR0ciA9IHJlZltqXTtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBvYmoucHJvcGVydGllc1twcmVmaXggKyBhdHRyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb250ZXh0UHJvcGVydGllcy5wcm90b3R5cGUud2FybV9jYWNoZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIGF0dHIsIGosIGxlbiwgcHJvcCwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzLmF0dHJzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXR0ciA9IHJlZltqXTtcbiAgICAgICAgICAgIHByb3AgPSB0aGlzLm9iai5wcm9wZXJ0aWVzW3RoaXMucHJlZml4ICsgYXR0cl07XG4gICAgICAgICAgICBpZiAocHJvcC5zcGVjLnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5jYWNoZVthdHRyXSA9IHByb3Auc3BlYy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5jYWNoZVthdHRyICsgXCJfYXJyYXlcIl0gPSBwcm9wLmFycmF5KHNvdXJjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgQ29udGV4dFByb3BlcnRpZXMucHJvdG90eXBlLmNhY2hlX3NlbGVjdCA9IGZ1bmN0aW9uIChhdHRyLCBpKSB7XG4gICAgICAgIHZhciBwcm9wO1xuICAgICAgICBwcm9wID0gdGhpcy5vYmoucHJvcGVydGllc1t0aGlzLnByZWZpeCArIGF0dHJdO1xuICAgICAgICBpZiAocHJvcC5zcGVjLnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW2F0dHJdID0gcHJvcC5zcGVjLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVbYXR0cl0gPSB0aGlzLmNhY2hlW2F0dHIgKyBcIl9hcnJheVwiXVtpXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRQcm9wZXJ0aWVzO1xufSkoKTtcbmV4cG9ydHMuTGluZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMaW5lLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lKCkge1xuICAgICAgICByZXR1cm4gTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZS5wcm90b3R5cGUuYXR0cnMgPSBPYmplY3Qua2V5cyhtaXhpbnMubGluZSgpKTtcbiAgICBMaW5lLnByb3RvdHlwZS5kb19hdHRyID0gXCJsaW5lX2NvbG9yXCI7XG4gICAgTGluZS5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmxpbmVfY29sb3IudmFsdWUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5saW5lX2FscGhhLnZhbHVlKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGgudmFsdWUoKTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5saW5lX2pvaW4udmFsdWUoKTtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmxpbmVfY2FwLnZhbHVlKCk7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmxpbmVfZGFzaC52YWx1ZSgpKTtcbiAgICAgICAgcmV0dXJuIGN0eC5zZXRMaW5lRGFzaE9mZnNldCh0aGlzLmxpbmVfZGFzaF9vZmZzZXQudmFsdWUoKSk7XG4gICAgfTtcbiAgICBMaW5lLnByb3RvdHlwZS5zZXRfdmVjdG9yaXplID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcImxpbmVfY29sb3JcIiwgaSk7XG4gICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09IHRoaXMuY2FjaGUubGluZV9jb2xvcikge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jYWNoZS5saW5lX2NvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV9hbHBoYVwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5nbG9iYWxBbHBoYSAhPT0gdGhpcy5jYWNoZS5saW5lX2FscGhhKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmNhY2hlLmxpbmVfYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJsaW5lX3dpZHRoXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LmxpbmVXaWR0aCAhPT0gdGhpcy5jYWNoZS5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5jYWNoZS5saW5lX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwibGluZV9qb2luXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LmxpbmVKb2luICE9PSB0aGlzLmNhY2hlLmxpbmVfam9pbikge1xuICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5jYWNoZS5saW5lX2pvaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJsaW5lX2NhcFwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5saW5lQ2FwICE9PSB0aGlzLmNhY2hlLmxpbmVfY2FwKSB7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IHRoaXMuY2FjaGUubGluZV9jYXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJsaW5lX2Rhc2hcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZ2V0TGluZURhc2goKSAhPT0gdGhpcy5jYWNoZS5saW5lX2Rhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmNhY2hlLmxpbmVfZGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJsaW5lX2Rhc2hfb2Zmc2V0XCIsIGkpO1xuICAgICAgICBpZiAoY3R4LmdldExpbmVEYXNoT2Zmc2V0KCkgIT09IHRoaXMuY2FjaGUubGluZV9kYXNoX29mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zZXRMaW5lRGFzaE9mZnNldCh0aGlzLmNhY2hlLmxpbmVfZGFzaF9vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5lLnByb3RvdHlwZS5jb2xvcl92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICBjb2xvciA9IGNvbG9yXzEuY29sb3IycmdiYSh0aGlzLmxpbmVfY29sb3IudmFsdWUoKSwgdGhpcy5saW5lX2FscGhhLnZhbHVlKCkpO1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgKGNvbG9yWzBdICogMjU1KSArIFwiLFwiICsgKGNvbG9yWzFdICogMjU1KSArIFwiLFwiICsgKGNvbG9yWzJdICogMjU1KSArIFwiLFwiICsgY29sb3JbM10gKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBMaW5lO1xufSkoQ29udGV4dFByb3BlcnRpZXMpO1xuZXhwb3J0cy5GaWxsID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEZpbGwsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEZpbGwoKSB7XG4gICAgICAgIHJldHVybiBGaWxsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGaWxsLnByb3RvdHlwZS5hdHRycyA9IE9iamVjdC5rZXlzKG1peGlucy5maWxsKCkpO1xuICAgIEZpbGwucHJvdG90eXBlLmRvX2F0dHIgPSBcImZpbGxfY29sb3JcIjtcbiAgICBGaWxsLnByb3RvdHlwZS5zZXRfdmFsdWUgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxfY29sb3IudmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZmlsbF9hbHBoYS52YWx1ZSgpO1xuICAgIH07XG4gICAgRmlsbC5wcm90b3R5cGUuc2V0X3ZlY3Rvcml6ZSA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgdGhpcy5jYWNoZV9zZWxlY3QoXCJmaWxsX2NvbG9yXCIsIGkpO1xuICAgICAgICBpZiAoY3R4LmZpbGxTdHlsZSAhPT0gdGhpcy5jYWNoZS5maWxsX2NvbG9yKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jYWNoZS5maWxsX2NvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwiZmlsbF9hbHBoYVwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5nbG9iYWxBbHBoYSAhPT0gdGhpcy5jYWNoZS5maWxsX2FscGhhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWNoZS5maWxsX2FscGhhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaWxsLnByb3RvdHlwZS5jb2xvcl92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICBjb2xvciA9IGNvbG9yXzEuY29sb3IycmdiYSh0aGlzLmZpbGxfY29sb3IudmFsdWUoKSwgdGhpcy5maWxsX2FscGhhLnZhbHVlKCkpO1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgKGNvbG9yWzBdICogMjU1KSArIFwiLFwiICsgKGNvbG9yWzFdICogMjU1KSArIFwiLFwiICsgKGNvbG9yWzJdICogMjU1KSArIFwiLFwiICsgY29sb3JbM10gKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBGaWxsO1xufSkoQ29udGV4dFByb3BlcnRpZXMpO1xuZXhwb3J0cy5UZXh0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS5hdHRycyA9IE9iamVjdC5rZXlzKG1peGlucy50ZXh0KCkpO1xuICAgIFRleHQucHJvdG90eXBlLmRvX2F0dHIgPSBcInRleHRfY29sb3JcIjtcbiAgICBUZXh0LnByb3RvdHlwZS5jYWNoZV9zZWxlY3QgPSBmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJmb250XCIpIHtcbiAgICAgICAgICAgIHZhbCA9IFRleHQuX19zdXBlcl9fLmNhY2hlX3NlbGVjdC5jYWxsKHRoaXMsIFwidGV4dF9mb250X3N0eWxlXCIsIGkpICsgXCIgXCIgKyBUZXh0Ll9fc3VwZXJfXy5jYWNoZV9zZWxlY3QuY2FsbCh0aGlzLCBcInRleHRfZm9udF9zaXplXCIsIGkpICsgXCIgXCIgKyBUZXh0Ll9fc3VwZXJfXy5jYWNoZV9zZWxlY3QuY2FsbCh0aGlzLCBcInRleHRfZm9udFwiLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmZvbnQgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dC5fX3N1cGVyX18uY2FjaGVfc2VsZWN0LmNhbGwodGhpcywgbmFtZSwgaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLmZvbnRfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb250LCBmb250X3NpemUsIGZvbnRfc3R5bGU7XG4gICAgICAgIGZvbnQgPSB0aGlzLnRleHRfZm9udC52YWx1ZSgpO1xuICAgICAgICBmb250X3NpemUgPSB0aGlzLnRleHRfZm9udF9zaXplLnZhbHVlKCk7XG4gICAgICAgIGZvbnRfc3R5bGUgPSB0aGlzLnRleHRfZm9udF9zdHlsZS52YWx1ZSgpO1xuICAgICAgICByZXR1cm4gZm9udF9zdHlsZSArIFwiIFwiICsgZm9udF9zaXplICsgXCIgXCIgKyBmb250O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUuY29sb3JfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgY29sb3IgPSBjb2xvcl8xLmNvbG9yMnJnYmEodGhpcy50ZXh0X2NvbG9yLnZhbHVlKCksIHRoaXMudGV4dF9hbHBoYS52YWx1ZSgpKTtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIChjb2xvclswXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsxXSAqIDI1NSkgKyBcIixcIiArIChjb2xvclsyXSAqIDI1NSkgKyBcIixcIiArIGNvbG9yWzNdICsgXCIpXCI7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5zZXRfdmFsdWUgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250X3ZhbHVlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnRleHRfY29sb3IudmFsdWUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy50ZXh0X2FscGhhLnZhbHVlKCk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRfYWxpZ24udmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRfYmFzZWxpbmUudmFsdWUoKTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnNldF92ZWN0b3JpemUgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwiZm9udFwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5mb250ICE9PSB0aGlzLmNhY2hlLmZvbnQpIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5jYWNoZS5mb250O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwidGV4dF9jb2xvclwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT09IHRoaXMuY2FjaGUudGV4dF9jb2xvcikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY2FjaGUudGV4dF9jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcInRleHRfYWxwaGFcIiwgaSk7XG4gICAgICAgIGlmIChjdHguZ2xvYmFsQWxwaGEgIT09IHRoaXMuY2FjaGUudGV4dF9hbHBoYSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWNoZS50ZXh0X2FscGhhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVfc2VsZWN0KFwidGV4dF9hbGlnblwiLCBpKTtcbiAgICAgICAgaWYgKGN0eC50ZXh0QWxpZ24gIT09IHRoaXMuY2FjaGUudGV4dF9hbGlnbikge1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuY2FjaGUudGV4dF9hbGlnbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlX3NlbGVjdChcInRleHRfYmFzZWxpbmVcIiwgaSk7XG4gICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lICE9PSB0aGlzLmNhY2hlLnRleHRfYmFzZWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy5jYWNoZS50ZXh0X2Jhc2VsaW5lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dDtcbn0pKENvbnRleHRQcm9wZXJ0aWVzKTtcbmV4cG9ydHMuVmlzdWFscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlzdWFscyhtb2RlbCkge1xuICAgICAgICB2YXIgY2xzLCBqLCBsZW4sIG5hbWUsIHByZWZpeCwgcmVmLCByZWYxLCByZWYyLCBzcGVjO1xuICAgICAgICByZWYgPSBtb2RlbC5taXhpbnM7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgc3BlYyA9IHJlZltqXTtcbiAgICAgICAgICAgIHJlZjEgPSBzcGVjLnNwbGl0KFwiOlwiKSwgbmFtZSA9IHJlZjFbMF0sIHByZWZpeCA9IChyZWYyID0gcmVmMVsxXSkgIT0gbnVsbCA/IHJlZjIgOiBcIlwiO1xuICAgICAgICAgICAgY2xzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5GaWxsO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdGhpc1twcmVmaXggKyBuYW1lXSA9IG5ldyBjbHMobW9kZWwsIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmlzdWFscy5wcm90b3R5cGUud2FybV9jYWNoZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG5hbWUsIHByb3AsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gdGhpcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIG5hbWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcHJvcCA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQ29udGV4dFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocHJvcC53YXJtX2NhY2hlKHNvdXJjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gVmlzdWFscztcbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFdmVudE1hbmFnZXIsIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgYmFzZV8xID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcIi4vY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nZ2luZ1wiKTtcbnZhciBoYXNfcHJvcHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvaGFzX3Byb3BzXCIpO1xudmFyIHJlZnNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9yZWZzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9zZXJpYWxpemF0aW9uXCIpO1xudmFyIGRhdGFfc3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2RhdGFfc3RydWN0dXJlc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBlcV8xID0gcmVxdWlyZShcIi4vY29yZS91dGlsL2VxXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tb2RlbHMvc291cmNlcy9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG5FdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihkb2N1bWVudDEpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50MTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkX21vZGVscyA9IG5ldyBkYXRhX3N0cnVjdHVyZXNfMS5TZXQoKTtcbiAgICB9XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZWYxO1xuICAgICAgICByZXR1cm4gKHJlZjEgPSB0aGlzLnNlc3Npb24pICE9IG51bGwgPyByZWYxLnNlbmRfZXZlbnQoZXZlbnQpIDogdm9pZCAwO1xuICAgIH07XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBqLCBsZW4sIG1vZGVsLCBtb2RlbF9pZCwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgcmVmMSA9IHRoaXMuc3Vic2NyaWJlZF9tb2RlbHMudmFsdWVzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIG1vZGVsX2lkID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGlmIChldmVudC5tb2RlbF9pZCAhPT0gbnVsbCAmJiBldmVudC5tb2RlbF9pZCAhPT0gbW9kZWxfaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsID0gdGhpcy5kb2N1bWVudC5fYWxsX21vZGVsc1ttb2RlbF9pZF07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobW9kZWwgIT0gbnVsbCA/IG1vZGVsLl9wcm9jZXNzX2V2ZW50KGV2ZW50KSA6IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xufSkoKTtcbmV4cG9ydHMuRG9jdW1lbnRDaGFuZ2VkRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50Q2hhbmdlZEV2ZW50KGRvY3VtZW50MSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQxO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnRDaGFuZ2VkRXZlbnQ7XG59KSgpO1xuZXhwb3J0cy5Nb2RlbENoYW5nZWRFdmVudCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoTW9kZWxDaGFuZ2VkRXZlbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE1vZGVsQ2hhbmdlZEV2ZW50KGRvY3VtZW50MSwgbW9kZWwxLCBhdHRyMSwgb2xkMSwgbmV3XzEsIHNldHRlcl9pZDEpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50MTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsMTtcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjE7XG4gICAgICAgIHRoaXMub2xkID0gb2xkMTtcbiAgICAgICAgdGhpcy5uZXdfID0gbmV3XzE7XG4gICAgICAgIHRoaXMuc2V0dGVyX2lkID0gc2V0dGVyX2lkMTtcbiAgICAgICAgTW9kZWxDaGFuZ2VkRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIE1vZGVsQ2hhbmdlZEV2ZW50LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXMpIHtcbiAgICAgICAgdmFyIGlkLCB2YWx1ZSwgdmFsdWVfanNvbiwgdmFsdWVfcmVmcztcbiAgICAgICAgaWYgKHRoaXMuYXR0ciA9PT0gJ2lkJykge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiJ2lkJyBmaWVsZCBpcyBpbW11dGFibGUgYW5kIHNob3VsZCBuZXZlciBiZSBpbiBhIE1vZGVsQ2hhbmdlZEV2ZW50IFwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidpZCcgZmllbGQgc2hvdWxkIG5ldmVyIGNoYW5nZSwgd2hhdGV2ZXIgY29kZSBqdXN0IHNldCBpdCBpcyB3cm9uZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMubmV3XztcbiAgICAgICAgdmFsdWVfanNvbiA9IHRoaXMubW9kZWwuY29uc3RydWN0b3IuX3ZhbHVlX3RvX2pzb24odGhpcy5hdHRyLCB2YWx1ZSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIHZhbHVlX3JlZnMgPSB7fTtcbiAgICAgICAgaGFzX3Byb3BzXzEuSGFzUHJvcHMuX3ZhbHVlX3JlY29yZF9yZWZlcmVuY2VzKHZhbHVlLCB2YWx1ZV9yZWZzLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuaWQgaW4gdmFsdWVfcmVmcyAmJiB0aGlzLm1vZGVsICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlX3JlZnNbdGhpcy5tb2RlbC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpZCBpbiB2YWx1ZV9yZWZzKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzW2lkXSA9IHZhbHVlX3JlZnNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAna2luZCc6ICdNb2RlbENoYW5nZWQnLFxuICAgICAgICAgICAgJ21vZGVsJzogdGhpcy5tb2RlbC5yZWYoKSxcbiAgICAgICAgICAgICdhdHRyJzogdGhpcy5hdHRyLFxuICAgICAgICAgICAgJ25ldyc6IHZhbHVlX2pzb25cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBNb2RlbENoYW5nZWRFdmVudDtcbn0pKGV4cG9ydHMuRG9jdW1lbnRDaGFuZ2VkRXZlbnQpO1xuZXhwb3J0cy5UaXRsZUNoYW5nZWRFdmVudCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoVGl0bGVDaGFuZ2VkRXZlbnQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRpdGxlQ2hhbmdlZEV2ZW50KGRvY3VtZW50MSwgdGl0bGUxLCBzZXR0ZXJfaWQxKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDE7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTE7XG4gICAgICAgIHRoaXMuc2V0dGVyX2lkID0gc2V0dGVyX2lkMTtcbiAgICAgICAgVGl0bGVDaGFuZ2VkRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIFRpdGxlQ2hhbmdlZEV2ZW50LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdraW5kJzogJ1RpdGxlQ2hhbmdlZCcsXG4gICAgICAgICAgICAndGl0bGUnOiB0aGlzLnRpdGxlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGl0bGVDaGFuZ2VkRXZlbnQ7XG59KShleHBvcnRzLkRvY3VtZW50Q2hhbmdlZEV2ZW50KTtcbmV4cG9ydHMuUm9vdEFkZGVkRXZlbnQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFJvb3RBZGRlZEV2ZW50LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSb290QWRkZWRFdmVudChkb2N1bWVudDEsIG1vZGVsMSwgc2V0dGVyX2lkMSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQxO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWwxO1xuICAgICAgICB0aGlzLnNldHRlcl9pZCA9IHNldHRlcl9pZDE7XG4gICAgICAgIFJvb3RBZGRlZEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHRoaXMuZG9jdW1lbnQpO1xuICAgIH1cbiAgICBSb290QWRkZWRFdmVudC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzKSB7XG4gICAgICAgIGhhc19wcm9wc18xLkhhc1Byb3BzLl92YWx1ZV9yZWNvcmRfcmVmZXJlbmNlcyh0aGlzLm1vZGVsLCByZWZlcmVuY2VzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdraW5kJzogJ1Jvb3RBZGRlZCcsXG4gICAgICAgICAgICAnbW9kZWwnOiB0aGlzLm1vZGVsLnJlZigpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUm9vdEFkZGVkRXZlbnQ7XG59KShleHBvcnRzLkRvY3VtZW50Q2hhbmdlZEV2ZW50KTtcbmV4cG9ydHMuUm9vdFJlbW92ZWRFdmVudCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoUm9vdFJlbW92ZWRFdmVudCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUm9vdFJlbW92ZWRFdmVudChkb2N1bWVudDEsIG1vZGVsMSwgc2V0dGVyX2lkMSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQxO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWwxO1xuICAgICAgICB0aGlzLnNldHRlcl9pZCA9IHNldHRlcl9pZDE7XG4gICAgICAgIFJvb3RSZW1vdmVkRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIFJvb3RSZW1vdmVkRXZlbnQucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAocmVmZXJlbmNlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2tpbmQnOiAnUm9vdFJlbW92ZWQnLFxuICAgICAgICAgICAgJ21vZGVsJzogdGhpcy5tb2RlbC5yZWYoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFJvb3RSZW1vdmVkRXZlbnQ7XG59KShleHBvcnRzLkRvY3VtZW50Q2hhbmdlZEV2ZW50KTtcbmV4cG9ydHMuREVGQVVMVF9USVRMRSA9IFwiQm9rZWggQXBwbGljYXRpb25cIjtcbmV4cG9ydHMuRG9jdW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50KCkge1xuICAgICAgICB0aGlzLl90aXRsZSA9IGV4cG9ydHMuREVGQVVMVF9USVRMRTtcbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsX21vZGVscyA9IHt9O1xuICAgICAgICB0aGlzLl9hbGxfbW9kZWxzX2J5X25hbWUgPSBuZXcgZGF0YV9zdHJ1Y3R1cmVzXzEuTXVsdGlEaWN0KCk7XG4gICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuX2RvY193aWR0aCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcImRvY3VtZW50X3dpZHRoXCIpO1xuICAgICAgICB0aGlzLl9kb2NfaGVpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiZG9jdW1lbnRfaGVpZ2h0XCIpO1xuICAgICAgICB0aGlzLl9zb2x2ZXIgPSBuZXcgc29sdmVyXzEuU29sdmVyKCk7XG4gICAgICAgIHRoaXMuX2luaXRfc29sdmVyKCk7XG4gICAgICAgIHRoaXMuZXZlbnRfbWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc2l6ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgICBEb2N1bWVudC5wcm90b3R5cGUuX2luaXRfc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuLCBtb2RlbCwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgdGhpcy5fc29sdmVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3NvbHZlci5hZGRfZWRpdF92YXJpYWJsZSh0aGlzLl9kb2Nfd2lkdGgpO1xuICAgICAgICB0aGlzLl9zb2x2ZXIuYWRkX2VkaXRfdmFyaWFibGUodGhpcy5fZG9jX2hlaWdodCk7XG4gICAgICAgIHJlZjEgPSB0aGlzLl9yb290cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBtb2RlbCA9IHJlZjFbal07XG4gICAgICAgICAgICBpZiAobW9kZWwubGF5b3V0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9hZGRfbGF5b3V0YWJsZShtb2RlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVyO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5fcmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgbWVhc3VyaW5nLCByZWYxLCByZWYyLCByb290LCByb290X2RpdiwgdmFycztcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHdpZHRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVmMSA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByb290ID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGlmIChyb290LmxheW91dGFibGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcnMgPSByb290LmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgIGlmICgodmFycy53aWR0aCA9PSBudWxsKSAmJiAodmFycy5oZWlnaHQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3RfZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RlbGlkX1wiICsgcm9vdC5pZCk7XG4gICAgICAgICAgICBpZiAoKHJvb3RfZGl2ICE9IG51bGwpICYmIHdpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyaW5nID0gcm9vdF9kaXY7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyaW5nID0gbWVhc3VyaW5nLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJlZjIgPSBtZWFzdXJpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gcmVmMi53aWR0aCwgaGVpZ2h0ID0gcmVmMi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhcnMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJTdWdnZXN0IHdpZHRoIG9uIERvY3VtZW50IC0tIFwiICsgd2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMuX2RvY193aWR0aCwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhcnMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiU3VnZ2VzdCBoZWlnaHQgb24gRG9jdW1lbnQgLS0gXCIgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvbHZlci5zdWdnZXN0X3ZhbHVlKHRoaXMuX2RvY19oZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc29sdmVyLnVwZGF0ZV92YXJpYWJsZXMoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVyLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgdGhpcy5fcHVzaF9hbGxfbW9kZWxzX2ZyZWV6ZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3Jvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1vdmVfcm9vdCh0aGlzLl9yb290c1swXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmRlc3RydWN0aXZlbHlfbW92ZSA9IGZ1bmN0aW9uIChkZXN0X2RvYykge1xuICAgICAgICB2YXIgaiwgbCwgbGVuLCBsZW4xLCBsZW4yLCBuLCByLCByZWYxLCByb290cztcbiAgICAgICAgaWYgKGRlc3RfZG9jID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gb3ZlcndyaXRlIGEgZG9jdW1lbnQgd2l0aCBpdHNlbGZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdF9kb2MuY2xlYXIoKTtcbiAgICAgICAgcm9vdHMgPSBbXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmMVtqXTtcbiAgICAgICAgICAgIHJvb3RzLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcm9vdHMubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICByID0gcm9vdHNbbF07XG4gICAgICAgICAgICBpZiAoci5kb2N1bWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWVob3cgd2UgZGlkbid0IGRldGFjaCBcIiArIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9hbGxfbW9kZWxzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBfYWxsX21vZGVscyBzdGlsbCBoYWQgc3R1ZmYgaW4gaXQ6IFwiICsgdGhpcy5fYWxsX21vZGVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuID0gMCwgbGVuMiA9IHJvb3RzLmxlbmd0aDsgbiA8IGxlbjI7IG4rKykge1xuICAgICAgICAgICAgciA9IHJvb3RzW25dO1xuICAgICAgICAgICAgZGVzdF9kb2MuYWRkX3Jvb3Qocik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3RfZG9jLnNldF90aXRsZSh0aGlzLl90aXRsZSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuX3B1c2hfYWxsX21vZGVsc19mcmVlemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxfbW9kZWxzX2ZyZWV6ZV9jb3VudCArPSAxO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl9wb3BfYWxsX21vZGVsc19mcmVlemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLl9hbGxfbW9kZWxzX2ZyZWV6ZV9jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29tcHV0ZV9hbGxfbW9kZWxzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5faW52YWxpZGF0ZV9hbGxfbW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiaW52YWxpZGF0aW5nIGRvY3VtZW50IG1vZGVsc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuX2FsbF9tb2RlbHNfZnJlZXplX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb21wdXRlX2FsbF9tb2RlbHMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl9yZWNvbXB1dGVfYWxsX21vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEsIGQsIGosIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbSwgbiwgbmFtZSwgbmV3X2FsbF9tb2RlbHNfc2V0LCBvLCBvbGRfYWxsX21vZGVsc19zZXQsIHIsIHJlY29tcHV0ZWQsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHRvX2F0dGFjaCwgdG9fZGV0YWNoO1xuICAgICAgICBuZXdfYWxsX21vZGVsc19zZXQgPSBuZXcgZGF0YV9zdHJ1Y3R1cmVzXzEuU2V0KCk7XG4gICAgICAgIHJlZjEgPSB0aGlzLl9yb290cztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZjFbal07XG4gICAgICAgICAgICBuZXdfYWxsX21vZGVsc19zZXQgPSBuZXdfYWxsX21vZGVsc19zZXQudW5pb24oci5yZWZlcmVuY2VzKCkpO1xuICAgICAgICB9XG4gICAgICAgIG9sZF9hbGxfbW9kZWxzX3NldCA9IG5ldyBkYXRhX3N0cnVjdHVyZXNfMS5TZXQob2JqZWN0XzEudmFsdWVzKHRoaXMuX2FsbF9tb2RlbHMpKTtcbiAgICAgICAgdG9fZGV0YWNoID0gb2xkX2FsbF9tb2RlbHNfc2V0LmRpZmYobmV3X2FsbF9tb2RlbHNfc2V0KTtcbiAgICAgICAgdG9fYXR0YWNoID0gbmV3X2FsbF9tb2RlbHNfc2V0LmRpZmYob2xkX2FsbF9tb2RlbHNfc2V0KTtcbiAgICAgICAgcmVjb21wdXRlZCA9IHt9O1xuICAgICAgICByZWYyID0gbmV3X2FsbF9tb2RlbHNfc2V0LnZhbHVlcztcbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBtID0gcmVmMltsXTtcbiAgICAgICAgICAgIHJlY29tcHV0ZWRbbS5pZF0gPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJlZjMgPSB0b19kZXRhY2gudmFsdWVzO1xuICAgICAgICBmb3IgKG4gPSAwLCBsZW4yID0gcmVmMy5sZW5ndGg7IG4gPCBsZW4yOyBuKyspIHtcbiAgICAgICAgICAgIGQgPSByZWYzW25dO1xuICAgICAgICAgICAgZC5kZXRhY2hfZG9jdW1lbnQoKTtcbiAgICAgICAgICAgIG5hbWUgPSBkLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5yZW1vdmVfdmFsdWUobmFtZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmNCA9IHRvX2F0dGFjaC52YWx1ZXM7XG4gICAgICAgIGZvciAobyA9IDAsIGxlbjMgPSByZWY0Lmxlbmd0aDsgbyA8IGxlbjM7IG8rKykge1xuICAgICAgICAgICAgYSA9IHJlZjRbb107XG4gICAgICAgICAgICBhLmF0dGFjaF9kb2N1bWVudCh0aGlzKTtcbiAgICAgICAgICAgIG5hbWUgPSBhLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5hZGRfdmFsdWUobmFtZSwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbF9tb2RlbHMgPSByZWNvbXB1dGVkO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdHM7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuX2FkZF9sYXlvdXRhYmxlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50LCBjb25zdHJhaW50cywgZWRpdF92YXJpYWJsZSwgZWRpdGFibGVzLCBqLCBsLCBsZW4sIGxlbjEsIHJlZjEsIHN0cmVuZ3RoLCB2YXJzO1xuICAgICAgICBpZiAobW9kZWwubGF5b3V0YWJsZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBub24tbGF5b3V0YWJsZSAtIFwiICsgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlcyA9IG1vZGVsLmdldF9lZGl0X3ZhcmlhYmxlcygpO1xuICAgICAgICBjb25zdHJhaW50cyA9IG1vZGVsLmdldF9jb25zdHJhaW50cygpO1xuICAgICAgICB2YXJzID0gbW9kZWwuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBlZGl0YWJsZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHJlZjEgPSBlZGl0YWJsZXNbal0sIGVkaXRfdmFyaWFibGUgPSByZWYxLmVkaXRfdmFyaWFibGUsIHN0cmVuZ3RoID0gcmVmMS5zdHJlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlci5hZGRfZWRpdF92YXJpYWJsZShlZGl0X3ZhcmlhYmxlLCBzdHJlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IGNvbnN0cmFpbnRzLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2xdO1xuICAgICAgICAgICAgdGhpcy5fc29sdmVyLmFkZF9jb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJzLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvbHZlci5hZGRfY29uc3RyYWludChzb2x2ZXJfMS5FUSh2YXJzLndpZHRoLCB0aGlzLl9kb2Nfd2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFycy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc29sdmVyLmFkZF9jb25zdHJhaW50KHNvbHZlcl8xLkVRKHZhcnMuaGVpZ2h0LCB0aGlzLl9kb2NfaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvbHZlci51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuYWRkX3Jvb3QgPSBmdW5jdGlvbiAobW9kZWwsIHNldHRlcl9pZCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiQWRkaW5nIHJvb3Q6IFwiICsgbW9kZWwpO1xuICAgICAgICBpZiAoaW5kZXhPZi5jYWxsKHRoaXMuX3Jvb3RzLCBtb2RlbCkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2hfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgbW9kZWwuX2lzX3Jvb3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fcG9wX2FsbF9tb2RlbHNfZnJlZXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5pdF9zb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJfb25fY2hhbmdlKG5ldyBleHBvcnRzLlJvb3RBZGRlZEV2ZW50KHRoaXMsIG1vZGVsLCBzZXR0ZXJfaWQpKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVfcm9vdCA9IGZ1bmN0aW9uIChtb2RlbCwgc2V0dGVyX2lkKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy5fcm9vdHMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2hfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIG1vZGVsLl9pc19yb290ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BfYWxsX21vZGVsc19mcmVlemUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbml0X3NvbHZlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcl9vbl9jaGFuZ2UobmV3IGV4cG9ydHMuUm9vdFJlbW92ZWRFdmVudCh0aGlzLCBtb2RlbCwgc2V0dGVyX2lkKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUudGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aXRsZTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUsIHNldHRlcl9pZCkge1xuICAgICAgICBpZiAodGl0bGUgIT09IHRoaXMuX3RpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl90aXRsZSA9IHRpdGxlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJfb25fY2hhbmdlKG5ldyBleHBvcnRzLlRpdGxlQ2hhbmdlZEV2ZW50KHRoaXMsIHRpdGxlLCBzZXR0ZXJfaWQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmdldF9tb2RlbF9ieV9pZCA9IGZ1bmN0aW9uIChtb2RlbF9pZCkge1xuICAgICAgICBpZiAobW9kZWxfaWQgaW4gdGhpcy5fYWxsX21vZGVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbF9tb2RlbHNbbW9kZWxfaWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5nZXRfbW9kZWxfYnlfbmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxfbW9kZWxzX2J5X25hbWUuZ2V0X29uZShuYW1lLCBcIk11bHRpcGxlIG1vZGVscyBhcmUgbmFtZWQgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5vbl9jaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGNhbGxiYWNrKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVfb25fY2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy5fY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLl90cmlnZ2VyX29uX2NoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2IsIGosIGxlbiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgcmVmMSA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjYiA9IHJlZjFbal07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2IoZXZlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZS5fbm90aWZ5X2NoYW5nZSA9IGZ1bmN0aW9uIChtb2RlbCwgYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5yZW1vdmVfdmFsdWUob2xkLCBtb2RlbCk7XG4gICAgICAgICAgICBpZiAobmV3XyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbF9tb2RlbHNfYnlfbmFtZS5hZGRfdmFsdWUobmV3XywgbW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyX29uX2NoYW5nZShuZXcgZXhwb3J0cy5Nb2RlbENoYW5nZWRFdmVudCh0aGlzLCBtb2RlbCwgYXR0ciwgb2xkLCBuZXdfLCBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnNldHRlcl9pZCA6IHZvaWQgMCkpO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX3JlZmVyZW5jZXNfanNvbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzLCBpbmNsdWRlX2RlZmF1bHRzKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHIsIHJlZiwgcmVmZXJlbmNlc19qc29uO1xuICAgICAgICBpZiAoaW5jbHVkZV9kZWZhdWx0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlX2RlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VzX2pzb24gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmZXJlbmNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZmVyZW5jZXNbal07XG4gICAgICAgICAgICByZWYgPSByLnJlZigpO1xuICAgICAgICAgICAgcmVmWydhdHRyaWJ1dGVzJ10gPSByLmF0dHJpYnV0ZXNfYXNfanNvbihpbmNsdWRlX2RlZmF1bHRzKTtcbiAgICAgICAgICAgIGRlbGV0ZSByZWZbJ2F0dHJpYnV0ZXMnXVsnaWQnXTtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNfanNvbi5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZXNfanNvbjtcbiAgICB9O1xuICAgIERvY3VtZW50Ll9pbnN0YW50aWF0ZV9vYmplY3QgPSBmdW5jdGlvbiAob2JqX2lkLCBvYmpfdHlwZSwgb2JqX2F0dHJzKSB7XG4gICAgICAgIHZhciBmdWxsX2F0dHJzLCBtb2RlbDtcbiAgICAgICAgZnVsbF9hdHRycyA9IG9iamVjdF8xLmV4dGVuZCh7fSwgb2JqX2F0dHJzLCB7XG4gICAgICAgICAgICBpZDogb2JqX2lkXG4gICAgICAgIH0pO1xuICAgICAgICBtb2RlbCA9IGJhc2VfMS5Nb2RlbHMob2JqX3R5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsKGZ1bGxfYXR0cnMsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmVyX2luaXRpYWxpemF0aW9uOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX2luc3RhbnRpYXRlX3JlZmVyZW5jZXNfanNvbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzX2pzb24sIGV4aXN0aW5nX21vZGVscykge1xuICAgICAgICB2YXIgaW5zdGFuY2UsIGosIGxlbiwgb2JqLCBvYmpfYXR0cnMsIG9ial9pZCwgb2JqX3R5cGUsIHJlZmVyZW5jZXM7XG4gICAgICAgIHJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmZXJlbmNlc19qc29uLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBvYmogPSByZWZlcmVuY2VzX2pzb25bal07XG4gICAgICAgICAgICBvYmpfaWQgPSBvYmpbJ2lkJ107XG4gICAgICAgICAgICBvYmpfdHlwZSA9IG9ialsndHlwZSddO1xuICAgICAgICAgICAgb2JqX2F0dHJzID0gb2JqWydhdHRyaWJ1dGVzJ107XG4gICAgICAgICAgICBpZiAob2JqX2lkIGluIGV4aXN0aW5nX21vZGVscykge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZXhpc3RpbmdfbW9kZWxzW29ial9pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IERvY3VtZW50Ll9pbnN0YW50aWF0ZV9vYmplY3Qob2JqX2lkLCBvYmpfdHlwZSwgb2JqX2F0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3N1YnR5cGUnIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRfc3VidHlwZShvYmpbJ3N1YnR5cGUnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmZXJlbmNlc1tpbnN0YW5jZS5pZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgICB9O1xuICAgIERvY3VtZW50Ll9yZXNvbHZlX3JlZnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZF9yZWZlcmVuY2VzLCBuZXdfcmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgcmVzb2x2ZV9hcnJheSwgcmVzb2x2ZV9kaWN0LCByZXNvbHZlX3JlZjtcbiAgICAgICAgcmVzb2x2ZV9yZWYgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHJlZnNfMS5pc19yZWYodikpIHtcbiAgICAgICAgICAgICAgICBpZiAodlsnaWQnXSBpbiBvbGRfcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkX3JlZmVyZW5jZXNbdlsnaWQnXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZbJ2lkJ10gaW4gbmV3X3JlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld19yZWZlcmVuY2VzW3ZbJ2lkJ11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVmZXJlbmNlIFwiICsgKEpTT04uc3RyaW5naWZ5KHYpKSArIFwiIGlzbid0IGtub3duIChub3QgaW4gRG9jdW1lbnQ/KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZV9hcnJheSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZV9kaWN0KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmVfZGljdCA9IGZ1bmN0aW9uIChkaWN0KSB7XG4gICAgICAgICAgICB2YXIgaywgcmVzb2x2ZWQsIHY7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHt9O1xuICAgICAgICAgICAgZm9yIChrIGluIGRpY3QpIHtcbiAgICAgICAgICAgICAgICB2ID0gZGljdFtrXTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFtrXSA9IHJlc29sdmVfcmVmKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXNvbHZlX2FycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzLCB2O1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gYXJyYXlbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc29sdmVfcmVmKHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZV9yZWYodmFsdWUpO1xuICAgIH07XG4gICAgRG9jdW1lbnQuX2luaXRpYWxpemVfcmVmZXJlbmNlc19qc29uID0gZnVuY3Rpb24gKHJlZmVyZW5jZXNfanNvbiwgb2xkX3JlZmVyZW5jZXMsIG5ld19yZWZlcmVuY2VzKSB7XG4gICAgICAgIHZhciBmb3JlYWNoX2RlcHRoX2ZpcnN0LCBpbnN0YW5jZSwgaiwgbGVuLCBvYmosIG9ial9hdHRycywgb2JqX2lkLCB0b191cGRhdGUsIHdhc19uZXc7XG4gICAgICAgIHRvX3VwZGF0ZSA9IHt9O1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWZlcmVuY2VzX2pzb24ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIG9iaiA9IHJlZmVyZW5jZXNfanNvbltqXTtcbiAgICAgICAgICAgIG9ial9pZCA9IG9ialsnaWQnXTtcbiAgICAgICAgICAgIG9ial9hdHRycyA9IG9ialsnYXR0cmlidXRlcyddO1xuICAgICAgICAgICAgd2FzX25ldyA9IGZhbHNlO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBvYmpfaWQgaW4gb2xkX3JlZmVyZW5jZXMgPyBvbGRfcmVmZXJlbmNlc1tvYmpfaWRdIDogKHdhc19uZXcgPSB0cnVlLCBuZXdfcmVmZXJlbmNlc1tvYmpfaWRdKTtcbiAgICAgICAgICAgIG9ial9hdHRycyA9IERvY3VtZW50Ll9yZXNvbHZlX3JlZnMob2JqX2F0dHJzLCBvbGRfcmVmZXJlbmNlcywgbmV3X3JlZmVyZW5jZXMpO1xuICAgICAgICAgICAgdG9fdXBkYXRlW2luc3RhbmNlLmlkXSA9IFtpbnN0YW5jZSwgb2JqX2F0dHJzLCB3YXNfbmV3XTtcbiAgICAgICAgfVxuICAgICAgICBmb3JlYWNoX2RlcHRoX2ZpcnN0ID0gZnVuY3Rpb24gKGl0ZW1zLCBmKSB7XG4gICAgICAgICAgICB2YXIgYWxyZWFkeV9zdGFydGVkLCBmb3JlYWNoX3ZhbHVlLCBrLCByZXN1bHRzLCB2O1xuICAgICAgICAgICAgYWxyZWFkeV9zdGFydGVkID0ge307XG4gICAgICAgICAgICBmb3JlYWNoX3ZhbHVlID0gZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYXR0cnMsIGUsIGssIGwsIGxlbjEsIHJlZjEsIHJlc3VsdHMsIHJlc3VsdHMxLCBzYW1lX2FzX3Y7XG4gICAgICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBoYXNfcHJvcHNfMS5IYXNQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2LmlkIGluIGFscmVhZHlfc3RhcnRlZCkgJiYgdi5pZCBpbiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeV9zdGFydGVkW3YuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjEgPSBpdGVtc1t2LmlkXSwgc2FtZV9hc192ID0gcmVmMVswXSwgYXR0cnMgPSByZWYxWzFdLCB3YXNfbmV3ID0gcmVmMVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBhdHRyc1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JlYWNoX3ZhbHVlKGUsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYodiwgYXR0cnMsIHdhc19uZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSB2Lmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHZbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZm9yZWFjaF92YWx1ZShlLCBmKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB2W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaChmb3JlYWNoX3ZhbHVlKGUsIGYpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoayBpbiBpdGVtcykge1xuICAgICAgICAgICAgICAgIHYgPSBpdGVtc1trXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZm9yZWFjaF92YWx1ZSh2WzBdLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcbiAgICAgICAgZm9yZWFjaF9kZXB0aF9maXJzdCh0b191cGRhdGUsIGZ1bmN0aW9uIChpbnN0YW5jZSwgYXR0cnMsIHdhc19uZXcpIHtcbiAgICAgICAgICAgIGlmICh3YXNfbmV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnNldHYoYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcmVhY2hfZGVwdGhfZmlyc3QodG9fdXBkYXRlLCBmdW5jdGlvbiAoaW5zdGFuY2UsIGF0dHJzLCB3YXNfbmV3KSB7XG4gICAgICAgICAgICBpZiAod2FzX25ldykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5pbml0aWFsaXplKGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5fZXZlbnRfZm9yX2F0dHJpYnV0ZV9jaGFuZ2UgPSBmdW5jdGlvbiAoY2hhbmdlZF9vYmosIGtleSwgbmV3X3ZhbHVlLCBkb2MsIHZhbHVlX3JlZnMpIHtcbiAgICAgICAgdmFyIGNoYW5nZWRfbW9kZWwsIGV2ZW50O1xuICAgICAgICBjaGFuZ2VkX21vZGVsID0gZG9jLmdldF9tb2RlbF9ieV9pZChjaGFuZ2VkX29iai5pZCk7XG4gICAgICAgIGlmICghY2hhbmdlZF9tb2RlbC5hdHRyaWJ1dGVfaXNfc2VyaWFsaXphYmxlKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgJ2tpbmQnOiAnTW9kZWxDaGFuZ2VkJyxcbiAgICAgICAgICAgICdtb2RlbCc6IHtcbiAgICAgICAgICAgICAgICBpZDogY2hhbmdlZF9vYmouaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogY2hhbmdlZF9vYmoudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhdHRyJzoga2V5LFxuICAgICAgICAgICAgJ25ldyc6IG5ld192YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBoYXNfcHJvcHNfMS5IYXNQcm9wcy5fanNvbl9yZWNvcmRfcmVmZXJlbmNlcyhkb2MsIG5ld192YWx1ZSwgdmFsdWVfcmVmcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIERvY3VtZW50Ll9ldmVudHNfdG9fc3luY19vYmplY3RzID0gZnVuY3Rpb24gKGZyb21fb2JqLCB0b19vYmosIHRvX2RvYywgdmFsdWVfcmVmcykge1xuICAgICAgICB2YXIgYWRkZWQsIGV2ZW50cywgZnJvbV9rZXlzLCBqLCBrZXksIGwsIGxlbiwgbGVuMSwgbGVuMiwgbiwgbmV3X3ZhbHVlLCBvbGRfdmFsdWUsIHJlbW92ZWQsIHNoYXJlZCwgdG9fa2V5cztcbiAgICAgICAgZnJvbV9rZXlzID0gT2JqZWN0LmtleXMoZnJvbV9vYmouYXR0cmlidXRlcyk7XG4gICAgICAgIHRvX2tleXMgPSBPYmplY3Qua2V5cyh0b19vYmouYXR0cmlidXRlcyk7XG4gICAgICAgIHJlbW92ZWQgPSBhcnJheV8xLmRpZmZlcmVuY2UoZnJvbV9rZXlzLCB0b19rZXlzKTtcbiAgICAgICAgYWRkZWQgPSBhcnJheV8xLmRpZmZlcmVuY2UodG9fa2V5cywgZnJvbV9rZXlzKTtcbiAgICAgICAgc2hhcmVkID0gYXJyYXlfMS5pbnRlcnNlY3Rpb24oZnJvbV9rZXlzLCB0b19rZXlzKTtcbiAgICAgICAgZXZlbnRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlbW92ZWQubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGtleSA9IHJlbW92ZWRbal07XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJTZXJ2ZXIgc2VudCBrZXkgXCIgKyBrZXkgKyBcIiBidXQgd2UgZG9uJ3Qgc2VlbSB0byBoYXZlIGl0IGluIG91ciBKU09OXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBhZGRlZC5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgIGtleSA9IGFkZGVkW2xdO1xuICAgICAgICAgICAgbmV3X3ZhbHVlID0gdG9fb2JqLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKERvY3VtZW50Ll9ldmVudF9mb3JfYXR0cmlidXRlX2NoYW5nZShmcm9tX29iaiwga2V5LCBuZXdfdmFsdWUsIHRvX2RvYywgdmFsdWVfcmVmcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobiA9IDAsIGxlbjIgPSBzaGFyZWQubGVuZ3RoOyBuIDwgbGVuMjsgbisrKSB7XG4gICAgICAgICAgICBrZXkgPSBzaGFyZWRbbl07XG4gICAgICAgICAgICBvbGRfdmFsdWUgPSBmcm9tX29iai5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBuZXdfdmFsdWUgPSB0b19vYmouYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgaWYgKG9sZF92YWx1ZSA9PT0gbnVsbCAmJiBuZXdfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZF92YWx1ZSA9PT0gbnVsbCB8fCBuZXdfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaChEb2N1bWVudC5fZXZlbnRfZm9yX2F0dHJpYnV0ZV9jaGFuZ2UoZnJvbV9vYmosIGtleSwgbmV3X3ZhbHVlLCB0b19kb2MsIHZhbHVlX3JlZnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZXFfMS5pc0VxdWFsKG9sZF92YWx1ZSwgbmV3X3ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChEb2N1bWVudC5fZXZlbnRfZm9yX2F0dHJpYnV0ZV9jaGFuZ2UoZnJvbV9vYmosIGtleSwgbmV3X3ZhbHVlLCB0b19kb2MsIHZhbHVlX3JlZnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERvY3VtZW50Ll9jb21wdXRlX3BhdGNoX3NpbmNlX2pzb24gPSBmdW5jdGlvbiAoZnJvbV9qc29uLCB0b19kb2MpIHtcbiAgICAgICAgdmFyIGV2ZW50cywgZnJvbV9yZWZlcmVuY2VzLCBmcm9tX3Jvb3RfaWRzLCBmcm9tX3Jvb3RzLCBpZCwgaW5jbHVkZV9kZWZhdWx0cywgaiwgbCwgbGVuLCBsZW4xLCBtb2RlbCwgciwgcmVmMSwgcmVmMiwgcmVmMywgcmVmcywgdG9fanNvbiwgdG9fcmVmZXJlbmNlcywgdG9fcm9vdF9pZHMsIHRvX3Jvb3RzLCB1cGRhdGVfbW9kZWxfZXZlbnRzLCB2YWx1ZV9yZWZzO1xuICAgICAgICB0b19qc29uID0gdG9fZG9jLnRvX2pzb24oaW5jbHVkZV9kZWZhdWx0cyA9IGZhbHNlKTtcbiAgICAgICAgcmVmcyA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCBvYmosIHJlZjEsIHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgcmVmMSA9IGpzb25bJ3Jvb3RzJ11bJ3JlZmVyZW5jZXMnXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBvYmogPSByZWYxW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtvYmouaWRdID0gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgZnJvbV9yZWZlcmVuY2VzID0gcmVmcyhmcm9tX2pzb24pO1xuICAgICAgICBmcm9tX3Jvb3RzID0ge307XG4gICAgICAgIGZyb21fcm9vdF9pZHMgPSBbXTtcbiAgICAgICAgcmVmMSA9IGZyb21fanNvblsncm9vdHMnXVsncm9vdF9pZHMnXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZjFbal07XG4gICAgICAgICAgICBmcm9tX3Jvb3RzW3JdID0gZnJvbV9yZWZlcmVuY2VzW3JdO1xuICAgICAgICAgICAgZnJvbV9yb290X2lkcy5wdXNoKHIpO1xuICAgICAgICB9XG4gICAgICAgIHRvX3JlZmVyZW5jZXMgPSByZWZzKHRvX2pzb24pO1xuICAgICAgICB0b19yb290cyA9IHt9O1xuICAgICAgICB0b19yb290X2lkcyA9IFtdO1xuICAgICAgICByZWYyID0gdG9fanNvblsncm9vdHMnXVsncm9vdF9pZHMnXTtcbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICByID0gcmVmMltsXTtcbiAgICAgICAgICAgIHRvX3Jvb3RzW3JdID0gdG9fcmVmZXJlbmNlc1tyXTtcbiAgICAgICAgICAgIHRvX3Jvb3RfaWRzLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbV9yb290X2lkcy5zb3J0KCk7XG4gICAgICAgIHRvX3Jvb3RfaWRzLnNvcnQoKTtcbiAgICAgICAgaWYgKGFycmF5XzEuZGlmZmVyZW5jZShmcm9tX3Jvb3RfaWRzLCB0b19yb290X2lkcykubGVuZ3RoID4gMCB8fCBhcnJheV8xLmRpZmZlcmVuY2UodG9fcm9vdF9pZHMsIGZyb21fcm9vdF9pZHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogY29tcHV0aW5nIGFkZC9yZW1vdmUgb2YgZG9jdW1lbnQgcm9vdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVfcmVmcyA9IHt9O1xuICAgICAgICBldmVudHMgPSBbXTtcbiAgICAgICAgcmVmMyA9IHRvX2RvYy5fYWxsX21vZGVscztcbiAgICAgICAgZm9yIChpZCBpbiByZWYzKSB7XG4gICAgICAgICAgICBtb2RlbCA9IHJlZjNbaWRdO1xuICAgICAgICAgICAgaWYgKGlkIGluIGZyb21fcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZV9tb2RlbF9ldmVudHMgPSBEb2N1bWVudC5fZXZlbnRzX3RvX3N5bmNfb2JqZWN0cyhmcm9tX3JlZmVyZW5jZXNbaWRdLCB0b19yZWZlcmVuY2VzW2lkXSwgdG9fZG9jLCB2YWx1ZV9yZWZzKTtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHVwZGF0ZV9tb2RlbF9ldmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZXZlbnRzJzogZXZlbnRzLFxuICAgICAgICAgICAgJ3JlZmVyZW5jZXMnOiBEb2N1bWVudC5fcmVmZXJlbmNlc19qc29uKG9iamVjdF8xLnZhbHVlcyh2YWx1ZV9yZWZzKSwgaW5jbHVkZV9kZWZhdWx0cyA9IGZhbHNlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLnRvX2pzb25fc3RyaW5nID0gZnVuY3Rpb24gKGluY2x1ZGVfZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVfZGVmYXVsdHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVkZV9kZWZhdWx0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9fanNvbihpbmNsdWRlX2RlZmF1bHRzKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUudG9fanNvbiA9IGZ1bmN0aW9uIChpbmNsdWRlX2RlZmF1bHRzKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIHIsIHJlZjEsIHJvb3RfaWRzLCByb290X3JlZmVyZW5jZXM7XG4gICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJvb3RfaWRzID0gW107XG4gICAgICAgIHJlZjEgPSB0aGlzLl9yb290cztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZjFbal07XG4gICAgICAgICAgICByb290X2lkcy5wdXNoKHIuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3RfcmVmZXJlbmNlcyA9IG9iamVjdF8xLnZhbHVlcyh0aGlzLl9hbGxfbW9kZWxzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aXRsZSc6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgJ3Jvb3RzJzoge1xuICAgICAgICAgICAgICAgICdyb290X2lkcyc6IHJvb3RfaWRzLFxuICAgICAgICAgICAgICAgICdyZWZlcmVuY2VzJzogRG9jdW1lbnQuX3JlZmVyZW5jZXNfanNvbihyb290X3JlZmVyZW5jZXMsIGluY2x1ZGVfZGVmYXVsdHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEb2N1bWVudC5mcm9tX2pzb25fc3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGpzb247XG4gICAgICAgIGlmIChzID09PSBudWxsIHx8IChzID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIHN0cmluZyBpcyBcIiArICh0eXBlb2YgcykpO1xuICAgICAgICB9XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICByZXR1cm4gRG9jdW1lbnQuZnJvbV9qc29uKGpzb24pO1xuICAgIH07XG4gICAgRG9jdW1lbnQuZnJvbV9qc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIGRvYywgaXNfZGV2LCBqLCBsZW4sIHB5X3ZlcnNpb24sIHIsIHJlZmVyZW5jZXMsIHJlZmVyZW5jZXNfanNvbiwgcm9vdF9pZHMsIHJvb3RzX2pzb24sIHZlcnNpb25zX3N0cmluZztcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIkNyZWF0aW5nIERvY3VtZW50IGZyb20gSlNPTlwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTiBvYmplY3QgaGFzIHdyb25nIHR5cGUgXCIgKyAodHlwZW9mIGpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBweV92ZXJzaW9uID0ganNvblsndmVyc2lvbiddO1xuICAgICAgICBpc19kZXYgPSBweV92ZXJzaW9uLmluZGV4T2YoJysnKSAhPT0gLTEgfHwgcHlfdmVyc2lvbi5pbmRleE9mKCctJykgIT09IC0xO1xuICAgICAgICB2ZXJzaW9uc19zdHJpbmcgPSBcIkxpYnJhcnkgdmVyc2lvbnM6IEpTIChcIiArIHZlcnNpb25fMS52ZXJzaW9uICsgXCIpICAvICBQeXRob24gKFwiICsgcHlfdmVyc2lvbiArIFwiKVwiO1xuICAgICAgICBpZiAoIWlzX2RldiAmJiB2ZXJzaW9uXzEudmVyc2lvbiAhPT0gcHlfdmVyc2lvbikge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiSlMvUHl0aG9uIHZlcnNpb24gbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4odmVyc2lvbnNfc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcodmVyc2lvbnNfc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByb290c19qc29uID0ganNvblsncm9vdHMnXTtcbiAgICAgICAgcm9vdF9pZHMgPSByb290c19qc29uWydyb290X2lkcyddO1xuICAgICAgICByZWZlcmVuY2VzX2pzb24gPSByb290c19qc29uWydyZWZlcmVuY2VzJ107XG4gICAgICAgIHJlZmVyZW5jZXMgPSBEb2N1bWVudC5faW5zdGFudGlhdGVfcmVmZXJlbmNlc19qc29uKHJlZmVyZW5jZXNfanNvbiwge30pO1xuICAgICAgICBEb2N1bWVudC5faW5pdGlhbGl6ZV9yZWZlcmVuY2VzX2pzb24ocmVmZXJlbmNlc19qc29uLCB7fSwgcmVmZXJlbmNlcyk7XG4gICAgICAgIGRvYyA9IG5ldyBEb2N1bWVudCgpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByb290X2lkcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJvb3RfaWRzW2pdO1xuICAgICAgICAgICAgZG9jLmFkZF9yb290KHJlZmVyZW5jZXNbcl0pO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5zZXRfdGl0bGUoanNvblsndGl0bGUnXSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUucmVwbGFjZV93aXRoX2pzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gRG9jdW1lbnQuZnJvbV9qc29uKGpzb24pO1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQuZGVzdHJ1Y3RpdmVseV9tb3ZlKHRoaXMpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZV9qc29uX3BhdGNoX3N0cmluZyA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuY3JlYXRlX2pzb25fcGF0Y2goZXZlbnRzKSk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlX2pzb25fcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBldmVudCwgaiwganNvbl9ldmVudHMsIGxlbiwgcmVmZXJlbmNlcywgcmVzdWx0O1xuICAgICAgICByZWZlcmVuY2VzID0ge307XG4gICAgICAgIGpzb25fZXZlbnRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbal07XG4gICAgICAgICAgICBpZiAoZXZlbnQuZG9jdW1lbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJDYW5ub3QgY3JlYXRlIGEgcGF0Y2ggdXNpbmcgZXZlbnRzIGZyb20gYSBkaWZmZXJlbnQgZG9jdW1lbnQsIGV2ZW50IGhhZCBcIiwgZXZlbnQuZG9jdW1lbnQsIFwiIHdlIGFyZSBcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIHBhdGNoIHVzaW5nIGV2ZW50cyBmcm9tIGEgZGlmZmVyZW50IGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAganNvbl9ldmVudHMucHVzaChldmVudC5qc29uKHJlZmVyZW5jZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBqc29uX2V2ZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IERvY3VtZW50Ll9yZWZlcmVuY2VzX2pzb24ob2JqZWN0XzEudmFsdWVzKHJlZmVyZW5jZXMpKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmFwcGx5X2pzb25fcGF0Y2hfc3RyaW5nID0gZnVuY3Rpb24gKHBhdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5X2pzb25fcGF0Y2goSlNPTi5wYXJzZShwYXRjaCkpO1xuICAgIH07XG4gICAgRG9jdW1lbnQucHJvdG90eXBlLmFwcGx5X2pzb25fcGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2gsIHNldHRlcl9pZCkge1xuICAgICAgICB2YXIgYXR0ciwgY29sdW1uX3NvdXJjZSwgY29sdW1uX3NvdXJjZV9pZCwgZGF0YSwgZXZlbnRfanNvbiwgZXZlbnRzX2pzb24sIGlkLCBqLCBsLCBsZW4sIGxlbjEsIG1vZGVsX2lkLCBtb2RlbF90eXBlLCBuZXdfcmVmZXJlbmNlcywgb2JqMSwgb2xkX3JlZmVyZW5jZXMsIHBhdGNoZWRfaWQsIHBhdGNoZWRfb2JqLCBwYXRjaGVzLCByZWYxLCByZWZlcmVuY2VzLCByZWZlcmVuY2VzX2pzb24sIHJlc3VsdHMsIHJvbGxvdmVyLCByb290X2lkLCByb290X29iaiwgc2hhcGVzLCB2YWx1ZTtcbiAgICAgICAgcmVmZXJlbmNlc19qc29uID0gcGF0Y2hbJ3JlZmVyZW5jZXMnXTtcbiAgICAgICAgZXZlbnRzX2pzb24gPSBwYXRjaFsnZXZlbnRzJ107XG4gICAgICAgIHJlZmVyZW5jZXMgPSBEb2N1bWVudC5faW5zdGFudGlhdGVfcmVmZXJlbmNlc19qc29uKHJlZmVyZW5jZXNfanNvbiwgdGhpcy5fYWxsX21vZGVscyk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGV2ZW50c19qc29uLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBldmVudF9qc29uID0gZXZlbnRzX2pzb25bal07XG4gICAgICAgICAgICBpZiAoJ21vZGVsJyBpbiBldmVudF9qc29uKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxfaWQgPSBldmVudF9qc29uWydtb2RlbCddWydpZCddO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbF9pZCBpbiB0aGlzLl9hbGxfbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXNbbW9kZWxfaWRdID0gdGhpcy5fYWxsX21vZGVsc1ttb2RlbF9pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlbF9pZCBpbiByZWZlcmVuY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiR290IGFuIGV2ZW50IGZvciB1bmtub3duIG1vZGVsIFwiLCBldmVudF9qc29uWydtb2RlbCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV2ZW50IG1vZGVsIHdhc24ndCBrbm93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbGRfcmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBuZXdfcmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBmb3IgKGlkIGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVmZXJlbmNlc1tpZF07XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5fYWxsX21vZGVscykge1xuICAgICAgICAgICAgICAgIG9sZF9yZWZlcmVuY2VzW2lkXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3X3JlZmVyZW5jZXNbaWRdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgRG9jdW1lbnQuX2luaXRpYWxpemVfcmVmZXJlbmNlc19qc29uKHJlZmVyZW5jZXNfanNvbiwgb2xkX3JlZmVyZW5jZXMsIG5ld19yZWZlcmVuY2VzKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gZXZlbnRzX2pzb24ubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBldmVudF9qc29uID0gZXZlbnRzX2pzb25bbF07XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50X2pzb24ua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ01vZGVsQ2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWRfaWQgPSBldmVudF9qc29uWydtb2RlbCddWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXRjaGVkX2lkIGluIHRoaXMuX2FsbF9tb2RlbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgcGF0Y2ggdG8gXCIgKyBwYXRjaGVkX2lkICsgXCIgd2hpY2ggaXMgbm90IGluIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkX29iaiA9IHRoaXMuX2FsbF9tb2RlbHNbcGF0Y2hlZF9pZF07XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBldmVudF9qc29uWydhdHRyJ107XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsX3R5cGUgPSBldmVudF9qc29uWydtb2RlbCddWyd0eXBlJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyID09PSAnZGF0YScgJiYgbW9kZWxfdHlwZSA9PT0gJ0NvbHVtbkRhdGFTb3VyY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYxID0gc2VyaWFsaXphdGlvbl8xLmRlY29kZV9jb2x1bW5fZGF0YShldmVudF9qc29uWyduZXcnXSksIGRhdGEgPSByZWYxWzBdLCBzaGFwZXMgPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhdGNoZWRfb2JqLnNldHYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaGFwZXM6IHNoYXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyX2lkOiBzZXR0ZXJfaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gRG9jdW1lbnQuX3Jlc29sdmVfcmVmcyhldmVudF9qc29uWyduZXcnXSwgb2xkX3JlZmVyZW5jZXMsIG5ld19yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXRjaGVkX29iai5zZXR2KChvYmoxID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqMVtcIlwiICsgYXR0cl0gPSB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoxKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcl9pZDogc2V0dGVyX2lkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29sdW1uc1N0cmVhbWVkJzpcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX3NvdXJjZV9pZCA9IGV2ZW50X2pzb25bJ2NvbHVtbl9zb3VyY2UnXVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29sdW1uX3NvdXJjZV9pZCBpbiB0aGlzLl9hbGxfbW9kZWxzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0cmVhbSB0byBcIiArIGNvbHVtbl9zb3VyY2VfaWQgKyBcIiB3aGljaCBpcyBub3QgaW4gdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9zb3VyY2UgPSB0aGlzLl9hbGxfbW9kZWxzW2NvbHVtbl9zb3VyY2VfaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2x1bW5fc291cmNlIGluc3RhbmNlb2YgY29sdW1uX2RhdGFfc291cmNlXzEuQ29sdW1uRGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdHJlYW0gdG8gbm9uLUNvbHVtbkRhdGFTb3VyY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGV2ZW50X2pzb25bJ2RhdGEnXTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbG92ZXIgPSBldmVudF9qc29uWydyb2xsb3ZlciddO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY29sdW1uX3NvdXJjZS5zdHJlYW0oZGF0YSwgcm9sbG92ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29sdW1uc1BhdGNoZWQnOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5fc291cmNlX2lkID0gZXZlbnRfanNvblsnY29sdW1uX3NvdXJjZSddWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2x1bW5fc291cmNlX2lkIGluIHRoaXMuX2FsbF9tb2RlbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGF0Y2ggXCIgKyBjb2x1bW5fc291cmNlX2lkICsgXCIgd2hpY2ggaXMgbm90IGluIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5fc291cmNlID0gdGhpcy5fYWxsX21vZGVsc1tjb2x1bW5fc291cmNlX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29sdW1uX3NvdXJjZSBpbnN0YW5jZW9mIGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGF0Y2ggbm9uLUNvbHVtbkRhdGFTb3VyY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcyA9IGV2ZW50X2pzb25bJ3BhdGNoZXMnXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvbHVtbl9zb3VyY2UucGF0Y2gocGF0Y2hlcykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdSb290QWRkZWQnOlxuICAgICAgICAgICAgICAgICAgICByb290X2lkID0gZXZlbnRfanNvblsnbW9kZWwnXVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdF9vYmogPSByZWZlcmVuY2VzW3Jvb3RfaWRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5hZGRfcm9vdChyb290X29iaiwgc2V0dGVyX2lkKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1Jvb3RSZW1vdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgcm9vdF9pZCA9IGV2ZW50X2pzb25bJ21vZGVsJ11bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIHJvb3Rfb2JqID0gcmVmZXJlbmNlc1tyb290X2lkXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucmVtb3ZlX3Jvb3Qocm9vdF9vYmosIHNldHRlcl9pZCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUaXRsZUNoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zZXRfdGl0bGUoZXZlbnRfanNvblsndGl0bGUnXSwgc2V0dGVyX2lkKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGF0Y2ggZXZlbnQgXCIgKyBKU09OLnN0cmluZ2lmeShldmVudF9qc29uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnQ7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2NyZWF0ZV92aWV3LCBfZ2V0X3Nlc3Npb24sIF9oYW5kbGVfbm90ZWJvb2tfY29tbXMsIF9pbml0X2NvbW1zLCBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQsIF9zZXNzaW9ucywgX3VwZGF0ZV9jb21tc19jYWxsYmFjaywgYWRkX2RvY3VtZW50X2Zyb21fc2Vzc2lvbiwgYWRkX21vZGVsX2Zyb21fc2Vzc2lvbiwgYWRkX21vZGVsX3N0YXRpYywgZmlsbF9yZW5kZXJfaXRlbV9mcm9tX3NjcmlwdF90YWc7XG52YXIgYmFzZSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vY29yZS9sb2dnaW5nXCIpO1xudmFyIGRvY3VtZW50XzEgPSByZXF1aXJlKFwiLi9kb2N1bWVudFwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2NvcmUvZG9tXCIpO1xudmFyIGNhbGxiYWNrXzEgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWwvY2FsbGJhY2tcIik7XG5leHBvcnRzLkJPS0VIX1JPT1QgPSBcImJrLXJvb3RcIjtcbl9oYW5kbGVfbm90ZWJvb2tfY29tbXMgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcImhhbmRsaW5nIG5vdGVib29rIGNvbW1zXCIpO1xuICAgIGRhdGEgPSBKU09OLnBhcnNlKG1zZy5jb250ZW50LmRhdGEpO1xuICAgIGlmICgnZXZlbnRzJyBpbiBkYXRhICYmICdyZWZlcmVuY2VzJyBpbiBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5X2pzb25fcGF0Y2goZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2MnIGluIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZV93aXRoX2pzb24oZGF0YVsnZG9jJ10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxpbmcgbm90ZWJvb2sgY29tbXMgbWVzc2FnZTogXCIsIG1zZyk7XG4gICAgfVxufTtcbl91cGRhdGVfY29tbXNfY2FsbGJhY2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBkb2MsIGNvbW0pIHtcbiAgICBpZiAodGFyZ2V0ID09PSBjb21tLnRhcmdldF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBjb21tLm9uX21zZyhfaGFuZGxlX25vdGVib29rX2NvbW1zLmJpbmQoZG9jKSk7XG4gICAgfVxufTtcbl9pbml0X2NvbW1zID0gZnVuY3Rpb24gKHRhcmdldCwgZG9jKSB7XG4gICAgdmFyIGNvbW1fbWFuYWdlciwgZSwgaWQsIHByb21pc2UsIHJlZiwgdXBkYXRlX2NvbW1zO1xuICAgIGlmICgodHlwZW9mIEp1cHl0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgSnVweXRlciAhPT0gbnVsbCkgJiYgKEp1cHl0ZXIubm90ZWJvb2sua2VybmVsICE9IG51bGwpKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuaW5mbyhcIlJlZ2lzdGVyaW5nIEp1cHl0ZXIgY29tbXMgZm9yIHRhcmdldCBcIiArIHRhcmdldCk7XG4gICAgICAgIGNvbW1fbWFuYWdlciA9IEp1cHl0ZXIubm90ZWJvb2sua2VybmVsLmNvbW1fbWFuYWdlcjtcbiAgICAgICAgdXBkYXRlX2NvbW1zID0gZnVuY3Rpb24gKGNvbW0pIHtcbiAgICAgICAgICAgIHJldHVybiBfdXBkYXRlX2NvbW1zX2NhbGxiYWNrKHRhcmdldCwgZG9jLCBjb21tKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVmID0gY29tbV9tYW5hZ2VyLmNvbW1zO1xuICAgICAgICBmb3IgKGlkIGluIHJlZikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHJlZltpZF07XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4odXBkYXRlX2NvbW1zKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1fbWFuYWdlci5yZWdpc3Rlcl90YXJnZXQodGFyZ2V0LCBmdW5jdGlvbiAoY29tbSwgbXNnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5pbmZvKFwiUmVnaXN0ZXJpbmcgSnVweXRlciBjb21tcyBmb3IgdGFyZ2V0IFwiICsgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbS5vbl9tc2coX2hhbmRsZV9ub3RlYm9va19jb21tcy5iaW5kKGRvYykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgZSA9IGVycm9yMTtcbiAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJKdXB5dGVyIGNvbW1zIGZhaWxlZCB0byByZWdpc3Rlci4gcHVzaF9ub3RlYm9vaygpIHdpbGwgbm90IGZ1bmN0aW9uLiAoZXhjZXB0aW9uIHJlcG9ydGVkOiBcIiArIGUgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ0p1cHl0ZXIgbm90ZWJvb2tzIGNvbW1zIG5vdCBhdmFpbGFibGUuIHB1c2hfbm90ZWJvb2soKSB3aWxsIG5vdCBmdW5jdGlvbicpO1xuICAgIH1cbn07XG5fY3JlYXRlX3ZpZXcgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICB2YXIgdmlldztcbiAgICB2aWV3ID0gbmV3IG1vZGVsLmRlZmF1bHRfdmlldyh7XG4gICAgICAgIG1vZGVsOiBtb2RlbFxuICAgIH0pO1xuICAgIGJhc2UuaW5kZXhbbW9kZWwuaWRdID0gdmlldztcbiAgICByZXR1cm4gdmlldztcbn07XG5fcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZG9jdW1lbnQsIHVzZV9mb3JfdGl0bGUpIHtcbiAgICB2YXIgaSwgbGVuLCBtb2RlbCwgcmVmLCByZW5kZXJfbW9kZWwsIHVucmVuZGVyX21vZGVsLCB2aWV3cztcbiAgICB2aWV3cyA9IHt9O1xuICAgIHJlbmRlcl9tb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgdmlldztcbiAgICAgICAgdmlldyA9IF9jcmVhdGVfdmlldyhtb2RlbCk7XG4gICAgICAgIHZpZXdzW21vZGVsLmlkXSA9IHZpZXc7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmFwcGVuZENoaWxkKHZpZXcuZWwpO1xuICAgIH07XG4gICAgdW5yZW5kZXJfbW9kZWwgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIHZpZXc7XG4gICAgICAgIGlmIChtb2RlbC5pZCBpbiB2aWV3cykge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdzW21vZGVsLmlkXTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodmlldy5lbCk7XG4gICAgICAgICAgICBkZWxldGUgdmlld3NbbW9kZWwuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBiYXNlLmluZGV4W21vZGVsLmlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVmID0gZG9jdW1lbnQucm9vdHMoKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbW9kZWwgPSByZWZbaV07XG4gICAgICAgIHJlbmRlcl9tb2RlbChtb2RlbCk7XG4gICAgfVxuICAgIGlmICh1c2VfZm9yX3RpdGxlKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC50aXRsZSA9IGRvY3VtZW50LnRpdGxlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50Lm9uX2NoYW5nZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZG9jdW1lbnRfMS5Sb290QWRkZWRFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcl9tb2RlbChldmVudC5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBkb2N1bWVudF8xLlJvb3RSZW1vdmVkRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnJlbmRlcl9tb2RlbChldmVudC5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXNlX2Zvcl90aXRsZSAmJiBldmVudCBpbnN0YW5jZW9mIGRvY3VtZW50XzEuVGl0bGVDaGFuZ2VkRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQudGl0bGUgPSBldmVudC50aXRsZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2aWV3cztcbn07XG5hZGRfbW9kZWxfc3RhdGljID0gZnVuY3Rpb24gKGVsZW1lbnQsIG1vZGVsX2lkLCBkb2MpIHtcbiAgICB2YXIgbW9kZWwsIHZpZXc7XG4gICAgbW9kZWwgPSBkb2MuZ2V0X21vZGVsX2J5X2lkKG1vZGVsX2lkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBcIiArIG1vZGVsX2lkICsgXCIgd2FzIG5vdCBpbiBkb2N1bWVudCBcIiArIGRvYyk7XG4gICAgfVxuICAgIHZpZXcgPSBfY3JlYXRlX3ZpZXcobW9kZWwpO1xuICAgIHJldHVybiBjYWxsYmFja18xLmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvbV8xLnJlcGxhY2VXaXRoKGVsZW1lbnQsIHZpZXcuZWwpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuYWRkX2RvY3VtZW50X3N0YXRpYyA9IGZ1bmN0aW9uIChlbGVtZW50LCBkb2MsIHVzZV9mb3JfdGl0bGUpIHtcbiAgICByZXR1cm4gY2FsbGJhY2tfMS5kZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQoZWxlbWVudCwgZG9jLCB1c2VfZm9yX3RpdGxlKTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmFkZF9kb2N1bWVudF9zdGFuZGFsb25lID0gZnVuY3Rpb24gKGRvY3VtZW50LCBlbGVtZW50LCB1c2VfZm9yX3RpdGxlKSB7XG4gICAgaWYgKHVzZV9mb3JfdGl0bGUgPT0gbnVsbCkge1xuICAgICAgICB1c2VfZm9yX3RpdGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQoZWxlbWVudCwgZG9jdW1lbnQsIHVzZV9mb3JfdGl0bGUpO1xufTtcbl9zZXNzaW9ucyA9IHt9O1xuX2dldF9zZXNzaW9uID0gZnVuY3Rpb24gKHdlYnNvY2tldF91cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKSB7XG4gICAgdmFyIHN1YnNlc3Npb25zO1xuICAgIGlmICgod2Vic29ja2V0X3VybCA9PSBudWxsKSB8fCB3ZWJzb2NrZXRfdXJsID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2Vic29ja2V0X3VybFwiKTtcbiAgICB9XG4gICAgaWYgKCEod2Vic29ja2V0X3VybCBpbiBfc2Vzc2lvbnMpKSB7XG4gICAgICAgIF9zZXNzaW9uc1t3ZWJzb2NrZXRfdXJsXSA9IHt9O1xuICAgIH1cbiAgICBzdWJzZXNzaW9ucyA9IF9zZXNzaW9uc1t3ZWJzb2NrZXRfdXJsXTtcbiAgICBpZiAoIShzZXNzaW9uX2lkIGluIHN1YnNlc3Npb25zKSkge1xuICAgICAgICBzdWJzZXNzaW9uc1tzZXNzaW9uX2lkXSA9IGNsaWVudF8xLnB1bGxfc2Vzc2lvbih3ZWJzb2NrZXRfdXJsLCBzZXNzaW9uX2lkLCBhcmdzX3N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzZXNzaW9uc1tzZXNzaW9uX2lkXTtcbn07XG5hZGRfZG9jdW1lbnRfZnJvbV9zZXNzaW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIHdlYnNvY2tldF91cmwsIHNlc3Npb25faWQsIHVzZV9mb3JfdGl0bGUpIHtcbiAgICB2YXIgYXJnc19zdHJpbmcsIHByb21pc2U7XG4gICAgYXJnc19zdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKTtcbiAgICBwcm9taXNlID0gX2dldF9zZXNzaW9uKHdlYnNvY2tldF91cmwsIHNlc3Npb25faWQsIGFyZ3Nfc3RyaW5nKTtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyX2RvY3VtZW50X3RvX2VsZW1lbnQoZWxlbWVudCwgc2Vzc2lvbi5kb2N1bWVudCwgdXNlX2Zvcl90aXRsZSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBCb2tlaCBzZXNzaW9uIFwiICsgc2Vzc2lvbl9pZCArIFwiOiBcIiArIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59O1xuYWRkX21vZGVsX2Zyb21fc2Vzc2lvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCB3ZWJzb2NrZXRfdXJsLCBtb2RlbF9pZCwgc2Vzc2lvbl9pZCkge1xuICAgIHZhciBhcmdzX3N0cmluZywgcHJvbWlzZTtcbiAgICBhcmdzX3N0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpO1xuICAgIHByb21pc2UgPSBfZ2V0X3Nlc3Npb24od2Vic29ja2V0X3VybCwgc2Vzc2lvbl9pZCwgYXJnc19zdHJpbmcpO1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIG1vZGVsLCB2aWV3O1xuICAgICAgICBtb2RlbCA9IHNlc3Npb24uZG9jdW1lbnQuZ2V0X21vZGVsX2J5X2lkKG1vZGVsX2lkKTtcbiAgICAgICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCBtb2RlbCBcIiArIG1vZGVsX2lkICsgXCIgaW4gc2Vzc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3ID0gX2NyZWF0ZV92aWV3KG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIGRvbV8xLnJlcGxhY2VXaXRoKGVsZW1lbnQsIHZpZXcuZWwpO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgQm9rZWggc2Vzc2lvbiBcIiArIHNlc3Npb25faWQgKyBcIjogXCIgKyBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuaW5qZWN0X2NzcyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICBlbGVtZW50ID0gZG9tXzEubGluayh7XG4gICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2Nzc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG59O1xuZXhwb3J0cy5pbmplY3RfcmF3X2NzcyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICBlbGVtZW50ID0gZG9tXzEuc3R5bGUoe30sIGNzcyk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG59O1xuZmlsbF9yZW5kZXJfaXRlbV9mcm9tX3NjcmlwdF90YWcgPSBmdW5jdGlvbiAoc2NyaXB0LCBpdGVtKSB7XG4gICAgdmFyIGluZm87XG4gICAgaW5mbyA9IHNjcmlwdC5kYXRhc2V0O1xuICAgIGlmICgoaW5mby5ib2tlaExvZ0xldmVsICE9IG51bGwpICYmIGluZm8uYm9rZWhMb2dMZXZlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5zZXRfbG9nX2xldmVsKGluZm8uYm9rZWhMb2dMZXZlbCk7XG4gICAgfVxuICAgIGlmICgoaW5mby5ib2tlaERvY0lkICE9IG51bGwpICYmIGluZm8uYm9rZWhEb2NJZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGl0ZW1bJ2RvY2lkJ10gPSBpbmZvLmJva2VoRG9jSWQ7XG4gICAgfVxuICAgIGlmICgoaW5mby5ib2tlaE1vZGVsSWQgIT0gbnVsbCkgJiYgaW5mby5ib2tlaE1vZGVsSWQubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtWydtb2RlbGlkJ10gPSBpbmZvLmJva2VoTW9kZWxJZDtcbiAgICB9XG4gICAgaWYgKChpbmZvLmJva2VoU2Vzc2lvbklkICE9IG51bGwpICYmIGluZm8uYm9rZWhTZXNzaW9uSWQubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtWydzZXNzaW9uaWQnXSA9IGluZm8uYm9rZWhTZXNzaW9uSWQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmluZm8oXCJXaWxsIGluamVjdCBCb2tlaCBzY3JpcHQgdGFnIHdpdGggcGFyYW1zIFwiICsgKEpTT04uc3RyaW5naWZ5KGl0ZW0pKSk7XG59O1xuZXhwb3J0cy5lbWJlZF9pdGVtcyA9IGZ1bmN0aW9uIChkb2NzX2pzb24sIHJlbmRlcl9pdGVtcywgYXBwX3BhdGgsIGFic29sdXRlX3VybCkge1xuICAgIHZhciBjaGlsZCwgY29udGFpbmVyLCBkb2NpZCwgZG9jcywgZWxlbSwgZWxlbWVudF9pZCwgaSwgaXRlbSwgbGVuLCBsb2MsIHByb21pc2UsIHByb3RvY29sLCByZXN1bHRzLCB1c2VfZm9yX3RpdGxlLCB3ZWJzb2NrZXRfdXJsO1xuICAgIHByb3RvY29sID0gJ3dzOic7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgcHJvdG9jb2wgPSAnd3NzOic7XG4gICAgfVxuICAgIGlmIChhYnNvbHV0ZV91cmwgIT0gbnVsbCkge1xuICAgICAgICBsb2MgPSBuZXcgVVJMKGFic29sdXRlX3VybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2MgPSB3aW5kb3cubG9jYXRpb247XG4gICAgfVxuICAgIGlmIChhcHBfcGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhcHBfcGF0aCA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIGFwcF9wYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwX3BhdGggPSBsb2MucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgfVxuICAgIHdlYnNvY2tldF91cmwgPSBwcm90b2NvbCArICcvLycgKyBsb2MuaG9zdCArIGFwcF9wYXRoICsgJy93cyc7XG4gICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcImVtYmVkOiBjb21wdXRlZCB3cyB1cmw6IFwiICsgd2Vic29ja2V0X3VybCk7XG4gICAgZG9jcyA9IHt9O1xuICAgIGZvciAoZG9jaWQgaW4gZG9jc19qc29uKSB7XG4gICAgICAgIGRvY3NbZG9jaWRdID0gZG9jdW1lbnRfMS5Eb2N1bWVudC5mcm9tX2pzb24oZG9jc19qc29uW2RvY2lkXSk7XG4gICAgfVxuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZW5kZXJfaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHJlbmRlcl9pdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm90ZWJvb2tfY29tbXNfdGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pbml0X2NvbW1zKGl0ZW0ubm90ZWJvb2tfY29tbXNfdGFyZ2V0LCBkb2NzW2RvY2lkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudF9pZCA9IGl0ZW1bJ2VsZW1lbnRpZCddO1xuICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudF9pZCk7XG4gICAgICAgIGlmIChlbGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHJlbmRlcmluZyBCb2tlaCBtb2RlbDogY291bGQgbm90IGZpbmQgdGFnIHdpdGggaWQ6IFwiICsgZWxlbWVudF9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZW5kZXJpbmcgQm9rZWggbW9kZWw6IGVsZW1lbnQgd2l0aCBpZCAnXCIgKyBlbGVtZW50X2lkICsgXCInIG11c3QgYmUgdW5kZXIgPGJvZHk+XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLnRhZ05hbWUgPT09IFwiU0NSSVBUXCIpIHtcbiAgICAgICAgICAgIGZpbGxfcmVuZGVyX2l0ZW1fZnJvbV9zY3JpcHRfdGFnKGVsZW0sIGl0ZW0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IGV4cG9ydHMuQk9LRUhfUk9PVFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb21fMS5yZXBsYWNlV2l0aChlbGVtLCBjb250YWluZXIpO1xuICAgICAgICAgICAgY2hpbGQgPSBkb21fMS5kaXYoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBlbGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdXNlX2Zvcl90aXRsZSA9IChpdGVtLnVzZV9mb3JfdGl0bGUgIT0gbnVsbCkgJiYgaXRlbS51c2VfZm9yX3RpdGxlO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYgKGl0ZW0ubW9kZWxpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkX21vZGVsX3N0YXRpYyhlbGVtLCBpdGVtLm1vZGVsaWQsIGRvY3NbaXRlbS5kb2NpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zZXNzaW9uaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBhZGRfbW9kZWxfZnJvbV9zZXNzaW9uKGVsZW0sIHdlYnNvY2tldF91cmwsIGl0ZW0ubW9kZWxpZCwgaXRlbS5zZXNzaW9uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmVuZGVyaW5nIEJva2VoIG1vZGVsIFwiICsgaXRlbVsnbW9kZWxpZCddICsgXCIgdG8gZWxlbWVudCBcIiArIGVsZW1lbnRfaWQgKyBcIjogbm8gZG9jdW1lbnQgSUQgb3Igc2Vzc2lvbiBJRCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5hZGRfZG9jdW1lbnRfc3RhdGljKGVsZW0sIGRvY3NbaXRlbS5kb2NpZF0sIHVzZV9mb3JfdGl0bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zZXNzaW9uaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBhZGRfZG9jdW1lbnRfZnJvbV9zZXNzaW9uKGVsZW0sIHdlYnNvY2tldF91cmwsIGl0ZW0uc2Vzc2lvbmlkLCB1c2VfZm9yX3RpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHJlbmRlcmluZyBCb2tlaCBkb2N1bWVudCB0byBlbGVtZW50IFwiICsgZWxlbWVudF9pZCArIFwiOiBubyBkb2N1bWVudCBJRCBvciBzZXNzaW9uIElEIHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJCb2tlaCBpdGVtcyB3ZXJlIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yIHJlbmRlcmluZyBCb2tlaCBpdGVtcyBcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb25fMS52ZXJzaW9uO1xudmFyIGVtYmVkID0gcmVxdWlyZShcIi4vZW1iZWRcIik7XG5leHBvcnRzLmVtYmVkID0gZW1iZWQ7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vY29yZS9sb2dnaW5nXCIpO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnaW5nXzEubG9nZ2VyO1xuZXhwb3J0cy5zZXRfbG9nX2xldmVsID0gbG9nZ2luZ18xLnNldF9sb2dfbGV2ZWw7XG52YXIgYmFzZV8xID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbmV4cG9ydHMuTW9kZWxzID0gYmFzZV8xLk1vZGVscztcbmV4cG9ydHMuaW5kZXggPSBiYXNlXzEuaW5kZXg7XG52YXIgc2FmZWx5XzEgPSByZXF1aXJlKFwiLi9zYWZlbHlcIik7XG5leHBvcnRzLnNhZmVseSA9IHNhZmVseV8xLnNhZmVseTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNfcHJvcHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvaGFzX3Byb3BzXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC90eXBlc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vY29yZS9sb2dnaW5nXCIpO1xuZXhwb3J0cy5Nb2RlbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNb2RlbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTW9kZWwoKSB7XG4gICAgICAgIHJldHVybiBNb2RlbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLnR5cGUgPSBcIk1vZGVsXCI7XG4gICAgTW9kZWwuZGVmaW5lKHtcbiAgICAgICAgdGFnczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgbmFtZTogW3AuU3RyaW5nXSxcbiAgICAgICAganNfcHJvcGVydHlfY2FsbGJhY2tzOiBbcC5BbnksIHt9XSxcbiAgICAgICAganNfZXZlbnRfY2FsbGJhY2tzOiBbcC5BbnksIHt9XSxcbiAgICAgICAgc3Vic2NyaWJlZF9ldmVudHM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MsIGNiLCBldnQsIGksIGxlbiwgcmVmMTtcbiAgICAgICAgTW9kZWwuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmVmMSA9IHRoaXMuanNfcHJvcGVydHlfY2FsbGJhY2tzO1xuICAgICAgICBmb3IgKGV2dCBpbiByZWYxKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MgPSByZWYxW2V2dF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsIGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IuZXhlY3V0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6anNfZXZlbnRfY2FsbGJhY2tzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9ldmVudF9jYWxsYmFja3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLCAnY2hhbmdlOnN1YnNjcmliZWRfZXZlbnRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9ldmVudF9jYWxsYmFja3M7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLl9wcm9jZXNzX2V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjYWxsYmFjaywgaSwgbGVuLCByZWYxLCByZWYyO1xuICAgICAgICBpZiAoZXZlbnQuaXNfYXBwbGljYWJsZV90byh0aGlzKSkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudC5fY3VzdG9taXplX2V2ZW50KHRoaXMpO1xuICAgICAgICAgICAgcmVmMiA9IChyZWYxID0gdGhpcy5qc19ldmVudF9jYWxsYmFja3NbZXZlbnQuZXZlbnRfbmFtZV0pICE9IG51bGwgPyByZWYxIDogW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWYyW2ldO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmV4ZWN1dGUoZXZlbnQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRfZXZlbnRzLnNvbWUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbSA9PT0gZXZlbnQuZXZlbnRfbmFtZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZXZlbnRfbWFuYWdlci5zZW5kX2V2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnRyaWdnZXJfZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlZjE7XG4gICAgICAgIHJldHVybiAocmVmMSA9IHRoaXMuZG9jdW1lbnQpICE9IG51bGwgPyByZWYxLmV2ZW50X21hbmFnZXIudHJpZ2dlcihldmVudC5zZXRfbW9kZWxfaWQodGhpcy5pZCkpIDogdm9pZCAwO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLl91cGRhdGVfZXZlbnRfY2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ1dBUk5JTkc6IERvY3VtZW50IG5vdCBkZWZpbmVkIGZvciB1cGRhdGluZyBldmVudCBjYWxsYmFja3MnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5ldmVudF9tYW5hZ2VyLnN1YnNjcmliZWRfbW9kZWxzLnB1c2godGhpcy5pZCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuX2RvY19hdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFvYmplY3RfMS5pc0VtcHR5KHRoaXMuanNfZXZlbnRfY2FsbGJhY2tzKSB8fCAhb2JqZWN0XzEuaXNFbXB0eSh0aGlzLnN1YnNjcmliZWRfZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9ldmVudF9jYWxsYmFja3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZXMoKS5maWx0ZXIoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYgaW5zdGFuY2VvZiBzZWxlY3RvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVzXzEuaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmLm5hbWUgPT09IHNlbGVjdG9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlbGVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc2VsZWN0X29uZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdChzZWxlY3Rvcik7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvdW5kIG1vcmUgdGhhbiBvbmUgb2JqZWN0IG1hdGNoaW5nIGdpdmVuIHNlbGVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWw7XG59KShoYXNfcHJvcHNfMS5IYXNQcm9wcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2lkZV9wYW5lbF8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NpZGVfcGFuZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvcmVuZGVyZXJcIik7XG5leHBvcnRzLkFubm90YXRpb25WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubm90YXRpb25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2dldF9wYW5lbF9vZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICB4ID0gdGhpcy5tb2RlbC5wYW5lbC5fbGVmdC5fdmFsdWU7XG4gICAgICAgIHkgPSB0aGlzLm1vZGVsLnBhbmVsLl9ib3R0b20uX3ZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IC15XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2dldF9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gQW5ub3RhdGlvblZpZXc7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyVmlldyk7XG5leHBvcnRzLkFubm90YXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQW5ub3RhdGlvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQW5ub3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFubm90YXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFubm90YXRpb24ucHJvdG90eXBlLnR5cGUgPSAnQW5ub3RhdGlvbic7XG4gICAgQW5ub3RhdGlvbi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Bbm5vdGF0aW9uVmlldztcbiAgICBBbm5vdGF0aW9uLmRlZmluZSh7XG4gICAgICAgIHBsb3Q6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIEFubm90YXRpb24ub3ZlcnJpZGUoe1xuICAgICAgICBsZXZlbDogJ2Fubm90YXRpb24nXG4gICAgfSk7XG4gICAgQW5ub3RhdGlvbi5wcm90b3R5cGUuYWRkX3BhbmVsID0gZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdGhpcy5wYW5lbCA9IG5ldyBzaWRlX3BhbmVsXzEuU2lkZVBhbmVsKHtcbiAgICAgICAgICAgIHNpZGU6IHNpZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFuZWwuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbCA9ICdvdmVybGF5JztcbiAgICB9O1xuICAgIHJldHVybiBBbm5vdGF0aW9uO1xufSkocmVuZGVyZXJfMS5SZW5kZXJlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciBhcnJvd19oZWFkXzEgPSByZXF1aXJlKFwiLi9hcnJvd19oZWFkXCIpO1xudmFyIGNvbHVtbl9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4uL3NvdXJjZXMvY29sdW1uX2RhdGFfc291cmNlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvbWF0aFwiKTtcbmV4cG9ydHMuQXJyb3dWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFycm93Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQXJyb3dWaWV3KCkge1xuICAgICAgICByZXR1cm4gQXJyb3dWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBcnJvd1ZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBBcnJvd1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc291cmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc291cmNlID0gbmV3IGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMucGxvdF9tb2RlbC5jYW52YXM7XG4gICAgICAgIHRoaXMueG1hcHBlciA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnhfbWFwcGVyc1t0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHRoaXMueW1hcHBlciA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnlfbWFwcGVyc1t0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzLnNldF9kYXRhKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5zb3VyY2UsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldF9kYXRhKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIEFycm93Vmlldy5fX3N1cGVyX18uc2V0X2RhdGEuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXN1YWxzLndhcm1fY2FjaGUoc291cmNlKTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW5kLCBzdGFydCwgeF9uYW1lLCB5X25hbWU7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXJ0X3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih0aGlzLl94X3N0YXJ0LCB0aGlzLl95X3N0YXJ0LCB4X25hbWUgPSB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZSwgeV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBbdGhpcy5jYW52YXMudl92eF90b19zeCh0aGlzLl94X3N0YXJ0KSwgdGhpcy5jYW52YXMudl92eV90b19zeSh0aGlzLl95X3N0YXJ0KV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZW5kX3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4odGhpcy5feF9lbmQsIHRoaXMuX3lfZW5kLCB4X25hbWUgPSB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZSwgeV9uYW1lID0gdGhpcy5tb2RlbC55X3JhbmdlX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gW3RoaXMuY2FudmFzLnZfdnhfdG9fc3godGhpcy5feF9lbmQpLCB0aGlzLmNhbnZhcy52X3Z5X3RvX3N5KHRoaXMuX3lfZW5kKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9O1xuICAgIEFycm93Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4LCByZWY7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICByZWYgPSB0aGlzLl9tYXBfZGF0YSgpLCB0aGlzLnN0YXJ0ID0gcmVmWzBdLCB0aGlzLmVuZCA9IHJlZlsxXTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcInJlbmRlclwiLCB0aGlzLm1vZGVsLmVuZCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcInJlbmRlclwiLCB0aGlzLm1vZGVsLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93X2hlYWQoY3R4LCBcImNsaXBcIiwgdGhpcy5tb2RlbC5lbmQsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hcnJvd19oZWFkKGN0eCwgXCJjbGlwXCIsIHRoaXMubW9kZWwuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIHRoaXMuX2Fycm93X2JvZHkoY3R4KTtcbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBBcnJvd1ZpZXcucHJvdG90eXBlLl9hcnJvd19ib2R5ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLl94X3N0YXJ0Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuc3RhcnRbMF1baV0sIHRoaXMuc3RhcnRbMV1baV0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVuZFswXVtpXSwgdGhpcy5lbmRbMV1baV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBBcnJvd1ZpZXcucHJvdG90eXBlLl9hcnJvd19oZWFkID0gZnVuY3Rpb24gKGN0eCwgYWN0aW9uLCBoZWFkLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBhbmdsZSwgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLl94X3N0YXJ0Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguUEkgLyAyICsgbWF0aF8xLmF0YW4yKFtzdGFydFswXVtpXSwgc3RhcnRbMV1baV1dLCBbZW5kWzBdW2ldLCBlbmRbMV1baV1dKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGVuZFswXVtpXSwgZW5kWzFdW2ldKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgICAgICAgICAgIGhlYWQucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09IFwiY2xpcFwiKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5jbGlwKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnJlc3RvcmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyb3dWaWV3O1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb25WaWV3KTtcbmV4cG9ydHMuQXJyb3cgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXJyb3csIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFycm93KCkge1xuICAgICAgICByZXR1cm4gQXJyb3cuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFycm93LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkFycm93VmlldztcbiAgICBBcnJvdy5wcm90b3R5cGUudHlwZSA9ICdBcnJvdyc7XG4gICAgQXJyb3cubWl4aW5zKFsnbGluZSddKTtcbiAgICBBcnJvdy5kZWZpbmUoe1xuICAgICAgICB4X3N0YXJ0OiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgeV9zdGFydDogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIHN0YXJ0X3VuaXRzOiBbcC5TdHJpbmcsICdkYXRhJ10sXG4gICAgICAgIHN0YXJ0OiBbcC5JbnN0YW5jZSwgbnVsbF0sXG4gICAgICAgIHhfZW5kOiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgeV9lbmQ6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICBlbmRfdW5pdHM6IFtwLlN0cmluZywgJ2RhdGEnXSxcbiAgICAgICAgZW5kOiBbcC5JbnN0YW5jZSwgbmV3IGFycm93X2hlYWRfMS5PcGVuSGVhZCh7fSldLFxuICAgICAgICBzb3VyY2U6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddXG4gICAgfSk7XG4gICAgcmV0dXJuIEFycm93O1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgdmlzdWFsc18xID0gcmVxdWlyZShcImNvcmUvdmlzdWFsc1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQXJyb3dIZWFkID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFycm93SGVhZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQXJyb3dIZWFkKCkge1xuICAgICAgICByZXR1cm4gQXJyb3dIZWFkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBcnJvd0hlYWQucHJvdG90eXBlLnR5cGUgPSAnQXJyb3dIZWFkJztcbiAgICBBcnJvd0hlYWQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBBcnJvd0hlYWQuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFscyA9IG5ldyB2aXN1YWxzXzEuVmlzdWFscyh0aGlzKTtcbiAgICB9O1xuICAgIEFycm93SGVhZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFycm93SGVhZC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyb3dIZWFkO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuZXhwb3J0cy5PcGVuSGVhZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChPcGVuSGVhZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gT3BlbkhlYWQoKSB7XG4gICAgICAgIHJldHVybiBPcGVuSGVhZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgT3BlbkhlYWQucHJvdG90eXBlLnR5cGUgPSAnT3BlbkhlYWQnO1xuICAgIE9wZW5IZWFkLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgLTIpO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIC0yKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgfTtcbiAgICBPcGVuSGVhZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3BlbkhlYWQubWl4aW5zKFsnbGluZSddKTtcbiAgICBPcGVuSGVhZC5kZWZpbmUoe1xuICAgICAgICBzaXplOiBbcC5OdW1iZXIsIDI1XVxuICAgIH0pO1xuICAgIHJldHVybiBPcGVuSGVhZDtcbn0pKGV4cG9ydHMuQXJyb3dIZWFkKTtcbmV4cG9ydHMuTm9ybWFsSGVhZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChOb3JtYWxIZWFkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOb3JtYWxIZWFkKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsSGVhZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTm9ybWFsSGVhZC5wcm90b3R5cGUudHlwZSA9ICdOb3JtYWxIZWFkJztcbiAgICBOb3JtYWxIZWFkLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKGN0eCwgaSkge1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAuNSAqIHRoaXMuc2l6ZSwgLTIpO1xuICAgICAgICBjdHgubGluZVRvKC0wLjUgKiB0aGlzLnNpemUsIC0yKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgfTtcbiAgICBOb3JtYWxIZWFkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWwoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbChjdHgsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9ybWFsSGVhZC5wcm90b3R5cGUuX25vcm1hbCA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICByZXR1cm4gY3R4LmNsb3NlUGF0aCgpO1xuICAgIH07XG4gICAgTm9ybWFsSGVhZC5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgTm9ybWFsSGVhZC5kZWZpbmUoe1xuICAgICAgICBzaXplOiBbcC5OdW1iZXIsIDI1XVxuICAgIH0pO1xuICAgIE5vcm1hbEhlYWQub3ZlcnJpZGUoe1xuICAgICAgICBmaWxsX2NvbG9yOiAnYmxhY2snXG4gICAgfSk7XG4gICAgcmV0dXJuIE5vcm1hbEhlYWQ7XG59KShleHBvcnRzLkFycm93SGVhZCk7XG5leHBvcnRzLlZlZUhlYWQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVmVlSGVhZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVmVlSGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIFZlZUhlYWQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFZlZUhlYWQucHJvdG90eXBlLnR5cGUgPSAnVmVlSGVhZCc7XG4gICAgVmVlSGVhZC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHgubW92ZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLjUgKiB0aGlzLnNpemUsIC0yKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCAtMik7XG4gICAgICAgIGN0eC5saW5lVG8oLTAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwLjUgKiB0aGlzLnNpemUpO1xuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbygwLjUgKiB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgfTtcbiAgICBWZWVIZWFkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICB0aGlzLl92ZWUoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIHRoaXMuX3ZlZShjdHgsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmVlSGVhZC5wcm90b3R5cGUuX3ZlZSA9IGZ1bmN0aW9uIChjdHgsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAuNSAqIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygtMC41ICogdGhpcy5zaXplLCB0aGlzLnNpemUpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDAuNSAqIHRoaXMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBjdHguY2xvc2VQYXRoKCk7XG4gICAgfTtcbiAgICBWZWVIZWFkLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBWZWVIZWFkLmRlZmluZSh7XG4gICAgICAgIHNpemU6IFtwLk51bWJlciwgMjVdXG4gICAgfSk7XG4gICAgVmVlSGVhZC5vdmVycmlkZSh7XG4gICAgICAgIGZpbGxfY29sb3I6ICdibGFjaydcbiAgICB9KTtcbiAgICByZXR1cm4gVmVlSGVhZDtcbn0pKGV4cG9ydHMuQXJyb3dIZWFkKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi9hbm5vdGF0aW9uXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5Cb3hBbm5vdGF0aW9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb3hBbm5vdGF0aW9uVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94QW5ub3RhdGlvblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBCb3hBbm5vdGF0aW9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm94QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBCb3hBbm5vdGF0aW9uVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5jYW52YXNfb3ZlcmxheXMuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLXNoYWRpbmdcIik7XG4gICAgICAgIHJldHVybiBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgIH07XG4gICAgQm94QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucmVuZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdkYXRhX3VwZGF0ZScsIHRoaXMucmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdkYXRhX3VwZGF0ZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQm94QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNib3R0b20sIHNsZWZ0LCBzcmlnaHQsIHN0b3A7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlICYmIHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLm1vZGVsLmxlZnQgPT0gbnVsbCkgJiYgKHRoaXMubW9kZWwucmlnaHQgPT0gbnVsbCkgJiYgKHRoaXMubW9kZWwudG9wID09IG51bGwpICYmICh0aGlzLm1vZGVsLmJvdHRvbSA9PSBudWxsKSkge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy54bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueF9tYXBwZXJzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy55bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueV9tYXBwZXJzW3RoaXMubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgc2xlZnQgPSB0aGlzLmNhbnZhcy52eF90b19zeCh0aGlzLl9jYWxjX2RpbSh0aGlzLm1vZGVsLmxlZnQsIHRoaXMubW9kZWwubGVmdF91bml0cywgdGhpcy54bWFwcGVyLCB0aGlzLmZyYW1lLmhfcmFuZ2Uuc3RhcnQpKTtcbiAgICAgICAgc3JpZ2h0ID0gdGhpcy5jYW52YXMudnhfdG9fc3godGhpcy5fY2FsY19kaW0odGhpcy5tb2RlbC5yaWdodCwgdGhpcy5tb2RlbC5yaWdodF91bml0cywgdGhpcy54bWFwcGVyLCB0aGlzLmZyYW1lLmhfcmFuZ2UuZW5kKSk7XG4gICAgICAgIHNib3R0b20gPSB0aGlzLmNhbnZhcy52eV90b19zeSh0aGlzLl9jYWxjX2RpbSh0aGlzLm1vZGVsLmJvdHRvbSwgdGhpcy5tb2RlbC5ib3R0b21fdW5pdHMsIHRoaXMueW1hcHBlciwgdGhpcy5mcmFtZS52X3JhbmdlLnN0YXJ0KSk7XG4gICAgICAgIHN0b3AgPSB0aGlzLmNhbnZhcy52eV90b19zeSh0aGlzLl9jYWxjX2RpbSh0aGlzLm1vZGVsLnRvcCwgdGhpcy5tb2RlbC50b3BfdW5pdHMsIHRoaXMueW1hcHBlciwgdGhpcy5mcmFtZS52X3JhbmdlLmVuZCkpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jc3NfYm94KHNsZWZ0LCBzcmlnaHQsIHNib3R0b20sIHN0b3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc19ib3goc2xlZnQsIHNyaWdodCwgc2JvdHRvbSwgc3RvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJveEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5fY3NzX2JveCA9IGZ1bmN0aW9uIChzbGVmdCwgc3JpZ2h0LCBzYm90dG9tLCBzdG9wKSB7XG4gICAgICAgIHZhciBsZCwgc2gsIHN3O1xuICAgICAgICBzdyA9IE1hdGguYWJzKHNyaWdodCAtIHNsZWZ0KTtcbiAgICAgICAgc2ggPSBNYXRoLmFicyhzYm90dG9tIC0gc3RvcCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHNsZWZ0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gc3cgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gc3RvcCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBzaCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3JkZXJXaWR0aCA9IHRoaXMubW9kZWwubGluZV93aWR0aC52YWx1ZSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3JkZXJDb2xvciA9IHRoaXMubW9kZWwubGluZV9jb2xvci52YWx1ZTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLm1vZGVsLmZpbGxfY29sb3IudmFsdWU7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9IHRoaXMubW9kZWwuZmlsbF9hbHBoYS52YWx1ZTtcbiAgICAgICAgbGQgPSB0aGlzLm1vZGVsLmxpbmVfZGFzaDtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShsZCkpIHtcbiAgICAgICAgICAgIGxkID0gbGQubGVuZ3RoIDwgMiA/IFwic29saWRcIiA6IFwiZGFzaGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcobGQpKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJvcmRlclN0eWxlID0gbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbV8xLnNob3codGhpcy5lbCk7XG4gICAgfTtcbiAgICBCb3hBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2NhbnZhc19ib3ggPSBmdW5jdGlvbiAoc2xlZnQsIHNyaWdodCwgc2JvdHRvbSwgc3RvcCkge1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3Qoc2xlZnQsIHN0b3AsIHNyaWdodCAtIHNsZWZ0LCBzYm90dG9tIC0gc3RvcCk7XG4gICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEJveEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5fY2FsY19kaW0gPSBmdW5jdGlvbiAoZGltLCBkaW1fdW5pdHMsIG1hcHBlciwgZnJhbWVfZXh0cmVtYSkge1xuICAgICAgICB2YXIgdmRpbTtcbiAgICAgICAgaWYgKGRpbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGltX3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICB2ZGltID0gbWFwcGVyLm1hcF90b190YXJnZXQoZGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZkaW0gPSBkaW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZGltID0gZnJhbWVfZXh0cmVtYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmRpbTtcbiAgICB9O1xuICAgIHJldHVybiBCb3hBbm5vdGF0aW9uVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLkJveEFubm90YXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQm94QW5ub3RhdGlvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94QW5ub3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJveEFubm90YXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJveEFubm90YXRpb24ucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQm94QW5ub3RhdGlvblZpZXc7XG4gICAgQm94QW5ub3RhdGlvbi5wcm90b3R5cGUudHlwZSA9ICdCb3hBbm5vdGF0aW9uJztcbiAgICBCb3hBbm5vdGF0aW9uLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBCb3hBbm5vdGF0aW9uLmRlZmluZSh7XG4gICAgICAgIHJlbmRlcl9tb2RlOiBbcC5SZW5kZXJNb2RlLCAnY2FudmFzJ10sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgdG9wOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICB0b3BfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgYm90dG9tOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBib3R0b21fdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgbGVmdDogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgbGVmdF91bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICByaWdodDogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgcmlnaHRfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXVxuICAgIH0pO1xuICAgIEJveEFubm90YXRpb24ub3ZlcnJpZGUoe1xuICAgICAgICBmaWxsX2NvbG9yOiAnI2ZmZjliYScsXG4gICAgICAgIGZpbGxfYWxwaGE6IDAuNCxcbiAgICAgICAgbGluZV9jb2xvcjogJyNjY2NjY2MnLFxuICAgICAgICBsaW5lX2FscGhhOiAwLjNcbiAgICB9KTtcbiAgICBCb3hBbm5vdGF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBib3R0b20sIGxlZnQsIHJpZ2h0LCB0b3A7XG4gICAgICAgIGxlZnQgPSBhcmcubGVmdCwgcmlnaHQgPSBhcmcucmlnaHQsIHRvcCA9IGFyZy50b3AsIGJvdHRvbSA9IGFyZy5ib3R0b207XG4gICAgICAgIHRoaXMuc2V0dih7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBib3R0b206IGJvdHRvbVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2RhdGFfdXBkYXRlJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQm94QW5ub3RhdGlvbjtcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExPTkdfRElNX01BWF9TQ0FMQVIsIExPTkdfRElNX01JTl9TQ0FMQVIsIFNIT1JUX0RJTSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgYmFzaWNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi4vdGlja2Vycy9iYXNpY190aWNrZXJcIik7XG52YXIgYmFzaWNfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi9mb3JtYXR0ZXJzL2Jhc2ljX3RpY2tfZm9ybWF0dGVyXCIpO1xudmFyIGxpbmVhcl9jb2xvcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tYXBwZXJzL2xpbmVhcl9jb2xvcl9tYXBwZXJcIik7XG52YXIgbGluZWFyX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvbGluZWFyX21hcHBlclwiKTtcbnZhciBsb2dfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9sb2dfbWFwcGVyXCIpO1xudmFyIHJhbmdlMWRfMSA9IHJlcXVpcmUoXCIuLi9yYW5nZXMvcmFuZ2UxZFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0ZXh0X3V0aWwgPSByZXF1aXJlKFwiY29yZS91dGlsL3RleHRcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5TSE9SVF9ESU0gPSAyNTtcbkxPTkdfRElNX01JTl9TQ0FMQVIgPSAwLjM7XG5MT05HX0RJTV9NQVhfU0NBTEFSID0gMC44O1xuZXhwb3J0cy5Db2xvckJhclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sb3JCYXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb2xvckJhclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDb2xvckJhclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIENvbG9yQmFyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0X2NhbnZhc19pbWFnZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnZpc2libGUnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC50aWNrZXIsICdjaGFuZ2UnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5mb3JtYXR0ZXIsICdjaGFuZ2UnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuY29sb3JfbWFwcGVyLCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0X2NhbnZhc19pbWFnZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZ2V0X3BhbmVsX29mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgIHggPSB0aGlzLm1vZGVsLnBhbmVsLl9sZWZ0Ll92YWx1ZTtcbiAgICAgICAgeSA9IHRoaXMubW9kZWwucGFuZWwuX3RvcC5fdmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogLXlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2dldF9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveCwgc2lkZTtcbiAgICAgICAgYmJveCA9IHRoaXMuY29tcHV0ZV9sZWdlbmRfZGltZW5zaW9ucygpO1xuICAgICAgICBzaWRlID0gdGhpcy5tb2RlbC5wYW5lbC5zaWRlO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ2Fib3ZlJyB8fCBzaWRlID09PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4gYmJveC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0JyB8fCBzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYmJveC53aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fc2V0X2NhbnZhc19pbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZiwgYnVmOCwgY2FudmFzLCBjbWFwLCBoLCBpbWFnZV9jdHgsIGltYWdlX2RhdGEsIGssIHBhbGV0dGUsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVzdWx0cywgdztcbiAgICAgICAgcGFsZXR0ZSA9IHRoaXMubW9kZWwuY29sb3JfbWFwcGVyLnBhbGV0dGU7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBwYWxldHRlID0gcGFsZXR0ZS5zbGljZSgwKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICByZWYgPSBbMSwgcGFsZXR0ZS5sZW5ndGhdLCB3ID0gcmVmWzBdLCBoID0gcmVmWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICByZWYxID0gW3BhbGV0dGUubGVuZ3RoLCAxXSwgdyA9IHJlZjFbMF0sIGggPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICByZWYyID0gW3csIGhdLCBjYW52YXMud2lkdGggPSByZWYyWzBdLCBjYW52YXMuaGVpZ2h0ID0gcmVmMlsxXTtcbiAgICAgICAgaW1hZ2VfY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGltYWdlX2RhdGEgPSBpbWFnZV9jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xuICAgICAgICBjbWFwID0gbmV3IGxpbmVhcl9jb2xvcl9tYXBwZXJfMS5MaW5lYXJDb2xvck1hcHBlcih7XG4gICAgICAgICAgICBwYWxldHRlOiBwYWxldHRlXG4gICAgICAgIH0pO1xuICAgICAgICBidWYgPSBjbWFwLnZfbWFwX3NjcmVlbigoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIHJlZjMgPSBwYWxldHRlLmxlbmd0aDsgMCA8PSByZWYzID8gayA8IHJlZjMgOiBrID4gcmVmMzsgMCA8PSByZWYzID8gaysrIDogay0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmFwcGx5KHRoaXMpKTtcbiAgICAgICAgYnVmOCA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgIGltYWdlX2RhdGEuZGF0YS5zZXQoYnVmOCk7XG4gICAgICAgIGltYWdlX2N0eC5wdXRJbWFnZURhdGEoaW1hZ2VfZGF0YSwgMCwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlID0gY2FudmFzO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5jb21wdXRlX2xlZ2VuZF9kaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW1hZ2VfZGltZW5zaW9ucywgaW1hZ2VfaGVpZ2h0LCBpbWFnZV93aWR0aCwgbGFiZWxfZXh0ZW50LCBsZWdlbmRfaGVpZ2h0LCBsZWdlbmRfd2lkdGgsIHBhZGRpbmcsIHJlZiwgdGlja19leHRlbnQsIHRpdGxlX2V4dGVudDtcbiAgICAgICAgaW1hZ2VfZGltZW5zaW9ucyA9IHRoaXMubW9kZWwuX2NvbXB1dGVkX2ltYWdlX2RpbWVuc2lvbnMoKTtcbiAgICAgICAgcmVmID0gW2ltYWdlX2RpbWVuc2lvbnMuaGVpZ2h0LCBpbWFnZV9kaW1lbnNpb25zLndpZHRoXSwgaW1hZ2VfaGVpZ2h0ID0gcmVmWzBdLCBpbWFnZV93aWR0aCA9IHJlZlsxXTtcbiAgICAgICAgbGFiZWxfZXh0ZW50ID0gdGhpcy5fZ2V0X2xhYmVsX2V4dGVudCgpO1xuICAgICAgICB0aXRsZV9leHRlbnQgPSB0aGlzLm1vZGVsLl90aXRsZV9leHRlbnQoKTtcbiAgICAgICAgdGlja19leHRlbnQgPSB0aGlzLm1vZGVsLl90aWNrX2V4dGVudCgpO1xuICAgICAgICBwYWRkaW5nID0gdGhpcy5tb2RlbC5wYWRkaW5nO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgICAgIGxlZ2VuZF9oZWlnaHQgPSBpbWFnZV9oZWlnaHQgKyB0aXRsZV9leHRlbnQgKyBwYWRkaW5nICogMjtcbiAgICAgICAgICAgICAgICBsZWdlbmRfd2lkdGggPSBpbWFnZV93aWR0aCArIHRpY2tfZXh0ZW50ICsgbGFiZWxfZXh0ZW50ICsgcGFkZGluZyAqIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgICAgIGxlZ2VuZF9oZWlnaHQgPSBpbWFnZV9oZWlnaHQgKyB0aXRsZV9leHRlbnQgKyB0aWNrX2V4dGVudCArIGxhYmVsX2V4dGVudCArIHBhZGRpbmcgKiAyO1xuICAgICAgICAgICAgICAgIGxlZ2VuZF93aWR0aCA9IGltYWdlX3dpZHRoICsgcGFkZGluZyAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogbGVnZW5kX2hlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBsZWdlbmRfd2lkdGhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuY29tcHV0ZV9sZWdlbmRfbG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoX3JhbmdlLCBsZWdlbmRfZGltZW5zaW9ucywgbGVnZW5kX2hlaWdodCwgbGVnZW5kX21hcmdpbiwgbGVnZW5kX3dpZHRoLCBsb2NhdGlvbiwgcmVmLCBzeCwgc3ksIHZfcmFuZ2UsIHgsIHk7XG4gICAgICAgIGxlZ2VuZF9kaW1lbnNpb25zID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9kaW1lbnNpb25zKCk7XG4gICAgICAgIHJlZiA9IFtsZWdlbmRfZGltZW5zaW9ucy5oZWlnaHQsIGxlZ2VuZF9kaW1lbnNpb25zLndpZHRoXSwgbGVnZW5kX2hlaWdodCA9IHJlZlswXSwgbGVnZW5kX3dpZHRoID0gcmVmWzFdO1xuICAgICAgICBsZWdlbmRfbWFyZ2luID0gdGhpcy5tb2RlbC5tYXJnaW47XG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5tb2RlbC5sb2NhdGlvbjtcbiAgICAgICAgaF9yYW5nZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lLmhfcmFuZ2U7XG4gICAgICAgIHZfcmFuZ2UgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS52X3JhbmdlO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9yaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLmVuZCAtIGxlZ2VuZF9tYXJnaW4gLSBsZWdlbmRfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9jZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB4ID0gKGhfcmFuZ2UuZW5kICsgaF9yYW5nZS5zdGFydCkgLyAyIC0gbGVnZW5kX3dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luICsgbGVnZW5kX2hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tX2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHggPSBsb2NhdGlvblswXSwgeSA9IGxvY2F0aW9uWzFdO1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KHgpO1xuICAgICAgICBzeSA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgIHN5OiBzeVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGZyYW1lX29mZnNldCwgaW1hZ2Vfb2Zmc2V0LCBsb2NhdGlvbiwgcGFuZWxfb2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFuZWxfb2Zmc2V0ID0gdGhpcy5fZ2V0X3BhbmVsX29mZnNldCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwYW5lbF9vZmZzZXQueCwgcGFuZWxfb2Zmc2V0LnkpO1xuICAgICAgICAgICAgZnJhbWVfb2Zmc2V0ID0gdGhpcy5fZ2V0X2ZyYW1lX29mZnNldCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShmcmFtZV9vZmZzZXQueCwgZnJhbWVfb2Zmc2V0LnkpO1xuICAgICAgICB9XG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9sb2NhdGlvbigpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGxvY2F0aW9uLnN4LCBsb2NhdGlvbi5zeSk7XG4gICAgICAgIHRoaXMuX2RyYXdfYmJveChjdHgpO1xuICAgICAgICBpbWFnZV9vZmZzZXQgPSB0aGlzLl9nZXRfaW1hZ2Vfb2Zmc2V0KCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoaW1hZ2Vfb2Zmc2V0LngsIGltYWdlX29mZnNldC55KTtcbiAgICAgICAgdGhpcy5fZHJhd19pbWFnZShjdHgpO1xuICAgICAgICBpZiAoKHRoaXMubW9kZWwuY29sb3JfbWFwcGVyLmxvdyAhPSBudWxsKSAmJiAodGhpcy5tb2RlbC5jb2xvcl9tYXBwZXIuaGlnaCAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd19tYWpvcl90aWNrcyhjdHgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhd19taW5vcl90aWNrcyhjdHgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhd19tYWpvcl9sYWJlbHMoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC50aXRsZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd190aXRsZShjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZHJhd19iYm94ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgYmJveCA9IHRoaXMuY29tcHV0ZV9sZWdlbmRfZGltZW5zaW9ucygpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2RyYXdfaW1hZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBpbWFnZTtcbiAgICAgICAgaW1hZ2UgPSB0aGlzLm1vZGVsLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm1vZGVsLnNjYWxlX2FscGhhO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJhcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYXJfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZHJhd19tYWpvcl90aWNrcyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGksIGltYWdlLCBrLCBueCwgbnksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3gsIHN5LCB0aW4sIHRvdXQsIHhfb2Zmc2V0LCB5X29mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMubWFqb3JfdGlja19saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLl9ub3JtYWxzKCksIG54ID0gcmVmWzBdLCBueSA9IHJlZlsxXTtcbiAgICAgICAgaW1hZ2UgPSB0aGlzLm1vZGVsLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zKCk7XG4gICAgICAgIHJlZjEgPSBbaW1hZ2Uud2lkdGggKiBueCwgaW1hZ2UuaGVpZ2h0ICogbnldLCB4X29mZnNldCA9IHJlZjFbMF0sIHlfb2Zmc2V0ID0gcmVmMVsxXTtcbiAgICAgICAgcmVmMiA9IHRoaXMubW9kZWwuX3RpY2tfY29vcmRpbmF0ZXMoKS5tYWpvciwgc3ggPSByZWYyWzBdLCBzeSA9IHJlZjJbMV07XG4gICAgICAgIHRpbiA9IHRoaXMubW9kZWwubWFqb3JfdGlja19pbjtcbiAgICAgICAgdG91dCA9IHRoaXMubW9kZWwubWFqb3JfdGlja19vdXQ7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoeF9vZmZzZXQsIHlfb2Zmc2V0KTtcbiAgICAgICAgdGhpcy52aXN1YWxzLm1ham9yX3RpY2tfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjMgPSBzeC5sZW5ndGg7IDAgPD0gcmVmMyA/IGsgPCByZWYzIDogayA+IHJlZjM7IGkgPSAwIDw9IHJlZjMgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5yb3VuZChzeFtpXSArIG54ICogdG91dCksIE1hdGgucm91bmQoc3lbaV0gKyBueSAqIHRvdXQpKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5yb3VuZChzeFtpXSAtIG54ICogdGluKSwgTWF0aC5yb3VuZChzeVtpXSAtIG55ICogdGluKSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9kcmF3X21pbm9yX3RpY2tzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgaSwgaW1hZ2UsIGssIG54LCBueSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzeCwgc3ksIHRpbiwgdG91dCwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFscy5taW5vcl90aWNrX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuX25vcm1hbHMoKSwgbnggPSByZWZbMF0sIG55ID0gcmVmWzFdO1xuICAgICAgICBpbWFnZSA9IHRoaXMubW9kZWwuX2NvbXB1dGVkX2ltYWdlX2RpbWVuc2lvbnMoKTtcbiAgICAgICAgcmVmMSA9IFtpbWFnZS53aWR0aCAqIG54LCBpbWFnZS5oZWlnaHQgKiBueV0sIHhfb2Zmc2V0ID0gcmVmMVswXSwgeV9vZmZzZXQgPSByZWYxWzFdO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5fdGlja19jb29yZGluYXRlcygpLm1pbm9yLCBzeCA9IHJlZjJbMF0sIHN5ID0gcmVmMlsxXTtcbiAgICAgICAgdGluID0gdGhpcy5tb2RlbC5taW5vcl90aWNrX2luO1xuICAgICAgICB0b3V0ID0gdGhpcy5tb2RlbC5taW5vcl90aWNrX291dDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4X29mZnNldCwgeV9vZmZzZXQpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubWlub3JfdGlja19saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMyA9IHN4Lmxlbmd0aDsgMCA8PSByZWYzID8gayA8IHJlZjMgOiBrID4gcmVmMzsgaSA9IDAgPD0gcmVmMyA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJvdW5kKHN4W2ldICsgbnggKiB0b3V0KSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogdG91dCkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLnJvdW5kKHN4W2ldIC0gbnggKiB0aW4pLCBNYXRoLnJvdW5kKHN5W2ldIC0gbnkgKiB0aW4pKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2RyYXdfbWFqb3JfbGFiZWxzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkX2xhYmVscywgaSwgaW1hZ2UsIGssIGxhYmVscywgbngsIG55LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHN0YW5kb2ZmLCBzeCwgc3ksIHhfb2Zmc2V0LCB4X3N0YW5kb2ZmLCB5X29mZnNldCwgeV9zdGFuZG9mZjtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMubWFqb3JfbGFiZWxfdGV4dC5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fbm9ybWFscygpLCBueCA9IHJlZlswXSwgbnkgPSByZWZbMV07XG4gICAgICAgIGltYWdlID0gdGhpcy5tb2RlbC5fY29tcHV0ZWRfaW1hZ2VfZGltZW5zaW9ucygpO1xuICAgICAgICByZWYxID0gW2ltYWdlLndpZHRoICogbngsIGltYWdlLmhlaWdodCAqIG55XSwgeF9vZmZzZXQgPSByZWYxWzBdLCB5X29mZnNldCA9IHJlZjFbMV07XG4gICAgICAgIHN0YW5kb2ZmID0gdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZiArIHRoaXMubW9kZWwuX3RpY2tfZXh0ZW50KCk7XG4gICAgICAgIHJlZjIgPSBbc3RhbmRvZmYgKiBueCwgc3RhbmRvZmYgKiBueV0sIHhfc3RhbmRvZmYgPSByZWYyWzBdLCB5X3N0YW5kb2ZmID0gcmVmMlsxXTtcbiAgICAgICAgcmVmMyA9IHRoaXMubW9kZWwuX3RpY2tfY29vcmRpbmF0ZXMoKS5tYWpvciwgc3ggPSByZWYzWzBdLCBzeSA9IHJlZjNbMV07XG4gICAgICAgIGxhYmVscyA9IHRoaXMubW9kZWwuX3RpY2tfY29vcmRpbmF0ZXMoKS5tYWpvcl9sYWJlbHM7XG4gICAgICAgIGZvcm1hdHRlZF9sYWJlbHMgPSB0aGlzLm1vZGVsLmZvcm1hdHRlci5kb0Zvcm1hdChsYWJlbHMsIG51bGwpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubWFqb3JfbGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4X29mZnNldCArIHhfc3RhbmRvZmYsIHlfb2Zmc2V0ICsgeV9zdGFuZG9mZik7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY0ID0gc3gubGVuZ3RoOyAwIDw9IHJlZjQgPyBrIDwgcmVmNCA6IGsgPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZm9ybWF0dGVkX2xhYmVsc1tpXSwgTWF0aC5yb3VuZChzeFtpXSArIG54ICogdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZiksIE1hdGgucm91bmQoc3lbaV0gKyBueSAqIHRoaXMubW9kZWwubGFiZWxfc3RhbmRvZmYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2RyYXdfdGl0bGUgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLnRpdGxlX3RleHQuZG9pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMudmlzdWFscy50aXRsZV90ZXh0LnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5tb2RlbC50aXRsZSwgMCwgLXRoaXMubW9kZWwudGl0bGVfc3RhbmRvZmYpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIENvbG9yQmFyVmlldy5wcm90b3R5cGUuX2dldF9sYWJlbF9leHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGZvcm1hdHRlZF9sYWJlbHMsIGxhYmVsLCBsYWJlbF9leHRlbnQ7XG4gICAgICAgIGlmICgodGhpcy5tb2RlbC5jb2xvcl9tYXBwZXIubG93ICE9IG51bGwpICYmICh0aGlzLm1vZGVsLmNvbG9yX21hcHBlci5oaWdoICE9IG51bGwpKSB7XG4gICAgICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLm1ham9yX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkX2xhYmVscyA9IHRoaXMubW9kZWwuZm9ybWF0dGVyLmRvRm9ybWF0KHRoaXMubW9kZWwuX3RpY2tfY29vcmRpbmF0ZXMoKS5tYWpvcl9sYWJlbHMpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbF9leHRlbnQgPSBhcnJheV8xLm1heCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGssIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IGZvcm1hdHRlZF9sYWJlbHMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGZvcm1hdHRlZF9sYWJlbHNba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5tZWFzdXJlVGV4dChsYWJlbC50b1N0cmluZygpKS53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsX2V4dGVudCA9IHRleHRfdXRpbC5nZXRfdGV4dF9oZWlnaHQodGhpcy52aXN1YWxzLm1ham9yX2xhYmVsX3RleHQuZm9udF92YWx1ZSgpKS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYWJlbF9leHRlbnQgKz0gdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbF9leHRlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbF9leHRlbnQ7XG4gICAgfTtcbiAgICBDb2xvckJhclZpZXcucHJvdG90eXBlLl9nZXRfZnJhbWVfb2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhbWUsIHBhbmVsLCByZWYsIHhvZmYsIHlvZmY7XG4gICAgICAgIHJlZiA9IFswLCAwXSwgeG9mZiA9IHJlZlswXSwgeW9mZiA9IHJlZlsxXTtcbiAgICAgICAgcGFuZWwgPSB0aGlzLm1vZGVsLnBhbmVsO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICBzd2l0Y2ggKHBhbmVsLnNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICB5b2ZmID0gTWF0aC5hYnMocGFuZWwudG9wIC0gZnJhbWUudG9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImJlbG93XCI6XG4gICAgICAgICAgICAgICAgeG9mZiA9IE1hdGguYWJzKGZyYW1lLmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4b2ZmLFxuICAgICAgICAgICAgeTogeW9mZlxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29sb3JCYXJWaWV3LnByb3RvdHlwZS5fZ2V0X2ltYWdlX29mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgIHggPSB0aGlzLm1vZGVsLnBhZGRpbmc7XG4gICAgICAgIHkgPSB0aGlzLm1vZGVsLnBhZGRpbmcgKyB0aGlzLm1vZGVsLl90aXRsZV9leHRlbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29sb3JCYXJWaWV3O1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb25WaWV3KTtcbmV4cG9ydHMuQ29sb3JCYXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sb3JCYXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENvbG9yQmFyKCkge1xuICAgICAgICByZXR1cm4gQ29sb3JCYXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbG9yQmFyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNvbG9yQmFyVmlldztcbiAgICBDb2xvckJhci5wcm90b3R5cGUudHlwZSA9ICdDb2xvckJhcic7XG4gICAgQ29sb3JCYXIubWl4aW5zKFsndGV4dDptYWpvcl9sYWJlbF8nLCAndGV4dDp0aXRsZV8nLCAnbGluZTptYWpvcl90aWNrXycsICdsaW5lOm1pbm9yX3RpY2tfJywgJ2xpbmU6Ym9yZGVyXycsICdsaW5lOmJhcl8nLCAnZmlsbDpiYWNrZ3JvdW5kXyddKTtcbiAgICBDb2xvckJhci5kZWZpbmUoe1xuICAgICAgICBsb2NhdGlvbjogW3AuQW55LCAndG9wX3JpZ2h0J10sXG4gICAgICAgIG9yaWVudGF0aW9uOiBbcC5PcmllbnRhdGlvbiwgJ3ZlcnRpY2FsJ10sXG4gICAgICAgIHRpdGxlOiBbcC5TdHJpbmddLFxuICAgICAgICB0aXRsZV9zdGFuZG9mZjogW3AuTnVtYmVyLCAyXSxcbiAgICAgICAgaGVpZ2h0OiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIHdpZHRoOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIHNjYWxlX2FscGhhOiBbcC5OdW1iZXIsIDEuMF0sXG4gICAgICAgIHRpY2tlcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYmFzaWNfdGlja2VyXzEuQmFzaWNUaWNrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZm9ybWF0dGVyOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNpY190aWNrX2Zvcm1hdHRlcl8xLkJhc2ljVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBjb2xvcl9tYXBwZXI6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgbGFiZWxfc3RhbmRvZmY6IFtwLk51bWJlciwgNV0sXG4gICAgICAgIG1hcmdpbjogW3AuTnVtYmVyLCAzMF0sXG4gICAgICAgIHBhZGRpbmc6IFtwLk51bWJlciwgMTBdLFxuICAgICAgICBtYWpvcl90aWNrX2luOiBbcC5OdW1iZXIsIDVdLFxuICAgICAgICBtYWpvcl90aWNrX291dDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgbWlub3JfdGlja19pbjogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgbWlub3JfdGlja19vdXQ6IFtwLk51bWJlciwgMF1cbiAgICB9KTtcbiAgICBDb2xvckJhci5vdmVycmlkZSh7XG4gICAgICAgIGJhY2tncm91bmRfZmlsbF9jb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGJhY2tncm91bmRfZmlsbF9hbHBoYTogMC45NSxcbiAgICAgICAgYmFyX2xpbmVfY29sb3I6IG51bGwsXG4gICAgICAgIGJvcmRlcl9saW5lX2NvbG9yOiBudWxsLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2FsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2Jhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2ZvbnRfc2l6ZTogXCI4cHRcIixcbiAgICAgICAgbWFqb3JfdGlja19saW5lX2NvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgbWlub3JfdGlja19saW5lX2NvbG9yOiBudWxsLFxuICAgICAgICB0aXRsZV90ZXh0X2ZvbnRfc2l6ZTogXCIxMHB0XCIsXG4gICAgICAgIHRpdGxlX3RleHRfZm9udF9zdHlsZTogXCJpdGFsaWNcIlxuICAgIH0pO1xuICAgIENvbG9yQmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb2xvckJhci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIENvbG9yQmFyLnByb3RvdHlwZS5fbm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZiwgcmVmMTtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHJlZiA9IFsxLCAwXSwgaSA9IHJlZlswXSwgaiA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjEgPSBbMCwgMV0sIGkgPSByZWYxWzBdLCBqID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ksIGpdO1xuICAgIH07XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLl90aXRsZV9leHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb250X3ZhbHVlLCB0aXRsZV9leHRlbnQ7XG4gICAgICAgIGZvbnRfdmFsdWUgPSB0aGlzLnRpdGxlX3RleHRfZm9udCArIFwiIFwiICsgdGhpcy50aXRsZV90ZXh0X2ZvbnRfc2l6ZSArIFwiIFwiICsgdGhpcy50aXRsZV90ZXh0X2ZvbnRfc3R5bGU7XG4gICAgICAgIHRpdGxlX2V4dGVudCA9IHRoaXMudGl0bGUgPyB0ZXh0X3V0aWwuZ2V0X3RleHRfaGVpZ2h0KGZvbnRfdmFsdWUpLmhlaWdodCArIHRoaXMudGl0bGVfc3RhbmRvZmYgOiAwO1xuICAgICAgICByZXR1cm4gdGl0bGVfZXh0ZW50O1xuICAgIH07XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLl90aWNrX2V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpY2tfZXh0ZW50O1xuICAgICAgICBpZiAoKHRoaXMuY29sb3JfbWFwcGVyLmxvdyAhPSBudWxsKSAmJiAodGhpcy5jb2xvcl9tYXBwZXIuaGlnaCAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGlja19leHRlbnQgPSBhcnJheV8xLm1heChbdGhpcy5tYWpvcl90aWNrX291dCwgdGhpcy5taW5vcl90aWNrX291dF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGlja19leHRlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrX2V4dGVudDtcbiAgICB9O1xuICAgIENvbG9yQmFyLnByb3RvdHlwZS5fY29tcHV0ZWRfaW1hZ2VfZGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypcbiAgICAgICAgSGV1cmlzdGljcyB0byBkZXRlcm1pbmUgQ29sb3JCYXIgaW1hZ2UgZGltZW5zaW9ucyBpZiBzZXQgdG8gXCJhdXRvXCJcbiAgICAgICAgXG4gICAgICAgIE5vdGU6IFJldHVybnMgdGhlIGhlaWdodC93aWR0aCB2YWx1ZXMgZm9yIHRoZSBDb2xvckJhcidzIHNjYWxlIGltYWdlLCBub3RcbiAgICAgICAgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVudGlyZSBDb2xvckJhci5cbiAgICAgICAgXG4gICAgICAgIElmIHRoZSBzaG9ydCBkaW1lbnNpb24gKHRoZSB3aWR0aCBvZiBhIHZlcnRpY2FsIGJhciBvciBoZWlnaHQgb2YgYVxuICAgICAgICBob3Jpem9udGFsIGJhcikgaXMgc2V0IHRvIFwiYXV0b1wiLCB0aGUgcmVzdWx0aW5nIGRpbWVuc2lvbiB3aWxsIGJlIHNldCB0b1xuICAgICAgICAyNSBweC5cbiAgICAgICAgXG4gICAgICAgIEZvciBhIENvbG9yQmFyIGluIGEgc2lkZSBwYW5lbCB3aXRoIHRoZSBsb25nIGRpbWVuc2lvbiAodGhlIGhlaWdodCBvZiBhXG4gICAgICAgIHZlcnRpY2FsIGJhciBvciB3aWR0aCBvZiBhIGhvcml6b250YWwgYmFyKSBzZXQgdG8gXCJhdXRvXCIsIHRoZVxuICAgICAgICByZXN1bHRpbmcgZGltZW5zaW9uIHdpbGwgYmUgYXMgbG9uZyBhcyB0aGUgYWRqYWNlbnQgZnJhbWUgZWRnZSwgc28gdGhhdCB0aGVcbiAgICAgICAgYmFyIFwiZml0c1wiIHRvIHRoZSBwbG90LlxuICAgICAgICBcbiAgICAgICAgRm9yIGEgQ29sb3JCYXIgaW4gdGhlIHBsb3QgZnJhbWUgd2l0aCB0aGUgbG9uZyBkaW1lbnNpb24gc2V0IHRvIFwiYXV0b1wiLCB0aGVcbiAgICAgICAgcmVzdWx0aW5nIGRpbWVuc2lvbiB3aWxsIGJlIHRoZSBncmVhdGVyIG9mOlxuICAgICAgICAgICogVGhlIGxlbmd0aCBvZiB0aGUgY29sb3IgcGFsZXR0ZSAqIDI1cHhcbiAgICAgICAgICAqIFRoZSBwYXJhbGxlbCBmcmFtZSBkaW1lbnNpb24gKiAwLjMwXG4gICAgICAgICAgICAoaS5lIHRoZSBmcmFtZSBoZWlnaHQgZm9yIGEgdmVydGljYWwgQ29sb3JCYXIpXG4gICAgICAgIEJ1dCBub3QgZ3JlYXRlciB0aGFuOlxuICAgICAgICAgICogVGhlIHBhcmFsbGVsIGZyYW1lIGRpbWVuc2lvbiAqIDAuODBcbiAgICAgICAgICovXG4gICAgICAgIHZhciBmcmFtZV9oZWlnaHQsIGZyYW1lX3dpZHRoLCBoZWlnaHQsIHRpdGxlX2V4dGVudCwgd2lkdGg7XG4gICAgICAgIGZyYW1lX2hlaWdodCA9IHRoaXMucGxvdC5wbG90X2NhbnZhcy5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIGZyYW1lX3dpZHRoID0gdGhpcy5wbG90LnBsb3RfY2FudmFzLmZyYW1lLndpZHRoO1xuICAgICAgICB0aXRsZV9leHRlbnQgPSB0aGlzLl90aXRsZV9leHRlbnQoKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYW5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBmcmFtZV9oZWlnaHQgLSAyICogdGhpcy5wYWRkaW5nIC0gdGl0bGVfZXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gYXJyYXlfMS5tYXgoW3RoaXMuY29sb3JfbWFwcGVyLnBhbGV0dGUubGVuZ3RoICogU0hPUlRfRElNLCBmcmFtZV9oZWlnaHQgKiBMT05HX0RJTV9NSU5fU0NBTEFSXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBhcnJheV8xLm1pbihbaGVpZ2h0LCBmcmFtZV9oZWlnaHQgKiBMT05HX0RJTV9NQVhfU0NBTEFSIC0gMiAqIHRoaXMucGFkZGluZyAtIHRpdGxlX2V4dGVudF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoID09PSAnYXV0bycgPyBTSE9SVF9ESU0gOiB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCA9PT0gJ2F1dG8nID8gU0hPUlRfRElNIDogdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYW5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGZyYW1lX3dpZHRoIC0gMiAqIHRoaXMucGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gYXJyYXlfMS5tYXgoW3RoaXMuY29sb3JfbWFwcGVyLnBhbGV0dGUubGVuZ3RoICogU0hPUlRfRElNLCBmcmFtZV93aWR0aCAqIExPTkdfRElNX01JTl9TQ0FMQVJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gYXJyYXlfMS5taW4oW3dpZHRoLCBmcmFtZV93aWR0aCAqIExPTkdfRElNX01BWF9TQ0FMQVIgLSAyICogdGhpcy5wYWRkaW5nXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IGhlaWdodCxcbiAgICAgICAgICAgIFwid2lkdGhcIjogd2lkdGhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbG9yQmFyLnByb3RvdHlwZS5fdGlja19jb29yZGluYXRlX21hcHBlciA9IGZ1bmN0aW9uIChzY2FsZV9sZW5ndGgpIHtcbiAgICAgICAgLypcbiAgICAgICAgQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG1hcHBlciBpbnN0YW5jZSB0aGF0IG1hcHMgdGhlIGBjb2xvcl9tYXBwZXJgIHJhbmdlXG4gICAgICAgIChsb3cgdG8gaGlnaCkgdG8gYSBzY3JlZW4gc3BhY2UgcmFuZ2UgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgQ29sb3JCYXInc1xuICAgICAgICBzY2FsZSBpbWFnZS4gVGhlIG1hcHBlciBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgdGljayBjb29yZGluYXRlcyBpbiBzY3JlZW5cbiAgICAgICAgY29vcmRpbmF0ZXMgZm9yIHBsb3R0aW5nIHB1cnBvc2VzLlxuICAgICAgICBcbiAgICAgICAgTm90ZTogdGhlIHR5cGUgb2YgY29sb3JfbWFwcGVyIGhhcyB0byBtYXRjaCB0aGUgdHlwZSBvZiBtYXBwZXIgKGkuZS5cbiAgICAgICAgYSBMaW5lYXJDb2xvck1hcHBlciB3aWxsIHJlcXVpcmUgYSBjb3JyZXNwb25kaW5nIExpbmVhck1hcHBlciBpbnN0YW5jZSkuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbWFwcGVyLCBtYXBwaW5nO1xuICAgICAgICBtYXBwaW5nID0ge1xuICAgICAgICAgICAgJ3NvdXJjZV9yYW5nZSc6IG5ldyByYW5nZTFkXzEuUmFuZ2UxZCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY29sb3JfbWFwcGVyLmxvdyxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuY29sb3JfbWFwcGVyLmhpZ2hcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ3RhcmdldF9yYW5nZSc6IG5ldyByYW5nZTFkXzEuUmFuZ2UxZCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZW5kOiBzY2FsZV9sZW5ndGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb2xvcl9tYXBwZXIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkxpbmVhckNvbG9yTWFwcGVyXCI6XG4gICAgICAgICAgICAgICAgbWFwcGVyID0gbmV3IGxpbmVhcl9tYXBwZXJfMS5MaW5lYXJNYXBwZXIobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTG9nQ29sb3JNYXBwZXJcIjpcbiAgICAgICAgICAgICAgICBtYXBwZXIgPSBuZXcgbG9nX21hcHBlcl8xLkxvZ01hcHBlcihtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVyO1xuICAgIH07XG4gICAgQ29sb3JCYXIucHJvdG90eXBlLl90aWNrX2Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29vcmQsIGVuZCwgaSwgaWksIGltYWdlX2RpbWVuc2lvbnMsIGosIGssIGwsIG1ham9yX2Nvb3JkcywgbWFqb3JfbGFiZWxzLCBtYWpvcnMsIG1hcHBlciwgbWlub3JfY29vcmRzLCBtaW5vcnMsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc2NhbGVfbGVuZ3RoLCBzdGFydCwgdGlja3M7XG4gICAgICAgIGltYWdlX2RpbWVuc2lvbnMgPSB0aGlzLl9jb21wdXRlZF9pbWFnZV9kaW1lbnNpb25zKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgICAgICAgc2NhbGVfbGVuZ3RoID0gaW1hZ2VfZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgICAgIHNjYWxlX2xlbmd0aCA9IGltYWdlX2RpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgbWFwcGVyID0gdGhpcy5fdGlja19jb29yZGluYXRlX21hcHBlcihzY2FsZV9sZW5ndGgpO1xuICAgICAgICByZWYgPSB0aGlzLl9ub3JtYWxzKCksIGkgPSByZWZbMF0sIGogPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSBbdGhpcy5jb2xvcl9tYXBwZXIubG93LCB0aGlzLmNvbG9yX21hcHBlci5oaWdoXSwgc3RhcnQgPSByZWYxWzBdLCBlbmQgPSByZWYxWzFdO1xuICAgICAgICB0aWNrcyA9IHRoaXMudGlja2VyLmdldF90aWNrcyhzdGFydCwgZW5kLCBudWxsLCBudWxsLCB0aGlzLnRpY2tlci5kZXNpcmVkX251bV90aWNrcyk7XG4gICAgICAgIG1ham9ycyA9IHRpY2tzLm1ham9yO1xuICAgICAgICBtaW5vcnMgPSB0aWNrcy5taW5vcjtcbiAgICAgICAgbWFqb3JfY29vcmRzID0gW1tdLCBbXV07XG4gICAgICAgIG1pbm9yX2Nvb3JkcyA9IFtbXSwgW11dO1xuICAgICAgICBmb3IgKGlpID0gayA9IDAsIHJlZjIgPSBtYWpvcnMubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpaSA9IDAgPD0gcmVmMiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgaWYgKG1ham9yc1tpaV0gPCBzdGFydCB8fCBtYWpvcnNbaWldID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWpvcl9jb29yZHNbaV0ucHVzaChtYWpvcnNbaWldKTtcbiAgICAgICAgICAgIG1ham9yX2Nvb3Jkc1tqXS5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaWkgPSBsID0gMCwgcmVmMyA9IG1pbm9ycy5sZW5ndGg7IDAgPD0gcmVmMyA/IGwgPCByZWYzIDogbCA+IHJlZjM7IGlpID0gMCA8PSByZWYzID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICBpZiAobWlub3JzW2lpXSA8IHN0YXJ0IHx8IG1pbm9yc1tpaV0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pbm9yX2Nvb3Jkc1tpXS5wdXNoKG1pbm9yc1tpaV0pO1xuICAgICAgICAgICAgbWlub3JfY29vcmRzW2pdLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFqb3JfbGFiZWxzID0gbWFqb3JfY29vcmRzW2ldLnNsaWNlKDApO1xuICAgICAgICBtYWpvcl9jb29yZHNbaV0gPSBtYXBwZXIudl9tYXBfdG9fdGFyZ2V0KG1ham9yX2Nvb3Jkc1tpXSk7XG4gICAgICAgIG1pbm9yX2Nvb3Jkc1tpXSA9IG1hcHBlci52X21hcF90b190YXJnZXQobWlub3JfY29vcmRzW2ldKTtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIG1ham9yX2Nvb3Jkc1tpXSA9IG5ldyBGbG9hdDY0QXJyYXkoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuLCBtLCByZWY0LCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZjQgPSBtYWpvcl9jb29yZHNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobSA9IDAsIGxlbiA9IHJlZjQubGVuZ3RoOyBtIDwgbGVuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmQgPSByZWY0W21dO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2NhbGVfbGVuZ3RoIC0gY29vcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgbWlub3JfY29vcmRzW2ldID0gbmV3IEZsb2F0NjRBcnJheSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4sIG0sIHJlZjQsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmNCA9IG1pbm9yX2Nvb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChtID0gMCwgbGVuID0gcmVmNC5sZW5ndGg7IG0gPCBsZW47IG0rKykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZCA9IHJlZjRbbV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzY2FsZV9sZW5ndGggLSBjb29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogbWFqb3JfY29vcmRzLFxuICAgICAgICAgICAgXCJtaW5vclwiOiBtaW5vcl9jb29yZHMsXG4gICAgICAgICAgICBcIm1ham9yX2xhYmVsc1wiOiBtYWpvcl9sYWJlbHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xvckJhcjtcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG5leHBvcnRzLkFubm90YXRpb24gPSBhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbjtcbnZhciBhcnJvd18xID0gcmVxdWlyZShcIi4vYXJyb3dcIik7XG5leHBvcnRzLkFycm93ID0gYXJyb3dfMS5BcnJvdztcbnZhciBhcnJvd19oZWFkXzEgPSByZXF1aXJlKFwiLi9hcnJvd19oZWFkXCIpO1xuZXhwb3J0cy5BcnJvd0hlYWQgPSBhcnJvd19oZWFkXzEuQXJyb3dIZWFkO1xudmFyIGFycm93X2hlYWRfMiA9IHJlcXVpcmUoXCIuL2Fycm93X2hlYWRcIik7XG5leHBvcnRzLk9wZW5IZWFkID0gYXJyb3dfaGVhZF8yLk9wZW5IZWFkO1xudmFyIGFycm93X2hlYWRfMyA9IHJlcXVpcmUoXCIuL2Fycm93X2hlYWRcIik7XG5leHBvcnRzLk5vcm1hbEhlYWQgPSBhcnJvd19oZWFkXzMuTm9ybWFsSGVhZDtcbnZhciBhcnJvd19oZWFkXzQgPSByZXF1aXJlKFwiLi9hcnJvd19oZWFkXCIpO1xuZXhwb3J0cy5WZWVIZWFkID0gYXJyb3dfaGVhZF80LlZlZUhlYWQ7XG52YXIgYm94X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2JveF9hbm5vdGF0aW9uXCIpO1xuZXhwb3J0cy5Cb3hBbm5vdGF0aW9uID0gYm94X2Fubm90YXRpb25fMS5Cb3hBbm5vdGF0aW9uO1xudmFyIGNvbG9yX2Jhcl8xID0gcmVxdWlyZShcIi4vY29sb3JfYmFyXCIpO1xuZXhwb3J0cy5Db2xvckJhciA9IGNvbG9yX2Jhcl8xLkNvbG9yQmFyO1xudmFyIGxhYmVsXzEgPSByZXF1aXJlKFwiLi9sYWJlbFwiKTtcbmV4cG9ydHMuTGFiZWwgPSBsYWJlbF8xLkxhYmVsO1xudmFyIGxhYmVsX3NldF8xID0gcmVxdWlyZShcIi4vbGFiZWxfc2V0XCIpO1xuZXhwb3J0cy5MYWJlbFNldCA9IGxhYmVsX3NldF8xLkxhYmVsU2V0O1xudmFyIGxlZ2VuZF8xID0gcmVxdWlyZShcIi4vbGVnZW5kXCIpO1xuZXhwb3J0cy5MZWdlbmQgPSBsZWdlbmRfMS5MZWdlbmQ7XG52YXIgbGVnZW5kX2l0ZW1fMSA9IHJlcXVpcmUoXCIuL2xlZ2VuZF9pdGVtXCIpO1xuZXhwb3J0cy5MZWdlbmRJdGVtID0gbGVnZW5kX2l0ZW1fMS5MZWdlbmRJdGVtO1xudmFyIHBvbHlfYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vcG9seV9hbm5vdGF0aW9uXCIpO1xuZXhwb3J0cy5Qb2x5QW5ub3RhdGlvbiA9IHBvbHlfYW5ub3RhdGlvbl8xLlBvbHlBbm5vdGF0aW9uO1xudmFyIHNwYW5fMSA9IHJlcXVpcmUoXCIuL3NwYW5cIik7XG5leHBvcnRzLlNwYW4gPSBzcGFuXzEuU3BhbjtcbnZhciB0ZXh0X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL3RleHRfYW5ub3RhdGlvblwiKTtcbmV4cG9ydHMuVGV4dEFubm90YXRpb24gPSB0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvbjtcbnZhciB0aXRsZV8xID0gcmVxdWlyZShcIi4vdGl0bGVcIik7XG5leHBvcnRzLlRpdGxlID0gdGl0bGVfMS5UaXRsZTtcbnZhciB0b29sdGlwXzEgPSByZXF1aXJlKFwiLi90b29sdGlwXCIpO1xuZXhwb3J0cy5Ub29sdGlwID0gdG9vbHRpcF8xLlRvb2x0aXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgdGV4dF9hbm5vdGF0aW9uXzEgPSByZXF1aXJlKFwiLi90ZXh0X2Fubm90YXRpb25cIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkxhYmVsVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExhYmVsVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExhYmVsVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTGFiZWxWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy54bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueF9tYXBwZXJzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy55bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueV9tYXBwZXJzW3RoaXMubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFscy53YXJtX2NhY2hlKG51bGwpO1xuICAgIH07XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGhlaWdodCwgc2lkZSwgd2lkdGg7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjdHgubWVhc3VyZVRleHQodGhpcy5tb2RlbC50ZXh0KS5hc2NlbnQ7XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcgfHwgc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy5tb2RlbC50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmdsZSwgY3R4LCBwYW5lbF9vZmZzZXQsIHN4LCBzeSwgdngsIHZ5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSAmJiB0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmFuZ2xlX3VuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIFwicmFkXCI6XG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtMSAqIHRoaXMubW9kZWwuYW5nbGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVnXCI6XG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtMSAqIHRoaXMubW9kZWwuYW5nbGUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwueF91bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHZ4ID0gdGhpcy54bWFwcGVyLm1hcF90b190YXJnZXQodGhpcy5tb2RlbC54KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4ID0gdGhpcy5tb2RlbC54O1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdGhpcy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC55X3VuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdnkgPSB0aGlzLnltYXBwZXIubWFwX3RvX3RhcmdldCh0aGlzLm1vZGVsLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnkgPSB0aGlzLm1vZGVsLnk7XG4gICAgICAgIH1cbiAgICAgICAgc3kgPSB0aGlzLmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnBhbmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhbmVsX29mZnNldCA9IHRoaXMuX2dldF9wYW5lbF9vZmZzZXQoKTtcbiAgICAgICAgICAgIHN4ICs9IHBhbmVsX29mZnNldC54O1xuICAgICAgICAgICAgc3kgKz0gcGFuZWxfb2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4ICsgdGhpcy5tb2RlbC54X29mZnNldCwgc3kgLSB0aGlzLm1vZGVsLnlfb2Zmc2V0LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3NzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4ICsgdGhpcy5tb2RlbC54X29mZnNldCwgc3kgLSB0aGlzLm1vZGVsLnlfb2Zmc2V0LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYWJlbFZpZXc7XG59KSh0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5MYWJlbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiBMYWJlbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWwucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFiZWxWaWV3O1xuICAgIExhYmVsLnByb3RvdHlwZS50eXBlID0gJ0xhYmVsJztcbiAgICBMYWJlbC5taXhpbnMoWyd0ZXh0JywgJ2xpbmU6Ym9yZGVyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIExhYmVsLmRlZmluZSh7XG4gICAgICAgIHg6IFtwLk51bWJlcl0sXG4gICAgICAgIHhfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgeTogW3AuTnVtYmVyXSxcbiAgICAgICAgeV91bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICB0ZXh0OiBbcC5TdHJpbmddLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGUsIDBdLFxuICAgICAgICBhbmdsZV91bml0czogW3AuQW5nbGVVbml0cywgJ3JhZCddLFxuICAgICAgICB4X29mZnNldDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgeV9vZmZzZXQ6IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgcmVuZGVyX21vZGU6IFtwLlJlbmRlck1vZGUsICdjYW52YXMnXVxuICAgIH0pO1xuICAgIExhYmVsLm92ZXJyaWRlKHtcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBudWxsLFxuICAgICAgICBib3JkZXJfbGluZV9jb2xvcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBMYWJlbDtcbn0pKHRleHRfYW5ub3RhdGlvbl8xLlRleHRBbm5vdGF0aW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0ZXh0X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL3RleHRfYW5ub3RhdGlvblwiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuTGFiZWxTZXRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhYmVsU2V0Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWxTZXRWaWV3KCkge1xuICAgICAgICByZXR1cm4gTGFiZWxTZXRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICBMYWJlbFNldFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy54bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueF9tYXBwZXJzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy55bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueV9tYXBwZXJzW3RoaXMubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3RleHQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlX2RpdiA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLWFubm90YXRpb24tY2hpbGQnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMudGl0bGVfZGl2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxTZXRWaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuc291cmNlLCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGF0YSh0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuc291cmNlLCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RhdGEodGhpcy5tb2RlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIExhYmVsU2V0Vmlldy5fX3N1cGVyX18uc2V0X2RhdGEuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXN1YWxzLndhcm1fY2FjaGUoc291cmNlKTtcbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3gsIHN5LCB2eCwgdnk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnhfdW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB2eCA9IHRoaXMueG1hcHBlci52X21hcF90b190YXJnZXQodGhpcy5feCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2eCA9IHRoaXMuX3guc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0aGlzLmNhbnZhcy52X3Z4X3RvX3N4KHZ4KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwueV91bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHZ5ID0gdGhpcy55bWFwcGVyLnZfbWFwX3RvX3RhcmdldCh0aGlzLl95KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ5ID0gdGhpcy5feS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBzeSA9IHRoaXMuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgaSwgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCByZXN1bHRzMSwgc3gsIHN5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSAmJiB0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgcmVmID0gdGhpcy5fbWFwX2RhdGEoKSwgc3ggPSByZWZbMF0sIHN5ID0gcmVmWzFdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYxID0gdGhpcy5fdGV4dC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fdl9jYW52YXNfdGV4dChjdHgsIGksIHRoaXMuX3RleHRbaV0sIHN4W2ldICsgdGhpcy5feF9vZmZzZXRbaV0sIHN5W2ldIC0gdGhpcy5feV9vZmZzZXRbaV0sIHRoaXMuX2FuZ2xlW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IHRoaXMuX3RleHQubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaCh0aGlzLl92X2Nzc190ZXh0KGN0eCwgaSwgdGhpcy5fdGV4dFtpXSwgc3hbaV0gKyB0aGlzLl94X29mZnNldFtpXSwgc3lbaV0gLSB0aGlzLl95X29mZnNldFtpXSwgdGhpcy5fYW5nbGVbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxTZXRWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHgsIGhlaWdodCwgc2lkZSwgd2lkdGg7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLnRleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsLnNpZGU7XG4gICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjdHgubWVhc3VyZVRleHQodGhpcy5fdGV4dFswXSkuYXNjZW50O1xuICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnIHx8IHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3RleHRbMF0pLndpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYWJlbFNldFZpZXcucHJvdG90eXBlLl92X2NhbnZhc190ZXh0ID0gZnVuY3Rpb24gKGN0eCwgaSwgdGV4dCwgc3gsIHN5LCBhbmdsZSkge1xuICAgICAgICB2YXIgYmJveF9kaW1zO1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGN0eC5yZWN0KGJib3hfZGltc1swXSwgYmJveF9kaW1zWzFdLCBiYm94X2RpbXNbMl0sIGJib3hfZGltc1szXSk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy50ZXh0LmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy50ZXh0LnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIExhYmVsU2V0Vmlldy5wcm90b3R5cGUuX3ZfY3NzX3RleHQgPSBmdW5jdGlvbiAoY3R4LCBpLCB0ZXh0LCBzeCwgc3ksIGFuZ2xlKSB7XG4gICAgICAgIHZhciBiYm94X2RpbXMsIGVsLCBsZCwgbGluZV9kYXNoO1xuICAgICAgICBlbCA9IHRoaXMuZWwuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGJib3hfZGltcyA9IHRoaXMuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyhjdHgsIHRleHQpO1xuICAgICAgICBsZCA9IHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5saW5lX2Rhc2gudmFsdWUoKTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShsZCkpIHtcbiAgICAgICAgICAgIGxpbmVfZGFzaCA9IGxkLmxlbmd0aCA8IDIgPyBcInNvbGlkXCIgOiBcImRhc2hlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKGxkKSkge1xuICAgICAgICAgICAgbGluZV9kYXNoID0gbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IChzeCArIGJib3hfZGltc1swXSkgKyBcInB4XCI7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IChzeSArIGJib3hfZGltc1sxXSkgKyBcInB4XCI7XG4gICAgICAgIGVsLnN0eWxlLmNvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2NvbG9yLnZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2FscGhhLnZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5mb250ID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC5mb250X3ZhbHVlKCkpO1xuICAgICAgICBlbC5zdHlsZS5saW5lSGVpZ2h0ID0gXCJub3JtYWxcIjtcbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGFuZ2xlICsgXCJyYWQpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmNvbG9yX3ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuYm9yZGVyU3R5bGUgPSBcIlwiICsgbGluZV9kYXNoO1xuICAgICAgICAgICAgZWwuc3R5bGUuYm9yZGVyV2lkdGggPSAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmxpbmVfd2lkdGgudmFsdWUoKSkgKyBcInB4XCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5ib3JkZXJDb2xvciA9IFwiXCIgKyAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmNvbG9yX3ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21fMS5zaG93KGVsKTtcbiAgICB9O1xuICAgIHJldHVybiBMYWJlbFNldFZpZXc7XG59KSh0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5MYWJlbFNldCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMYWJlbFNldCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFiZWxTZXQoKSB7XG4gICAgICAgIHJldHVybiBMYWJlbFNldC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFiZWxTZXQucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFiZWxTZXRWaWV3O1xuICAgIExhYmVsU2V0LnByb3RvdHlwZS50eXBlID0gJ0xhYmVsJztcbiAgICBMYWJlbFNldC5taXhpbnMoWyd0ZXh0JywgJ2xpbmU6Ym9yZGVyXycsICdmaWxsOmJhY2tncm91bmRfJ10pO1xuICAgIExhYmVsU2V0LmRlZmluZSh7XG4gICAgICAgIHg6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICB5OiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgeF91bml0czogW3AuU3BhdGlhbFVuaXRzLCAnZGF0YSddLFxuICAgICAgICB5X3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ10sXG4gICAgICAgIHRleHQ6IFtcbiAgICAgICAgICAgIHAuU3RyaW5nU3BlYywge1xuICAgICAgICAgICAgICAgIGZpZWxkOiBcInRleHRcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGVTcGVjLCAwXSxcbiAgICAgICAgeF9vZmZzZXQ6IFtcbiAgICAgICAgICAgIHAuTnVtYmVyU3BlYywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHlfb2Zmc2V0OiBbXG4gICAgICAgICAgICBwLk51bWJlclNwZWMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgIHAuSW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvbHVtbl9kYXRhX3NvdXJjZV8xLkNvbHVtbkRhdGFTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICByZW5kZXJfbW9kZTogW3AuUmVuZGVyTW9kZSwgJ2NhbnZhcyddXG4gICAgfSk7XG4gICAgTGFiZWxTZXQub3ZlcnJpZGUoe1xuICAgICAgICBiYWNrZ3JvdW5kX2ZpbGxfY29sb3I6IG51bGwsXG4gICAgICAgIGJvcmRlcl9saW5lX2NvbG9yOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIExhYmVsU2V0O1xufSkodGV4dF9hbm5vdGF0aW9uXzEuVGV4dEFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGV4dF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC90ZXh0XCIpO1xudmFyIGJib3hfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYmJveFwiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5MZWdlbmRWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExlZ2VuZFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExlZ2VuZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBMZWdlbmRWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIExlZ2VuZFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnZpc2libGUnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5jb21wdXRlX2xlZ2VuZF9iYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4LCBnbHlwaF9oZWlnaHQsIGdseXBoX3dpZHRoLCBoX3JhbmdlLCBpLCBsYWJlbF9oZWlnaHQsIGxhYmVsX3N0YW5kb2ZmLCBsYWJlbF93aWR0aCwgbGVnZW5kX2hlaWdodCwgbGVnZW5kX21hcmdpbiwgbGVnZW5kX25hbWVzLCBsZWdlbmRfcGFkZGluZywgbGVnZW5kX3NwYWNpbmcsIGxlZ2VuZF93aWR0aCwgbGVuLCBsb2NhdGlvbiwgbWF4X2xhYmVsX3dpZHRoLCBuYW1lLCBwYW5lbCwgcmVmLCByZWYxLCB2X3JhbmdlLCB3aWR0aCwgeCwgeTtcbiAgICAgICAgbGVnZW5kX25hbWVzID0gdGhpcy5tb2RlbC5nZXRfbGVnZW5kX25hbWVzKCk7XG4gICAgICAgIGdseXBoX2hlaWdodCA9IHRoaXMubW9kZWwuZ2x5cGhfaGVpZ2h0O1xuICAgICAgICBnbHlwaF93aWR0aCA9IHRoaXMubW9kZWwuZ2x5cGhfd2lkdGg7XG4gICAgICAgIGxhYmVsX2hlaWdodCA9IHRoaXMubW9kZWwubGFiZWxfaGVpZ2h0O1xuICAgICAgICBsYWJlbF93aWR0aCA9IHRoaXMubW9kZWwubGFiZWxfd2lkdGg7XG4gICAgICAgIHRoaXMubWF4X2xhYmVsX2hlaWdodCA9IGFycmF5XzEubWF4KFt0ZXh0XzEuZ2V0X3RleHRfaGVpZ2h0KHRoaXMudmlzdWFscy5sYWJlbF90ZXh0LmZvbnRfdmFsdWUoKSkuaGVpZ2h0LCBsYWJlbF9oZWlnaHQsIGdseXBoX2hlaWdodF0pO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMudmlzdWFscy5sYWJlbF90ZXh0LnNldF92YWx1ZShjdHgpO1xuICAgICAgICB0aGlzLnRleHRfd2lkdGhzID0ge307XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGxlZ2VuZF9uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGxlZ2VuZF9uYW1lc1tpXTtcbiAgICAgICAgICAgIHRoaXMudGV4dF93aWR0aHNbbmFtZV0gPSBhcnJheV8xLm1heChbY3R4Lm1lYXN1cmVUZXh0KG5hbWUpLndpZHRoLCBsYWJlbF93aWR0aF0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIG1heF9sYWJlbF93aWR0aCA9IGFycmF5XzEubWF4KG9iamVjdF8xLnZhbHVlcyh0aGlzLnRleHRfd2lkdGhzKSk7XG4gICAgICAgIGxlZ2VuZF9tYXJnaW4gPSB0aGlzLm1vZGVsLm1hcmdpbjtcbiAgICAgICAgbGVnZW5kX3BhZGRpbmcgPSB0aGlzLm1vZGVsLnBhZGRpbmc7XG4gICAgICAgIGxlZ2VuZF9zcGFjaW5nID0gdGhpcy5tb2RlbC5zcGFjaW5nO1xuICAgICAgICBsYWJlbF9zdGFuZG9mZiA9IHRoaXMubW9kZWwubGFiZWxfc3RhbmRvZmY7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICAgIGxlZ2VuZF9oZWlnaHQgPSBsZWdlbmRfbmFtZXMubGVuZ3RoICogdGhpcy5tYXhfbGFiZWxfaGVpZ2h0ICsgKGxlZ2VuZF9uYW1lcy5sZW5ndGggLSAxKSAqIGxlZ2VuZF9zcGFjaW5nICsgMiAqIGxlZ2VuZF9wYWRkaW5nO1xuICAgICAgICAgICAgbGVnZW5kX3dpZHRoID0gbWF4X2xhYmVsX3dpZHRoICsgZ2x5cGhfd2lkdGggKyBsYWJlbF9zdGFuZG9mZiArIDIgKiBsZWdlbmRfcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZF93aWR0aCA9IDIgKiBsZWdlbmRfcGFkZGluZyArIChsZWdlbmRfbmFtZXMubGVuZ3RoIC0gMSkgKiBsZWdlbmRfc3BhY2luZztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMudGV4dF93aWR0aHM7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSByZWZbbmFtZV07XG4gICAgICAgICAgICAgICAgbGVnZW5kX3dpZHRoICs9IGFycmF5XzEubWF4KFt3aWR0aCwgbGFiZWxfd2lkdGhdKSArIGdseXBoX3dpZHRoICsgbGFiZWxfc3RhbmRvZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWdlbmRfaGVpZ2h0ID0gdGhpcy5tYXhfbGFiZWxfaGVpZ2h0ICsgMiAqIGxlZ2VuZF9wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHBhbmVsID0gKHJlZjEgPSB0aGlzLm1vZGVsLnBhbmVsKSAhPSBudWxsID8gcmVmMSA6IHRoaXMucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICBoX3JhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBhbmVsLmxlZnQsXG4gICAgICAgICAgICBlbmQ6IHBhbmVsLnJpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHZfcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogcGFuZWwuYm90dG9tLFxuICAgICAgICAgICAgZW5kOiBwYW5lbC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm1vZGVsLmxvY2F0aW9uO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2UuZW5kIC0gbGVnZW5kX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wX2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0b3BfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdl9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5lbmQgLSBsZWdlbmRfbWFyZ2luIC0gbGVnZW5kX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9yaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHggPSBoX3JhbmdlLmVuZCAtIGxlZ2VuZF9tYXJnaW4gLSBsZWdlbmRfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9jZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB4ID0gKGhfcmFuZ2UuZW5kICsgaF9yYW5nZS5zdGFydCkgLyAyIC0gbGVnZW5kX3dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHZfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luICsgbGVnZW5kX2hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tX2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB4ID0gaF9yYW5nZS5zdGFydCArIGxlZ2VuZF9tYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHkgPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX21hcmdpbiArIGxlZ2VuZF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IGhfcmFuZ2Uuc3RhcnQgKyBsZWdlbmRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHggPSAoaF9yYW5nZS5lbmQgKyBoX3JhbmdlLnN0YXJ0KSAvIDIgLSBsZWdlbmRfd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHZfcmFuZ2UuZW5kICsgdl9yYW5nZS5zdGFydCkgLyAyICsgbGVnZW5kX2hlaWdodCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZXNfMS5pc0FycmF5KGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHggPSBsb2NhdGlvblswXSwgeSA9IGxvY2F0aW9uWzFdO1xuICAgICAgICAgICAgeCArPSBoX3JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgeSArPSB2X3JhbmdlLnN0YXJ0ICsgbGVnZW5kX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KHgpO1xuICAgICAgICB5ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogbGVnZW5kX3dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBsZWdlbmRfaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCByZWYsIHdpZHRoLCB4LCB5O1xuICAgICAgICByZWYgPSB0aGlzLmNvbXB1dGVfbGVnZW5kX2Jib3goKSwgeCA9IHJlZi54LCB5ID0gcmVmLnksIHdpZHRoID0gcmVmLndpZHRoLCBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gbmV3IGJib3hfMS5CQm94KHtcbiAgICAgICAgICAgIHgwOiB4LFxuICAgICAgICAgICAgeTA6IHksXG4gICAgICAgICAgICB4MTogeCArIHdpZHRoLFxuICAgICAgICAgICAgeTE6IHkgKyBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5vbl9oaXQgPSBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgIHZhciBiYm94LCBmaWVsZCwgZ2x5cGhfaGVpZ2h0LCBnbHlwaF93aWR0aCwgaCwgaSwgaXRlbSwgaiwgaywgbCwgbGFiZWwsIGxhYmVsX3N0YW5kb2ZmLCBsYWJlbHMsIGxlZ2VuZF9iYm94LCBsZWdlbmRfc3BhY2luZywgbGVuLCBsZW4xLCBsZW4yLCBsZW4zLCByLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHZlcnRpY2FsLCB3LCB4MSwgeDIsIHhvZmZzZXQsIHkxLCB5MiwgeW9mZnNldDtcbiAgICAgICAgZ2x5cGhfaGVpZ2h0ID0gdGhpcy5tb2RlbC5nbHlwaF9oZWlnaHQ7XG4gICAgICAgIGdseXBoX3dpZHRoID0gdGhpcy5tb2RlbC5nbHlwaF93aWR0aDtcbiAgICAgICAgbGVnZW5kX3NwYWNpbmcgPSB0aGlzLm1vZGVsLnNwYWNpbmc7XG4gICAgICAgIGxhYmVsX3N0YW5kb2ZmID0gdGhpcy5tb2RlbC5sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgeG9mZnNldCA9IHlvZmZzZXQgPSB0aGlzLm1vZGVsLnBhZGRpbmc7XG4gICAgICAgIGxlZ2VuZF9iYm94ID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9iYm94KCk7XG4gICAgICAgIHZlcnRpY2FsID0gdGhpcy5tb2RlbC5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLml0ZW1zO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWZbaV07XG4gICAgICAgICAgICBsYWJlbHMgPSBpdGVtLmdldF9sYWJlbHNfbGlzdF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgICAgIGZpZWxkID0gaXRlbS5nZXRfZmllbGRfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gbGFiZWxzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxzW2pdO1xuICAgICAgICAgICAgICAgIHgxID0gbGVnZW5kX2Jib3gueCArIHhvZmZzZXQ7XG4gICAgICAgICAgICAgICAgeTEgPSBsZWdlbmRfYmJveC55ICsgeW9mZnNldDtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICsgZ2x5cGhfd2lkdGg7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSArIGdseXBoX2hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmMSA9IFtsZWdlbmRfYmJveC53aWR0aCAtIDIgKiB0aGlzLm1vZGVsLnBhZGRpbmcsIHRoaXMubWF4X2xhYmVsX2hlaWdodF0sIHcgPSByZWYxWzBdLCBoID0gcmVmMVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjIgPSBbdGhpcy50ZXh0X3dpZHRoc1tsYWJlbF0gKyBnbHlwaF93aWR0aCArIGxhYmVsX3N0YW5kb2ZmLCB0aGlzLm1heF9sYWJlbF9oZWlnaHRdLCB3ID0gcmVmMlswXSwgaCA9IHJlZjJbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJib3ggPSBuZXcgYmJveF8xLkJCb3goe1xuICAgICAgICAgICAgICAgICAgICB4MDogeDEsXG4gICAgICAgICAgICAgICAgICAgIHkwOiB5MSxcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxICsgdyxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHkxICsgaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChiYm94LmNvbnRhaW5zKHN4LCBzeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmNsaWNrX3BvbGljeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhpZGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYzID0gaXRlbS5yZW5kZXJlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjMubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByZWYzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnZpc2libGUgPSAhci52aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmNCA9IGl0ZW0ucmVuZGVyZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjMgPSByZWY0Lmxlbmd0aDsgbCA8IGxlbjM7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcmVmNFtsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5tdXRlZCA9ICFyLm11dGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgKz0gdGhpcy5tYXhfbGFiZWxfaGVpZ2h0ICsgbGVnZW5kX3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4b2Zmc2V0ICs9IHRoaXMudGV4dF93aWR0aHNbbGFiZWxdICsgZ2x5cGhfd2lkdGggKyBsYWJlbF9zdGFuZG9mZiArIGxlZ2VuZF9zcGFjaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94LCBjdHg7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBiYm94ID0gdGhpcy5jb21wdXRlX2xlZ2VuZF9iYm94KCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuX2RyYXdfbGVnZW5kX2JveChjdHgsIGJib3gpO1xuICAgICAgICB0aGlzLl9kcmF3X2xlZ2VuZF9pdGVtcyhjdHgsIGJib3gpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIExlZ2VuZFZpZXcucHJvdG90eXBlLl9kcmF3X2xlZ2VuZF9ib3ggPSBmdW5jdGlvbiAoY3R4LCBiYm94KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgdGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZWdlbmRWaWV3LnByb3RvdHlwZS5fZHJhd19sZWdlbmRfaXRlbXMgPSBmdW5jdGlvbiAoY3R4LCBiYm94KSB7XG4gICAgICAgIHZhciBhY3RpdmUsIGZpZWxkLCBnbHlwaF9oZWlnaHQsIGdseXBoX3dpZHRoLCBoLCBpLCBpdGVtLCBqLCBrLCBsYWJlbCwgbGFiZWxfc3RhbmRvZmYsIGxhYmVscywgbGVnZW5kX3NwYWNpbmcsIGxlbiwgbGVuMSwgbGVuMiwgciwgcmVmLCByZWYxLCByZWYyLCByZWYzLCB2ZXJ0aWNhbCwgdmlldywgdywgeDEsIHgyLCB4b2Zmc2V0LCB5MSwgeTIsIHlvZmZzZXQ7XG4gICAgICAgIGdseXBoX2hlaWdodCA9IHRoaXMubW9kZWwuZ2x5cGhfaGVpZ2h0O1xuICAgICAgICBnbHlwaF93aWR0aCA9IHRoaXMubW9kZWwuZ2x5cGhfd2lkdGg7XG4gICAgICAgIGxlZ2VuZF9zcGFjaW5nID0gdGhpcy5tb2RlbC5zcGFjaW5nO1xuICAgICAgICBsYWJlbF9zdGFuZG9mZiA9IHRoaXMubW9kZWwubGFiZWxfc3RhbmRvZmY7XG4gICAgICAgIHhvZmZzZXQgPSB5b2Zmc2V0ID0gdGhpcy5tb2RlbC5wYWRkaW5nO1xuICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMubW9kZWwub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIjtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5pdGVtcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVmW2ldO1xuICAgICAgICAgICAgbGFiZWxzID0gaXRlbS5nZXRfbGFiZWxzX2xpc3RfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgICAgICBmaWVsZCA9IGl0ZW0uZ2V0X2ZpZWxkX2Zyb21fbGFiZWxfcHJvcCgpO1xuICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmNsaWNrX3BvbGljeSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfMS5hbGwoaXRlbS5yZW5kZXJlcnMsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIudmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibXV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5XzEuYWxsKGl0ZW0ucmVuZGVyZXJzLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhci5tdXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gbGFiZWxzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxzW2pdO1xuICAgICAgICAgICAgICAgIHgxID0gYmJveC54ICsgeG9mZnNldDtcbiAgICAgICAgICAgICAgICB5MSA9IGJib3gueSArIHlvZmZzZXQ7XG4gICAgICAgICAgICAgICAgeDIgPSB4MSArIGdseXBoX3dpZHRoO1xuICAgICAgICAgICAgICAgIHkyID0geTEgKyBnbHlwaF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgKz0gdGhpcy5tYXhfbGFiZWxfaGVpZ2h0ICsgbGVnZW5kX3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4b2Zmc2V0ICs9IHRoaXMudGV4dF93aWR0aHNbbGFiZWxdICsgZ2x5cGhfd2lkdGggKyBsYWJlbF9zdGFuZG9mZiArIGxlZ2VuZF9zcGFjaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIHgyICsgbGFiZWxfc3RhbmRvZmYsIHkxICsgdGhpcy5tYXhfbGFiZWxfaGVpZ2h0IC8gMi4wKTtcbiAgICAgICAgICAgICAgICByZWYxID0gaXRlbS5yZW5kZXJlcnM7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjEubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZWYxW2tdO1xuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5wbG90X3ZpZXcucmVuZGVyZXJfdmlld3Nbci5pZF07XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZHJhd19sZWdlbmQoY3R4LCB4MSwgeDIsIHkxLCB5MiwgZmllbGQsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYyID0gW2Jib3gud2lkdGggLSAyICogdGhpcy5tb2RlbC5wYWRkaW5nLCB0aGlzLm1heF9sYWJlbF9oZWlnaHRdLCB3ID0gcmVmMlswXSwgaCA9IHJlZjJbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYzID0gW3RoaXMudGV4dF93aWR0aHNbbGFiZWxdICsgZ2x5cGhfd2lkdGggKyBsYWJlbF9zdGFuZG9mZiwgdGhpcy5tYXhfbGFiZWxfaGVpZ2h0XSwgdyA9IHJlZjNbMF0sIGggPSByZWYzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeDEsIHkxLCB3LCBoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmluYWN0aXZlX2ZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGVnZW5kVmlldy5wcm90b3R5cGUuX2dldF9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveCwgc2lkZTtcbiAgICAgICAgYmJveCA9IHRoaXMuY29tcHV0ZV9sZWdlbmRfYmJveCgpO1xuICAgICAgICBzaWRlID0gdGhpcy5tb2RlbC5wYW5lbC5zaWRlO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ2Fib3ZlJyB8fCBzaWRlID09PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4gYmJveC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0JyB8fCBzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYmJveC53aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExlZ2VuZFZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5MZWdlbmQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGVnZW5kLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMZWdlbmQoKSB7XG4gICAgICAgIHJldHVybiBMZWdlbmQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExlZ2VuZC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5MZWdlbmRWaWV3O1xuICAgIExlZ2VuZC5wcm90b3R5cGUudHlwZSA9ICdMZWdlbmQnO1xuICAgIExlZ2VuZC5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja19wb2xpY3kgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInBvaW50ZXJcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGVnZW5kLnByb3RvdHlwZS5nZXRfbGVnZW5kX25hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaXRlbSwgbGFiZWxzLCBsZWdlbmRfbmFtZXMsIGxlbiwgcmVmO1xuICAgICAgICBsZWdlbmRfbmFtZXMgPSBbXTtcbiAgICAgICAgcmVmID0gdGhpcy5pdGVtcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVmW2ldO1xuICAgICAgICAgICAgbGFiZWxzID0gaXRlbS5nZXRfbGFiZWxzX2xpc3RfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgICAgICBsZWdlbmRfbmFtZXMgPSBsZWdlbmRfbmFtZXMuY29uY2F0KGxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZ2VuZF9uYW1lcztcbiAgICB9O1xuICAgIExlZ2VuZC5taXhpbnMoWyd0ZXh0OmxhYmVsXycsICdmaWxsOmluYWN0aXZlXycsICdsaW5lOmJvcmRlcl8nLCAnZmlsbDpiYWNrZ3JvdW5kXyddKTtcbiAgICBMZWdlbmQuZGVmaW5lKHtcbiAgICAgICAgb3JpZW50YXRpb246IFtwLk9yaWVudGF0aW9uLCAndmVydGljYWwnXSxcbiAgICAgICAgbG9jYXRpb246IFtwLkFueSwgJ3RvcF9yaWdodCddLFxuICAgICAgICBsYWJlbF9zdGFuZG9mZjogW3AuTnVtYmVyLCA1XSxcbiAgICAgICAgZ2x5cGhfaGVpZ2h0OiBbcC5OdW1iZXIsIDIwXSxcbiAgICAgICAgZ2x5cGhfd2lkdGg6IFtwLk51bWJlciwgMjBdLFxuICAgICAgICBsYWJlbF9oZWlnaHQ6IFtwLk51bWJlciwgMjBdLFxuICAgICAgICBsYWJlbF93aWR0aDogW3AuTnVtYmVyLCAyMF0sXG4gICAgICAgIG1hcmdpbjogW3AuTnVtYmVyLCAxMF0sXG4gICAgICAgIHBhZGRpbmc6IFtwLk51bWJlciwgMTBdLFxuICAgICAgICBzcGFjaW5nOiBbcC5OdW1iZXIsIDNdLFxuICAgICAgICBpdGVtczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgY2xpY2tfcG9saWN5OiBbcC5BbnksIFwibm9uZVwiXVxuICAgIH0pO1xuICAgIExlZ2VuZC5vdmVycmlkZSh7XG4gICAgICAgIGJvcmRlcl9saW5lX2NvbG9yOiBcIiNlNWU1ZTVcIixcbiAgICAgICAgYm9yZGVyX2xpbmVfYWxwaGE6IDAuNSxcbiAgICAgICAgYm9yZGVyX2xpbmVfd2lkdGg6IDEsXG4gICAgICAgIGJhY2tncm91bmRfZmlsbF9jb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGJhY2tncm91bmRfZmlsbF9hbHBoYTogMC45NSxcbiAgICAgICAgaW5hY3RpdmVfZmlsbF9jb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBpbmFjdGl2ZV9maWxsX2FscGhhOiAwLjksXG4gICAgICAgIGxhYmVsX3RleHRfZm9udF9zaXplOiBcIjEwcHRcIixcbiAgICAgICAgbGFiZWxfdGV4dF9iYXNlbGluZTogXCJtaWRkbGVcIlxuICAgIH0pO1xuICAgIHJldHVybiBMZWdlbmQ7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxzL3NvdXJjZXMvY29sdW1uX2RhdGFfc291cmNlXCIpO1xuZXhwb3J0cy5MZWdlbmRJdGVtID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExlZ2VuZEl0ZW0sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExlZ2VuZEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuZ2V0X2xhYmVsc19saXN0X2Zyb21fbGFiZWxfcHJvcCA9IGJpbmQodGhpcy5nZXRfbGFiZWxzX2xpc3RfZnJvbV9sYWJlbF9wcm9wLCB0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRfZmllbGRfZnJvbV9sYWJlbF9wcm9wID0gYmluZCh0aGlzLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AsIHRoaXMpO1xuICAgICAgICByZXR1cm4gTGVnZW5kSXRlbS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGVnZW5kSXRlbS5wcm90b3R5cGUudHlwZSA9IFwiTGVnZW5kSXRlbVwiO1xuICAgIExlZ2VuZEl0ZW0ucHJvdG90eXBlLl9jaGVja19kYXRhX3NvdXJjZXNfb25fcmVuZGVyZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmllbGQsIGksIGxlbiwgciwgcmVmLCBzb3VyY2U7XG4gICAgICAgIGZpZWxkID0gdGhpcy5nZXRfZmllbGRfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgIGlmIChmaWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucmVuZGVyZXJzWzBdLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5yZW5kZXJlcnM7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmRhdGFfc291cmNlICE9PSBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExlZ2VuZEl0ZW0ucHJvdG90eXBlLl9jaGVja19maWVsZF9sYWJlbF9vbl9kYXRhX3NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpZWxkLCBzb3VyY2U7XG4gICAgICAgIGZpZWxkID0gdGhpcy5nZXRfZmllbGRfZnJvbV9sYWJlbF9wcm9wKCk7XG4gICAgICAgIGlmIChmaWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucmVuZGVyZXJzWzBdLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgIT0gbnVsbCkgJiYgaW5kZXhPZi5jYWxsKHNvdXJjZS5jb2x1bW5zKCksIGZpZWxkKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBMZWdlbmRJdGVtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkYXRhX3NvdXJjZV92YWxpZGF0aW9uLCBmaWVsZF92YWxpZGF0aW9uO1xuICAgICAgICBMZWdlbmRJdGVtLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICBkYXRhX3NvdXJjZV92YWxpZGF0aW9uID0gdGhpcy5fY2hlY2tfZGF0YV9zb3VyY2VzX29uX3JlbmRlcmVycygpO1xuICAgICAgICBpZiAoIWRhdGFfc291cmNlX3ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJOb24gbWF0Y2hpbmcgZGF0YSBzb3VyY2VzIG9uIGxlZ2VuZCBpdGVtIHJlbmRlcmVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZF92YWxpZGF0aW9uID0gdGhpcy5fY2hlY2tfZmllbGRfbGFiZWxfb25fZGF0YV9zb3VyY2UoKTtcbiAgICAgICAgaWYgKCFmaWVsZF92YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5lcnJvcihcIkJhZCBjb2x1bW4gbmFtZSBvbiBsYWJlbDogXCIgKyB0aGlzLmxhYmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGVnZW5kSXRlbS5kZWZpbmUoe1xuICAgICAgICBsYWJlbDogW3AuU3RyaW5nU3BlYywgbnVsbF0sXG4gICAgICAgIHJlbmRlcmVyczogW3AuQXJyYXksIFtdXVxuICAgIH0pO1xuICAgIExlZ2VuZEl0ZW0ucHJvdG90eXBlLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgodGhpcy5sYWJlbCAhPSBudWxsKSAmJiAodGhpcy5sYWJlbC5maWVsZCAhPSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwuZmllbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExlZ2VuZEl0ZW0ucHJvdG90eXBlLmdldF9sYWJlbHNfbGlzdF9mcm9tX2xhYmVsX3Byb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhLCBmaWVsZCwgc291cmNlO1xuICAgICAgICBpZiAoKHRoaXMubGFiZWwgIT0gbnVsbCkgJiYgKHRoaXMubGFiZWwudmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5sYWJlbC52YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZmllbGQgPSB0aGlzLmdldF9maWVsZF9mcm9tX2xhYmVsX3Byb3AoKTtcbiAgICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1swXSAmJiAodGhpcy5yZW5kZXJlcnNbMF0uZGF0YV9zb3VyY2UgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnJlbmRlcmVyc1swXS5kYXRhX3NvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJObyBzb3VyY2UgZm91bmRcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgY29sdW1uX2RhdGFfc291cmNlXzEuQ29sdW1uRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBzb3VyY2UuZ2V0X2NvbHVtbihmaWVsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfMS51bmlxKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkludmFsaWQgZmllbGRcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIHJldHVybiBMZWdlbmRJdGVtO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUG9seUFubm90YXRpb25WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBvbHlBbm5vdGF0aW9uVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUG9seUFubm90YXRpb25WaWV3KCkge1xuICAgICAgICByZXR1cm4gUG9seUFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQb2x5QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdkYXRhX3VwZGF0ZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICB9O1xuICAgIFBvbHlBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgY2FudmFzLCBpLCBqLCByZWYsIHN4LCBzeSwgdngsIHZ5LCB4cywgeXM7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeHMgPSB0aGlzLm1vZGVsLnhzO1xuICAgICAgICB5cyA9IHRoaXMubW9kZWwueXM7XG4gICAgICAgIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhzLmxlbmd0aCA8IDMgfHwgeXMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4cy5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwueHNfdW5pdHMgPT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgdnggPSB4c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnlzX3VuaXRzID09PSAnc2NyZWVuJykge1xuICAgICAgICAgICAgICAgIHZ5ID0geXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeCA9IGNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgICAgICBzeSA9IGNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN4LCBzeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4LCBzeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQb2x5QW5ub3RhdGlvblZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5Qb2x5QW5ub3RhdGlvbiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQb2x5QW5ub3RhdGlvbiwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUG9seUFubm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBQb2x5QW5ub3RhdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUG9seUFubm90YXRpb24ucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUG9seUFubm90YXRpb25WaWV3O1xuICAgIFBvbHlBbm5vdGF0aW9uLnByb3RvdHlwZS50eXBlID0gXCJQb2x5QW5ub3RhdGlvblwiO1xuICAgIFBvbHlBbm5vdGF0aW9uLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBQb2x5QW5ub3RhdGlvbi5kZWZpbmUoe1xuICAgICAgICB4czogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgeHNfdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgeXM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIHlzX3VuaXRzOiBbcC5TcGF0aWFsVW5pdHMsICdkYXRhJ10sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXVxuICAgIH0pO1xuICAgIFBvbHlBbm5vdGF0aW9uLm92ZXJyaWRlKHtcbiAgICAgICAgZmlsbF9jb2xvcjogXCIjZmZmOWJhXCIsXG4gICAgICAgIGZpbGxfYWxwaGE6IDAuNCxcbiAgICAgICAgbGluZV9jb2xvcjogXCIjY2NjY2NjXCIsXG4gICAgICAgIGxpbmVfYWxwaGE6IDAuM1xuICAgIH0pO1xuICAgIFBvbHlBbm5vdGF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciB4cywgeXM7XG4gICAgICAgIHhzID0gYXJnLnhzLCB5cyA9IGFyZy55cztcbiAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgIHhzOiB4cyxcbiAgICAgICAgICAgIHlzOiB5c1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2RhdGFfdXBkYXRlJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9seUFubm90YXRpb247XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuU3BhblZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3BhblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNwYW5WaWV3KCkge1xuICAgICAgICByZXR1cm4gU3BhblZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNwYW5WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgU3BhblZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuY2FudmFzX292ZXJsYXlzLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICByZXR1cm4gZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICB9O1xuICAgIFNwYW5WaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZm9yX2hvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmNvbXB1dGVkX2xvY2F0aW9uJywgdGhpcy5fZHJhd19zcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY2FudmFzJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmxvY2F0aW9uJywgdGhpcy5wbG90X3ZpZXcucmVxdWVzdF9yZW5kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6bG9jYXRpb24nLCB0aGlzLl9kcmF3X3NwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGFuVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSAmJiB0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3X3NwYW4oKTtcbiAgICB9O1xuICAgIFNwYW5WaWV3LnByb3RvdHlwZS5fZHJhd19zcGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzLCBjdHgsIGZyYW1lLCBoZWlnaHQsIGxvYywgc2xlZnQsIHN0b3AsIHdpZHRoLCB4bWFwcGVyLCB5bWFwcGVyO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5mb3JfaG92ZXIpIHtcbiAgICAgICAgICAgIGxvYyA9IHRoaXMubW9kZWwuY29tcHV0ZWRfbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2MgPSB0aGlzLm1vZGVsLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgeG1hcHBlciA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnhfbWFwcGVyc1t0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHltYXBwZXIgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS55X21hcHBlcnNbdGhpcy5tb2RlbC55X3JhbmdlX25hbWVdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5kaW1lbnNpb24gPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgIHN0b3AgPSBjYW52YXMudnlfdG9fc3kodGhpcy5fY2FsY19kaW0obG9jLCB5bWFwcGVyKSk7XG4gICAgICAgICAgICBzbGVmdCA9IGNhbnZhcy52eF90b19zeChmcmFtZS5sZWZ0KTtcbiAgICAgICAgICAgIHdpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMubGluZV93aWR0aC52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcCA9IGNhbnZhcy52eV90b19zeShmcmFtZS50b3ApO1xuICAgICAgICAgICAgc2xlZnQgPSBjYW52YXMudnhfdG9fc3godGhpcy5fY2FsY19kaW0obG9jLCB4bWFwcGVyKSk7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMubW9kZWwucHJvcGVydGllcy5saW5lX3dpZHRoLnZhbHVlKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09IFwiY3NzXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gc3RvcCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHNsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnpJbmRleCA9IDEwMDA7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMubW9kZWwucHJvcGVydGllcy5saW5lX2NvbG9yLnZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMubGluZV9hbHBoYS52YWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRvbV8xLnNob3codGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzbGVmdCwgc3RvcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5kaW1lbnNpb24gPT09IFwid2lkdGhcIikge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2xlZnQgKyB3aWR0aCwgc3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHNsZWZ0LCBzdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTcGFuVmlldy5wcm90b3R5cGUuX2NhbGNfZGltID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIHZkaW07XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmxvY2F0aW9uX3VuaXRzID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHZkaW0gPSBtYXBwZXIubWFwX3RvX3RhcmdldChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZGltID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZkaW07XG4gICAgfTtcbiAgICByZXR1cm4gU3BhblZpZXc7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5TcGFuID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNwYW4sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNwYW4oKSB7XG4gICAgICAgIHJldHVybiBTcGFuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcGFuLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlNwYW5WaWV3O1xuICAgIFNwYW4ucHJvdG90eXBlLnR5cGUgPSAnU3Bhbic7XG4gICAgU3Bhbi5taXhpbnMoWydsaW5lJ10pO1xuICAgIFNwYW4uZGVmaW5lKHtcbiAgICAgICAgcmVuZGVyX21vZGU6IFtwLlJlbmRlck1vZGUsICdjYW52YXMnXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICBsb2NhdGlvbjogW3AuTnVtYmVyLCBudWxsXSxcbiAgICAgICAgbG9jYXRpb25fdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgJ2RhdGEnXSxcbiAgICAgICAgZGltZW5zaW9uOiBbcC5EaW1lbnNpb24sICd3aWR0aCddXG4gICAgfSk7XG4gICAgU3Bhbi5vdmVycmlkZSh7XG4gICAgICAgIGxpbmVfY29sb3I6ICdibGFjaydcbiAgICB9KTtcbiAgICBTcGFuLmludGVybmFsKHtcbiAgICAgICAgZm9yX2hvdmVyOiBbcC5Cb29sZWFuLCBmYWxzZV0sXG4gICAgICAgIGNvbXB1dGVkX2xvY2F0aW9uOiBbcC5OdW1iZXIsIG51bGxdXG4gICAgfSk7XG4gICAgcmV0dXJuIFNwYW47XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vYW5ub3RhdGlvblwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnZhciB0ZXh0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3RleHRcIik7XG5leHBvcnRzLlRleHRBbm5vdGF0aW9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0QW5ub3RhdGlvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHRBbm5vdGF0aW9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRBbm5vdGF0aW9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dEFubm90YXRpb25WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVGV4dEFubm90YXRpb25WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2JrLWFubm90YXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5jYW52YXNfb3ZlcmxheXMuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJlbmRlcl9tb2RlID09PSAnY3NzJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2NhbGN1bGF0ZV90ZXh0X2RpbWVuc2lvbnMgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0KSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGV4dF8xLmdldF90ZXh0X2hlaWdodCh0aGlzLnZpc3VhbHMudGV4dC5mb250X3ZhbHVlKCkpLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2NhbGN1bGF0ZV9ib3VuZGluZ19ib3hfZGltZW5zaW9ucyA9IGZ1bmN0aW9uIChjdHgsIHRleHQpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgcmVmLCB3aWR0aCwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgICByZWYgPSB0aGlzLl9jYWxjdWxhdGVfdGV4dF9kaW1lbnNpb25zKGN0eCwgdGV4dCksIHdpZHRoID0gcmVmWzBdLCBoZWlnaHQgPSByZWZbMV07XG4gICAgICAgIHN3aXRjaCAoY3R4LnRleHRBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeF9vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB4X29mZnNldCA9IC13aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeF9vZmZzZXQgPSAtd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjdHgudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ID0gMC4wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICB5X29mZnNldCA9IC0wLjUgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ID0gLTEuMCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ID0gLTAuOCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ID0gLTAuMTcgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgICAgICAgICAgeV9vZmZzZXQgPSAtMC44MyAqIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3hfb2Zmc2V0LCB5X29mZnNldCwgd2lkdGgsIGhlaWdodF07XG4gICAgfTtcbiAgICBUZXh0QW5ub3RhdGlvblZpZXcucHJvdG90eXBlLl9nZXRfc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLm1vZGVsLnRleHQpLmFzY2VudDtcbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2NhbnZhc190ZXh0ID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgc3gsIHN5LCBhbmdsZSkge1xuICAgICAgICB2YXIgYmJveF9kaW1zO1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgYmJveF9kaW1zID0gdGhpcy5fY2FsY3VsYXRlX2JvdW5kaW5nX2JveF9kaW1lbnNpb25zKGN0eCwgdGV4dCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZWN0KGJib3hfZGltc1swXSwgYmJveF9kaW1zWzFdLCBiYm94X2RpbXNbMl0sIGJib3hfZGltc1szXSk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMudGV4dC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIFRleHRBbm5vdGF0aW9uVmlldy5wcm90b3R5cGUuX2Nzc190ZXh0ID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgc3gsIHN5LCBhbmdsZSkge1xuICAgICAgICB2YXIgYmJveF9kaW1zLCBsZCwgbGluZV9kYXNoO1xuICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgYmJveF9kaW1zID0gdGhpcy5fY2FsY3VsYXRlX2JvdW5kaW5nX2JveF9kaW1lbnNpb25zKGN0eCwgdGV4dCk7XG4gICAgICAgIGxkID0gdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmxpbmVfZGFzaC52YWx1ZSgpO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KGxkKSkge1xuICAgICAgICAgICAgaWYgKGxkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBsaW5lX2Rhc2ggPSBcInNvbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lX2Rhc2ggPSBcImRhc2hlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKGxkKSkge1xuICAgICAgICAgICAgbGluZV9kYXNoID0gbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICB0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gKHN4ICsgYmJveF9kaW1zWzBdKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSAoc3kgKyBiYm94X2RpbXNbMV0pICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmNvbG9yID0gXCJcIiArICh0aGlzLnZpc3VhbHMudGV4dC50ZXh0X2NvbG9yLnZhbHVlKCkpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSBcIlwiICsgKHRoaXMudmlzdWFscy50ZXh0LnRleHRfYWxwaGEudmFsdWUoKSk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZm9udCA9IFwiXCIgKyAodGhpcy52aXN1YWxzLnRleHQuZm9udF92YWx1ZSgpKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5saW5lSGVpZ2h0ID0gXCJub3JtYWxcIjtcbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgYW5nbGUgKyBcInJhZClcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiXCIgKyAodGhpcy52aXN1YWxzLmJhY2tncm91bmRfZmlsbC5jb2xvcl92YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmJvcmRlcl9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuYm9yZGVyU3R5bGUgPSBcIlwiICsgbGluZV9kYXNoO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3JkZXJXaWR0aCA9ICh0aGlzLnZpc3VhbHMuYm9yZGVyX2xpbmUubGluZV93aWR0aC52YWx1ZSgpKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuYm9yZGVyQ29sb3IgPSBcIlwiICsgKHRoaXMudmlzdWFscy5ib3JkZXJfbGluZS5jb2xvcl92YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgcmV0dXJuIGRvbV8xLnNob3codGhpcy5lbCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEFubm90YXRpb25WaWV3O1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb25WaWV3KTtcbmV4cG9ydHMuVGV4dEFubm90YXRpb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGV4dEFubm90YXRpb24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHRBbm5vdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gVGV4dEFubm90YXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRleHRBbm5vdGF0aW9uLnByb3RvdHlwZS50eXBlID0gJ1RleHRBbm5vdGF0aW9uJztcbiAgICBUZXh0QW5ub3RhdGlvbi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UZXh0QW5ub3RhdGlvblZpZXc7XG4gICAgcmV0dXJuIFRleHRBbm5vdGF0aW9uO1xufSkoYW5ub3RhdGlvbl8xLkFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRleHRfYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4vdGV4dF9hbm5vdGF0aW9uXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIFZpc3VhbHMgPSByZXF1aXJlKFwiY29yZS92aXN1YWxzXCIpO1xuZXhwb3J0cy5UaXRsZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGl0bGVWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaXRsZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUaXRsZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpdGxlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjdHg7XG4gICAgICAgIFRpdGxlVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc3VhbHMudGV4dCA9IG5ldyBWaXN1YWxzLlRleHQodGhpcy5tb2RlbCk7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYW5lbC5hcHBseV9sYWJlbF90ZXh0X2hldXJpc3RpY3MoY3R4LCAnanVzdGlmaWVkJyk7XG4gICAgICAgIHRoaXMubW9kZWwudGV4dF9iYXNlbGluZSA9IGN0eC50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHRoaXMubW9kZWwudGV4dF9hbGlnbiA9IHRoaXMubW9kZWwuYWxpZ247XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgVGl0bGVWaWV3LnByb3RvdHlwZS5fZ2V0X2NvbXB1dGVkX2xvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCByZWYsIHN4LCBzeSwgdngsIHZ5LCB3aWR0aDtcbiAgICAgICAgcmVmID0gdGhpcy5fY2FsY3VsYXRlX3RleHRfZGltZW5zaW9ucyh0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHgsIHRoaXMudGV4dCksIHdpZHRoID0gcmVmWzBdLCBoZWlnaHQgPSByZWZbMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5wYW5lbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB2eCA9IDA7XG4gICAgICAgICAgICAgICAgdnkgPSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLnZfcmFuZ2UpICsgdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdnggPSB0aGlzLmNhbnZhcy5yaWdodCAtIDE7XG4gICAgICAgICAgICAgICAgdnkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLnZfcmFuZ2UpIC0gdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgdnggPSB0aGlzLl9nZXRfdGV4dF9sb2NhdGlvbih0aGlzLm1vZGVsLmFsaWduLCB0aGlzLmZyYW1lLmhfcmFuZ2UpICsgdGhpcy5tb2RlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdnkgPSB0aGlzLmNhbnZhcy50b3AgLSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JlbG93JzpcbiAgICAgICAgICAgICAgICB2eCA9IHRoaXMuX2dldF90ZXh0X2xvY2F0aW9uKHRoaXMubW9kZWwuYWxpZ24sIHRoaXMuZnJhbWUuaF9yYW5nZSkgKyB0aGlzLm1vZGVsLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0aGlzLmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gdGhpcy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICBUaXRsZVZpZXcucHJvdG90eXBlLl9nZXRfdGV4dF9sb2NhdGlvbiA9IGZ1bmN0aW9uIChhbGlnbm1lbnQsIHJhbmdlKSB7XG4gICAgICAgIHZhciB0ZXh0X2xvY2F0aW9uO1xuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgdGV4dF9sb2NhdGlvbiA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0ZXh0X2xvY2F0aW9uID0gKHJhbmdlLmVuZCArIHJhbmdlLnN0YXJ0KSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGV4dF9sb2NhdGlvbiA9IHJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dF9sb2NhdGlvbjtcbiAgICB9O1xuICAgIFRpdGxlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5nbGUsIGN0eCwgcmVmLCBzeCwgc3k7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlICYmIHRoaXMubW9kZWwucmVuZGVyX21vZGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMoJ3BhcmFsbGVsJyk7XG4gICAgICAgIHJlZiA9IHRoaXMuX2dldF9jb21wdXRlZF9sb2NhdGlvbigpLCBzeCA9IHJlZlswXSwgc3kgPSByZWZbMV07XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwudGV4dCA9PT0gXCJcIiB8fCB0aGlzLm1vZGVsLnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfbW9kZSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNfdGV4dChjdHgsIHRoaXMubW9kZWwudGV4dCwgc3gsIHN5LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3NzX3RleHQoY3R4LCB0aGlzLm1vZGVsLnRleHQsIHN4LCBzeSwgYW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaXRsZVZpZXcucHJvdG90eXBlLl9nZXRfc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgdGV4dDtcbiAgICAgICAgdGV4dCA9IHRoaXMubW9kZWwudGV4dDtcbiAgICAgICAgaWYgKHRleHQgPT09IFwiXCIgfHwgdGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQodGV4dCkuYXNjZW50ICsgMTA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaXRsZVZpZXc7XG59KSh0ZXh0X2Fubm90YXRpb25fMS5UZXh0QW5ub3RhdGlvblZpZXcpO1xuZXhwb3J0cy5UaXRsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUaXRsZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiBUaXRsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGl0bGUucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVGl0bGVWaWV3O1xuICAgIFRpdGxlLnByb3RvdHlwZS50eXBlID0gJ1RpdGxlJztcbiAgICBUaXRsZS5taXhpbnMoWydsaW5lOmJvcmRlcl8nLCAnZmlsbDpiYWNrZ3JvdW5kXyddKTtcbiAgICBUaXRsZS5kZWZpbmUoe1xuICAgICAgICB0ZXh0OiBbcC5TdHJpbmddLFxuICAgICAgICB0ZXh0X2ZvbnQ6IFtwLkZvbnQsICdoZWx2ZXRpY2EnXSxcbiAgICAgICAgdGV4dF9mb250X3NpemU6IFtwLkZvbnRTaXplU3BlYywgJzEwcHQnXSxcbiAgICAgICAgdGV4dF9mb250X3N0eWxlOiBbcC5Gb250U3R5bGUsICdib2xkJ10sXG4gICAgICAgIHRleHRfY29sb3I6IFtwLkNvbG9yU3BlYywgJyM0NDQ0NDQnXSxcbiAgICAgICAgdGV4dF9hbHBoYTogW3AuTnVtYmVyU3BlYywgMS4wXSxcbiAgICAgICAgYWxpZ246IFtwLlRleHRBbGlnbiwgJ2xlZnQnXSxcbiAgICAgICAgb2Zmc2V0OiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICByZW5kZXJfbW9kZTogW3AuUmVuZGVyTW9kZSwgJ2NhbnZhcyddXG4gICAgfSk7XG4gICAgVGl0bGUub3ZlcnJpZGUoe1xuICAgICAgICBiYWNrZ3JvdW5kX2ZpbGxfY29sb3I6IG51bGwsXG4gICAgICAgIGJvcmRlcl9saW5lX2NvbG9yOiBudWxsXG4gICAgfSk7XG4gICAgVGl0bGUuaW50ZXJuYWwoe1xuICAgICAgICB0ZXh0X2FsaWduOiBbcC5UZXh0QWxpZ24sICdsZWZ0J10sXG4gICAgICAgIHRleHRfYmFzZWxpbmU6IFtwLlRleHRCYXNlbGluZSwgJ2JvdHRvbSddXG4gICAgfSk7XG4gICAgcmV0dXJuIFRpdGxlO1xufSkodGV4dF9hbm5vdGF0aW9uXzEuVGV4dEFubm90YXRpb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuL2Fubm90YXRpb25cIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlRvb2x0aXBWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRvb2x0aXBWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sdGlwVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRvb2x0aXBWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay10b29sdGlwXCI7XG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBUb29sdGlwVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5jYW52YXNfb3ZlcmxheXMuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuekluZGV4ID0gMTAxMDtcbiAgICAgICAgcmV0dXJuIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgfTtcbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6ZGF0YScsIHRoaXMuX2RyYXdfdGlwcyk7XG4gICAgfTtcbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3X3RpcHMoKTtcbiAgICB9O1xuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fZHJhd190aXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyb3dfc2l6ZSwgYXR0YWNobWVudCwgYm90dG9tLCBjb250ZW50LCBkYXRhLCBoZWlnaHQsIGksIGxlZnQsIGxlbiwgc2lkZSwgc3gsIHN5LCB0aXAsIHRvcCwgdmFsLCB2eCwgdnksIHdpZHRoO1xuICAgICAgICBkYXRhID0gdGhpcy5tb2RlbC5kYXRhO1xuICAgICAgICBkb21fMS5lbXB0eSh0aGlzLmVsKTtcbiAgICAgICAgZG9tXzEuaGlkZSh0aGlzLmVsKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY3VzdG9tKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJiay10b29sdGlwLWN1c3RvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImJrLXRvb2x0aXAtY3VzdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhbCA9IGRhdGFbaV07XG4gICAgICAgICAgICB2eCA9IHZhbFswXSwgdnkgPSB2YWxbMV0sIGNvbnRlbnQgPSB2YWxbMl07XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5pbm5lcl9vbmx5ICYmICF0aGlzLnBsb3Rfdmlldy5mcmFtZS5jb250YWlucyh2eCwgdnkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aXAgPSBkb21fMS5kaXYoe30sIGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aXApO1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdGhpcy5wbG90X3ZpZXcubW9kZWwuY2FudmFzLnZ4X3RvX3N4KHZ4KTtcbiAgICAgICAgc3kgPSB0aGlzLnBsb3Rfdmlldy5tb2RlbC5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5tb2RlbC5hdHRhY2htZW50O1xuICAgICAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS53aWR0aDtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUubGVmdDtcbiAgICAgICAgICAgICAgICBpZiAodnggLSBsZWZ0IDwgd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUuYm90dG9tO1xuICAgICAgICAgICAgICAgIGlmICh2eSAtIGJvdHRvbSA8IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICdiZWxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWRlID0gJ2Fib3ZlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNpZGUgPSBhdHRhY2htZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImJrLXJpZ2h0XCIpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJiay1sZWZ0XCIpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJiay1hYm92ZVwiKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiYmstYmVsb3dcIik7XG4gICAgICAgIGFycm93X3NpemUgPSAxMDtcbiAgICAgICAgZG9tXzEuc2hvdyh0aGlzLmVsKTtcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJiay1sZWZ0XCIpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzeCArICh0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aCkgKyBhcnJvd19zaXplO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5IC0gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJiay1yaWdodFwiKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3ggLSB0aGlzLmVsLm9mZnNldFdpZHRoIC0gYXJyb3dfc2l6ZTtcbiAgICAgICAgICAgICAgICB0b3AgPSBzeSAtIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLWFib3ZlXCIpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5ICsgKHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQpICsgYXJyb3dfc2l6ZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5yb3VuZChzeCAtIHRoaXMuZWwub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLWJlbG93XCIpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHN5IC0gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSBhcnJvd19zaXplO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLnJvdW5kKHN4IC0gdGhpcy5lbC5vZmZzZXRXaWR0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNob3dfYXJyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLXRvb2x0aXAtYXJyb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWwuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb29sdGlwVmlldztcbn0pKGFubm90YXRpb25fMS5Bbm5vdGF0aW9uVmlldyk7XG5leHBvcnRzLlRvb2x0aXAgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbHRpcCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2x0aXAuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVG9vbHRpcFZpZXc7XG4gICAgVG9vbHRpcC5wcm90b3R5cGUudHlwZSA9ICdUb29sdGlwJztcbiAgICBUb29sdGlwLmRlZmluZSh7XG4gICAgICAgIGF0dGFjaG1lbnQ6IFtwLlN0cmluZywgJ2hvcml6b250YWwnXSxcbiAgICAgICAgaW5uZXJfb25seTogW3AuQm9vbCwgdHJ1ZV0sXG4gICAgICAgIHNob3dfYXJyb3c6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgVG9vbHRpcC5vdmVycmlkZSh7XG4gICAgICAgIGxldmVsOiAnb3ZlcmxheSdcbiAgICB9KTtcbiAgICBUb29sdGlwLmludGVybmFsKHtcbiAgICAgICAgZGF0YTogW3AuQW55LCBbXV0sXG4gICAgICAgIGN1c3RvbTogW3AuQW55XVxuICAgIH0pO1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gW107XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodngsIHZ5LCBjb250ZW50KSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBkYXRhLnB1c2goW3Z4LCB2eSwgY29udGVudF0pO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdjaGFuZ2U6ZGF0YScpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2x0aXA7XG59KShhbm5vdGF0aW9uXzEuQW5ub3RhdGlvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2lkZV9wYW5lbF8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NpZGVfcGFuZWxcIik7XG52YXIgZ3VpZGVfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvZ3VpZGVfcmVuZGVyZXJcIik7XG52YXIgcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvcmVuZGVyZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuQXhpc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXhpc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEF4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gQXhpc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgQXhpc1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5feF9yYW5nZV9uYW1lID0gdGhpcy5tb2RlbC54X3JhbmdlX25hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLl95X3JhbmdlX25hbWUgPSB0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZTtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHg7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLl9kcmF3X3J1bGUoY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd19tYWpvcl90aWNrcyhjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3X21pbm9yX3RpY2tzKGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdfbWFqb3JfbGFiZWxzKGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdfYXhpc19sYWJlbChjdHgpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKTtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fZ2V0X3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrX2V4dGVudCgpICsgdGhpcy5fdGlja19sYWJlbF9leHRlbnQoKSArIHRoaXMuX2F4aXNfbGFiZWxfZXh0ZW50KCk7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2RyYXdfcnVsZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGNvb3JkcywgaSwgaywgbngsIG55LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHN4LCBzeSwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMuYXhpc19saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBjb29yZHMgPSB0aGlzLm1vZGVsLnJ1bGVfY29vcmRzLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4LCB5LCB0aGlzLl94X3JhbmdlX25hbWUsIHRoaXMuX3lfcmFuZ2VfbmFtZSksIHN4ID0gcmVmMVswXSwgc3kgPSByZWYxWzFdO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5ub3JtYWxzLCBueCA9IHJlZjJbMF0sIG55ID0gcmVmMlsxXTtcbiAgICAgICAgcmVmMyA9IHRoaXMubW9kZWwub2Zmc2V0cywgeG9mZiA9IHJlZjNbMF0sIHlvZmYgPSByZWYzWzFdO1xuICAgICAgICB0aGlzLnZpc3VhbHMuYXhpc19saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5yb3VuZChzeFswXSArIG54ICogeG9mZiksIE1hdGgucm91bmQoc3lbMF0gKyBueSAqIHlvZmYpKTtcbiAgICAgICAgZm9yIChpID0gayA9IDEsIHJlZjQgPSBzeC5sZW5ndGg7IDEgPD0gcmVmNCA/IGsgPCByZWY0IDogayA+IHJlZjQ7IGkgPSAxIDw9IHJlZjQgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5yb3VuZChzeFtpXSArIG54ICogeG9mZiksIE1hdGgucm91bmQoc3lbaV0gKyBueSAqIHlvZmYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnN0cm9rZSgpO1xuICAgIH07XG4gICAgQXhpc1ZpZXcucHJvdG90eXBlLl9kcmF3X21ham9yX3RpY2tzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgY29vcmRzLCBpLCBrLCBueCwgbnksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVzdWx0cywgc3gsIHN5LCB0aW4sIHRvdXQsIHgsIHhvZmYsIHksIHlvZmY7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLm1ham9yX3RpY2tfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzID0gdGhpcy5tb2RlbC50aWNrX2Nvb3JkcztcbiAgICAgICAgcmVmID0gY29vcmRzLm1ham9yLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4LCB5LCB0aGlzLl94X3JhbmdlX25hbWUsIHRoaXMuX3lfcmFuZ2VfbmFtZSksIHN4ID0gcmVmMVswXSwgc3kgPSByZWYxWzFdO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5ub3JtYWxzLCBueCA9IHJlZjJbMF0sIG55ID0gcmVmMlsxXTtcbiAgICAgICAgcmVmMyA9IHRoaXMubW9kZWwub2Zmc2V0cywgeG9mZiA9IHJlZjNbMF0sIHlvZmYgPSByZWYzWzFdO1xuICAgICAgICB0aW4gPSB0aGlzLm1vZGVsLm1ham9yX3RpY2tfaW47XG4gICAgICAgIHRvdXQgPSB0aGlzLm1vZGVsLm1ham9yX3RpY2tfb3V0O1xuICAgICAgICB0aGlzLnZpc3VhbHMubWFqb3JfdGlja19saW5lLnNldF92YWx1ZShjdHgpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY0ID0gc3gubGVuZ3RoOyAwIDw9IHJlZjQgPyBrIDwgcmVmNCA6IGsgPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKE1hdGgucm91bmQoc3hbaV0gKyBueCAqIHRvdXQgKyBueCAqIHhvZmYpLCBNYXRoLnJvdW5kKHN5W2ldICsgbnkgKiB0b3V0ICsgbnkgKiB5b2ZmKSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKE1hdGgucm91bmQoc3hbaV0gLSBueCAqIHRpbiArIG54ICogeG9mZiksIE1hdGgucm91bmQoc3lbaV0gLSBueSAqIHRpbiArIG55ICogeW9mZikpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2RyYXdfbWlub3JfdGlja3MgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBjb29yZHMsIGksIGssIG54LCBueSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRzLCBzeCwgc3ksIHRpbiwgdG91dCwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMubWlub3JfdGlja19saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb29yZHMgPSB0aGlzLm1vZGVsLnRpY2tfY29vcmRzO1xuICAgICAgICByZWYgPSBjb29yZHMubWlub3IsIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3ggPSByZWYxWzBdLCBzeSA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLm5vcm1hbHMsIG54ID0gcmVmMlswXSwgbnkgPSByZWYyWzFdO1xuICAgICAgICByZWYzID0gdGhpcy5tb2RlbC5vZmZzZXRzLCB4b2ZmID0gcmVmM1swXSwgeW9mZiA9IHJlZjNbMV07XG4gICAgICAgIHRpbiA9IHRoaXMubW9kZWwubWlub3JfdGlja19pbjtcbiAgICAgICAgdG91dCA9IHRoaXMubW9kZWwubWlub3JfdGlja19vdXQ7XG4gICAgICAgIHRoaXMudmlzdWFscy5taW5vcl90aWNrX2xpbmUuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjQgPSBzeC5sZW5ndGg7IDAgPD0gcmVmNCA/IGsgPCByZWY0IDogayA+IHJlZjQ7IGkgPSAwIDw9IHJlZjQgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oTWF0aC5yb3VuZChzeFtpXSArIG54ICogdG91dCArIG54ICogeG9mZiksIE1hdGgucm91bmQoc3lbaV0gKyBueSAqIHRvdXQgKyBueSAqIHlvZmYpKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5yb3VuZChzeFtpXSAtIG54ICogdGluICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSAtIG55ICogdGluICsgbnkgKiB5b2ZmKSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fZHJhd19tYWpvcl9sYWJlbHMgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBhbmdsZSwgY29vcmRzLCBkaW0sIGksIGssIGxhYmVscywgbngsIG55LCBvcmllbnQsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVzdWx0cywgc2lkZSwgc3RhbmRvZmYsIHN4LCBzeSwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgY29vcmRzID0gdGhpcy5tb2RlbC50aWNrX2Nvb3JkcztcbiAgICAgICAgcmVmID0gY29vcmRzLm1ham9yLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4LCB5LCB0aGlzLl94X3JhbmdlX25hbWUsIHRoaXMuX3lfcmFuZ2VfbmFtZSksIHN4ID0gcmVmMVswXSwgc3kgPSByZWYxWzFdO1xuICAgICAgICByZWYyID0gdGhpcy5tb2RlbC5ub3JtYWxzLCBueCA9IHJlZjJbMF0sIG55ID0gcmVmMlsxXTtcbiAgICAgICAgcmVmMyA9IHRoaXMubW9kZWwub2Zmc2V0cywgeG9mZiA9IHJlZjNbMF0sIHlvZmYgPSByZWYzWzFdO1xuICAgICAgICBkaW0gPSB0aGlzLm1vZGVsLmRpbWVuc2lvbjtcbiAgICAgICAgc2lkZSA9IHRoaXMubW9kZWwucGFuZWxfc2lkZTtcbiAgICAgICAgb3JpZW50ID0gdGhpcy5tb2RlbC5tYWpvcl9sYWJlbF9vcmllbnRhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcob3JpZW50KSkge1xuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMob3JpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gLW9yaWVudDtcbiAgICAgICAgfVxuICAgICAgICBzdGFuZG9mZiA9IHRoaXMuX3RpY2tfZXh0ZW50KCkgKyB0aGlzLm1vZGVsLm1ham9yX2xhYmVsX3N0YW5kb2ZmO1xuICAgICAgICBsYWJlbHMgPSB0aGlzLm1vZGVsLmZvcm1hdHRlci5kb0Zvcm1hdChjb29yZHMubWFqb3JbZGltXSwgdGhpcy5tb2RlbC5sb2MpO1xuICAgICAgICB0aGlzLnZpc3VhbHMubWFqb3JfbGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgdGhpcy5tb2RlbC5wYW5lbC5hcHBseV9sYWJlbF90ZXh0X2hldXJpc3RpY3MoY3R4LCBvcmllbnQpO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY0ID0gc3gubGVuZ3RoOyAwIDw9IHJlZjQgPyBrIDwgcmVmNCA6IGsgPiByZWY0OyBpID0gMCA8PSByZWY0ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN4W2ldICsgbnggKiBzdGFuZG9mZiArIG54ICogeG9mZiwgc3lbaV0gKyBueSAqIHN0YW5kb2ZmICsgbnkgKiB5b2ZmKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWxzW2ldLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC50cmFuc2xhdGUoLXN4W2ldIC0gbnggKiBzdGFuZG9mZiArIG54ICogeG9mZiwgLXN5W2ldIC0gbnkgKiBzdGFuZG9mZiArIG55ICogeW9mZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5maWxsVGV4dChsYWJlbHNbaV0sIE1hdGgucm91bmQoc3hbaV0gKyBueCAqIHN0YW5kb2ZmICsgbnggKiB4b2ZmKSwgTWF0aC5yb3VuZChzeVtpXSArIG55ICogc3RhbmRvZmYgKyBueSAqIHlvZmYpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2RyYXdfYXhpc19sYWJlbCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBsYWJlbCwgbngsIG55LCBvcmllbnQsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc2lkZSwgc3RhbmRvZmYsIHN4LCBzeSwgeCwgeG9mZiwgeSwgeW9mZjtcbiAgICAgICAgbGFiZWwgPSB0aGlzLm1vZGVsLmF4aXNfbGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5ydWxlX2Nvb3JkcywgeCA9IHJlZlswXSwgeSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMucGxvdF92aWV3Lm1hcF90b19zY3JlZW4oeCwgeSwgdGhpcy5feF9yYW5nZV9uYW1lLCB0aGlzLl95X3JhbmdlX25hbWUpLCBzeCA9IHJlZjFbMF0sIHN5ID0gcmVmMVsxXTtcbiAgICAgICAgcmVmMiA9IHRoaXMubW9kZWwubm9ybWFscywgbnggPSByZWYyWzBdLCBueSA9IHJlZjJbMV07XG4gICAgICAgIHJlZjMgPSB0aGlzLm1vZGVsLm9mZnNldHMsIHhvZmYgPSByZWYzWzBdLCB5b2ZmID0gcmVmM1sxXTtcbiAgICAgICAgc2lkZSA9IHRoaXMubW9kZWwucGFuZWxfc2lkZTtcbiAgICAgICAgb3JpZW50ID0gJ3BhcmFsbGVsJztcbiAgICAgICAgYW5nbGUgPSB0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMob3JpZW50KTtcbiAgICAgICAgc3RhbmRvZmYgPSB0aGlzLl90aWNrX2V4dGVudCgpICsgdGhpcy5fdGlja19sYWJlbF9leHRlbnQoKSArIHRoaXMubW9kZWwuYXhpc19sYWJlbF9zdGFuZG9mZjtcbiAgICAgICAgc3ggPSAoc3hbMF0gKyBzeFtzeC5sZW5ndGggLSAxXSkgLyAyO1xuICAgICAgICBzeSA9IChzeVswXSArIHN5W3N5Lmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgICAgIHRoaXMudmlzdWFscy5heGlzX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIHRoaXMubW9kZWwucGFuZWwuYXBwbHlfbGFiZWxfdGV4dF9oZXVyaXN0aWNzKGN0eCwgb3JpZW50KTtcbiAgICAgICAgeCA9IHN4ICsgbnggKiBzdGFuZG9mZiArIG54ICogeG9mZjtcbiAgICAgICAgeSA9IHN5ICsgbnkgKiBzdGFuZG9mZiArIG55ICogeW9mZjtcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIDAsIDApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZmlsbFRleHQobGFiZWwsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX3RpY2tfZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5tYWpvcl90aWNrX291dDtcbiAgICB9O1xuICAgIEF4aXNWaWV3LnByb3RvdHlwZS5fdGlja19sYWJlbF9leHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmdsZSwgYywgY29vcmRzLCBjdHgsIGRpbSwgZXh0ZW50LCBoLCBoZmFjdG9yLCBoc2NhbGUsIGksIGssIGxhYmVscywgb3JpZW50LCByZWYsIHMsIHNpZGUsIHZhbCwgdywgd2ZhY3RvcjtcbiAgICAgICAgZXh0ZW50ID0gMDtcbiAgICAgICAgY3R4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBkaW0gPSB0aGlzLm1vZGVsLmRpbWVuc2lvbjtcbiAgICAgICAgY29vcmRzID0gdGhpcy5tb2RlbC50aWNrX2Nvb3Jkcy5tYWpvcjtcbiAgICAgICAgc2lkZSA9IHRoaXMubW9kZWwucGFuZWxfc2lkZTtcbiAgICAgICAgb3JpZW50ID0gdGhpcy5tb2RlbC5tYWpvcl9sYWJlbF9vcmllbnRhdGlvbjtcbiAgICAgICAgbGFiZWxzID0gdGhpcy5tb2RlbC5mb3JtYXR0ZXIuZG9Gb3JtYXQoY29vcmRzW2RpbV0sIHRoaXMubW9kZWwubG9jKTtcbiAgICAgICAgdGhpcy52aXN1YWxzLm1ham9yX2xhYmVsX3RleHQuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgIGlmICh0eXBlc18xLmlzU3RyaW5nKG9yaWVudCkpIHtcbiAgICAgICAgICAgIGhzY2FsZSA9IDE7XG4gICAgICAgICAgICBhbmdsZSA9IHRoaXMubW9kZWwucGFuZWwuZ2V0X2xhYmVsX2FuZ2xlX2hldXJpc3RpYyhvcmllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNjYWxlID0gMjtcbiAgICAgICAgICAgIGFuZ2xlID0gLW9yaWVudDtcbiAgICAgICAgfVxuICAgICAgICBhbmdsZSA9IE1hdGguYWJzKGFuZ2xlKTtcbiAgICAgICAgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKHNpZGUgPT09IFwiYWJvdmVcIiB8fCBzaWRlID09PSBcImJlbG93XCIpIHtcbiAgICAgICAgICAgIHdmYWN0b3IgPSBzO1xuICAgICAgICAgICAgaGZhY3RvciA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3ZmFjdG9yID0gYztcbiAgICAgICAgICAgIGhmYWN0b3IgPSBzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBsYWJlbHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlmIChsYWJlbHNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbHNbaV0pLndpZHRoICogMS4xO1xuICAgICAgICAgICAgaCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbHNbaV0pLmFzY2VudCAqIDAuOTtcbiAgICAgICAgICAgIHZhbCA9IHcgKiB3ZmFjdG9yICsgKGggLyBoc2NhbGUpICogaGZhY3RvcjtcbiAgICAgICAgICAgIGlmICh2YWwgPiBleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVudCA+IDApIHtcbiAgICAgICAgICAgIGV4dGVudCArPSB0aGlzLm1vZGVsLm1ham9yX2xhYmVsX3N0YW5kb2ZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfTtcbiAgICBBeGlzVmlldy5wcm90b3R5cGUuX2F4aXNfbGFiZWxfZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5nbGUsIGF4aXNfbGFiZWwsIGMsIGN0eCwgZXh0ZW50LCBoLCBvcmllbnQsIHMsIHNpZGUsIHc7XG4gICAgICAgIGV4dGVudCA9IDA7XG4gICAgICAgIHNpZGUgPSB0aGlzLm1vZGVsLnBhbmVsX3NpZGU7XG4gICAgICAgIGF4aXNfbGFiZWwgPSB0aGlzLm1vZGVsLmF4aXNfbGFiZWw7XG4gICAgICAgIG9yaWVudCA9ICdwYXJhbGxlbCc7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgdGhpcy52aXN1YWxzLmF4aXNfbGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgYW5nbGUgPSBNYXRoLmFicyh0aGlzLm1vZGVsLnBhbmVsLmdldF9sYWJlbF9hbmdsZV9oZXVyaXN0aWMob3JpZW50KSk7XG4gICAgICAgIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGlmIChheGlzX2xhYmVsKSB7XG4gICAgICAgICAgICBleHRlbnQgKz0gdGhpcy5tb2RlbC5heGlzX2xhYmVsX3N0YW5kb2ZmO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmF4aXNfbGFiZWxfdGV4dC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIHcgPSBjdHgubWVhc3VyZVRleHQoYXhpc19sYWJlbCkud2lkdGggKiAxLjE7XG4gICAgICAgICAgICBoID0gY3R4Lm1lYXN1cmVUZXh0KGF4aXNfbGFiZWwpLmFzY2VudCAqIDAuOTtcbiAgICAgICAgICAgIGlmIChzaWRlID09PSBcImFib3ZlXCIgfHwgc2lkZSA9PT0gXCJiZWxvd1wiKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ICs9IHcgKiBzICsgaCAqIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgKz0gdyAqIGMgKyBoICogcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgIH07XG4gICAgcmV0dXJuIEF4aXNWaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5BeGlzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEF4aXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEF4aXMoKSB7XG4gICAgICAgIHJldHVybiBBeGlzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBeGlzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkF4aXNWaWV3O1xuICAgIEF4aXMucHJvdG90eXBlLnR5cGUgPSAnQXhpcyc7XG4gICAgQXhpcy5taXhpbnMoWydsaW5lOmF4aXNfJywgJ2xpbmU6bWFqb3JfdGlja18nLCAnbGluZTptaW5vcl90aWNrXycsICd0ZXh0Om1ham9yX2xhYmVsXycsICd0ZXh0OmF4aXNfbGFiZWxfJ10pO1xuICAgIEF4aXMuZGVmaW5lKHtcbiAgICAgICAgYm91bmRzOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIHRpY2tlcjogW3AuSW5zdGFuY2UsIG51bGxdLFxuICAgICAgICBmb3JtYXR0ZXI6IFtwLkluc3RhbmNlLCBudWxsXSxcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICBheGlzX2xhYmVsOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgYXhpc19sYWJlbF9zdGFuZG9mZjogW3AuSW50LCA1XSxcbiAgICAgICAgbWFqb3JfbGFiZWxfc3RhbmRvZmY6IFtwLkludCwgNV0sXG4gICAgICAgIG1ham9yX2xhYmVsX29yaWVudGF0aW9uOiBbcC5BbnksIFwiaG9yaXpvbnRhbFwiXSxcbiAgICAgICAgbWFqb3JfdGlja19pbjogW3AuTnVtYmVyLCAyXSxcbiAgICAgICAgbWFqb3JfdGlja19vdXQ6IFtwLk51bWJlciwgNl0sXG4gICAgICAgIG1pbm9yX3RpY2tfaW46IFtwLk51bWJlciwgMF0sXG4gICAgICAgIG1pbm9yX3RpY2tfb3V0OiBbcC5OdW1iZXIsIDRdXG4gICAgfSk7XG4gICAgQXhpcy5vdmVycmlkZSh7XG4gICAgICAgIGF4aXNfbGluZV9jb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgbWFqb3JfdGlja19saW5lX2NvbG9yOiAnYmxhY2snLFxuICAgICAgICBtaW5vcl90aWNrX2xpbmVfY29sb3I6ICdibGFjaycsXG4gICAgICAgIG1ham9yX2xhYmVsX3RleHRfZm9udF9zaXplOiBcIjhwdFwiLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2FsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBtYWpvcl9sYWJlbF90ZXh0X2Jhc2VsaW5lOiBcImFscGhhYmV0aWNcIixcbiAgICAgICAgYXhpc19sYWJlbF90ZXh0X2ZvbnRfc2l6ZTogXCIxMHB0XCIsXG4gICAgICAgIGF4aXNfbGFiZWxfdGV4dF9mb250X3N0eWxlOiBcIml0YWxpY1wiXG4gICAgfSk7XG4gICAgQXhpcy5pbnRlcm5hbCh7XG4gICAgICAgIHBhbmVsX3NpZGU6IFtwLkFueV1cbiAgICB9KTtcbiAgICBBeGlzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIEF4aXMuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGVmaW5lX2NvbXB1dGVkX3Byb3BlcnR5KCdjb21wdXRlZF9ib3VuZHMnLCB0aGlzLl9jb21wdXRlZF9ib3VuZHMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRfZGVwZW5kZW5jaWVzKCdjb21wdXRlZF9ib3VuZHMnLCB0aGlzLCBbJ2JvdW5kcyddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2RlcGVuZGVuY2llcygnY29tcHV0ZWRfYm91bmRzJywgdGhpcy5wbG90LCBbJ3hfcmFuZ2UnLCAneV9yYW5nZSddKTtcbiAgICB9O1xuICAgIEF4aXMuZ2V0dGVycyh7XG4gICAgICAgIGNvbXB1dGVkX2JvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb21wdXRlZCgnY29tcHV0ZWRfYm91bmRzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bGVfY29vcmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVsZV9jb29yZHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGlja19jb29yZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrX2Nvb3JkcygpO1xuICAgICAgICB9LFxuICAgICAgICByYW5nZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9ybWFsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuX25vcm1hbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGRpbWVuc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuX2RpbTtcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2xvYygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQXhpcy5wcm90b3R5cGUuYWRkX3BhbmVsID0gZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdGhpcy5wYW5lbCA9IG5ldyBzaWRlX3BhbmVsXzEuU2lkZVBhbmVsKHtcbiAgICAgICAgICAgIHNpZGU6IHNpZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFuZWwuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYW5lbF9zaWRlID0gc2lkZTtcbiAgICB9O1xuICAgIEF4aXMucHJvdG90eXBlLl9vZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhbWUsIHJlZiwgc2lkZSwgeG9mZiwgeW9mZjtcbiAgICAgICAgc2lkZSA9IHRoaXMucGFuZWxfc2lkZTtcbiAgICAgICAgcmVmID0gWzAsIDBdLCB4b2ZmID0gcmVmWzBdLCB5b2ZmID0gcmVmWzFdO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdC5wbG90X2NhbnZhcy5mcmFtZTtcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmVsb3dcIjpcbiAgICAgICAgICAgICAgICB5b2ZmID0gTWF0aC5hYnModGhpcy5wYW5lbC50b3AgLSBmcmFtZS5ib3R0b20pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFib3ZlXCI6XG4gICAgICAgICAgICAgICAgeW9mZiA9IE1hdGguYWJzKHRoaXMucGFuZWwuYm90dG9tIC0gZnJhbWUudG9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHhvZmYgPSBNYXRoLmFicyh0aGlzLnBhbmVsLmxlZnQgLSBmcmFtZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIHhvZmYgPSBNYXRoLmFicyh0aGlzLnBhbmVsLnJpZ2h0IC0gZnJhbWUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4b2ZmLCB5b2ZmXTtcbiAgICB9O1xuICAgIEF4aXMucHJvdG90eXBlLl9yYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZSwgaSwgaiwgcmFuZ2VzO1xuICAgICAgICBpID0gdGhpcy5kaW1lbnNpb247XG4gICAgICAgIGogPSAoaSArIDEpICUgMjtcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3QucGxvdF9jYW52YXMuZnJhbWU7XG4gICAgICAgIHJhbmdlcyA9IFtmcmFtZS54X3Jhbmdlc1t0aGlzLnhfcmFuZ2VfbmFtZV0sIGZyYW1lLnlfcmFuZ2VzW3RoaXMueV9yYW5nZV9uYW1lXV07XG4gICAgICAgIHJldHVybiBbcmFuZ2VzW2ldLCByYW5nZXNbal1dO1xuICAgIH07XG4gICAgQXhpcy5wcm90b3R5cGUuX2NvbXB1dGVkX2JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyb3NzX3JhbmdlLCBlbmQsIHJhbmdlLCByYW5nZV9ib3VuZHMsIHJlZiwgcmVmMSwgc3RhcnQsIHVzZXJfYm91bmRzO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcywgcmFuZ2UgPSByZWZbMF0sIGNyb3NzX3JhbmdlID0gcmVmWzFdO1xuICAgICAgICB1c2VyX2JvdW5kcyA9IChyZWYxID0gdGhpcy5ib3VuZHMpICE9IG51bGwgPyByZWYxIDogJ2F1dG8nO1xuICAgICAgICByYW5nZV9ib3VuZHMgPSBbcmFuZ2UubWluLCByYW5nZS5tYXhdO1xuICAgICAgICBpZiAodXNlcl9ib3VuZHMgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlX2JvdW5kcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KHVzZXJfYm91bmRzKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHVzZXJfYm91bmRzWzBdIC0gdXNlcl9ib3VuZHNbMV0pID4gTWF0aC5hYnMocmFuZ2VfYm91bmRzWzBdIC0gcmFuZ2VfYm91bmRzWzFdKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5taW4odXNlcl9ib3VuZHNbMF0sIHVzZXJfYm91bmRzWzFdKSwgcmFuZ2VfYm91bmRzWzBdKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihNYXRoLm1heCh1c2VyX2JvdW5kc1swXSwgdXNlcl9ib3VuZHNbMV0pLCByYW5nZV9ib3VuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbih1c2VyX2JvdW5kc1swXSwgdXNlcl9ib3VuZHNbMV0pO1xuICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWF4KHVzZXJfYm91bmRzWzBdLCB1c2VyX2JvdW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJ1c2VyIGJvdW5kcyAnXCIgKyB1c2VyX2JvdW5kcyArIFwiJyBub3QgdW5kZXJzdG9vZFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBeGlzLnByb3RvdHlwZS5fcnVsZV9jb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb29yZHMsIGNyb3NzX3JhbmdlLCBlbmQsIGksIGosIHJhbmdlLCByZWYsIHJlZjEsIHN0YXJ0LCB4cywgeXM7XG4gICAgICAgIGkgPSB0aGlzLmRpbWVuc2lvbjtcbiAgICAgICAgaiA9IChpICsgMSkgJSAyO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcywgcmFuZ2UgPSByZWZbMF0sIGNyb3NzX3JhbmdlID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5jb21wdXRlZF9ib3VuZHMsIHN0YXJ0ID0gcmVmMVswXSwgZW5kID0gcmVmMVsxXTtcbiAgICAgICAgeHMgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIHlzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBjb29yZHMgPSBbeHMsIHlzXTtcbiAgICAgICAgY29vcmRzW2ldWzBdID0gTWF0aC5tYXgoc3RhcnQsIHJhbmdlLm1pbik7XG4gICAgICAgIGNvb3Jkc1tpXVsxXSA9IE1hdGgubWluKGVuZCwgcmFuZ2UubWF4KTtcbiAgICAgICAgaWYgKGNvb3Jkc1tpXVswXSA+IGNvb3Jkc1tpXVsxXSkge1xuICAgICAgICAgICAgY29vcmRzW2ldWzBdID0gY29vcmRzW2ldWzFdID0gMCAvIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzW2pdWzBdID0gdGhpcy5sb2M7XG4gICAgICAgIGNvb3Jkc1tqXVsxXSA9IHRoaXMubG9jO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH07XG4gICAgQXhpcy5wcm90b3R5cGUuX3RpY2tfY29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29vcmRzLCBjcm9zc19yYW5nZSwgZW5kLCBpLCBpaSwgaiwgaywgbCwgbSwgbWFqb3JzLCBtaW5vcl9jb29yZHMsIG1pbm9yX3hzLCBtaW5vcl95cywgbWlub3JzLCByYW5nZSwgcmFuZ2VfbWF4LCByYW5nZV9taW4sIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgc3RhcnQsIHRpY2tzLCB4cywgeXM7XG4gICAgICAgIGkgPSB0aGlzLmRpbWVuc2lvbjtcbiAgICAgICAgaiA9IChpICsgMSkgJSAyO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcywgcmFuZ2UgPSByZWZbMF0sIGNyb3NzX3JhbmdlID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5jb21wdXRlZF9ib3VuZHMsIHN0YXJ0ID0gcmVmMVswXSwgZW5kID0gcmVmMVsxXTtcbiAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tlci5nZXRfdGlja3Moc3RhcnQsIGVuZCwgcmFuZ2UsIHRoaXMubG9jLCB7fSk7XG4gICAgICAgIG1ham9ycyA9IHRpY2tzLm1ham9yO1xuICAgICAgICBtaW5vcnMgPSB0aWNrcy5taW5vcjtcbiAgICAgICAgeHMgPSBbXTtcbiAgICAgICAgeXMgPSBbXTtcbiAgICAgICAgY29vcmRzID0gW3hzLCB5c107XG4gICAgICAgIG1pbm9yX3hzID0gW107XG4gICAgICAgIG1pbm9yX3lzID0gW107XG4gICAgICAgIG1pbm9yX2Nvb3JkcyA9IFttaW5vcl94cywgbWlub3JfeXNdO1xuICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gXCJGYWN0b3JSYW5nZVwiKSB7XG4gICAgICAgICAgICBmb3IgKGlpID0gayA9IDAsIHJlZjIgPSBtYWpvcnMubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpaSA9IDAgPD0gcmVmMiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIGNvb3Jkc1tpXS5wdXNoKG1ham9yc1tpaV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkc1tqXS5wdXNoKHRoaXMubG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjMgPSBbcmFuZ2UubWluLCByYW5nZS5tYXhdLCByYW5nZV9taW4gPSByZWYzWzBdLCByYW5nZV9tYXggPSByZWYzWzFdO1xuICAgICAgICAgICAgZm9yIChpaSA9IGwgPSAwLCByZWY0ID0gbWFqb3JzLmxlbmd0aDsgMCA8PSByZWY0ID8gbCA8IHJlZjQgOiBsID4gcmVmNDsgaWkgPSAwIDw9IHJlZjQgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFqb3JzW2lpXSA8IHJhbmdlX21pbiB8fCBtYWpvcnNbaWldID4gcmFuZ2VfbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29yZHNbaV0ucHVzaChtYWpvcnNbaWldKTtcbiAgICAgICAgICAgICAgICBjb29yZHNbal0ucHVzaCh0aGlzLmxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGlpID0gbSA9IDAsIHJlZjUgPSBtaW5vcnMubGVuZ3RoOyAwIDw9IHJlZjUgPyBtIDwgcmVmNSA6IG0gPiByZWY1OyBpaSA9IDAgPD0gcmVmNSA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgICAgICAgIGlmIChtaW5vcnNbaWldIDwgcmFuZ2VfbWluIHx8IG1pbm9yc1tpaV0gPiByYW5nZV9tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pbm9yX2Nvb3Jkc1tpXS5wdXNoKG1pbm9yc1tpaV0pO1xuICAgICAgICAgICAgICAgIG1pbm9yX2Nvb3Jkc1tqXS5wdXNoKHRoaXMubG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJtYWpvclwiOiBjb29yZHMsXG4gICAgICAgICAgICBcIm1pbm9yXCI6IG1pbm9yX2Nvb3Jkc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQXhpcy5wcm90b3R5cGUuX2dldF9sb2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZW5kLCBjcm9zc19yYW5nZSwgY3N0YXJ0LCByYW5nZSwgcmVmLCBzaWRlO1xuICAgICAgICByZWYgPSB0aGlzLnJhbmdlcywgcmFuZ2UgPSByZWZbMF0sIGNyb3NzX3JhbmdlID0gcmVmWzFdO1xuICAgICAgICBjc3RhcnQgPSBjcm9zc19yYW5nZS5zdGFydDtcbiAgICAgICAgY2VuZCA9IGNyb3NzX3JhbmdlLmVuZDtcbiAgICAgICAgc2lkZSA9IHRoaXMucGFuZWxfc2lkZTtcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2JlbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzX3JhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEF4aXM7XG59KShndWlkZV9yZW5kZXJlcl8xLkd1aWRlUmVuZGVyZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGF4aXNfMSA9IHJlcXVpcmUoXCIuL2F4aXNcIik7XG52YXIgY2F0ZWdvcmljYWxfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi9mb3JtYXR0ZXJzL2NhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyXCIpO1xudmFyIGNhdGVnb3JpY2FsX3RpY2tlcl8xID0gcmVxdWlyZShcIi4uL3RpY2tlcnMvY2F0ZWdvcmljYWxfdGlja2VyXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG5leHBvcnRzLkNhdGVnb3JpY2FsQXhpc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2F0ZWdvcmljYWxBeGlzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsQXhpc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBDYXRlZ29yaWNhbEF4aXNWaWV3O1xufSkoYXhpc18xLkF4aXNWaWV3KTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxBeGlzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhdGVnb3JpY2FsQXhpcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxBeGlzKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxBeGlzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYXRlZ29yaWNhbEF4aXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ2F0ZWdvcmljYWxBeGlzVmlldztcbiAgICBDYXRlZ29yaWNhbEF4aXMucHJvdG90eXBlLnR5cGUgPSAnQ2F0ZWdvcmljYWxBeGlzJztcbiAgICBDYXRlZ29yaWNhbEF4aXMub3ZlcnJpZGUoe1xuICAgICAgICB0aWNrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2F0ZWdvcmljYWxfdGlja2VyXzEuQ2F0ZWdvcmljYWxUaWNrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyXzEuQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDYXRlZ29yaWNhbEF4aXMucHJvdG90eXBlLl9jb21wdXRlZF9ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjcm9zc19yYW5nZSwgcmFuZ2UsIHJhbmdlX2JvdW5kcywgcmVmLCByZWYxLCB1c2VyX2JvdW5kcztcbiAgICAgICAgcmVmID0gdGhpcy5yYW5nZXMsIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgdXNlcl9ib3VuZHMgPSAocmVmMSA9IHRoaXMuYm91bmRzKSAhPSBudWxsID8gcmVmMSA6ICdhdXRvJztcbiAgICAgICAgcmFuZ2VfYm91bmRzID0gW3JhbmdlLm1pbiwgcmFuZ2UubWF4XTtcbiAgICAgICAgaWYgKHVzZXJfYm91bmRzICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIkNhdGVnb3JpY2FsIEF4ZXMgb25seSBzdXBwb3J0IHVzZXJfYm91bmRzPSdhdXRvJywgaWdub3JpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlX2JvdW5kcztcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yaWNhbEF4aXM7XG59KShheGlzXzEuQXhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYXhpc18xID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbmV4cG9ydHMuQ29udGludW91c0F4aXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29udGludW91c0F4aXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENvbnRpbnVvdXNBeGlzKCkge1xuICAgICAgICByZXR1cm4gQ29udGludW91c0F4aXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRpbnVvdXNBeGlzLnByb3RvdHlwZS50eXBlID0gJ0NvbnRpbnVvdXNBeGlzJztcbiAgICByZXR1cm4gQ29udGludW91c0F4aXM7XG59KShheGlzXzEuQXhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbGluZWFyX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2xpbmVhcl9heGlzXCIpO1xudmFyIGRhdGV0aW1lX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vZm9ybWF0dGVycy9kYXRldGltZV90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBkYXRldGltZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuLi90aWNrZXJzL2RhdGV0aW1lX3RpY2tlclwiKTtcbmV4cG9ydHMuRGF0ZXRpbWVBeGlzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRldGltZUF4aXNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEYXRldGltZUF4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gRGF0ZXRpbWVBeGlzVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIERhdGV0aW1lQXhpc1ZpZXc7XG59KShsaW5lYXJfYXhpc18xLkxpbmVhckF4aXNWaWV3KTtcbmV4cG9ydHMuRGF0ZXRpbWVBeGlzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGV0aW1lQXhpcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZXRpbWVBeGlzKCkge1xuICAgICAgICByZXR1cm4gRGF0ZXRpbWVBeGlzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRldGltZUF4aXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRGF0ZXRpbWVBeGlzVmlldztcbiAgICBEYXRldGltZUF4aXMucHJvdG90eXBlLnR5cGUgPSAnRGF0ZXRpbWVBeGlzJztcbiAgICBEYXRldGltZUF4aXMub3ZlcnJpZGUoe1xuICAgICAgICB0aWNrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGF0ZXRpbWVfdGlja2VyXzEuRGF0ZXRpbWVUaWNrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRhdGV0aW1lX3RpY2tfZm9ybWF0dGVyXzEuRGF0ZXRpbWVUaWNrRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gRGF0ZXRpbWVBeGlzO1xufSkobGluZWFyX2F4aXNfMS5MaW5lYXJBeGlzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF4aXNfMSA9IHJlcXVpcmUoXCIuL2F4aXNcIik7XG5leHBvcnRzLkF4aXMgPSBheGlzXzEuQXhpcztcbnZhciBjYXRlZ29yaWNhbF9heGlzXzEgPSByZXF1aXJlKFwiLi9jYXRlZ29yaWNhbF9heGlzXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbEF4aXMgPSBjYXRlZ29yaWNhbF9heGlzXzEuQ2F0ZWdvcmljYWxBeGlzO1xudmFyIGNvbnRpbnVvdXNfYXhpc18xID0gcmVxdWlyZShcIi4vY29udGludW91c19heGlzXCIpO1xuZXhwb3J0cy5Db250aW51b3VzQXhpcyA9IGNvbnRpbnVvdXNfYXhpc18xLkNvbnRpbnVvdXNBeGlzO1xudmFyIGRhdGV0aW1lX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2RhdGV0aW1lX2F4aXNcIik7XG5leHBvcnRzLkRhdGV0aW1lQXhpcyA9IGRhdGV0aW1lX2F4aXNfMS5EYXRldGltZUF4aXM7XG52YXIgbGluZWFyX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2xpbmVhcl9heGlzXCIpO1xuZXhwb3J0cy5MaW5lYXJBeGlzID0gbGluZWFyX2F4aXNfMS5MaW5lYXJBeGlzO1xudmFyIGxvZ19heGlzXzEgPSByZXF1aXJlKFwiLi9sb2dfYXhpc1wiKTtcbmV4cG9ydHMuTG9nQXhpcyA9IGxvZ19heGlzXzEuTG9nQXhpcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBheGlzXzEgPSByZXF1aXJlKFwiLi9heGlzXCIpO1xudmFyIGNvbnRpbnVvdXNfYXhpc18xID0gcmVxdWlyZShcIi4vY29udGludW91c19heGlzXCIpO1xudmFyIGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vZm9ybWF0dGVycy9iYXNpY190aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBiYXNpY190aWNrZXJfMSA9IHJlcXVpcmUoXCIuLi90aWNrZXJzL2Jhc2ljX3RpY2tlclwiKTtcbmV4cG9ydHMuTGluZWFyQXhpc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZWFyQXhpc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExpbmVhckF4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQXhpc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBMaW5lYXJBeGlzVmlldztcbn0pKGF4aXNfMS5BeGlzVmlldyk7XG5leHBvcnRzLkxpbmVhckF4aXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZWFyQXhpcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZWFyQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckF4aXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVhckF4aXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGluZWFyQXhpc1ZpZXc7XG4gICAgTGluZWFyQXhpcy5wcm90b3R5cGUudHlwZSA9ICdMaW5lYXJBeGlzJztcbiAgICBMaW5lYXJBeGlzLm92ZXJyaWRlKHtcbiAgICAgICAgdGlja2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJhc2ljX3RpY2tlcl8xLkJhc2ljVGlja2VyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNpY190aWNrX2Zvcm1hdHRlcl8xLkJhc2ljVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIExpbmVhckF4aXM7XG59KShjb250aW51b3VzX2F4aXNfMS5Db250aW51b3VzQXhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYXhpc18xID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbnZhciBjb250aW51b3VzX2F4aXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfYXhpc1wiKTtcbnZhciBsb2dfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi9mb3JtYXR0ZXJzL2xvZ190aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBsb2dfdGlja2VyXzEgPSByZXF1aXJlKFwiLi4vdGlja2Vycy9sb2dfdGlja2VyXCIpO1xuZXhwb3J0cy5Mb2dBeGlzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dBeGlzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTG9nQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBMb2dBeGlzVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIExvZ0F4aXNWaWV3O1xufSkoYXhpc18xLkF4aXNWaWV3KTtcbmV4cG9ydHMuTG9nQXhpcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dBeGlzLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMb2dBeGlzKCkge1xuICAgICAgICByZXR1cm4gTG9nQXhpcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9nQXhpcy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Mb2dBeGlzVmlldztcbiAgICBMb2dBeGlzLnByb3RvdHlwZS50eXBlID0gJ0xvZ0F4aXMnO1xuICAgIExvZ0F4aXMub3ZlcnJpZGUoe1xuICAgICAgICB0aWNrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbG9nX3RpY2tlcl8xLkxvZ1RpY2tlcigpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbG9nX3RpY2tfZm9ybWF0dGVyXzEuTG9nVGlja0Zvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ0F4aXM7XG59KShjb250aW51b3VzX2F4aXNfMS5Db250aW51b3VzQXhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIHNsaWNlID0gW10uc2xpY2U7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5DdXN0b21KUyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDdXN0b21KUywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ3VzdG9tSlMoKSB7XG4gICAgICAgIHJldHVybiBDdXN0b21KUy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ3VzdG9tSlMucHJvdG90eXBlLnR5cGUgPSAnQ3VzdG9tSlMnO1xuICAgIEN1c3RvbUpTLmRlZmluZSh7XG4gICAgICAgIGFyZ3M6IFtwLkFueSwge31dLFxuICAgICAgICBjb2RlOiBbcC5TdHJpbmcsICcnXVxuICAgIH0pO1xuICAgIEN1c3RvbUpTLmdldHRlcnMoe1xuICAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlX3ZhbHVlcygpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZV9mdW5jKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDdXN0b21KUy5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChjYl9vYmosIGNiX2RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYy5hcHBseSh0aGlzLCBzbGljZS5jYWxsKHRoaXMudmFsdWVzKS5jb25jYXQoW2NiX29ial0sIFtjYl9kYXRhXSwgW3JlcXVpcmVdLCBbe31dKSk7XG4gICAgfTtcbiAgICBDdXN0b21KUy5wcm90b3R5cGUuX21ha2VfdmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0XzEudmFsdWVzKHRoaXMuYXJncyk7XG4gICAgfTtcbiAgICBDdXN0b21KUy5wcm90b3R5cGUuX21ha2VfZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoZnVuYywgYXJncywgY3Rvcikge1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5ldyBjdG9yLCByZXN1bHQgPSBmdW5jLmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0ID8gcmVzdWx0IDogY2hpbGQ7XG4gICAgICAgIH0pKEZ1bmN0aW9uLCBzbGljZS5jYWxsKE9iamVjdC5rZXlzKHRoaXMuYXJncykpLmNvbmNhdChbXCJjYl9vYmpcIl0sIFtcImNiX2RhdGFcIl0sIFtcInJlcXVpcmVcIl0sIFtcImV4cG9ydHNcIl0sIFt0aGlzLmNvZGVdKSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21KUztcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY3VzdG9tanNfMSA9IHJlcXVpcmUoXCIuL2N1c3RvbWpzXCIpO1xuZXhwb3J0cy5DdXN0b21KUyA9IGN1c3RvbWpzXzEuQ3VzdG9tSlM7XG52YXIgb3Blbl91cmxfMSA9IHJlcXVpcmUoXCIuL29wZW5fdXJsXCIpO1xuZXhwb3J0cy5PcGVuVVJMID0gb3Blbl91cmxfMS5PcGVuVVJMO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NlbGVjdGlvblwiKTtcbnZhciB0ZW1wbGF0aW5nXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3RlbXBsYXRpbmdcIik7XG5leHBvcnRzLk9wZW5VUkwgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoT3BlblVSTCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gT3BlblVSTCgpIHtcbiAgICAgICAgcmV0dXJuIE9wZW5VUkwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE9wZW5VUkwucHJvdG90eXBlLnR5cGUgPSAnT3BlblVSTCc7XG4gICAgT3BlblVSTC5kZWZpbmUoe1xuICAgICAgICB1cmw6IFtwLlN0cmluZywgJ2h0dHA6Ly8nXVxuICAgIH0pO1xuICAgIE9wZW5VUkwucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YV9zb3VyY2UpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVmLCB1cmw7XG4gICAgICAgIHJlZiA9IHNlbGVjdGlvbl8xLmdldF9pbmRpY2VzKGRhdGFfc291cmNlKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gcmVmW2pdO1xuICAgICAgICAgICAgdXJsID0gdGVtcGxhdGluZ18xLnJlcGxhY2VfcGxhY2Vob2xkZXJzKHRoaXMudXJsLCBkYXRhX3NvdXJjZSwgaSk7XG4gICAgICAgICAgICB3aW5kb3cub3Blbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZW5VUkw7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjYW52YXNfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL2NhbnZhc190ZW1wbGF0ZVwiKTtcbnZhciBsYXlvdXRfY2FudmFzXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvbGF5b3V0X2NhbnZhc1wiKTtcbnZhciBib2tlaF92aWV3XzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF92aWV3XCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGVxXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2VxXCIpO1xudmFyIGNhbnZhc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jYW52YXNcIik7XG5leHBvcnRzLkNhbnZhc1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2FudmFzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2FudmFzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIENhbnZhc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbnZhc1ZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstY2FudmFzLXdyYXBwZXJcIjtcbiAgICBDYW52YXNWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IGNhbnZhc190ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBodG1sO1xuICAgICAgICBDYW52YXNWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGh0bWwgPSB0aGlzLnRlbXBsYXRlKHtcbiAgICAgICAgICAgIG1hcDogdGhpcy5tb2RlbC5tYXBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5nZXRfY3R4KCk7XG4gICAgICAgIGNhbnZhc18xLmZpeHVwX2xpbmVfZGFzaCh0aGlzLmN0eCk7XG4gICAgICAgIGNhbnZhc18xLmZpeHVwX2xpbmVfZGFzaF9vZmZzZXQodGhpcy5jdHgpO1xuICAgICAgICBjYW52YXNfMS5maXh1cF9pbWFnZV9zbW9vdGhpbmcodGhpcy5jdHgpO1xuICAgICAgICBjYW52YXNfMS5maXh1cF9tZWFzdXJlX3RleHQodGhpcy5jdHgpO1xuICAgICAgICBjYW52YXNfMS5maXh1cF9lbGxpcHNlKHRoaXMuY3R4KTtcbiAgICAgICAgaWYgKHdpbmRvdy5DYW52YXNQaXhlbEFycmF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIENhbnZhc1BpeGVsQXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpc1tpXSA9IGFycltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcF9kaXYgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5iay1jYW52YXMtbWFwJyk7XG4gICAgICAgIHRoaXMuc2V0X2RpbXMoW3RoaXMubW9kZWwuaW5pdGlhbF93aWR0aCwgdGhpcy5tb2RlbC5pbml0aWFsX2hlaWdodF0pO1xuICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIkNhbnZhc1ZpZXcgaW5pdGlhbGl6ZWRcIik7XG4gICAgfTtcbiAgICBDYW52YXNWaWV3LnByb3RvdHlwZS5nZXRfY2FudmFzX2VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5iay1jYW52YXMnKTtcbiAgICB9O1xuICAgIENhbnZhc1ZpZXcucHJvdG90eXBlLmdldF9jdHggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9jYW52YXNfZWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgfTtcbiAgICBDYW52YXNWaWV3LnByb3RvdHlwZS5wcmVwYXJlX2NhbnZhcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICB2YXIgY2FudmFzX2VsLCBkcHIsIGhlaWdodCwgcmF0aW8sIHdpZHRoO1xuICAgICAgICBpZiAoZm9yY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IHRoaXMubW9kZWwuX3dpZHRoLl92YWx1ZTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0Ll92YWx1ZTtcbiAgICAgICAgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGlmICghZXFfMS5pc0VxdWFsKHRoaXMubGFzdF9kaW1zLCBbd2lkdGgsIGhlaWdodCwgZHByXSkgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5waXhlbF9yYXRpbyA9IHJhdGlvID0gY2FudmFzXzEuZ2V0X3NjYWxlX3JhdGlvKHRoaXMuY3R4LCB0aGlzLm1vZGVsLnVzZV9oaWRwaSk7XG4gICAgICAgICAgICBjYW52YXNfZWwgPSB0aGlzLmdldF9jYW52YXNfZWxlbWVudCgpO1xuICAgICAgICAgICAgY2FudmFzX2VsLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICBjYW52YXNfZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgY2FudmFzX2VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICAgIGNhbnZhc19lbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJSZW5kZXJpbmcgQ2FudmFzVmlldyBbZm9yY2U9XCIgKyBmb3JjZSArIFwiXSB3aXRoIHdpZHRoOiBcIiArIHdpZHRoICsgXCIsIGhlaWdodDogXCIgKyBoZWlnaHQgKyBcIiwgcmF0aW86IFwiICsgcmF0aW8pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5waXhlbF9yYXRpbyA9IHRoaXMucGl4ZWxfcmF0aW87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0X2RpbXMgPSBbd2lkdGgsIGhlaWdodCwgZHByXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUuc2V0X2RpbXMgPSBmdW5jdGlvbiAoZGltcywgdHJpZ2dlcikge1xuICAgICAgICBpZiAodHJpZ2dlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RlZF93aWR0aCA9IGRpbXNbMF07XG4gICAgICAgIHRoaXMucmVxdWVzdGVkX2hlaWdodCA9IGRpbXNbMV07XG4gICAgICAgIHRoaXMudXBkYXRlX2NvbnN0cmFpbnRzKHRyaWdnZXIpO1xuICAgIH07XG4gICAgQ2FudmFzVmlldy5wcm90b3R5cGUudXBkYXRlX2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIE1JTl9TSVpFLCByZXF1ZXN0ZWRfaGVpZ2h0LCByZXF1ZXN0ZWRfd2lkdGgsIHM7XG4gICAgICAgIGlmICh0cmlnZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RlZF93aWR0aCA9IHRoaXMucmVxdWVzdGVkX3dpZHRoO1xuICAgICAgICByZXF1ZXN0ZWRfaGVpZ2h0ID0gdGhpcy5yZXF1ZXN0ZWRfaGVpZ2h0O1xuICAgICAgICBpZiAoKHJlcXVlc3RlZF93aWR0aCA9PSBudWxsKSB8fCAocmVxdWVzdGVkX2hlaWdodCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE1JTl9TSVpFID0gNTA7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRfd2lkdGggPCBNSU5fU0laRSB8fCByZXF1ZXN0ZWRfaGVpZ2h0IDwgTUlOX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXFfMS5pc0VxdWFsKHRoaXMubGFzdF9yZXF1ZXN0ZWRfZGltcywgW3JlcXVlc3RlZF93aWR0aCwgcmVxdWVzdGVkX2hlaWdodF0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHRoaXMubW9kZWwuZG9jdW1lbnQuc29sdmVyKCk7XG4gICAgICAgIGlmICh0aGlzLl93aWR0aF9jb25zdHJhaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHMucmVtb3ZlX2NvbnN0cmFpbnQodGhpcy5fd2lkdGhfY29uc3RyYWludCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2lkdGhfY29uc3RyYWludCA9IHNvbHZlcl8xLkVRKHRoaXMubW9kZWwuX3dpZHRoLCAtcmVxdWVzdGVkX3dpZHRoKTtcbiAgICAgICAgcy5hZGRfY29uc3RyYWludCh0aGlzLl93aWR0aF9jb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2hlaWdodF9jb25zdHJhaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHMucmVtb3ZlX2NvbnN0cmFpbnQodGhpcy5faGVpZ2h0X2NvbnN0cmFpbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlaWdodF9jb25zdHJhaW50ID0gc29sdmVyXzEuRVEodGhpcy5tb2RlbC5faGVpZ2h0LCAtcmVxdWVzdGVkX2hlaWdodCk7XG4gICAgICAgIHMuYWRkX2NvbnN0cmFpbnQodGhpcy5faGVpZ2h0X2NvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLmxhc3RfcmVxdWVzdGVkX2RpbXMgPSBbcmVxdWVzdGVkX3dpZHRoLCByZXF1ZXN0ZWRfaGVpZ2h0XTtcbiAgICAgICAgcmV0dXJuIHMudXBkYXRlX3ZhcmlhYmxlcyh0cmlnZ2VyKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW52YXNWaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLkNhbnZhcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDYW52YXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIENhbnZhcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FudmFzLnByb3RvdHlwZS50eXBlID0gJ0NhbnZhcyc7XG4gICAgQ2FudmFzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNhbnZhc1ZpZXc7XG4gICAgQ2FudmFzLmludGVybmFsKHtcbiAgICAgICAgbWFwOiBbcC5Cb29sZWFuLCBmYWxzZV0sXG4gICAgICAgIGluaXRpYWxfd2lkdGg6IFtwLk51bWJlcl0sXG4gICAgICAgIGluaXRpYWxfaGVpZ2h0OiBbcC5OdW1iZXJdLFxuICAgICAgICB1c2VfaGlkcGk6IFtwLkJvb2xlYW4sIHRydWVdLFxuICAgICAgICBwaXhlbF9yYXRpbzogW3AuTnVtYmVyXVxuICAgIH0pO1xuICAgIENhbnZhcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBDYW52YXMuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsID0gdGhpcztcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudnhfdG9fc3ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudnlfdG9fc3kgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0Ll92YWx1ZSAtICh5ICsgMSk7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLnZfdnhfdG9fc3ggPSBmdW5jdGlvbiAoeHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoeHgpO1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS52X3Z5X3RvX3N5ID0gZnVuY3Rpb24gKHl5KSB7XG4gICAgICAgIHZhciBfeXksIGhlaWdodCwgaWR4LCBqLCBsZW4sIHk7XG4gICAgICAgIF95eSA9IG5ldyBGbG9hdDY0QXJyYXkoeXkubGVuZ3RoKTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0Ll92YWx1ZTtcbiAgICAgICAgZm9yIChpZHggPSBqID0gMCwgbGVuID0geXkubGVuZ3RoOyBqIDwgbGVuOyBpZHggPSArK2opIHtcbiAgICAgICAgICAgIHkgPSB5eVtpZHhdO1xuICAgICAgICAgICAgX3l5W2lkeF0gPSBoZWlnaHQgLSAoeSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfeXk7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLnN4X3RvX3Z4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLnN5X3RvX3Z5ID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodC5fdmFsdWUgLSAoeSArIDEpO1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS52X3N4X3RvX3Z4ID0gZnVuY3Rpb24gKHh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KHh4KTtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudl9zeV90b192eSA9IGZ1bmN0aW9uICh5eSkge1xuICAgICAgICB2YXIgX3l5LCBoZWlnaHQsIGlkeCwgaiwgbGVuLCB5O1xuICAgICAgICBfeXkgPSBuZXcgRmxvYXQ2NEFycmF5KHl5Lmxlbmd0aCk7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodC5fdmFsdWU7XG4gICAgICAgIGZvciAoaWR4ID0gaiA9IDAsIGxlbiA9IHl5Lmxlbmd0aDsgaiA8IGxlbjsgaWR4ID0gKytqKSB7XG4gICAgICAgICAgICB5ID0geXlbaWR4XTtcbiAgICAgICAgICAgIF95eVtpZHhdID0gaGVpZ2h0IC0gKHkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3l5O1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cztcbiAgICAgICAgY29uc3RyYWludHMgPSBDYW52YXMuX19zdXBlcl9fLmdldF9jb25zdHJhaW50cy5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX3RvcCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2JvdHRvbSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2xlZnQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9yaWdodCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX3dpZHRoKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5faGVpZ2h0KSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5fd2lkdGgsIFstMSwgdGhpcy5fcmlnaHRdKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMuX3RvcF0pKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIENhbnZhcztcbn0pKGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRE9NID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgcmV0dXJuIChET00uY3JlYXRlRWxlbWVudChcImZyYWdtZW50XCIsIG51bGwsXG4gICAgICAgIHByb3BzLm1hcCAmJiBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiBcImJrLWNhbnZhcy1tYXBcIiB9KSxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogXCJiay1jYW52YXMtZXZlbnRzXCIgfSksXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6IFwiYmstY2FudmFzLW92ZXJsYXlzXCIgfSksXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgY2xhc3M6ICdiay1jYW52YXMnIH0pKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGNhdGVnb3JpY2FsX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvY2F0ZWdvcmljYWxfbWFwcGVyXCIpO1xudmFyIGxpbmVhcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tYXBwZXJzL2xpbmVhcl9tYXBwZXJcIik7XG52YXIgbG9nX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvbG9nX21hcHBlclwiKTtcbnZhciByYW5nZTFkXzEgPSByZXF1aXJlKFwiLi4vcmFuZ2VzL3JhbmdlMWRcIik7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIGxheW91dF9jYW52YXNfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9sYXlvdXRfY2FudmFzXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkNhcnRlc2lhbkZyYW1lID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhcnRlc2lhbkZyYW1lLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDYXJ0ZXNpYW5GcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIENhcnRlc2lhbkZyYW1lLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUudHlwZSA9ICdDYXJ0ZXNpYW5GcmFtZSc7XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQ2FydGVzaWFuRnJhbWUuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGFuZWwgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb25maWd1cmVfbWFwcGVycygpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2UnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29uZmlndXJlX21hcHBlcnMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuX2RvY19hdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmRvY3VtZW50LnNvbHZlcigpLCAnbGF5b3V0X3VwZGF0ZScsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfbWFwcGVycygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2eCwgdnkpIHtcbiAgICAgICAgcmV0dXJuIHZ4ID49IHRoaXMubGVmdCAmJiB2eCA8PSB0aGlzLnJpZ2h0ICYmIHZ5ID49IHRoaXMuYm90dG9tICYmIHZ5IDw9IHRoaXMudG9wO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLm1hcF90b19zY3JlZW4gPSBmdW5jdGlvbiAoeCwgeSwgY2FudmFzLCB4X25hbWUsIHlfbmFtZSkge1xuICAgICAgICB2YXIgc3gsIHN5LCB2eCwgdnk7XG4gICAgICAgIGlmICh4X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeF9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeV9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHZ4ID0gdGhpcy54X21hcHBlcnNbeF9uYW1lXS52X21hcF90b190YXJnZXQoeCk7XG4gICAgICAgIHN4ID0gY2FudmFzLnZfdnhfdG9fc3godngpO1xuICAgICAgICB2eSA9IHRoaXMueV9tYXBwZXJzW3lfbmFtZV0udl9tYXBfdG9fdGFyZ2V0KHkpO1xuICAgICAgICBzeSA9IGNhbnZhcy52X3Z5X3RvX3N5KHZ5KTtcbiAgICAgICAgcmV0dXJuIFtzeCwgc3ldO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLl9nZXRfcmFuZ2VzID0gZnVuY3Rpb24gKHJhbmdlLCBleHRyYV9yYW5nZXMpIHtcbiAgICAgICAgdmFyIGV4dHJhX3JhbmdlLCBuYW1lLCByYW5nZXM7XG4gICAgICAgIHJhbmdlcyA9IHt9O1xuICAgICAgICByYW5nZXNbJ2RlZmF1bHQnXSA9IHJhbmdlO1xuICAgICAgICBpZiAoZXh0cmFfcmFuZ2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBleHRyYV9yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBleHRyYV9yYW5nZSA9IGV4dHJhX3Jhbmdlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICByYW5nZXNbbmFtZV0gPSBleHRyYV9yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH07XG4gICAgQ2FydGVzaWFuRnJhbWUucHJvdG90eXBlLl9nZXRfbWFwcGVycyA9IGZ1bmN0aW9uIChtYXBwZXJfdHlwZSwgcmFuZ2VzLCBmcmFtZV9yYW5nZSkge1xuICAgICAgICB2YXIgbWFwcGVyX21vZGVsLCBtYXBwZXJzLCBuYW1lLCByYW5nZTtcbiAgICAgICAgbWFwcGVycyA9IHt9O1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmFuZ2VzKSB7XG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSBcIlJhbmdlMWRcIiB8fCByYW5nZS50eXBlID09PSBcIkRhdGFSYW5nZTFkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVyX3R5cGUgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVyX21vZGVsID0gbG9nX21hcHBlcl8xLkxvZ01hcHBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBlcl9tb2RlbCA9IGxpbmVhcl9tYXBwZXJfMS5MaW5lYXJNYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlLm1hcHBlcl9oaW50ID0gbWFwcGVyX3R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZS50eXBlID09PSBcIkZhY3RvclJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBtYXBwZXJfbW9kZWwgPSBjYXRlZ29yaWNhbF9tYXBwZXJfMS5DYXRlZ29yaWNhbE1hcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcInVua25vd24gcmFuZ2UgdHlwZSBmb3IgcmFuZ2UgJ1wiICsgbmFtZSArIFwiJzogXCIgKyByYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwZXJzW25hbWVdID0gbmV3IG1hcHBlcl9tb2RlbCh7XG4gICAgICAgICAgICAgICAgc291cmNlX3JhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRfcmFuZ2U6IGZyYW1lX3JhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVycztcbiAgICB9O1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5fY29uZmlndXJlX2ZyYW1lX3JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faF9yYW5nZSA9IG5ldyByYW5nZTFkXzEuUmFuZ2UxZCh7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5sZWZ0LFxuICAgICAgICAgICAgZW5kOiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdl9yYW5nZSA9IG5ldyByYW5nZTFkXzEuUmFuZ2UxZCh7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5ib3R0b20sXG4gICAgICAgICAgICBlbmQ6IHRoaXMuYm90dG9tICsgdGhpcy5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5wcm90b3R5cGUuX2NvbmZpZ3VyZV9tYXBwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb25maWd1cmVfZnJhbWVfcmFuZ2VzKCk7XG4gICAgICAgIHRoaXMuX3hfcmFuZ2VzID0gdGhpcy5fZ2V0X3Jhbmdlcyh0aGlzLnhfcmFuZ2UsIHRoaXMuZXh0cmFfeF9yYW5nZXMpO1xuICAgICAgICB0aGlzLl95X3JhbmdlcyA9IHRoaXMuX2dldF9yYW5nZXModGhpcy55X3JhbmdlLCB0aGlzLmV4dHJhX3lfcmFuZ2VzKTtcbiAgICAgICAgdGhpcy5feF9tYXBwZXJzID0gdGhpcy5fZ2V0X21hcHBlcnModGhpcy54X21hcHBlcl90eXBlLCB0aGlzLl94X3JhbmdlcywgdGhpcy5faF9yYW5nZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl95X21hcHBlcnMgPSB0aGlzLl9nZXRfbWFwcGVycyh0aGlzLnlfbWFwcGVyX3R5cGUsIHRoaXMuX3lfcmFuZ2VzLCB0aGlzLl92X3JhbmdlKTtcbiAgICB9O1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5fdXBkYXRlX21hcHBlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXBwZXIsIG5hbWUsIHJlZiwgcmVmMTtcbiAgICAgICAgdGhpcy5fY29uZmlndXJlX2ZyYW1lX3JhbmdlcygpO1xuICAgICAgICByZWYgPSB0aGlzLl94X21hcHBlcnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIG1hcHBlciA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgIG1hcHBlci50YXJnZXRfcmFuZ2UgPSB0aGlzLl9oX3JhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSB0aGlzLl95X21hcHBlcnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYxKSB7XG4gICAgICAgICAgICBtYXBwZXIgPSByZWYxW25hbWVdO1xuICAgICAgICAgICAgbWFwcGVyLnRhcmdldF9yYW5nZSA9IHRoaXMuX3ZfcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYXJ0ZXNpYW5GcmFtZS5nZXR0ZXJzKHtcbiAgICAgICAgaF9yYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hfcmFuZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHZfcmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92X3JhbmdlO1xuICAgICAgICB9LFxuICAgICAgICB4X3JhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3hfcmFuZ2VzO1xuICAgICAgICB9LFxuICAgICAgICB5X3JhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3lfcmFuZ2VzO1xuICAgICAgICB9LFxuICAgICAgICB4X21hcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl94X21hcHBlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIHlfbWFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3lfbWFwcGVycztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhcnRlc2lhbkZyYW1lLmludGVybmFsKHtcbiAgICAgICAgZXh0cmFfeF9yYW5nZXM6IFtwLkFueSwge31dLFxuICAgICAgICBleHRyYV95X3JhbmdlczogW3AuQW55LCB7fV0sXG4gICAgICAgIHhfcmFuZ2U6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgeV9yYW5nZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICB4X21hcHBlcl90eXBlOiBbcC5TdHJpbmcsICdhdXRvJ10sXG4gICAgICAgIHlfbWFwcGVyX3R5cGU6IFtwLlN0cmluZywgJ2F1dG8nXVxuICAgIH0pO1xuICAgIENhcnRlc2lhbkZyYW1lLnByb3RvdHlwZS5nZXRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cztcbiAgICAgICAgY29uc3RyYWludHMgPSBbXTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl90b3ApKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9ib3R0b20pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9sZWZ0KSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5fcmlnaHQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl93aWR0aCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2hlaWdodCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX2xlZnQsIHRoaXMuX3dpZHRoLCBbLTEsIHRoaXMuX3JpZ2h0XSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX2JvdHRvbSwgdGhpcy5faGVpZ2h0LCBbLTEsIHRoaXMuX3RvcF0pKTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIENhcnRlc2lhbkZyYW1lO1xufSkobGF5b3V0X2NhbnZhc18xLkxheW91dENhbnZhcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYW52YXNfMSA9IHJlcXVpcmUoXCIuL2NhbnZhc1wiKTtcbmV4cG9ydHMuQ2FudmFzID0gY2FudmFzXzEuQ2FudmFzO1xudmFyIGNhcnRlc2lhbl9mcmFtZV8xID0gcmVxdWlyZShcIi4vY2FydGVzaWFuX2ZyYW1lXCIpO1xuZXhwb3J0cy5DYXJ0ZXNpYW5GcmFtZSA9IGNhcnRlc2lhbl9mcmFtZV8xLkNhcnRlc2lhbkZyYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuQmFzaWNUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJhc2ljVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQmFzaWNUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gQmFzaWNUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnQmFzaWNUaWNrRm9ybWF0dGVyJztcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgcHJlY2lzaW9uOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIHVzZV9zY2llbnRpZmljOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgcG93ZXJfbGltaXRfaGlnaDogW3AuTnVtYmVyLCA1XSxcbiAgICAgICAgcG93ZXJfbGltaXRfbG93OiBbcC5OdW1iZXIsIC0zXVxuICAgIH0pO1xuICAgIEJhc2ljVGlja0Zvcm1hdHRlci5nZXR0ZXJzKHtcbiAgICAgICAgc2NpZW50aWZpY19saW1pdF9sb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygxMC4wLCB0aGlzLnBvd2VyX2xpbWl0X2xvdyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjaWVudGlmaWNfbGltaXRfaGlnaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLjAsIHRoaXMucG93ZXJfbGltaXRfaGlnaCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQmFzaWNUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0X3ByZWNpc2lvbiA9IDM7XG4gICAgfTtcbiAgICBCYXNpY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MpIHtcbiAgICAgICAgdmFyIGksIGlzX29rLCBqLCBrLCBsLCBsYWJlbHMsIGxlbiwgbSwgbiwgbmVlZF9zY2ksIG8sIHByZWNpc2lvbiwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCB0aWNrLCB0aWNrX2FicywgeCwgemVyb19lcHM7XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB6ZXJvX2VwcyA9IDA7XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgemVyb19lcHMgPSBNYXRoLmFicyh0aWNrc1sxXSAtIHRpY2tzWzBdKSAvIDEwMDAwO1xuICAgICAgICB9XG4gICAgICAgIG5lZWRfc2NpID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnVzZV9zY2llbnRpZmljKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSB0aWNrcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrc1tqXTtcbiAgICAgICAgICAgICAgICB0aWNrX2FicyA9IE1hdGguYWJzKHRpY2spO1xuICAgICAgICAgICAgICAgIGlmICh0aWNrX2FicyA+IHplcm9fZXBzICYmICh0aWNrX2FicyA+PSB0aGlzLnNjaWVudGlmaWNfbGltaXRfaGlnaCB8fCB0aWNrX2FicyA8PSB0aGlzLnNjaWVudGlmaWNfbGltaXRfbG93KSkge1xuICAgICAgICAgICAgICAgICAgICBuZWVkX3NjaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVjaXNpb24gPSB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgaWYgKChwcmVjaXNpb24gPT0gbnVsbCkgfHwgdHlwZXNfMS5pc051bWJlcihwcmVjaXNpb24pKSB7XG4gICAgICAgICAgICBsYWJlbHMgPSBuZXcgQXJyYXkodGlja3MubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChuZWVkX3NjaSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aWNrcy5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHNbaV0gPSB0aWNrc1tpXS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiB8fCB2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGwgPSAwLCByZWYxID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZjEgPyBsIDwgcmVmMSA6IGwgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsc1tpXSA9IHRpY2tzW2ldLnRvRml4ZWQocHJlY2lzaW9uIHx8IHZvaWQgMCkucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgXCIkMVwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgbGFiZWxzID0gbmV3IEFycmF5KHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHggPSBtID0gcmVmMiA9IHRoaXMubGFzdF9wcmVjaXNpb247IHJlZjIgPD0gMTUgPyBtIDw9IDE1IDogbSA+PSAxNTsgeCA9IHJlZjIgPD0gMTUgPyArK20gOiAtLW0pIHtcbiAgICAgICAgICAgICAgICBpc19vayA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRfc2NpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG4gPSAwLCByZWYzID0gdGlja3MubGVuZ3RoOyAwIDw9IHJlZjMgPyBuIDwgcmVmMyA6IG4gPiByZWYzOyBpID0gMCA8PSByZWYzID8gKytuIDogLS1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNbaV0gPSB0aWNrc1tpXS50b0V4cG9uZW50aWFsKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsc1tpXSA9PT0gbGFiZWxzW2kgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19vayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbyA9IDAsIHJlZjQgPSB0aWNrcy5sZW5ndGg7IDAgPD0gcmVmNCA/IG8gPCByZWY0IDogbyA+IHJlZjQ7IGkgPSAwIDw9IHJlZjQgPyArK28gOiAtLW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsc1tpXSA9IHRpY2tzW2ldLnRvRml4ZWQoeCkucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgXCIkMVwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxzW2ldID09PSBsYWJlbHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzX29rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc19vaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RfcHJlY2lzaW9uID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBCYXNpY1RpY2tGb3JtYXR0ZXI7XG59KSh0aWNrX2Zvcm1hdHRlcl8xLlRpY2tGb3JtYXR0ZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhdGVnb3JpY2FsVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYXRlZ29yaWNhbFRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnQ2F0ZWdvcmljYWxUaWNrRm9ybWF0dGVyJztcbiAgICBDYXRlZ29yaWNhbFRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MpIHtcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3JpY2FsVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfYXJyYXksIF9zdHJmdGltZSwgX3VzLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgU1ByaW50ZiA9IHJlcXVpcmUoXCJzcHJpbnRmXCIpO1xudmFyIHR6ID0gcmVxdWlyZShcInRpbWV6b25lXCIpO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuX3VzID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHQgLyAxMDAwKSAlIDEpICogMTAwMDAwMCk7XG59O1xuX2FycmF5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdHoodCwgXCIlWSAlbSAlZCAlSCAlTSAlU1wiKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZSwgMTApO1xuICAgIH0pO1xufTtcbl9zdHJmdGltZSA9IGZ1bmN0aW9uICh0LCBmb3JtYXQpIHtcbiAgICB2YXIgbWljcm9zZWNvbmRfcmVwbGFjZW1lbnRfc3RyaW5nO1xuICAgIGlmICh0eXBlc18xLmlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0KHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWljcm9zZWNvbmRfcmVwbGFjZW1lbnRfc3RyaW5nID0gU1ByaW50Zi5zcHJpbnRmKFwiJDElMDZkXCIsIF91cyh0KSk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oKF58W14lXSkoJSUpKiklZi8sIG1pY3Jvc2Vjb25kX3JlcGxhY2VtZW50X3N0cmluZyk7XG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZihcIiVcIikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eih0LCBmb3JtYXQpO1xuICAgIH1cbn07XG5leHBvcnRzLkRhdGV0aW1lVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRldGltZVRpY2tGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGV0aW1lVGlja0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIERhdGV0aW1lVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ0RhdGV0aW1lVGlja0Zvcm1hdHRlcic7XG4gICAgRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIG1pY3Jvc2Vjb25kczogW3AuQXJyYXksIFsnJWZ1cyddXSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBbcC5BcnJheSwgWyclM05tcycsICclUy4lM05zJ11dLFxuICAgICAgICBzZWNvbmRzOiBbcC5BcnJheSwgWyclU3MnXV0sXG4gICAgICAgIG1pbnNlYzogW3AuQXJyYXksIFsnOiVNOiVTJ11dLFxuICAgICAgICBtaW51dGVzOiBbcC5BcnJheSwgWyc6JU0nLCAnJU1tJ11dLFxuICAgICAgICBob3VybWluOiBbcC5BcnJheSwgWyclSDolTSddXSxcbiAgICAgICAgaG91cnM6IFtwLkFycmF5LCBbJyVIaCcsICclSDolTSddXSxcbiAgICAgICAgZGF5czogW3AuQXJyYXksIFsnJW0vJWQnLCAnJWElZCddXSxcbiAgICAgICAgbW9udGhzOiBbcC5BcnJheSwgWyclbS8lWScsICclYiV5J11dLFxuICAgICAgICB5ZWFyczogW3AuQXJyYXksIFsnJVknXV1cbiAgICB9KTtcbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdF9vcmRlciA9IFsnbWljcm9zZWNvbmRzJywgJ21pbGxpc2Vjb25kcycsICdzZWNvbmRzJywgJ21pbnNlYycsICdtaW51dGVzJywgJ2hvdXJtaW4nLCAnaG91cnMnLCAnZGF5cycsICdtb250aHMnLCAneWVhcnMnXTtcbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnN0cmlwX2xlYWRpbmdfemVyb3MgPSB0cnVlO1xuICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVfd2lkdGhfZm9ybWF0cygpO1xuICAgIH07XG4gICAgRGF0ZXRpbWVUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5fdXBkYXRlX3dpZHRoX2Zvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfd2lkdGhzLCBub3c7XG4gICAgICAgIG5vdyA9IHR6KG5ldyBEYXRlKCkpO1xuICAgICAgICBfd2lkdGhzID0gZnVuY3Rpb24gKGZtdF9zdHJpbmdzKSB7XG4gICAgICAgICAgICB2YXIgZm10X3N0cmluZywgc2l6ZXMsIHNvcnRlZDtcbiAgICAgICAgICAgIHNpemVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBmbXRfc3RyaW5ncy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBmbXRfc3RyaW5nID0gZm10X3N0cmluZ3Nbal07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChfc3RyZnRpbWUobm93LCBmbXRfc3RyaW5nKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBzb3J0ZWQgPSBhcnJheV8xLnNvcnRCeShhcnJheV8xLnppcChzaXplcywgZm10X3N0cmluZ3MpLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZtdCwgc2l6ZTtcbiAgICAgICAgICAgICAgICBzaXplID0gYXJnWzBdLCBmbXQgPSBhcmdbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheV8xLnVuemlwKHNvcnRlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aF9mb3JtYXRzID0ge1xuICAgICAgICAgICAgbWljcm9zZWNvbmRzOiBfd2lkdGhzKHRoaXMubWljcm9zZWNvbmRzKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogX3dpZHRocyh0aGlzLm1pbGxpc2Vjb25kcyksXG4gICAgICAgICAgICBzZWNvbmRzOiBfd2lkdGhzKHRoaXMuc2Vjb25kcyksXG4gICAgICAgICAgICBtaW5zZWM6IF93aWR0aHModGhpcy5taW5zZWMpLFxuICAgICAgICAgICAgbWludXRlczogX3dpZHRocyh0aGlzLm1pbnV0ZXMpLFxuICAgICAgICAgICAgaG91cm1pbjogX3dpZHRocyh0aGlzLmhvdXJtaW4pLFxuICAgICAgICAgICAgaG91cnM6IF93aWR0aHModGhpcy5ob3VycyksXG4gICAgICAgICAgICBkYXlzOiBfd2lkdGhzKHRoaXMuZGF5cyksXG4gICAgICAgICAgICBtb250aHM6IF93aWR0aHModGhpcy5tb250aHMpLFxuICAgICAgICAgICAgeWVhcnM6IF93aWR0aHModGhpcy55ZWFycylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERhdGV0aW1lVGlja0Zvcm1hdHRlci5wcm90b3R5cGUuX2dldF9yZXNvbHV0aW9uX3N0ciA9IGZ1bmN0aW9uIChyZXNvbHV0aW9uX3NlY3MsIHNwYW5fc2Vjcykge1xuICAgICAgICB2YXIgYWRqdXN0ZWRfc2VjcztcbiAgICAgICAgYWRqdXN0ZWRfc2VjcyA9IHJlc29sdXRpb25fc2VjcyAqIDEuMTtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAxZS0zKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtaWNyb3NlY29uZHNcIjtcbiAgICAgICAgICAgIGNhc2UgIShhZGp1c3RlZF9zZWNzIDwgMS4wKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZHNcIjtcbiAgICAgICAgICAgIGNhc2UgIShhZGp1c3RlZF9zZWNzIDwgNjApOlxuICAgICAgICAgICAgICAgIGlmIChzcGFuX3NlY3MgPj0gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWluc2VjXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWNvbmRzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAzNjAwKTpcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbl9zZWNzID49IDM2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaG91cm1pblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWludXRlc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgIShhZGp1c3RlZF9zZWNzIDwgMjQgKiAzNjAwKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Vyc1wiO1xuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAzMSAqIDI0ICogMzYwMCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF5c1wiO1xuICAgICAgICAgICAgY2FzZSAhKGFkanVzdGVkX3NlY3MgPCAzNjUgKiAyNCAqIDM2MDApOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIm1vbnRoc1wiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ5ZWFyc1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRldGltZVRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MsIG51bV9sYWJlbHMsIGNoYXJfd2lkdGgsIGZpbGxfcmF0aW8sIHRpY2tlcikge1xuICAgICAgICB2YXIgZXJyb3IsIGZtdCwgZm9ybWF0LCBmb3JtYXRzLCBnb29kX2Zvcm1hdHMsIGh5YnJpZF9oYW5kbGVkLCBpLCBqLCBrLCBsLCBsYWJlbHMsIGxlbiwgbGVuMSwgbmV4dF9mb3JtYXQsIG5leHRfbmR4LCByLCByZWYsIHJlZjEsIHJlZjIsIHJlc29sLCByZXNvbF9uZHgsIHMsIHNwYW4sIHNzLCB0LCB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2wsIHRtLCB3aWR0aHM7XG4gICAgICAgIGlmIChudW1fbGFiZWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIG51bV9sYWJlbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYXJfd2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsX3JhdGlvID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGxfcmF0aW8gPSAwLjM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpY2tlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuID0gTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0gLSB0aWNrc1swXSkgLyAxMDAwLjA7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgIHIgPSB0aWNrZXIucmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBzcGFuIC8gKHRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sID0gdGhpcy5fZ2V0X3Jlc29sdXRpb25fc3RyKHIsIHNwYW4pO1xuICAgICAgICByZWYgPSB0aGlzLl93aWR0aF9mb3JtYXRzW3Jlc29sXSwgd2lkdGhzID0gcmVmWzBdLCBmb3JtYXRzID0gcmVmWzFdO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgICBpZiAoY2hhcl93aWR0aCkge1xuICAgICAgICAgICAgZ29vZF9mb3JtYXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHdpZHRocy5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGhzW2ldICogdGlja3MubGVuZ3RoIDwgZmlsbF9yYXRpbyAqIGNoYXJfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZF9mb3JtYXRzLnB1c2godGhpcy5fd2lkdGhfZm9ybWF0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvb2RfZm9ybWF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZ29vZF9mb3JtYXRzW2dvb2RfZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYWJlbHMgPSBbXTtcbiAgICAgICAgcmVzb2xfbmR4ID0gdGhpcy5mb3JtYXRfb3JkZXIuaW5kZXhPZihyZXNvbCk7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbCA9IHt9O1xuICAgICAgICByZWYyID0gdGhpcy5mb3JtYXRfb3JkZXI7XG4gICAgICAgIGZvciAoayA9IDAsIGxlbiA9IHJlZjIubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGZtdCA9IHJlZjJba107XG4gICAgICAgICAgICB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2xbZm10XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGltZV90dXBsZV9uZHhfZm9yX3Jlc29sW1wic2Vjb25kc1wiXSA9IDU7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFtcIm1pbnNlY1wiXSA9IDQ7XG4gICAgICAgIHRpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFtcIm1pbnV0ZXNcIl0gPSA0O1xuICAgICAgICB0aW1lX3R1cGxlX25keF9mb3JfcmVzb2xbXCJob3VybWluXCJdID0gMztcbiAgICAgICAgdGltZV90dXBsZV9uZHhfZm9yX3Jlc29sW1wiaG91cnNcIl0gPSAzO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gdGlja3MubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICB0ID0gdGlja3NbbF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRtID0gX2FycmF5KHQpO1xuICAgICAgICAgICAgICAgIHMgPSBfc3RyZnRpbWUodCwgZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yMTtcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZm9ybWF0IHRpY2sgZm9yIHRpbWVzdGFtcCB2YWx1ZSBcIiArIHQpO1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIud2FybihcIiAtIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKFwiRVJSXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlicmlkX2hhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHRfbmR4ID0gcmVzb2xfbmR4O1xuICAgICAgICAgICAgd2hpbGUgKHRtW3RpbWVfdHVwbGVfbmR4X2Zvcl9yZXNvbFt0aGlzLmZvcm1hdF9vcmRlcltuZXh0X25keF1dXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHRfbmR4ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRfbmR4ID09PSB0aGlzLmZvcm1hdF9vcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocmVzb2wgPT09IFwibWluc2VjXCIgfHwgcmVzb2wgPT09IFwiaG91cm1pblwiKSAmJiAhaHlicmlkX2hhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyZXNvbCA9PT0gXCJtaW5zZWNcIiAmJiB0bVs0XSA9PT0gMCAmJiB0bVs1XSAhPT0gMCkgfHwgKHJlc29sID09PSBcImhvdXJtaW5cIiAmJiB0bVszXSA9PT0gMCAmJiB0bVs0XSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRfZm9ybWF0ID0gdGhpcy5fd2lkdGhfZm9ybWF0c1t0aGlzLmZvcm1hdF9vcmRlcltyZXNvbF9uZHggLSAxXV1bMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gX3N0cmZ0aW1lKHQsIG5leHRfZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlicmlkX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRfZm9ybWF0ID0gdGhpcy5fd2lkdGhfZm9ybWF0c1t0aGlzLmZvcm1hdF9vcmRlcltuZXh0X25keF1dWzFdWzBdO1xuICAgICAgICAgICAgICAgIHMgPSBfc3RyZnRpbWUodCwgbmV4dF9mb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaXBfbGVhZGluZ196ZXJvcykge1xuICAgICAgICAgICAgICAgIHNzID0gcy5yZXBsYWNlKC9eMCsvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNzICE9PSBzICYmIGlzTmFOKHBhcnNlSW50KHNzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3MgPSAnMCcgKyBzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2gocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBEYXRldGltZVRpY2tGb3JtYXR0ZXI7XG59KSh0aWNrX2Zvcm1hdHRlcl8xLlRpY2tGb3JtYXR0ZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5GdW5jVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGdW5jVGlja0Zvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRnVuY1RpY2tGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBGdW5jVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRnVuY1RpY2tGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnRnVuY1RpY2tGb3JtYXR0ZXInO1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGFyZ3M6IFtwLkFueSwge31dLFxuICAgICAgICBjb2RlOiBbcC5TdHJpbmcsICcnXVxuICAgIH0pO1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBGdW5jVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5fbWFrZV9mdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChmdW5jLCBhcmdzLCBjdG9yKSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3IGN0b3IsIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChyZXN1bHQpID09PSByZXN1bHQgPyByZXN1bHQgOiBjaGlsZDtcbiAgICAgICAgfSkoRnVuY3Rpb24sIFtcInRpY2tcIl0uY29uY2F0KHNsaWNlLmNhbGwoT2JqZWN0LmtleXModGhpcy5hcmdzKSksIFtcInJlcXVpcmVcIl0sIFt0aGlzLmNvZGVdKSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9O1xuICAgIEZ1bmNUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrcywgbG9jKSB7XG4gICAgICAgIHZhciBmdW5jLCB0aWNrO1xuICAgICAgICBmdW5jID0gdGhpcy5fbWFrZV9mdW5jKCk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmdW5jLmFwcGx5KG51bGwsIFt0aWNrXS5jb25jYXQoc2xpY2UuY2FsbChvYmplY3RfMS52YWx1ZXModGhpcy5hcmdzKSksIFtyZXF1aXJlXSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmNUaWNrRm9ybWF0dGVyO1xufSkodGlja19mb3JtYXR0ZXJfMS5UaWNrRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9iYXNpY190aWNrX2Zvcm1hdHRlclwiKTtcbmV4cG9ydHMuQmFzaWNUaWNrRm9ybWF0dGVyID0gYmFzaWNfdGlja19mb3JtYXR0ZXJfMS5CYXNpY1RpY2tGb3JtYXR0ZXI7XG52YXIgY2F0ZWdvcmljYWxfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2NhdGVnb3JpY2FsX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbFRpY2tGb3JtYXR0ZXIgPSBjYXRlZ29yaWNhbF90aWNrX2Zvcm1hdHRlcl8xLkNhdGVnb3JpY2FsVGlja0Zvcm1hdHRlcjtcbnZhciBkYXRldGltZV90aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vZGF0ZXRpbWVfdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLkRhdGV0aW1lVGlja0Zvcm1hdHRlciA9IGRhdGV0aW1lX3RpY2tfZm9ybWF0dGVyXzEuRGF0ZXRpbWVUaWNrRm9ybWF0dGVyO1xudmFyIGZ1bmNfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Z1bmNfdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLkZ1bmNUaWNrRm9ybWF0dGVyID0gZnVuY190aWNrX2Zvcm1hdHRlcl8xLkZ1bmNUaWNrRm9ybWF0dGVyO1xudmFyIGxvZ190aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vbG9nX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5Mb2dUaWNrRm9ybWF0dGVyID0gbG9nX3RpY2tfZm9ybWF0dGVyXzEuTG9nVGlja0Zvcm1hdHRlcjtcbnZhciBtZXJjYXRvcl90aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLk1lcmNhdG9yVGlja0Zvcm1hdHRlciA9IG1lcmNhdG9yX3RpY2tfZm9ybWF0dGVyXzEuTWVyY2F0b3JUaWNrRm9ybWF0dGVyO1xudmFyIG51bWVyYWxfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL251bWVyYWxfdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLk51bWVyYWxUaWNrRm9ybWF0dGVyID0gbnVtZXJhbF90aWNrX2Zvcm1hdHRlcl8xLk51bWVyYWxUaWNrRm9ybWF0dGVyO1xudmFyIHByaW50Zl90aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vcHJpbnRmX3RpY2tfZm9ybWF0dGVyXCIpO1xuZXhwb3J0cy5QcmludGZUaWNrRm9ybWF0dGVyID0gcHJpbnRmX3RpY2tfZm9ybWF0dGVyXzEuUHJpbnRmVGlja0Zvcm1hdHRlcjtcbnZhciB0aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdGlja19mb3JtYXR0ZXJcIik7XG5leHBvcnRzLlRpY2tGb3JtYXR0ZXIgPSB0aWNrX2Zvcm1hdHRlcl8xLlRpY2tGb3JtYXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYmFzaWNfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Jhc2ljX3RpY2tfZm9ybWF0dGVyXCIpO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Mb2dUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExvZ1RpY2tGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExvZ1RpY2tGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBMb2dUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMb2dUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ0xvZ1RpY2tGb3JtYXR0ZXInO1xuICAgIExvZ1RpY2tGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgdGlja2VyOiBbcC5JbnN0YW5jZSwgbnVsbF1cbiAgICB9KTtcbiAgICBMb2dUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIExvZ1RpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFzaWNfZm9ybWF0dGVyID0gbmV3IGJhc2ljX3RpY2tfZm9ybWF0dGVyXzEuQmFzaWNUaWNrRm9ybWF0dGVyKCk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiTG9nVGlja0Zvcm1hdHRlciBub3QgY29uZmlndXJlZCB3aXRoIGEgdGlja2VyLCB1c2luZyBkZWZhdWx0IGJhc2Ugb2YgMTAgKGxhYmVscyB3aWxsIGJlIGluY29ycmVjdCBpZiB0aWNrZXIgYmFzZSBpcyBub3QgMTApXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrcywgbG9jKSB7XG4gICAgICAgIHZhciBiYXNlLCBpLCBqLCBsYWJlbHMsIHJlZiwgc21hbGxfaW50ZXJ2YWw7XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aWNrZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMudGlja2VyLmJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYXNlID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgc21hbGxfaW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgICAgbGFiZWxzID0gbmV3IEFycmF5KHRpY2tzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aWNrcy5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgbGFiZWxzW2ldID0gYmFzZSArIFwiXlwiICsgKE1hdGgucm91bmQoTWF0aC5sb2codGlja3NbaV0pIC8gTWF0aC5sb2coYmFzZSkpKTtcbiAgICAgICAgICAgIGlmICgoaSA+IDApICYmIChsYWJlbHNbaV0gPT09IGxhYmVsc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgc21hbGxfaW50ZXJ2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzbWFsbF9pbnRlcnZhbCkge1xuICAgICAgICAgICAgbGFiZWxzID0gdGhpcy5iYXNpY19mb3JtYXR0ZXIuZG9Gb3JtYXQodGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYmFzaWNfdGlja19mb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Jhc2ljX3RpY2tfZm9ybWF0dGVyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHByb2o0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3Byb2o0XCIpO1xuZXhwb3J0cy5NZXJjYXRvclRpY2tGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTWVyY2F0b3JUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNZXJjYXRvclRpY2tGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBNZXJjYXRvclRpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lcmNhdG9yVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdNZXJjYXRvclRpY2tGb3JtYXR0ZXInO1xuICAgIE1lcmNhdG9yVGlja0Zvcm1hdHRlci5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb246IFtwLkxhdExvbl1cbiAgICB9KTtcbiAgICBNZXJjYXRvclRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MpIHtcbiAgICAgICAgdmFyIGksIGosIGssIGxhdCwgbG9uLCBwcm9qX3RpY2tzLCByZWYsIHJlZjEsIHJlZjIsIHJlZjM7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXJjYXRvclRpY2tGb3JtYXR0ZXIuZGltZW5zaW9uIG5vdCBjb25maWd1cmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qX3RpY2tzID0gbmV3IEFycmF5KHRpY2tzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PT0gXCJsb25cIikge1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVmMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbdGlja3NbaV0sIGxvY10pLCBsb24gPSByZWYxWzBdLCBsYXQgPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgIHByb2pfdGlja3NbaV0gPSBsb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IHRpY2tzLmxlbmd0aDsgMCA8PSByZWYyID8gayA8IHJlZjIgOiBrID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHJlZjMgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmludmVyc2UoW2xvYywgdGlja3NbaV1dKSwgbG9uID0gcmVmM1swXSwgbGF0ID0gcmVmM1sxXTtcbiAgICAgICAgICAgICAgICBwcm9qX3RpY2tzW2ldID0gbGF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNZXJjYXRvclRpY2tGb3JtYXR0ZXIuX19zdXBlcl9fLmRvRm9ybWF0LmNhbGwodGhpcywgcHJval90aWNrcywgbG9jKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJjYXRvclRpY2tGb3JtYXR0ZXI7XG59KShiYXNpY190aWNrX2Zvcm1hdHRlcl8xLkJhc2ljVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgTnVtYnJvID0gcmVxdWlyZShcIm51bWJyb1wiKTtcbnZhciB0aWNrX2Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdGlja19mb3JtYXR0ZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLk51bWVyYWxUaWNrRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE51bWVyYWxUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOdW1lcmFsVGlja0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIE51bWVyYWxUaWNrRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOdW1lcmFsVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdOdW1lcmFsVGlja0Zvcm1hdHRlcic7XG4gICAgTnVtZXJhbFRpY2tGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgZm9ybWF0OiBbcC5TdHJpbmcsICcwLDAnXSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtwLlN0cmluZywgJ2VuJ10sXG4gICAgICAgIHJvdW5kaW5nOiBbcC5TdHJpbmcsICdyb3VuZCddXG4gICAgfSk7XG4gICAgTnVtZXJhbFRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MpIHtcbiAgICAgICAgdmFyIGZvcm1hdCwgbGFiZWxzLCBsYW5ndWFnZSwgcm91bmRpbmcsIHRpY2s7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgICAgICBsYW5ndWFnZSA9IHRoaXMubGFuZ3VhZ2U7XG4gICAgICAgIHJvdW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yb3VuZGluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9vclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZGRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3I7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNlaWxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicm91bmR1cFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICBsYWJlbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChOdW1icm8uZm9ybWF0KHRpY2ssIGZvcm1hdCwgbGFuZ3VhZ2UsIHJvdW5kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBOdW1lcmFsVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgU1ByaW50ZiA9IHJlcXVpcmUoXCJzcHJpbnRmXCIpO1xudmFyIHRpY2tfZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi90aWNrX2Zvcm1hdHRlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUHJpbnRmVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQcmludGZUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQcmludGZUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gUHJpbnRmVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJpbnRmVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdQcmludGZUaWNrRm9ybWF0dGVyJztcbiAgICBQcmludGZUaWNrRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGZvcm1hdDogW3AuU3RyaW5nLCAnJXMnXVxuICAgIH0pO1xuICAgIFByaW50ZlRpY2tGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHRpY2tzLCBsb2MpIHtcbiAgICAgICAgdmFyIGZvcm1hdCwgbGFiZWxzLCB0aWNrO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICAgICAgbGFiZWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goU1ByaW50Zi5zcHJpbnRmKGZvcm1hdCwgdGljaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpbnRmVGlja0Zvcm1hdHRlcjtcbn0pKHRpY2tfZm9ybWF0dGVyXzEuVGlja0Zvcm1hdHRlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuVGlja0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUaWNrRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaWNrRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gVGlja0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGlja0Zvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdUaWNrRm9ybWF0dGVyJztcbiAgICBUaWNrRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrcywgbG9jKSB7IH07XG4gICAgcmV0dXJuIFRpY2tGb3JtYXR0ZXI7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9tYXRoXCIpO1xuZXhwb3J0cy5Bbm51bGFyV2VkZ2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubnVsYXJXZWRnZVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFubnVsYXJXZWRnZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBBbm51bGFyV2VkZ2VWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm51bGFyV2VkZ2VWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaW5uZXJfcmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5zaW5uZXJfcmFkaXVzID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gsIHRoaXMuX2lubmVyX3JhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNpbm5lcl9yYWRpdXMgPSB0aGlzLl9pbm5lcl9yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5vdXRlcl9yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXRlcl9yYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueG1hcHBlciwgdGhpcy5feCwgdGhpcy5fb3V0ZXJfcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291dGVyX3JhZGl1cyA9IHRoaXMuX291dGVyX3JhZGl1cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmdsZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fc3RhcnRfYW5nbGUubGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fc3RhcnRfYW5nbGUubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9hbmdsZVtpXSA9IHRoaXMuX2VuZF9hbmdsZVtpXSAtIHRoaXMuX3N0YXJ0X2FuZ2xlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIF9hbmdsZSwgX3N0YXJ0X2FuZ2xlLCBkaXJlY3Rpb24sIGksIGosIGxlbiwgcmVzdWx0cywgc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIF9zdGFydF9hbmdsZSA9IGFyZy5fc3RhcnRfYW5nbGUsIF9hbmdsZSA9IGFyZy5fYW5nbGUsIHNpbm5lcl9yYWRpdXMgPSBhcmcuc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cyA9IGFyZy5zb3V0ZXJfcmFkaXVzO1xuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHNpbm5lcl9yYWRpdXNbaV0gKyBzb3V0ZXJfcmFkaXVzW2ldICsgX3N0YXJ0X2FuZ2xlW2ldICsgX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShfc3RhcnRfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzb3V0ZXJfcmFkaXVzW2ldLCAwKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc291dGVyX3JhZGl1c1tpXSwgMCwgX2FuZ2xlW2ldLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhzaW5uZXJfcmFkaXVzW2ldLCAwKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc2lubmVyX3JhZGl1c1tpXSwgMCwgLV9hbmdsZVtpXSwgIWRpcmVjdGlvbik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1fYW5nbGVbaV0gLSBfc3RhcnRfYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGFuZ2xlLCBiYm94LCBjYW5kaWRhdGVzLCBkaXJlY3Rpb24sIGRpc3QsIGhpdHMsIGksIGlyMiwgaiwgaywgbGVuLCBsZW4xLCBvcjIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgc3gsIHN4MCwgc3gxLCBzeSwgc3kwLCBzeTEsIHZ4LCB2eDAsIHZ4MSwgdnksIHZ5MCwgdnkxLCB4LCB4MCwgeDEsIHksIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgeCA9IHRoaXMucmVuZGVyZXIueG1hcHBlci5tYXBfZnJvbV90YXJnZXQodngsIHRydWUpO1xuICAgICAgICB5ID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMub3V0ZXJfcmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgeDAgPSB4IC0gdGhpcy5tYXhfb3V0ZXJfcmFkaXVzO1xuICAgICAgICAgICAgeDEgPSB4ICsgdGhpcy5tYXhfb3V0ZXJfcmFkaXVzO1xuICAgICAgICAgICAgeTAgPSB5IC0gdGhpcy5tYXhfb3V0ZXJfcmFkaXVzO1xuICAgICAgICAgICAgeTEgPSB5ICsgdGhpcy5tYXhfb3V0ZXJfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdngwID0gdnggLSB0aGlzLm1heF9vdXRlcl9yYWRpdXM7XG4gICAgICAgICAgICB2eDEgPSB2eCArIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z4MCwgdngxXSwgdHJ1ZSksIHgwID0gcmVmMVswXSwgeDEgPSByZWYxWzFdO1xuICAgICAgICAgICAgdnkwID0gdnkgLSB0aGlzLm1heF9vdXRlcl9yYWRpdXM7XG4gICAgICAgICAgICB2eTEgPSB2eSArIHRoaXMubWF4X291dGVyX3JhZGl1cztcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z5MCwgdnkxXSwgdHJ1ZSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmVmMyA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IHJlZjNbal07XG4gICAgICAgICAgICBvcjIgPSBNYXRoLnBvdyh0aGlzLnNvdXRlcl9yYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgaXIyID0gTWF0aC5wb3codGhpcy5zaW5uZXJfcmFkaXVzW2ldLCAyKTtcbiAgICAgICAgICAgIHN4MCA9IHRoaXMucmVuZGVyZXIueG1hcHBlci5tYXBfdG9fdGFyZ2V0KHgsIHRydWUpO1xuICAgICAgICAgICAgc3gxID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF90b190YXJnZXQodGhpcy5feFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBzeTAgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX3RvX3RhcmdldCh5LCB0cnVlKTtcbiAgICAgICAgICAgIHN5MSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfdG9fdGFyZ2V0KHRoaXMuX3lbaV0sIHRydWUpO1xuICAgICAgICAgICAgZGlzdCA9IE1hdGgucG93KHN4MCAtIHN4MSwgMikgKyBNYXRoLnBvdyhzeTAgLSBzeTEsIDIpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPD0gb3IyICYmIGRpc3QgPj0gaXIyKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKFtpLCBkaXN0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmRpcmVjdGlvbi52YWx1ZSgpO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBjYW5kaWRhdGVzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgcmVmNCA9IGNhbmRpZGF0ZXNba10sIGkgPSByZWY0WzBdLCBkaXN0ID0gcmVmNFsxXTtcbiAgICAgICAgICAgIHN4ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KHZ4KTtcbiAgICAgICAgICAgIHN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihzeSAtIHRoaXMuc3lbaV0sIHN4IC0gdGhpcy5zeFtpXSk7XG4gICAgICAgICAgICBpZiAobWF0aF8xLmFuZ2xlX2JldHdlZW4oLWFuZ2xlLCAtdGhpcy5fc3RhcnRfYW5nbGVbaV0sIC10aGlzLl9lbmRfYW5nbGVbaV0sIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0dGVzdC5jcmVhdGVfMWRfaGl0X3Rlc3RfcmVzdWx0KGhpdHMpO1xuICAgIH07XG4gICAgQW5udWxhcldlZGdlVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIEFubnVsYXJXZWRnZVZpZXcucHJvdG90eXBlLl9zY3h5ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGEsIHI7XG4gICAgICAgIHIgPSAodGhpcy5zaW5uZXJfcmFkaXVzW2ldICsgdGhpcy5zb3V0ZXJfcmFkaXVzW2ldKSAvIDI7XG4gICAgICAgIGEgPSAodGhpcy5fc3RhcnRfYW5nbGVbaV0gKyB0aGlzLl9lbmRfYW5nbGVbaV0pIC8gMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMuc3hbaV0gKyByICogTWF0aC5jb3MoYSksXG4gICAgICAgICAgICB5OiB0aGlzLnN5W2ldICsgciAqIE1hdGguc2luKGEpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBbm51bGFyV2VkZ2VWaWV3LnByb3RvdHlwZS5zY3ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2N4eShpKS54O1xuICAgIH07XG4gICAgQW5udWxhcldlZGdlVmlldy5wcm90b3R5cGUuc2N5ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjeHkoaSkueTtcbiAgICB9O1xuICAgIHJldHVybiBBbm51bGFyV2VkZ2VWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkFubnVsYXJXZWRnZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBbm51bGFyV2VkZ2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFubnVsYXJXZWRnZSgpIHtcbiAgICAgICAgcmV0dXJuIEFubnVsYXJXZWRnZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5udWxhcldlZGdlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkFubnVsYXJXZWRnZVZpZXc7XG4gICAgQW5udWxhcldlZGdlLnByb3RvdHlwZS50eXBlID0gJ0FubnVsYXJXZWRnZSc7XG4gICAgQW5udWxhcldlZGdlLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBBbm51bGFyV2VkZ2UuZGVmaW5lKHtcbiAgICAgICAgZGlyZWN0aW9uOiBbcC5EaXJlY3Rpb24sICdhbnRpY2xvY2snXSxcbiAgICAgICAgaW5uZXJfcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBvdXRlcl9yYWRpdXM6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIHN0YXJ0X2FuZ2xlOiBbcC5BbmdsZVNwZWNdLFxuICAgICAgICBlbmRfYW5nbGU6IFtwLkFuZ2xlU3BlY11cbiAgICB9KTtcbiAgICByZXR1cm4gQW5udWxhcldlZGdlO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkFubnVsdXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubnVsdXNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbm51bHVzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFubnVsdXNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm51bHVzVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmlubmVyX3JhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2lubmVyX3JhZGl1cyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl94LCB0aGlzLl9pbm5lcl9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaW5uZXJfcmFkaXVzID0gdGhpcy5faW5uZXJfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMub3V0ZXJfcmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291dGVyX3JhZGl1cyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl94LCB0aGlzLl9vdXRlcl9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291dGVyX3JhZGl1cyA9IHRoaXMuX291dGVyX3JhZGl1cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5udWx1c1ZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGNsb2Nrd2lzZSwgaSwgaXNpZSwgaiwgaywgbGVuLCBsZW4xLCByZWYsIHJlc3VsdHMsIHNpbm5lcl9yYWRpdXMsIHNvdXRlcl9yYWRpdXMsIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5LCBzaW5uZXJfcmFkaXVzID0gYXJnLnNpbm5lcl9yYWRpdXMsIHNvdXRlcl9yYWRpdXMgPSBhcmcuc291dGVyX3JhZGl1cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc2lubmVyX3JhZGl1c1tpXSArIHNvdXRlcl9yYWRpdXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc2llID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgPj0gMCB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA+IDAgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc2llKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZiA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSByZWZba107XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHN4W2ldLCBzeVtpXSwgc2lubmVyX3JhZGl1c1tpXSwgMCwgTWF0aC5QSSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoc3hbaV0sIHN5W2ldLCBzb3V0ZXJfcmFkaXVzW2ldLCBNYXRoLlBJLCAwLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNpbm5lcl9yYWRpdXNbaV0sIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNvdXRlcl9yYWRpdXNbaV0sIDIgKiBNYXRoLlBJLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNpbm5lcl9yYWRpdXNbaV0sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN4W2ldICsgc291dGVyX3JhZGl1c1tpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoc3hbaV0sIHN5W2ldLCBzb3V0ZXJfcmFkaXVzW2ldLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEFubnVsdXNWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBkaXN0LCBoaXRzLCBpLCBpcjIsIGosIGxlbiwgb3IyLCByZWYsIHJlZjEsIHN4MCwgc3gxLCBzeTAsIHN5MSwgdngsIHZ5LCB4LCB4MCwgeDEsIHksIHkwLCB5MTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgeCA9IHRoaXMucmVuZGVyZXIueG1hcHBlci5tYXBfZnJvbV90YXJnZXQodngsIHRydWUpO1xuICAgICAgICB4MCA9IHggLSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIHgxID0geCArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfZnJvbV90YXJnZXQodnksIHRydWUpO1xuICAgICAgICB5MCA9IHkgLSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIHkxID0geSArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZWYxID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gcmVmMVtqXTtcbiAgICAgICAgICAgIG9yMiA9IE1hdGgucG93KHRoaXMuc291dGVyX3JhZGl1c1tpXSwgMik7XG4gICAgICAgICAgICBpcjIgPSBNYXRoLnBvdyh0aGlzLnNpbm5lcl9yYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgc3gwID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF90b190YXJnZXQoeCk7XG4gICAgICAgICAgICBzeDEgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX3RvX3RhcmdldCh0aGlzLl94W2ldKTtcbiAgICAgICAgICAgIHN5MCA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfdG9fdGFyZ2V0KHkpO1xuICAgICAgICAgICAgc3kxID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLm1hcF90b190YXJnZXQodGhpcy5feVtpXSk7XG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5wb3coc3gwIC0gc3gxLCAyKSArIE1hdGgucG93KHN5MCAtIHN5MSwgMik7XG4gICAgICAgICAgICBpZiAoZGlzdCA8PSBvcjIgJiYgZGlzdCA+PSBpcjIpIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0dGVzdC5jcmVhdGVfMWRfaGl0X3Rlc3RfcmVzdWx0KGhpdHMpO1xuICAgIH07XG4gICAgQW5udWx1c1ZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICB2YXIgZGF0YSwgaW5kaWNlcywgciwgc2lubmVyX3JhZGl1cywgc291dGVyX3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgc3ggPSB7fTtcbiAgICAgICAgc3hbaW5kZXhdID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgc3kgPSB7fTtcbiAgICAgICAgc3lbaW5kZXhdID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgciA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjU7XG4gICAgICAgIHNpbm5lcl9yYWRpdXMgPSB7fTtcbiAgICAgICAgc2lubmVyX3JhZGl1c1tpbmRleF0gPSByICogMC40O1xuICAgICAgICBzb3V0ZXJfcmFkaXVzID0ge307XG4gICAgICAgIHNvdXRlcl9yYWRpdXNbaW5kZXhdID0gciAqIDAuODtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgIHN5OiBzeSxcbiAgICAgICAgICAgIHNpbm5lcl9yYWRpdXM6IHNpbm5lcl9yYWRpdXMsXG4gICAgICAgICAgICBzb3V0ZXJfcmFkaXVzOiBzb3V0ZXJfcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBBbm51bHVzVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5Bbm51bHVzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubnVsdXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFubnVsdXMoKSB7XG4gICAgICAgIHJldHVybiBBbm51bHVzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm51bHVzLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkFubnVsdXNWaWV3O1xuICAgIEFubnVsdXMucHJvdG90eXBlLnR5cGUgPSAnQW5udWx1cyc7XG4gICAgQW5udWx1cy5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgQW5udWx1cy5kZWZpbmUoe1xuICAgICAgICBpbm5lcl9yYWRpdXM6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIG91dGVyX3JhZGl1czogW3AuRGlzdGFuY2VTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBBbm51bHVzO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkFyY1ZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXJjVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQXJjVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFyY1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFyY1ZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5yYWRpdXMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gsIHRoaXMuX3JhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmNWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfZW5kX2FuZ2xlLCBfc3RhcnRfYW5nbGUsIGRpcmVjdGlvbiwgaSwgaiwgbGVuLCByZXN1bHRzLCBzcmFkaXVzLCBzeCwgc3k7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3JhZGl1cyA9IGFyZy5zcmFkaXVzLCBfc3RhcnRfYW5nbGUgPSBhcmcuX3N0YXJ0X2FuZ2xlLCBfZW5kX2FuZ2xlID0gYXJnLl9lbmRfYW5nbGU7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBzcmFkaXVzW2ldICsgX3N0YXJ0X2FuZ2xlW2ldICsgX2VuZF9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHN4W2ldLCBzeVtpXSwgc3JhZGl1c1tpXSwgX3N0YXJ0X2FuZ2xlW2ldLCBfZW5kX2FuZ2xlW2ldLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmNWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyY1ZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuQXJjID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFyYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQXJjKCkge1xuICAgICAgICByZXR1cm4gQXJjLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBcmMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQXJjVmlldztcbiAgICBBcmMucHJvdG90eXBlLnR5cGUgPSAnQXJjJztcbiAgICBBcmMubWl4aW5zKFsnbGluZSddKTtcbiAgICBBcmMuZGVmaW5lKHtcbiAgICAgICAgZGlyZWN0aW9uOiBbcC5EaXJlY3Rpb24sICdhbnRpY2xvY2snXSxcbiAgICAgICAgcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBzdGFydF9hbmdsZTogW3AuQW5nbGVTcGVjXSxcbiAgICAgICAgZW5kX2FuZ2xlOiBbcC5BbmdsZVNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIEFyYztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfY2JiLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbl9jYmIgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGEsIGIsIGIyYWMsIGJvdW5kcywgYywgaSwgaiwgamxlbiwgaywgbXQsIHNxcnRiMmFjLCB0LCB0MSwgdDIsIHR2YWx1ZXMsIHgsIHk7XG4gICAgdHZhbHVlcyA9IFtdO1xuICAgIGJvdW5kcyA9IFtbXSwgW11dO1xuICAgIGZvciAoaSA9IGsgPSAwOyBrIDw9IDI7IGkgPSArK2spIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICB9XG4gICAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaiA9IHR2YWx1ZXMubGVuZ3RoO1xuICAgIGpsZW4gPSBqO1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICAgIG10ID0gMSAtIHQ7XG4gICAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG4gICAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICAgIGJvdW5kc1sxXVtqXSA9IHk7XG4gICAgfVxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgcmV0dXJuIFtNYXRoLm1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pLCBNYXRoLm1heC5hcHBseShudWxsLCBib3VuZHNbMV0pLCBNYXRoLm1heC5hcHBseShudWxsLCBib3VuZHNbMF0pLCBNYXRoLm1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXTtcbn07XG5leHBvcnRzLkJlemllclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQmV6aWVyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQmV6aWVyVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJlemllclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJlemllclZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaywgcG9pbnRzLCByZWYsIHJlZjEsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuX3gwLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5feDBbaV0gKyB0aGlzLl94MVtpXSArIHRoaXMuX3kwW2ldICsgdGhpcy5feTFbaV0gKyB0aGlzLl9jeDBbaV0gKyB0aGlzLl9jeTBbaV0gKyB0aGlzLl9jeDFbaV0gKyB0aGlzLl9jeTFbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYxID0gX2NiYih0aGlzLl94MFtpXSwgdGhpcy5feTBbaV0sIHRoaXMuX3gxW2ldLCB0aGlzLl95MVtpXSwgdGhpcy5fY3gwW2ldLCB0aGlzLl9jeTBbaV0sIHRoaXMuX2N4MVtpXSwgdGhpcy5fY3kxW2ldKSwgeDAgPSByZWYxWzBdLCB5MCA9IHJlZjFbMV0sIHgxID0gcmVmMVsyXSwgeTEgPSByZWYxWzNdO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1pblg6IHgwLFxuICAgICAgICAgICAgICAgIG1pblk6IHkwLFxuICAgICAgICAgICAgICAgIG1heFg6IHgxLFxuICAgICAgICAgICAgICAgIG1heFk6IHkxLFxuICAgICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICBCZXppZXJWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBrLCBsZW4sIHJlc3VsdHMsIHNjeCwgc2N4MCwgc2N4MSwgc2N5MCwgc2N5MSwgc3gwLCBzeDEsIHN5MCwgc3kxO1xuICAgICAgICBzeDAgPSBhcmcuc3gwLCBzeTAgPSBhcmcuc3kwLCBzeDEgPSBhcmcuc3gxLCBzeTEgPSBhcmcuc3kxLCBzY3ggPSBhcmcuc2N4LCBzY3gwID0gYXJnLnNjeDAsIHNjeTAgPSBhcmcuc2N5MCwgc2N4MSA9IGFyZy5zY3gxLCBzY3kxID0gYXJnLnNjeTE7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNba107XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHN4MFtpXSArIHN5MFtpXSArIHN4MVtpXSArIHN5MVtpXSArIHNjeDBbaV0gKyBzY3kwW2ldICsgc2N4MVtpXSArIHNjeTFbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeDBbaV0sIHN5MFtpXSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oc2N4MFtpXSwgc2N5MFtpXSwgc2N4MVtpXSwgc2N5MVtpXSwgc3gxW2ldLCBzeTFbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCZXppZXJWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIEJlemllclZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLkJlemllciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCZXppZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJlemllcigpIHtcbiAgICAgICAgcmV0dXJuIEJlemllci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmV6aWVyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJlemllclZpZXc7XG4gICAgQmV6aWVyLnByb3RvdHlwZS50eXBlID0gJ0Jlemllcic7XG4gICAgQmV6aWVyLmNvb3JkcyhbWyd4MCcsICd5MCddLCBbJ3gxJywgJ3kxJ10sIFsnY3gwJywgJ2N5MCddLCBbJ2N4MScsICdjeTEnXV0pO1xuICAgIEJlemllci5taXhpbnMoWydsaW5lJ10pO1xuICAgIHJldHVybiBCZXppZXI7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkNpcmNsZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2lyY2xlVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2lyY2xlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJkLCBzO1xuICAgICAgICBpZiAodGhpcy5fcmFkaXVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnNwZWMudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgcmQgPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzX2RpbWVuc2lvbi5zcGVjLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNyYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXJbcmQgKyBcIm1hcHBlclwiXSwgdGhpc1tcIl9cIiArIHJkXSwgdGhpcy5fcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3JhZGl1cyA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfc2l6ZSA9IDIgKiB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmFkaXVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSByZWZbal07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX21hc2tfZGF0YSA9IGZ1bmN0aW9uIChhbGxfaW5kaWNlcykge1xuICAgICAgICB2YXIgYmJveCwgaHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3gwLCBzeDEsIHN5MCwgc3kxLCB2ciwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIGhyID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgdnIgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS52X3JhbmdlO1xuICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgc3gwID0gaHIuc3RhcnQ7XG4gICAgICAgICAgICBzeDEgPSBoci5lbmQ7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3N4MCwgc3gxXSwgdHJ1ZSksIHgwID0gcmVmWzBdLCB4MSA9IHJlZlsxXTtcbiAgICAgICAgICAgIHgwIC09IHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHgxICs9IHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHN5MCA9IHZyLnN0YXJ0O1xuICAgICAgICAgICAgc3kxID0gdnIuZW5kO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbc3kwLCBzeTFdLCB0cnVlKSwgeTAgPSByZWYxWzBdLCB5MSA9IHJlZjFbMV07XG4gICAgICAgICAgICB5MCAtPSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICB5MSArPSB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeDAgPSBoci5zdGFydCAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgICAgICBzeDEgPSBoci5lbmQgKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMiA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbc3gwLCBzeDFdLCB0cnVlKSwgeDAgPSByZWYyWzBdLCB4MSA9IHJlZjJbMV07XG4gICAgICAgICAgICBzeTAgPSB2ci5zdGFydCAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgICAgICBzeTEgPSB2ci5lbmQgKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbc3kwLCBzeTFdLCB0cnVlKSwgeTAgPSByZWYzWzBdLCB5MSA9IHJlZjNbMV07XG4gICAgICAgIH1cbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHNyYWRpdXMgPSBhcmcuc3JhZGl1cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3JhZGl1c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoc3hbaV0sIHN5W2ldLCBzcmFkaXVzW2ldLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5maWxsLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHguc3Ryb2tlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBDaXJjbGVWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBjYW5kaWRhdGVzLCBkaXN0LCBoaXRzLCBpLCBqLCBrLCBsZW4sIGxlbjEsIHIyLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHN4LCBzeDAsIHN4MSwgc3ksIHN5MCwgc3kxLCB2eCwgdngwLCB2eDEsIHZ5LCB2eTAsIHZ5MSwgeCwgeDAsIHgxLCB5LCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ4LCB0cnVlKTtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfZnJvbV90YXJnZXQodnksIHRydWUpO1xuICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgeDAgPSB4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeDEgPSB4ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeTAgPSB5IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgeTEgPSB5ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdngwID0gdnggLSB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgdngxID0gdnggKyB0aGlzLm1heF9zaXplO1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdngwLCB2eDFdLCB0cnVlKSwgeDAgPSByZWYxWzBdLCB4MSA9IHJlZjFbMV07XG4gICAgICAgICAgICByZWYyID0gW01hdGgubWluKHgwLCB4MSksIE1hdGgubWF4KHgwLCB4MSldLCB4MCA9IHJlZjJbMF0sIHgxID0gcmVmMlsxXTtcbiAgICAgICAgICAgIHZ5MCA9IHZ5IC0gdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgICAgIHZ5MSA9IHZ5ICsgdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgICAgIHJlZjMgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z5MCwgdnkxXSwgdHJ1ZSksIHkwID0gcmVmM1swXSwgeTEgPSByZWYzWzFdO1xuICAgICAgICAgICAgcmVmNCA9IFtNYXRoLm1pbih5MCwgeTEpLCBNYXRoLm1heCh5MCwgeTEpXSwgeTAgPSByZWY0WzBdLCB5MSA9IHJlZjRbMV07XG4gICAgICAgIH1cbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGkgPSBjYW5kaWRhdGVzW2pdO1xuICAgICAgICAgICAgICAgIHIyID0gTWF0aC5wb3codGhpcy5zcmFkaXVzW2ldLCAyKTtcbiAgICAgICAgICAgICAgICBzeDAgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX3RvX3RhcmdldCh4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeDEgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX3RvX3RhcmdldCh0aGlzLl94W2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeTAgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX3RvX3RhcmdldCh5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeTEgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX3RvX3RhcmdldCh0aGlzLl95W2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5wb3coc3gwIC0gc3gxLCAyKSArIE1hdGgucG93KHN5MCAtIHN5MSwgMik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPD0gcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0cy5wdXNoKFtpLCBkaXN0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGNhbmRpZGF0ZXNba107XG4gICAgICAgICAgICAgICAgcjIgPSBNYXRoLnBvdyh0aGlzLnNyYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnBvdyh0aGlzLnN4W2ldIC0gc3gsIDIpICsgTWF0aC5wb3codGhpcy5zeVtpXSAtIHN5LCAyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8PSByMikge1xuICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2goW2ksIGRpc3RdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdHRlc3QuY3JlYXRlXzFkX2hpdF90ZXN0X3Jlc3VsdChoaXRzKTtcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgaGl0cywgbWF4WCwgbWF4WSwgbWluWCwgbWluWSwgbXMsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVzdWx0LCB2eCwgdngwLCB2eDEsIHZ5LCB2eTAsIHZ5MSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLmJvdW5kcygpLCBtaW5YID0gcmVmMS5taW5YLCBtaW5ZID0gcmVmMS5taW5ZLCBtYXhYID0gcmVmMS5tYXhYLCBtYXhZID0gcmVmMS5tYXhZO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmRpcmVjdGlvbiA9PT0gJ2gnKSB7XG4gICAgICAgICAgICB5MCA9IG1pblk7XG4gICAgICAgICAgICB5MSA9IG1heFk7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHZ4MCA9IHZ4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHZ4MSA9IHZ4ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z4MCwgdngxXSksIHgwID0gcmVmMlswXSwgeDEgPSByZWYyWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXMgPSB0aGlzLm1heF9zaXplIC8gMjtcbiAgICAgICAgICAgICAgICB2eDAgPSB2eCAtIG1zO1xuICAgICAgICAgICAgICAgIHZ4MSA9IHZ4ICsgbXM7XG4gICAgICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdngwLCB2eDFdLCB0cnVlKSwgeDAgPSByZWYzWzBdLCB4MSA9IHJlZjNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4MCA9IG1pblg7XG4gICAgICAgICAgICB4MSA9IG1heFg7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX3JhZGl1cyAhPSBudWxsKSAmJiB0aGlzLm1vZGVsLnByb3BlcnRpZXMucmFkaXVzLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHZ5MCA9IHZ5IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHZ5MSA9IHZ5ICsgdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlZjQgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z5MCwgdnkxXSksIHkwID0gcmVmNFswXSwgeTEgPSByZWY0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXMgPSB0aGlzLm1heF9zaXplIC8gMjtcbiAgICAgICAgICAgICAgICB2eTAgPSB2eSAtIG1zO1xuICAgICAgICAgICAgICAgIHZ5MSA9IHZ5ICsgbXM7XG4gICAgICAgICAgICAgICAgcmVmNSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdnkwLCB2eTFdLCB0cnVlKSwgeTAgPSByZWY1WzBdLCB5MSA9IHJlZjVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgaGl0cyA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX2hpdF9yZWN0ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCByZWYsIHJlZjEsIHJlc3VsdCwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbZ2VvbWV0cnkudngwLCBnZW9tZXRyeS52eDFdLCB0cnVlKSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFtnZW9tZXRyeS52eTAsIGdlb21ldHJ5LnZ5MV0sIHRydWUpLCB5MCA9IHJlZjFbMF0sIHkxID0gcmVmMVsxXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gdGhpcy5pbmRleC5pbmRpY2VzKGJib3gpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2lyY2xlVmlldy5wcm90b3R5cGUuX2hpdF9wb2x5ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzLCBoaXRzLCBpLCBpZHgsIGosIGssIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0LCByZXN1bHRzLCBzeCwgc3ksIHZ4LCB2eTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICBjYW5kaWRhdGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCByZWYxID0gdGhpcy5zeC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IDAgPD0gcmVmMSA/IGorKyA6IGotLSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5hcHBseSh0aGlzKTtcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyAwIDw9IHJlZjIgPyBrIDwgcmVmMiA6IGsgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZHggPSBjYW5kaWRhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKGhpdHRlc3QucG9pbnRfaW5fcG9seSh0aGlzLnN4W2ldLCB0aGlzLnN5W2ldLCBzeCwgc3kpKSB7XG4gICAgICAgICAgICAgICAgaGl0cy5wdXNoKGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENpcmNsZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICB2YXIgZGF0YSwgaW5kaWNlcywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgc3ggPSB7fTtcbiAgICAgICAgc3hbaW5kZXhdID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgc3kgPSB7fTtcbiAgICAgICAgc3lbaW5kZXhdID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgc3JhZGl1cyA9IHt9O1xuICAgICAgICBzcmFkaXVzW2luZGV4XSA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjI7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICBzcmFkaXVzOiBzcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBDaXJjbGVWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLkNpcmNsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaXJjbGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2lyY2xlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNpcmNsZVZpZXc7XG4gICAgQ2lyY2xlLnByb3RvdHlwZS50eXBlID0gJ0NpcmNsZSc7XG4gICAgQ2lyY2xlLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBDaXJjbGUuZGVmaW5lKHtcbiAgICAgICAgYW5nbGU6IFtwLkFuZ2xlU3BlYywgMF0sXG4gICAgICAgIHNpemU6IFtcbiAgICAgICAgICAgIHAuRGlzdGFuY2VTcGVjLCB7XG4gICAgICAgICAgICAgICAgdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDRcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmFkaXVzOiBbcC5EaXN0YW5jZVNwZWMsIG51bGxdLFxuICAgICAgICByYWRpdXNfZGltZW5zaW9uOiBbcC5TdHJpbmcsICd4J11cbiAgICB9KTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQ2lyY2xlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1cy5vcHRpb25hbCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ2lyY2xlO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkVsbGlwc2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEVsbGlwc2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBFbGxpcHNlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEVsbGlwc2VWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFbGxpcHNlVmlldy5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1heF93MiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMud2lkdGgudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLm1heF93MiA9IHRoaXMubWF4X3dpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heF9oMiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaGVpZ2h0LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4X2gyID0gdGhpcy5tYXhfaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxsaXBzZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueG1hcHBlciwgdGhpcy5feCwgdGhpcy5fd2lkdGgsICdjZW50ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLl93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmhlaWdodC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnltYXBwZXIsIHRoaXMuX3ksIHRoaXMuX2hlaWdodCwgJ2NlbnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsbGlwc2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlc3VsdHMsIHNoLCBzdywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHN3ID0gYXJnLnN3LCBzaCA9IGFyZy5zaDtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3dbaV0gKyBzaFtpXSArIHRoaXMuX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmVsbGlwc2Uoc3hbaV0sIHN5W2ldLCBzd1tpXSAvIDIuMCwgc2hbaV0gLyAyLjAsIHRoaXMuX2FuZ2xlW2ldLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEVsbGlwc2VWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGQsIGRhdGEsIGluZGljZXMsIHNjYWxlLCBzaCwgc3csIHN4LCBzeTtcbiAgICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgICAgIHN4ID0ge307XG4gICAgICAgIHN4W2luZGV4XSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICAgIHN5ID0ge307XG4gICAgICAgIHN5W2luZGV4XSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICAgIHNjYWxlID0gdGhpcy5zd1tpbmRleF0gLyB0aGlzLnNoW2luZGV4XTtcbiAgICAgICAgZCA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjg7XG4gICAgICAgIHN3ID0ge307XG4gICAgICAgIHNoID0ge307XG4gICAgICAgIGlmIChzY2FsZSA+IDEpIHtcbiAgICAgICAgICAgIHN3W2luZGV4XSA9IGQ7XG4gICAgICAgICAgICBzaFtpbmRleF0gPSBkIC8gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd1tpbmRleF0gPSBkICogc2NhbGU7XG4gICAgICAgICAgICBzaFtpbmRleF0gPSBkO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICBzdzogc3csXG4gICAgICAgICAgICBzaDogc2hcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcihjdHgsIGluZGljZXMsIGRhdGEpO1xuICAgIH07XG4gICAgRWxsaXBzZVZpZXcucHJvdG90eXBlLl9ib3VuZHMgPSBmdW5jdGlvbiAoYmRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heF93aDJfYm91bmRzKGJkcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxsaXBzZVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuRWxsaXBzZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChFbGxpcHNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBFbGxpcHNlKCkge1xuICAgICAgICByZXR1cm4gRWxsaXBzZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRWxsaXBzZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5FbGxpcHNlVmlldztcbiAgICBFbGxpcHNlLnByb3RvdHlwZS50eXBlID0gJ0VsbGlwc2UnO1xuICAgIEVsbGlwc2UubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIEVsbGlwc2UuZGVmaW5lKHtcbiAgICAgICAgYW5nbGU6IFtwLkFuZ2xlU3BlYywgMC4wXSxcbiAgICAgICAgd2lkdGg6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGhlaWdodDogW3AuRGlzdGFuY2VTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBFbGxpcHNlO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYmJveCA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYmJveFwiKTtcbnZhciBwcm9qID0gcmVxdWlyZShcImNvcmUvdXRpbC9wcm9qZWN0aW9uc1wiKTtcbnZhciBib2tlaF92aWV3XzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF92aWV3XCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgdmlzdWFsc18xID0gcmVxdWlyZShcImNvcmUvdmlzdWFsc1wiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLkdseXBoVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoR2x5cGhWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHbHlwaFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBHbHlwaFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdseXBoVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBDbHMsIGN0eCwgZSwgZ2xnbHlwaHM7XG4gICAgICAgIEdseXBoVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9ub2hpdF93YXJuZWQgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXI7XG4gICAgICAgIHRoaXMudmlzdWFscyA9IG5ldyB2aXN1YWxzXzEuVmlzdWFscyh0aGlzLm1vZGVsKTtcbiAgICAgICAgY3R4ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBpZiAoY3R4LmdsY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2xnbHlwaHMgPSByZXF1aXJlKFwibW9kZWxzL2dseXBocy93ZWJnbC9pbmRleFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdXZWJHTCB3YXMgcmVxdWVzdGVkIGFuZCBpcyBzdXBwb3J0ZWQsIGJ1dCBib2tlaC1nbCgubWluKS5qcyBpcyBub3QgYXZhaWxhYmxlLCBmYWxsaW5nIGJhY2sgdG8gMkQgcmVuZGVyaW5nLicpO1xuICAgICAgICAgICAgICAgICAgICBnbGdseXBocyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbGdseXBocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgQ2xzID0gZ2xnbHlwaHNbdGhpcy5tb2RlbC50eXBlICsgJ0dMR2x5cGgnXTtcbiAgICAgICAgICAgICAgICBpZiAoQ2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xnbHlwaCA9IG5ldyBDbHMoY3R4LmdsY2FudmFzLmdsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuc2V0X3Zpc3VhbHMgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMudmlzdWFscy53YXJtX2NhY2hlKHNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLmdsZ2x5cGggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xnbHlwaC5zZXRfdmlzdWFsc19jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgZGF0YSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmICh0aGlzLmdsZ2x5cGggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xnbHlwaC5yZW5kZXIoY3R4LCBpbmRpY2VzLCBkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyKGN0eCwgaW5kaWNlcywgZGF0YSk7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLmJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJib3guZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHModGhpcy5pbmRleC5iYm94KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5sb2dfYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmIsIGosIGssIGxlbiwgbGVuMSwgcG9zaXRpdmVfeF9iYnMsIHBvc2l0aXZlX3lfYmJzLCB4LCB5O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmJveC5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGJiID0gYmJveC5lbXB0eSgpO1xuICAgICAgICBwb3NpdGl2ZV94X2JicyA9IHRoaXMuaW5kZXguc2VhcmNoKGJib3gucG9zaXRpdmVfeCgpKTtcbiAgICAgICAgcG9zaXRpdmVfeV9iYnMgPSB0aGlzLmluZGV4LnNlYXJjaChiYm94LnBvc2l0aXZlX3koKSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHBvc2l0aXZlX3hfYmJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB4ID0gcG9zaXRpdmVfeF9iYnNbal07XG4gICAgICAgICAgICBpZiAoeC5taW5YIDwgYmIubWluWCkge1xuICAgICAgICAgICAgICAgIGJiLm1pblggPSB4Lm1pblg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5tYXhYID4gYmIubWF4WCkge1xuICAgICAgICAgICAgICAgIGJiLm1heFggPSB4Lm1heFg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHBvc2l0aXZlX3lfYmJzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgeSA9IHBvc2l0aXZlX3lfYmJzW2tdO1xuICAgICAgICAgICAgaWYgKHkubWluWSA8IGJiLm1pblkpIHtcbiAgICAgICAgICAgICAgICBiYi5taW5ZID0geS5taW5ZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkubWF4WSA+IGJiLm1heFkpIHtcbiAgICAgICAgICAgICAgICBiYi5tYXhZID0geS5tYXhZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMoYmIpO1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5tYXhfd2gyX2JvdW5kcyA9IGZ1bmN0aW9uIChiZHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pblg6IGJkcy5taW5YIC0gdGhpcy5tYXhfdzIsXG4gICAgICAgICAgICBtYXhYOiBiZHMubWF4WCArIHRoaXMubWF4X3cyLFxuICAgICAgICAgICAgbWluWTogYmRzLm1pblkgLSB0aGlzLm1heF9oMixcbiAgICAgICAgICAgIG1heFk6IGJkcy5tYXhZICsgdGhpcy5tYXhfaDJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuZ2V0X2FuY2hvcl9wb2ludCA9IGZ1bmN0aW9uIChhbmNob3IsIGksIGFyZykge1xuICAgICAgICB2YXIgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZ1swXSwgc3kgPSBhcmdbMV07XG4gICAgICAgIHN3aXRjaCAoYW5jaG9yKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zY3goaSwgc3gsIHN5KSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zY3koaSwgc3gsIHN5KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLnNjeCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN4W2ldO1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5zY3kgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeVtpXTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuc2Rpc3QgPSBmdW5jdGlvbiAobWFwcGVyLCBwdHMsIHNwYW5zLCBwdHNfbG9jYXRpb24sIGRpbGF0ZSkge1xuICAgICAgICB2YXIgZCwgaGFsZnNwYW4sIGksIHB0MCwgcHQxLCBzcHQwLCBzcHQxO1xuICAgICAgICBpZiAocHRzX2xvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHB0c19sb2NhdGlvbiA9IFwiZWRnZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWxhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcocHRzWzBdKSkge1xuICAgICAgICAgICAgcHRzID0gbWFwcGVyLnZfbWFwX3RvX3RhcmdldChwdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdHNfbG9jYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBoYWxmc3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gc3BhbnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHNwYW5zW2pdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZCAvIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBwdDAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBwdHMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHB0c1tpXSAtIGhhbGZzcGFuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcHQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHRzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwdHNbaV0gKyBoYWxmc3BhbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHB0MCA9IHB0cztcbiAgICAgICAgICAgIHB0MSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHB0MC5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocHQwW2ldICsgc3BhbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3B0MCA9IG1hcHBlci52X21hcF90b190YXJnZXQocHQwKTtcbiAgICAgICAgc3B0MSA9IG1hcHBlci52X21hcF90b190YXJnZXQocHQxKTtcbiAgICAgICAgaWYgKGRpbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHNwdDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguY2VpbChNYXRoLmFicyhzcHQxW2ldIC0gc3B0MFtpXSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHNwdDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguYWJzKHNwdDFbaV0gLSBzcHQwW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLl9nZW5lcmljX2xpbmVfbGVnZW5kID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MCwgKHkwICsgeTEpIC8gMik7XG4gICAgICAgIGN0eC5saW5lVG8oeDEsICh5MCArIHkxKSAvIDIpO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX2dlbmVyaWNfYXJlYV9sZWdlbmQgPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRoLCBkdywgaCwgaW5kaWNlcywgc3gwLCBzeDEsIHN5MCwgc3kxLCB3O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgdyA9IE1hdGguYWJzKHgxIC0geDApO1xuICAgICAgICBkdyA9IHcgKiAwLjE7XG4gICAgICAgIGggPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICAgICAgZGggPSBoICogMC4xO1xuICAgICAgICBzeDAgPSB4MCArIGR3O1xuICAgICAgICBzeDEgPSB4MSAtIGR3O1xuICAgICAgICBzeTAgPSB5MCArIGRoO1xuICAgICAgICBzeTEgPSB5MSAtIGRoO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChzeDAsIHN5MCwgc3gxIC0gc3gwLCBzeTEgLSBzeTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChzeDAsIHN5MCwgc3gxIC0gc3gwLCBzeTEgLSBzeTApO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuaGl0X3Rlc3QgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGZ1bmMsIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZnVuYyA9IFwiX2hpdF9cIiArIGdlb21ldHJ5LnR5cGU7XG4gICAgICAgIGlmICh0aGlzW2Z1bmNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXNbZnVuY10oZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX25vaGl0X3dhcm5lZFtnZW9tZXRyeS50eXBlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiJ1wiICsgZ2VvbWV0cnkudHlwZSArIFwiJyBzZWxlY3Rpb24gbm90IGF2YWlsYWJsZSBmb3IgXCIgKyB0aGlzLm1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fbm9oaXRfd2FybmVkW2dlb21ldHJ5LnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5zZXRfZGF0YSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIGRhdGEsIHJlZiwgcmVmMTtcbiAgICAgICAgZGF0YSA9IHRoaXMubW9kZWwubWF0ZXJpYWxpemVfZGF0YXNwZWNzKHNvdXJjZSk7XG4gICAgICAgIG9iamVjdF8xLmV4dGVuZCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIucGxvdF92aWV3Lm1vZGVsLnVzZV9tYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBwcm9qLnByb2plY3RfeHkodGhpcy5feCwgdGhpcy5feSksIHRoaXMuX3ggPSByZWZbMF0sIHRoaXMuX3kgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5feHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZjEgPSBwcm9qLnByb2plY3RfeHN5cyh0aGlzLl94cywgdGhpcy5feXMpLCB0aGlzLl94cyA9IHJlZjFbMF0sIHRoaXMuX3lzID0gcmVmMVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xnbHlwaC5zZXRfZGF0YV9jaGFuZ2VkKHRoaXMuX3gubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRfZGF0YShzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9IHRoaXMuX2luZGV4X2RhdGEoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5tYXNrX2RhdGEgPSBmdW5jdGlvbiAoaW5kaWNlcykge1xuICAgICAgICBpZiAodGhpcy5nbGdseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2tfZGF0YShpbmRpY2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhWaWV3LnByb3RvdHlwZS5fbWFza19kYXRhID0gZnVuY3Rpb24gKGluZGljZXMpIHtcbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLl9ib3VuZHMgPSBmdW5jdGlvbiAoYm91bmRzKSB7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcbiAgICBHbHlwaFZpZXcucHJvdG90eXBlLm1hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgaywgbGVuLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlZjUsIHJlZjYsIHJlZjcsIHJlZjgsIHN4LCBzeG5hbWUsIHN5LCBzeW5hbWUsIHhuYW1lLCB5bmFtZTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fY29vcmRzO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHJlZjEgPSByZWZbal0sIHhuYW1lID0gcmVmMVswXSwgeW5hbWUgPSByZWYxWzFdO1xuICAgICAgICAgICAgc3huYW1lID0gXCJzXCIgKyB4bmFtZTtcbiAgICAgICAgICAgIHN5bmFtZSA9IFwic1wiICsgeW5hbWU7XG4gICAgICAgICAgICB4bmFtZSA9IFwiX1wiICsgeG5hbWU7XG4gICAgICAgICAgICB5bmFtZSA9IFwiX1wiICsgeW5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KChyZWYyID0gdGhpc1t4bmFtZV0pICE9IG51bGwgPyByZWYyWzBdIDogdm9pZCAwKSB8fCAoKHJlZjMgPSB0aGlzW3huYW1lXSkgIT0gbnVsbCA/IChyZWY0ID0gcmVmM1swXSkgIT0gbnVsbCA/IHJlZjQuYnVmZmVyIDogdm9pZCAwIDogdm9pZCAwKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmVmNSA9IFtbXSwgW11dLCB0aGlzW3N4bmFtZV0gPSByZWY1WzBdLCB0aGlzW3N5bmFtZV0gPSByZWY1WzFdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWY2ID0gdGhpc1t4bmFtZV0ubGVuZ3RoOyAwIDw9IHJlZjYgPyBrIDwgcmVmNiA6IGsgPiByZWY2OyBpID0gMCA8PSByZWY2ID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjcgPSB0aGlzLm1hcF90b19zY3JlZW4odGhpc1t4bmFtZV1baV0sIHRoaXNbeW5hbWVdW2ldKSwgc3ggPSByZWY3WzBdLCBzeSA9IHJlZjdbMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3huYW1lXS5wdXNoKHN4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW5hbWVdLnB1c2goc3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZjggPSB0aGlzLm1hcF90b19zY3JlZW4odGhpc1t4bmFtZV0sIHRoaXNbeW5hbWVdKSwgdGhpc1tzeG5hbWVdID0gcmVmOFswXSwgdGhpc1tzeW5hbWVdID0gcmVmOFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwX2RhdGEoKTtcbiAgICB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEdseXBoVmlldy5wcm90b3R5cGUubWFwX3RvX3NjcmVlbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMubW9kZWwueF9yYW5nZV9uYW1lLCB0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2x5cGhWaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLkdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR2x5cGgucHJvdG90eXBlLl9jb29yZHMgPSBbXTtcbiAgICBHbHlwaC5jb29yZHMgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHZhciBfY29vcmRzLCBqLCBsZW4sIHJlZiwgcmVzdWx0LCB4LCB5O1xuICAgICAgICBfY29vcmRzID0gdGhpcy5wcm90b3R5cGUuX2Nvb3Jkcy5jb25jYXQoY29vcmRzKTtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2Nvb3JkcyA9IF9jb29yZHM7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHJlZiA9IGNvb3Jkc1tqXSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJlc3VsdFt4XSA9IFtwLk51bWJlclNwZWNdO1xuICAgICAgICAgICAgcmVzdWx0W3ldID0gW3AuTnVtYmVyU3BlY107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lKHJlc3VsdCk7XG4gICAgfTtcbiAgICBHbHlwaC5pbnRlcm5hbCh7XG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICB5X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXVxuICAgIH0pO1xuICAgIHJldHVybiBHbHlwaDtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNwYXRpYWxfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvc3BhdGlhbFwiKTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG52YXIgY2F0ZWdvcmljYWxfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9jYXRlZ29yaWNhbF9tYXBwZXJcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkhCYXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhCYXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBIQmFyVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEhCYXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIQmFyVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmLCB2bGVmdCwgdnJpZ2h0LCB2eTtcbiAgICAgICAgdnkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX3kpO1xuICAgICAgICB0aGlzLnN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZfdnlfdG9fc3kodnkpO1xuICAgICAgICB2cmlnaHQgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX3JpZ2h0KTtcbiAgICAgICAgdmxlZnQgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX2xlZnQpO1xuICAgICAgICB0aGlzLnNyaWdodCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3Z4X3RvX3N4KHZyaWdodCk7XG4gICAgICAgIHRoaXMuc2xlZnQgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eF90b19zeCh2bGVmdCk7XG4gICAgICAgIHRoaXMuc3RvcCA9IFtdO1xuICAgICAgICB0aGlzLnNib3R0b20gPSBbXTtcbiAgICAgICAgdGhpcy5zaCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci55bWFwcGVyLCB0aGlzLl95LCB0aGlzLl9oZWlnaHQsICdjZW50ZXInKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuc3kubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcC5wdXNoKHRoaXMuc3lbaV0gLSB0aGlzLnNoW2ldIC8gMik7XG4gICAgICAgICAgICB0aGlzLnNib3R0b20ucHVzaCh0aGlzLnN5W2ldICsgdGhpcy5zaFtpXSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSEJhclZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgaGVpZ2h0LCBpLCBqLCBsLCBsZWZ0LCBtYXBfdG9fc3ludGhldGljLCBwb2ludHMsIHIsIHJlZiwgcmlnaHQsIHQsIHk7XG4gICAgICAgIG1hcF90b19zeW50aGV0aWMgPSBmdW5jdGlvbiAobWFwcGVyLCBhcnJheSkge1xuICAgICAgICAgICAgaWYgKG1hcHBlciBpbnN0YW5jZW9mIGNhdGVnb3JpY2FsX21hcHBlcl8xLkNhdGVnb3JpY2FsTWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBlci52X21hcF90b190YXJnZXQoYXJyYXksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZWZ0ID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX2xlZnQpO1xuICAgICAgICByaWdodCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl9yaWdodCk7XG4gICAgICAgIHkgPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueW1hcHBlciwgdGhpcy5feSk7XG4gICAgICAgIGhlaWdodCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci55bWFwcGVyLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHkubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGwgPSBsZWZ0W2ldO1xuICAgICAgICAgICAgciA9IHJpZ2h0W2ldO1xuICAgICAgICAgICAgdCA9IHlbaV0gKyAwLjUgKiBoZWlnaHRbaV07XG4gICAgICAgICAgICBiID0geVtpXSAtIDAuNSAqIGhlaWdodFtpXTtcbiAgICAgICAgICAgIGlmIChpc05hTihsICsgciArIHQgKyBiKSB8fCAhaXNGaW5pdGUobCArIHIgKyB0ICsgYikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtaW5YOiBsLFxuICAgICAgICAgICAgICAgIG1pblk6IGIsXG4gICAgICAgICAgICAgICAgbWF4WDogcixcbiAgICAgICAgICAgICAgICBtYXhZOiB0LFxuICAgICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICBIQmFyVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgbGVuLCByZXN1bHRzLCBzYm90dG9tLCBzbGVmdCwgc3JpZ2h0LCBzdG9wO1xuICAgICAgICBzbGVmdCA9IGFyZy5zbGVmdCwgc3JpZ2h0ID0gYXJnLnNyaWdodCwgc3RvcCA9IGFyZy5zdG9wLCBzYm90dG9tID0gYXJnLnNib3R0b207XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc2xlZnRbaV0gKyBzdG9wW2ldICsgc3JpZ2h0W2ldICsgc2JvdHRvbVtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHNsZWZ0W2ldLCBzdG9wW2ldLCBzcmlnaHRbaV0gLSBzbGVmdFtpXSwgc2JvdHRvbVtpXSAtIHN0b3BbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgSEJhclZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGhpdHMsIHJlZiwgcmVzdWx0LCB2eCwgdnksIHgsIHk7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ4LCB0cnVlKTtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfZnJvbV90YXJnZXQodnksIHRydWUpO1xuICAgICAgICBoaXRzID0gdGhpcy5pbmRleC5pbmRpY2VzKHtcbiAgICAgICAgICAgIG1pblg6IHgsXG4gICAgICAgICAgICBtaW5ZOiB5LFxuICAgICAgICAgICAgbWF4WDogeCxcbiAgICAgICAgICAgIG1heFk6IHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICByZXN1bHRbJzFkJ10uaW5kaWNlcyA9IGhpdHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIQmFyVmlldy5wcm90b3R5cGUuc2N4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNsZWZ0W2ldICsgdGhpcy5zcmlnaHRbaV0pIC8gMjtcbiAgICB9O1xuICAgIEhCYXJWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfYXJlYV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIEhCYXJWaWV3O1xufSkoZ2x5cGhfMS5HbHlwaFZpZXcpO1xuZXhwb3J0cy5IQmFyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhCYXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEhCYXIoKSB7XG4gICAgICAgIHJldHVybiBIQmFyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIQmFyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkhCYXJWaWV3O1xuICAgIEhCYXIucHJvdG90eXBlLnR5cGUgPSAnSEJhcic7XG4gICAgSEJhci5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgSEJhci5kZWZpbmUoe1xuICAgICAgICB5OiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgaGVpZ2h0OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBsZWZ0OiBbcC5OdW1iZXJTcGVjLCAwXSxcbiAgICAgICAgcmlnaHQ6IFtwLk51bWJlclNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIEhCYXI7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEdyZXlzOSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBsaW5lYXJfY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9saW5lYXJfY29sb3JfbWFwcGVyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuZXhwb3J0cy5JbWFnZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW1hZ2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbWFnZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEltYWdlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEltYWdlVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmNvbG9yX21hcHBlciwgJ2NoYW5nZScsIHRoaXMuX3VwZGF0ZV9pbWFnZSk7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLl91cGRhdGVfaW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0X2RhdGEoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZiwgYnVmOCwgY2FudmFzLCBjbWFwLCBjdHgsIGksIGltYWdlX2RhdGEsIGltZywgaiwgcmVmLCByZXN1bHRzLCBzaGFwZTtcbiAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGEgPT0gbnVsbCkgfHwgdGhpcy5pbWFnZV9kYXRhLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlX2RhdGEgPSBuZXcgQXJyYXkodGhpcy5faW1hZ2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3dpZHRoID09IG51bGwpIHx8IHRoaXMuX3dpZHRoLmxlbmd0aCAhPT0gdGhpcy5faW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5faGVpZ2h0ID09IG51bGwpIHx8IHRoaXMuX2hlaWdodC5sZW5ndGggIT09IHRoaXMuX2ltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3IEFycmF5KHRoaXMuX2ltYWdlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5faW1hZ2UubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHNoYXBlID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5faW1hZ2Vfc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5faW1hZ2Vfc2hhcGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGltZyA9IHRoaXMuX2ltYWdlW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodFtpXSA9IHNoYXBlWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoW2ldID0gc2hhcGVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWcgPSBhcnJheV8xLmNvbmNhdCh0aGlzLl9pbWFnZVtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0W2ldID0gdGhpcy5faW1hZ2VbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoW2ldID0gdGhpcy5faW1hZ2VbaV1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmltYWdlX2RhdGFbaV0gIT0gbnVsbCkgJiYgdGhpcy5pbWFnZV9kYXRhW2ldLndpZHRoID09PSB0aGlzLl93aWR0aFtpXSAmJiB0aGlzLmltYWdlX2RhdGFbaV0uaGVpZ2h0ID09PSB0aGlzLl9oZWlnaHRbaV0pIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSB0aGlzLmltYWdlX2RhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl93aWR0aFtpXTtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpbWFnZV9kYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl93aWR0aFtpXSwgdGhpcy5faGVpZ2h0W2ldKTtcbiAgICAgICAgICAgIGNtYXAgPSB0aGlzLm1vZGVsLmNvbG9yX21hcHBlcjtcbiAgICAgICAgICAgIGJ1ZiA9IGNtYXAudl9tYXBfc2NyZWVuKGltZywgdHJ1ZSk7XG4gICAgICAgICAgICBidWY4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgICAgIGltYWdlX2RhdGEuZGF0YS5zZXQoYnVmOCk7XG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlX2RhdGEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5pbWFnZV9kYXRhW2ldID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5tYXhfZHcgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R3LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4X2R3ID0gYXJyYXlfMS5tYXgodGhpcy5fZHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXhfZGggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLm1heF9kaCA9IGFycmF5XzEubWF4KHRoaXMuX2RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kdy51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gsIHRoaXMuX2R3LCAnZWRnZScsIHRoaXMubW9kZWwuZGlsYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY3JlZW5cIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN3ID0gdGhpcy5fZHc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGgudW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueW1hcHBlciwgdGhpcy5feSwgdGhpcy5fZGgsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgY2FzZSBcInNjcmVlblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNoID0gdGhpcy5fZGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaW1hZ2VfZGF0YSwgaiwgbGVuLCBvbGRfc21vb3RoaW5nLCBzaCwgc3csIHN4LCBzeSwgeV9vZmZzZXQ7XG4gICAgICAgIGltYWdlX2RhdGEgPSBhcmcuaW1hZ2VfZGF0YSwgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5LCBzdyA9IGFyZy5zdywgc2ggPSBhcmcuc2g7XG4gICAgICAgIG9sZF9zbW9vdGhpbmcgPSBjdHguZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCk7XG4gICAgICAgIGN0eC5zZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpbWFnZV9kYXRhW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3dbaV0gKyBzaFtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlfb2Zmc2V0ID0gc3lbaV07XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHlfb2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC15X29mZnNldCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlX2RhdGFbaV0sIHN4W2ldIHwgMCwgc3lbaV0gfCAwLCBzd1tpXSwgc2hbaV0pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5X29mZnNldCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAteV9vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHguc2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKG9sZF9zbW9vdGhpbmcpO1xuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5ib3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBiYm94ID0gdGhpcy5pbmRleC5iYm94O1xuICAgICAgICBiYm94Lm1heFggKz0gdGhpcy5tYXhfZHc7XG4gICAgICAgIGJib3gubWF4WSArPSB0aGlzLm1heF9kaDtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5HcmV5czkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFsweDAwMDAwMCwgMHgyNTI1MjUsIDB4NTI1MjUyLCAweDczNzM3MywgMHg5Njk2OTYsIDB4YmRiZGJkLCAweGQ5ZDlkOSwgMHhmMGYwZjAsIDB4ZmZmZmZmXTtcbn07XG5leHBvcnRzLkltYWdlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5JbWFnZVZpZXc7XG4gICAgSW1hZ2UucHJvdG90eXBlLnR5cGUgPSAnSW1hZ2UnO1xuICAgIEltYWdlLmRlZmluZSh7XG4gICAgICAgIGltYWdlOiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgZHc6IFtwLkRpc3RhbmNlU3BlY10sXG4gICAgICAgIGRoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaWxhdGU6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgY29sb3JfbWFwcGVyOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaW5lYXJfY29sb3JfbWFwcGVyXzEuTGluZWFyQ29sb3JNYXBwZXIoe1xuICAgICAgICAgICAgICAgICAgICBwYWxldHRlOiBHcmV5czkoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIEltYWdlO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG5leHBvcnRzLkltYWdlUkdCQVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW1hZ2VSR0JBVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2VSR0JBVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlUkdCQVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEltYWdlUkdCQVZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uIChzb3VyY2UsIGFyZykge1xuICAgICAgICB2YXIgYnVmLCBidWY4LCBjYW52YXMsIGNvbG9yLCBjdHgsIGZsYXQsIGksIGltYWdlX2RhdGEsIGosIGssIGwsIG0sIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0cywgc2hhcGU7XG4gICAgICAgIGlmICgodGhpcy5pbWFnZV9kYXRhID09IG51bGwpIHx8IHRoaXMuaW1hZ2VfZGF0YS5sZW5ndGggIT09IHRoaXMuX2ltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZV9kYXRhID0gbmV3IEFycmF5KHRoaXMuX2ltYWdlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLl93aWR0aCA9PSBudWxsKSB8fCB0aGlzLl93aWR0aC5sZW5ndGggIT09IHRoaXMuX2ltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSBuZXcgQXJyYXkodGhpcy5faW1hZ2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX2hlaWdodCA9PSBudWxsKSB8fCB0aGlzLl9oZWlnaHQubGVuZ3RoICE9PSB0aGlzLl9pbWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuX2ltYWdlLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoYXJnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXBlID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5faW1hZ2Vfc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5faW1hZ2Vfc2hhcGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0W2ldID0gdGhpcy5fcm93c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aFtpXSA9IHRoaXMuX2NvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gdGhpcy5faW1hZ2VbaV0uYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdCA9IHRoaXMuX2ltYWdlW2ldO1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoZmxhdC5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjEgPSBmbGF0Lmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3Jbal0gPSBmbGF0W2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IHRoaXMuX2ltYWdlW2ldLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHRbaV0gPSBzaGFwZVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aFtpXSA9IHNoYXBlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhdCA9IGFycmF5XzEuY29uY2F0KHRoaXMuX2ltYWdlW2ldKTtcbiAgICAgICAgICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoZmxhdC5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgICAgICBjb2xvciA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IG0gPSAwLCByZWYyID0gZmxhdC5sZW5ndGg7IDAgPD0gcmVmMiA/IG0gPCByZWYyIDogbSA+IHJlZjI7IGogPSAwIDw9IHJlZjIgPyArK20gOiAtLW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3Jbal0gPSBmbGF0W2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHRbaV0gPSB0aGlzLl9pbWFnZVtpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhbaV0gPSB0aGlzLl9pbWFnZVtpXVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuaW1hZ2VfZGF0YVtpXSAhPSBudWxsKSAmJiB0aGlzLmltYWdlX2RhdGFbaV0ud2lkdGggPT09IHRoaXMuX3dpZHRoW2ldICYmIHRoaXMuaW1hZ2VfZGF0YVtpXS5oZWlnaHQgPT09IHRoaXMuX2hlaWdodFtpXSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuaW1hZ2VfZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3dpZHRoW2ldO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGltYWdlX2RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuX3dpZHRoW2ldLCB0aGlzLl9oZWlnaHRbaV0pO1xuICAgICAgICAgICAgYnVmOCA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgICAgICBpbWFnZV9kYXRhLmRhdGEuc2V0KGJ1ZjgpO1xuICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZV9kYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VfZGF0YVtpXSA9IGNhbnZhcztcbiAgICAgICAgICAgIHRoaXMubWF4X2R3ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kdy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heF9kdyA9IGFycmF5XzEubWF4KHRoaXMuX2R3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF4X2RoID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5tYXhfZGggPSBhcnJheV8xLm1heCh0aGlzLl9kaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBJbWFnZVJHQkFWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmR3LnVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueG1hcHBlciwgdGhpcy5feCwgdGhpcy5fZHcsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjcmVlblwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLl9kdztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwucHJvcGVydGllcy5kaC51bml0cykge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci55bWFwcGVyLCB0aGlzLl95LCB0aGlzLl9kaCwgJ2VkZ2UnLCB0aGlzLm1vZGVsLmRpbGF0ZSk7XG4gICAgICAgICAgICBjYXNlIFwic2NyZWVuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLl9kaDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VSR0JBVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZzEpIHtcbiAgICAgICAgdmFyIGksIGltYWdlX2RhdGEsIGssIGxlbiwgb2xkX3Ntb290aGluZywgc2gsIHN3LCBzeCwgc3ksIHlfb2Zmc2V0O1xuICAgICAgICBpbWFnZV9kYXRhID0gYXJnMS5pbWFnZV9kYXRhLCBzeCA9IGFyZzEuc3gsIHN5ID0gYXJnMS5zeSwgc3cgPSBhcmcxLnN3LCBzaCA9IGFyZzEuc2g7XG4gICAgICAgIG9sZF9zbW9vdGhpbmcgPSBjdHguZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCk7XG4gICAgICAgIGN0eC5zZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3dbaV0gKyBzaFtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlfb2Zmc2V0ID0gc3lbaV07XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHlfb2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC15X29mZnNldCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlX2RhdGFbaV0sIHN4W2ldIHwgMCwgc3lbaV0gfCAwLCBzd1tpXSwgc2hbaV0pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5X29mZnNldCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAteV9vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHguc2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKG9sZF9zbW9vdGhpbmcpO1xuICAgIH07XG4gICAgSW1hZ2VSR0JBVmlldy5wcm90b3R5cGUuYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgYmJveCA9IHRoaXMuaW5kZXguYmJveDtcbiAgICAgICAgYmJveC5tYXhYICs9IHRoaXMubWF4X2R3O1xuICAgICAgICBiYm94Lm1heFkgKz0gdGhpcy5tYXhfZGg7XG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgcmV0dXJuIEltYWdlUkdCQVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuSW1hZ2VSR0JBID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlUkdCQSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2VSR0JBKCkge1xuICAgICAgICByZXR1cm4gSW1hZ2VSR0JBLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZVJHQkEucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuSW1hZ2VSR0JBVmlldztcbiAgICBJbWFnZVJHQkEucHJvdG90eXBlLnR5cGUgPSAnSW1hZ2VSR0JBJztcbiAgICBJbWFnZVJHQkEuZGVmaW5lKHtcbiAgICAgICAgaW1hZ2U6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICByb3dzOiBbcC5OdW1iZXJTcGVjXSxcbiAgICAgICAgY29sczogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIGR3OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgZGlsYXRlOiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICBJbWFnZVJHQkEucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgSW1hZ2VSR0JBLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMucm93cy5vcHRpb25hbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuY29scy5vcHRpb25hbCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VSR0JBO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuSW1hZ2VVUkxWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlVVJMVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2VVUkxWaWV3KCkge1xuICAgICAgICByZXR1cm4gSW1hZ2VVUkxWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbWFnZVVSTFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBJbWFnZVVSTFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTpnbG9iYWxfYWxwaGEnLCB0aGlzLnJlbmRlcmVyLnJlcXVlc3RfcmVuZGVyKTtcbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgSW1hZ2VVUkxWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBpbWcsIGosIHJlZiwgcmVzdWx0cywgcmV0cnlfYXR0ZW1wdHMsIHJldHJ5X3RpbWVvdXQ7XG4gICAgICAgIGlmICgodGhpcy5pbWFnZSA9PSBudWxsKSB8fCB0aGlzLmltYWdlLmxlbmd0aCAhPT0gdGhpcy5fdXJsLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMuX3VybDtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZyA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlfYXR0ZW1wdHMgPSB0aGlzLm1vZGVsLnJldHJ5X2F0dGVtcHRzO1xuICAgICAgICByZXRyeV90aW1lb3V0ID0gdGhpcy5tb2RlbC5yZXRyeV90aW1lb3V0O1xuICAgICAgICB0aGlzLnJldHJpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVmID0gdGhpcy5fdXJsO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW1nID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXRyeV9hdHRlbXB0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fdXJsLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXJsW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXRyaWVzW2ldID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCJJbWFnZVVSTCBmYWlsZWQgdG8gbG9hZCBcIiArIF90aGlzLl91cmxbaV0gKyBcIiBpbWFnZSwgcmV0cnlpbmcgaW4gXCIgKyByZXRyeV90aW1lb3V0ICsgXCIgbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1nLnNyYyA9IF90aGlzLl91cmxbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHJldHJ5X3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiSW1hZ2VVUkwgdW5hYmxlIHRvIGxvYWQgXCIgKyBfdGhpcy5fdXJsW2ldICsgXCIgaW1hZ2UgYWZ0ZXIgXCIgKyByZXRyeV9hdHRlbXB0cyArIFwiIHJldHJpZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmV0cmllc1tpXSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKShpLCBpbWcpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGltZywgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2VbaV0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVuZGVyZXIucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykoaW1nLCBpKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbWcuc3JjID0gdGhpcy5fdXJsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHMsIHdzLCB4O1xuICAgICAgICB3cyA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5feDtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSByZWZbal07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgwIC8gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgaHMgPSAoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIGlmICh0aGlzLl9oICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goMCAvIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLncudW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl94LCB3cywgJ2VkZ2UnLCB0aGlzLm1vZGVsLmRpbGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NyZWVuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdyA9IHdzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLmgudW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueW1hcHBlciwgdGhpcy5feSwgaHMsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgY2FzZSBcInNjcmVlblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNoID0gaHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgX2FuZ2xlLCBfdXJsLCBmcmFtZSwgaSwgaW1hZ2UsIGosIGxlbiwgcmVzdWx0cywgc2gsIHN3LCBzeCwgc3k7XG4gICAgICAgIF91cmwgPSBhcmcuX3VybCwgaW1hZ2UgPSBhcmcuaW1hZ2UsIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBmcmFtZSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICBjdHgucmVjdChmcmFtZS5sZWZ0ICsgMSwgZnJhbWUuYm90dG9tICsgMSwgZnJhbWUud2lkdGggLSAyLCBmcmFtZS5oZWlnaHQgLSAyKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cmllc1tpXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWFnZVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fcmVuZGVyX2ltYWdlKGN0eCwgaSwgaW1hZ2VbaV0sIHN4LCBzeSwgc3csIHNoLCBfYW5nbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEltYWdlVVJMVmlldy5wcm90b3R5cGUuX2ZpbmFsX3N4X3N5ID0gZnVuY3Rpb24gKGFuY2hvciwgc3gsIHN5LCBzdywgc2gpIHtcbiAgICAgICAgc3dpdGNoIChhbmNob3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcF9sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgICAgICAgICBjYXNlICd0b3BfY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N4IC0gc3cgLyAyLCBzeV07XG4gICAgICAgICAgICBjYXNlICd0b3BfcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3ggLSBzdywgc3ldO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N4IC0gc3csIHN5IC0gc2ggLyAyXTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCAtIHN3LCBzeSAtIHNoXTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9jZW50ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3ggLSBzdyAvIDIsIHN5IC0gc2hdO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tX2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3gsIHN5IC0gc2hdO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyX2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbc3gsIHN5IC0gc2ggLyAyXTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeCAtIHN3IC8gMiwgc3kgLSBzaCAvIDJdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVVSTFZpZXcucHJvdG90eXBlLl9yZW5kZXJfaW1hZ2UgPSBmdW5jdGlvbiAoY3R4LCBpLCBpbWFnZSwgc3gsIHN5LCBzdywgc2gsIGFuZ2xlKSB7XG4gICAgICAgIHZhciBhbmNob3IsIHJlZjtcbiAgICAgICAgaWYgKGlzTmFOKHN3W2ldKSkge1xuICAgICAgICAgICAgc3dbaV0gPSBpbWFnZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oc2hbaV0pKSB7XG4gICAgICAgICAgICBzaFtpXSA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhbmNob3IgPSB0aGlzLm1vZGVsLmFuY2hvcjtcbiAgICAgICAgcmVmID0gdGhpcy5fZmluYWxfc3hfc3koYW5jaG9yLCBzeFtpXSwgc3lbaV0sIHN3W2ldLCBzaFtpXSksIHN4ID0gcmVmWzBdLCBzeSA9IHJlZlsxXTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5tb2RlbC5nbG9iYWxfYWxwaGE7XG4gICAgICAgIGlmIChhbmdsZVtpXSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZVtpXSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBzd1tpXSwgc2hbaV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGVbaV0pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3gsIC1zeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VVUkxWaWV3O1xufSkoZ2x5cGhfMS5HbHlwaFZpZXcpO1xuZXhwb3J0cy5JbWFnZVVSTCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbWFnZVVSTCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW1hZ2VVUkwoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVVSTC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW1hZ2VVUkwucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuSW1hZ2VVUkxWaWV3O1xuICAgIEltYWdlVVJMLnByb3RvdHlwZS50eXBlID0gJ0ltYWdlVVJMJztcbiAgICBJbWFnZVVSTC5jb29yZHMoW1sneCcsICd5J11dKTtcbiAgICBJbWFnZVVSTC5taXhpbnMoW10pO1xuICAgIEltYWdlVVJMLmRlZmluZSh7XG4gICAgICAgIHVybDogW3AuU3RyaW5nU3BlY10sXG4gICAgICAgIGFuY2hvcjogW3AuQW5jaG9yLCAndG9wX2xlZnQnXSxcbiAgICAgICAgZ2xvYmFsX2FscGhhOiBbcC5OdW1iZXIsIDEuMF0sXG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdLFxuICAgICAgICB3OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaWxhdGU6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgcmV0cnlfYXR0ZW1wdHM6IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHJldHJ5X3RpbWVvdXQ6IFtwLk51bWJlciwgMF1cbiAgICB9KTtcbiAgICByZXR1cm4gSW1hZ2VVUkw7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFubnVsYXJfd2VkZ2VfMSA9IHJlcXVpcmUoXCIuL2FubnVsYXJfd2VkZ2VcIik7XG5leHBvcnRzLkFubnVsYXJXZWRnZSA9IGFubnVsYXJfd2VkZ2VfMS5Bbm51bGFyV2VkZ2U7XG52YXIgYW5udWx1c18xID0gcmVxdWlyZShcIi4vYW5udWx1c1wiKTtcbmV4cG9ydHMuQW5udWx1cyA9IGFubnVsdXNfMS5Bbm51bHVzO1xudmFyIGFyY18xID0gcmVxdWlyZShcIi4vYXJjXCIpO1xuZXhwb3J0cy5BcmMgPSBhcmNfMS5BcmM7XG52YXIgYmV6aWVyXzEgPSByZXF1aXJlKFwiLi9iZXppZXJcIik7XG5leHBvcnRzLkJlemllciA9IGJlemllcl8xLkJlemllcjtcbnZhciBjaXJjbGVfMSA9IHJlcXVpcmUoXCIuL2NpcmNsZVwiKTtcbmV4cG9ydHMuQ2lyY2xlID0gY2lyY2xlXzEuQ2lyY2xlO1xudmFyIGVsbGlwc2VfMSA9IHJlcXVpcmUoXCIuL2VsbGlwc2VcIik7XG5leHBvcnRzLkVsbGlwc2UgPSBlbGxpcHNlXzEuRWxsaXBzZTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG5leHBvcnRzLkdseXBoID0gZ2x5cGhfMS5HbHlwaDtcbnZhciBoYmFyXzEgPSByZXF1aXJlKFwiLi9oYmFyXCIpO1xuZXhwb3J0cy5IQmFyID0gaGJhcl8xLkhCYXI7XG52YXIgaW1hZ2VfMSA9IHJlcXVpcmUoXCIuL2ltYWdlXCIpO1xuZXhwb3J0cy5JbWFnZSA9IGltYWdlXzEuSW1hZ2U7XG52YXIgaW1hZ2VfcmdiYV8xID0gcmVxdWlyZShcIi4vaW1hZ2VfcmdiYVwiKTtcbmV4cG9ydHMuSW1hZ2VSR0JBID0gaW1hZ2VfcmdiYV8xLkltYWdlUkdCQTtcbnZhciBpbWFnZV91cmxfMSA9IHJlcXVpcmUoXCIuL2ltYWdlX3VybFwiKTtcbmV4cG9ydHMuSW1hZ2VVUkwgPSBpbWFnZV91cmxfMS5JbWFnZVVSTDtcbnZhciBsaW5lXzEgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuZXhwb3J0cy5MaW5lID0gbGluZV8xLkxpbmU7XG52YXIgbXVsdGlfbGluZV8xID0gcmVxdWlyZShcIi4vbXVsdGlfbGluZVwiKTtcbmV4cG9ydHMuTXVsdGlMaW5lID0gbXVsdGlfbGluZV8xLk11bHRpTGluZTtcbnZhciBvdmFsXzEgPSByZXF1aXJlKFwiLi9vdmFsXCIpO1xuZXhwb3J0cy5PdmFsID0gb3ZhbF8xLk92YWw7XG52YXIgcGF0Y2hfMSA9IHJlcXVpcmUoXCIuL3BhdGNoXCIpO1xuZXhwb3J0cy5QYXRjaCA9IHBhdGNoXzEuUGF0Y2g7XG52YXIgcGF0Y2hlc18xID0gcmVxdWlyZShcIi4vcGF0Y2hlc1wiKTtcbmV4cG9ydHMuUGF0Y2hlcyA9IHBhdGNoZXNfMS5QYXRjaGVzO1xudmFyIHF1YWRfMSA9IHJlcXVpcmUoXCIuL3F1YWRcIik7XG5leHBvcnRzLlF1YWQgPSBxdWFkXzEuUXVhZDtcbnZhciBxdWFkcmF0aWNfMSA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcbmV4cG9ydHMuUXVhZHJhdGljID0gcXVhZHJhdGljXzEuUXVhZHJhdGljO1xudmFyIHJheV8xID0gcmVxdWlyZShcIi4vcmF5XCIpO1xuZXhwb3J0cy5SYXkgPSByYXlfMS5SYXk7XG52YXIgcmVjdF8xID0gcmVxdWlyZShcIi4vcmVjdFwiKTtcbmV4cG9ydHMuUmVjdCA9IHJlY3RfMS5SZWN0O1xudmFyIHNlZ21lbnRfMSA9IHJlcXVpcmUoXCIuL3NlZ21lbnRcIik7XG5leHBvcnRzLlNlZ21lbnQgPSBzZWdtZW50XzEuU2VnbWVudDtcbnZhciB0ZXh0XzEgPSByZXF1aXJlKFwiLi90ZXh0XCIpO1xuZXhwb3J0cy5UZXh0ID0gdGV4dF8xLlRleHQ7XG52YXIgdmJhcl8xID0gcmVxdWlyZShcIi4vdmJhclwiKTtcbmV4cG9ydHMuVkJhciA9IHZiYXJfMS5WQmFyO1xudmFyIHdlZGdlXzEgPSByZXF1aXJlKFwiLi93ZWRnZVwiKTtcbmV4cG9ydHMuV2VkZ2UgPSB3ZWRnZV8xLldlZGdlO1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbmV4cG9ydHMuWFlHbHlwaCA9IHh5X2dseXBoXzEuWFlHbHlwaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG5leHBvcnRzLkxpbmVWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExpbmVWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgZHJhd2luZywgaSwgaiwgbGVuLCBzeCwgc3k7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeTtcbiAgICAgICAgZHJhd2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKHN4W2ldICsgc3lbaV0pICYmIGRyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICBkcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhd2luZykge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVZpZXcucHJvdG90eXBlLl9oaXRfcG9pbnQgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgLyogQ2hlY2sgaWYgdGhlIHBvaW50IGdlb21ldHJ5IGhpdHMgdGhpcyBsaW5lIGdseXBoIGFuZCByZXR1cm4gYW4gb2JqZWN0XG4gICAgICAgIHRoYXQgZGVzY3JpYmVzIHRoZSBoaXQgcmVzdWx0OlxuICAgICAgICAgIEFyZ3M6XG4gICAgICAgICAgICAqIGdlb21ldHJ5IChvYmplY3QpOiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGtleXNcbiAgICAgICAgICAgICAgKiB2eCAoZmxvYXQpOiB2aWV3IHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgICAgICAgICAgKiB2eSAoZmxvYXQpOiB2aWV3IHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgICAgICAgICAgKiB0eXBlIChzdHIpOiB0eXBlIG9mIGdlb21ldHJ5IChpbiB0aGlzIGNhc2UgaXQncyBhIHBvaW50KVxuICAgICAgICAgIE91dHB1dDpcbiAgICAgICAgICAgIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgICAgICAgICAgKiAwZCAoYm9vbCk6IHdoZXRoZXIgdGhlIHBvaW50IGhpdHMgdGhlIGdseXBoIG9yIG5vdFxuICAgICAgICAgICAgICAqIDFkIChhcnJheShpbnQpKTogYXJyYXkgd2l0aCB0aGUgaW5kaWNlcyBoaXQgYnkgdGhlIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGlzdCwgaSwgaiwgcDAsIHAxLCBwb2ludCwgcmVmLCByZWYxLCByZXN1bHQsIHNob3J0ZXN0LCB0aHJlc2hvbGQ7XG4gICAgICAgIHJlc3VsdCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeChnZW9tZXRyeS52eCksXG4gICAgICAgICAgICB5OiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3koZ2VvbWV0cnkudnkpXG4gICAgICAgIH07XG4gICAgICAgIHNob3J0ZXN0ID0gOTk5OTtcbiAgICAgICAgdGhyZXNob2xkID0gTWF0aC5tYXgoMiwgdGhpcy52aXN1YWxzLmxpbmUubGluZV93aWR0aC52YWx1ZSgpIC8gMik7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLnN4Lmxlbmd0aCAtIDE7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgcmVmMSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc3hbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuc3lbaV1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc3hbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnN5W2kgKyAxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sIHAwID0gcmVmMVswXSwgcDEgPSByZWYxWzFdO1xuICAgICAgICAgICAgZGlzdCA9IGhpdHRlc3QuZGlzdF90b19zZWdtZW50KHBvaW50LCBwMCwgcDEpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCB0aHJlc2hvbGQgJiYgZGlzdCA8IHNob3J0ZXN0KSB7XG4gICAgICAgICAgICAgICAgc2hvcnRlc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIHJlc3VsdFsnMGQnXS5nbHlwaCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmdldF92aWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbJzBkJ10uZmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmluZGljZXMgPSBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExpbmVWaWV3LnByb3RvdHlwZS5faGl0X3NwYW4gPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZiwgcmVmMSwgcmVzdWx0LCB2YWwsIHZhbHVlcywgdngsIHZ5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmRpcmVjdGlvbiA9PT0gJ3YnKSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5KTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ4KTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3g7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB2YWx1ZXMubGVuZ3RoIC0gMTsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgaWYgKCh2YWx1ZXNbaV0gPD0gdmFsICYmIHZhbCA8PSB2YWx1ZXNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFsnMGQnXS5nbHlwaCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmdldF92aWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbJzBkJ10uZmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0WycwZCddLmluZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTGluZVZpZXcucHJvdG90eXBlLmdldF9pbnRlcnBvbGF0aW9uX2hpdCA9IGZ1bmN0aW9uIChpLCBnZW9tZXRyeSkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3LCByZXMsIHZ4LCB2eSwgeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzO1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gW3RoaXMuX3hbaV0sIHRoaXMuX3lbaV0sIHRoaXMuX3hbaSArIDFdLCB0aGlzLl95W2kgKyAxXV0sIHgyID0gcmVmMVswXSwgeTIgPSByZWYxWzFdLCB4MyA9IHJlZjFbMl0sIHkzID0gcmVmMVszXTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgIHJlZjIgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z5IC0gMSwgdnkgKyAxXSksIHkwID0gcmVmMlswXSwgeTEgPSByZWYyWzFdO1xuICAgICAgICAgICAgcmVmMyA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdnggLSAxLCB2eCArIDFdKSwgeDAgPSByZWYzWzBdLCB4MSA9IHJlZjNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuZGlyZWN0aW9uID09PSAndicpIHtcbiAgICAgICAgICAgICAgICByZWY0ID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFt2eSwgdnldKSwgeTAgPSByZWY0WzBdLCB5MSA9IHJlZjRbMV07XG4gICAgICAgICAgICAgICAgcmVmNSA9IFt4MiwgeDNdLCB4MCA9IHJlZjVbMF0sIHgxID0gcmVmNVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZjYgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z4LCB2eF0pLCB4MCA9IHJlZjZbMF0sIHgxID0gcmVmNlsxXTtcbiAgICAgICAgICAgICAgICByZWY3ID0gW3kyLCB5M10sIHkwID0gcmVmN1swXSwgeTEgPSByZWY3WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGhpdHRlc3QuY2hlY2tfMl9zZWdtZW50c19pbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgcmV0dXJuIFtyZXMueCwgcmVzLnldO1xuICAgIH07XG4gICAgTGluZVZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19saW5lX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuTGluZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMaW5lLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lKCkge1xuICAgICAgICByZXR1cm4gTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5MaW5lVmlldztcbiAgICBMaW5lLnByb3RvdHlwZS50eXBlID0gJ0xpbmUnO1xuICAgIExpbmUubWl4aW5zKFsnbGluZSddKTtcbiAgICByZXR1cm4gTGluZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbmV4cG9ydHMuTXVsdGlMaW5lVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNdWx0aUxpbmVWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNdWx0aUxpbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gTXVsdGlMaW5lVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTXVsdGlMaW5lVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBrLCBwb2ludHMsIHJlZiwgeCwgeHMsIHksIHlzO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHRoaXMuX3hzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICB4cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwsIGxlbiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZWYxID0gdGhpcy5feHNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJlZjFbbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZXNfMS5pc1N0cmljdE5hTih4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCwgbGVuLCByZWYxLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZjEgPSB0aGlzLl95c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xuICAgICAgICAgICAgICAgICAgICB5ID0gcmVmMVtsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlc18xLmlzU3RyaWN0TmFOKHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1pblg6IGFycmF5XzEubWluKHhzKSxcbiAgICAgICAgICAgICAgICBtaW5ZOiBhcnJheV8xLm1pbih5cyksXG4gICAgICAgICAgICAgICAgbWF4WDogYXJyYXlfMS5tYXgoeHMpLFxuICAgICAgICAgICAgICAgIG1heFk6IGFycmF5XzEubWF4KHlzKSxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgTXVsdGlMaW5lVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgaSwgaiwgaywgbCwgbGVuLCByZWYsIHJlZjEsIHJlc3VsdHMsIHN4LCBzeHMsIHN5LCBzeXM7XG4gICAgICAgIHN4cyA9IGFyZy5zeHMsIHN5cyA9IGFyZy5zeXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNba107XG4gICAgICAgICAgICByZWYgPSBbc3hzW2ldLCBzeXNbaV1dLCBzeCA9IHJlZlswXSwgc3kgPSByZWZbMV07XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICBmb3IgKGogPSBsID0gMCwgcmVmMSA9IHN4Lmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeFtqXSwgc3lbal0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4oc3hbal0pIHx8IGlzTmFOKHN5W2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2pdLCBzeVtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNdWx0aUxpbmVWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBkaXN0LCBoaXRzLCBpLCBqLCBrLCBsLCBwMCwgcDEsIHBvaW50LCBwb2ludHMsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0LCBzaG9ydGVzdCwgdGhyZXNob2xkO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3goZ2VvbWV0cnkudngpLFxuICAgICAgICAgICAgeTogdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KGdlb21ldHJ5LnZ5KVxuICAgICAgICB9O1xuICAgICAgICBzaG9ydGVzdCA9IDk5OTk7XG4gICAgICAgIHRocmVzaG9sZCA9IE1hdGgubWF4KDIsIHRoaXMudmlzdWFscy5saW5lLmxpbmVfd2lkdGgudmFsdWUoKSAvIDIpO1xuICAgICAgICBoaXRzID0ge307XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSB0aGlzLnN4cy5sZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0gdGhpcy5zeHNbaV0ubGVuZ3RoIC0gMTsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIHJlZjIgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuc3hzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zeXNbaV1bal1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zeHNbaV1baiArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zeXNbaV1baiArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLCBwMCA9IHJlZjJbMF0sIHAxID0gcmVmMlsxXTtcbiAgICAgICAgICAgICAgICBkaXN0ID0gaGl0dGVzdC5kaXN0X3RvX3NlZ21lbnQocG9pbnQsIHAwLCBwMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCB0aHJlc2hvbGQgJiYgZGlzdCA8IHNob3J0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3J0ZXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBoaXRzW2ldID0gcG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gT2JqZWN0LmtleXMoaGl0cyk7XG4gICAgICAgIHJlc3VsdFsnMmQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE11bHRpTGluZVZpZXcucHJvdG90eXBlLl9oaXRfc3BhbiA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgaGl0cywgaSwgaiwgaywgbCwgcG9pbnRzLCByZWYsIHJlZjEsIHJlZjIsIHJlc3VsdCwgdmFsLCB2YWx1ZXMsIHZ4LCB2eTtcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIGlmIChnZW9tZXRyeS5kaXJlY3Rpb24gPT09ICd2Jykge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eSk7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLl95cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucmVuZGVyZXIueG1hcHBlci5tYXBfZnJvbV90YXJnZXQodngpO1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5feHM7XG4gICAgICAgIH1cbiAgICAgICAgaGl0cyA9IHt9O1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IHZhbHVlcy5sZW5ndGg7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjIgPSB2YWx1ZXNbaV0ubGVuZ3RoIC0gMTsgMCA8PSByZWYyID8gbCA8IHJlZjIgOiBsID4gcmVmMjsgaiA9IDAgPD0gcmVmMiA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWVzW2ldW2pdIDw9IHZhbCAmJiB2YWwgPD0gdmFsdWVzW2ldW2ogKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGl0c1tpXSA9IHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbJzFkJ10uaW5kaWNlcyA9IE9iamVjdC5rZXlzKGhpdHMpO1xuICAgICAgICByZXN1bHRbJzJkJ10uaW5kaWNlcyA9IGhpdHM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNdWx0aUxpbmVWaWV3LnByb3RvdHlwZS5nZXRfaW50ZXJwb2xhdGlvbl9oaXQgPSBmdW5jdGlvbiAoaSwgcG9pbnRfaSwgZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVzLCB2eCwgdnksIHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MztcbiAgICAgICAgcmVmID0gW2dlb21ldHJ5LnZ4LCBnZW9tZXRyeS52eV0sIHZ4ID0gcmVmWzBdLCB2eSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IFt0aGlzLl94c1tpXVtwb2ludF9pXSwgdGhpcy5feXNbaV1bcG9pbnRfaV0sIHRoaXMuX3hzW2ldW3BvaW50X2kgKyAxXSwgdGhpcy5feXNbaV1bcG9pbnRfaSArIDFdXSwgeDIgPSByZWYxWzBdLCB5MiA9IHJlZjFbMV0sIHgzID0gcmVmMVsyXSwgeTMgPSByZWYxWzNdO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ3BvaW50Jykge1xuICAgICAgICAgICAgcmVmMiA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdnkgLSAxLCB2eSArIDFdKSwgeTAgPSByZWYyWzBdLCB5MSA9IHJlZjJbMV07XG4gICAgICAgICAgICByZWYzID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFt2eCAtIDEsIHZ4ICsgMV0pLCB4MCA9IHJlZjNbMF0sIHgxID0gcmVmM1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5kaXJlY3Rpb24gPT09ICd2Jykge1xuICAgICAgICAgICAgICAgIHJlZjQgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z5LCB2eV0pLCB5MCA9IHJlZjRbMF0sIHkxID0gcmVmNFsxXTtcbiAgICAgICAgICAgICAgICByZWY1ID0gW3gyLCB4M10sIHgwID0gcmVmNVswXSwgeDEgPSByZWY1WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmNiA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdngsIHZ4XSksIHgwID0gcmVmNlswXSwgeDEgPSByZWY2WzFdO1xuICAgICAgICAgICAgICAgIHJlZjcgPSBbeTIsIHkzXSwgeTAgPSByZWY3WzBdLCB5MSA9IHJlZjdbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gaGl0dGVzdC5jaGVja18yX3NlZ21lbnRzX2ludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICByZXR1cm4gW3Jlcy54LCByZXMueV07XG4gICAgfTtcbiAgICBNdWx0aUxpbmVWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpTGluZVZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLk11bHRpTGluZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNdWx0aUxpbmUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE11bHRpTGluZSgpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTXVsdGlMaW5lLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLk11bHRpTGluZVZpZXc7XG4gICAgTXVsdGlMaW5lLnByb3RvdHlwZS50eXBlID0gJ011bHRpTGluZSc7XG4gICAgTXVsdGlMaW5lLmNvb3JkcyhbWyd4cycsICd5cyddXSk7XG4gICAgTXVsdGlMaW5lLm1peGlucyhbJ2xpbmUnXSk7XG4gICAgcmV0dXJuIE11bHRpTGluZTtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuT3ZhbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoT3ZhbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE92YWxWaWV3KCkge1xuICAgICAgICByZXR1cm4gT3ZhbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE92YWxWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF4X3cyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWF4X3cyID0gdGhpcy5tYXhfd2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4X2gyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5oZWlnaHQudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfaDIgPSB0aGlzLm1heF9oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmFsVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLndpZHRoLnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5zdyA9IHRoaXMuc2Rpc3QodGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl94LCB0aGlzLl93aWR0aCwgJ2NlbnRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdyA9IHRoaXMuX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaGVpZ2h0LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ggPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueW1hcHBlciwgdGhpcy5feSwgdGhpcy5faGVpZ2h0LCAnY2VudGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZhbFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2gsIHN3LCBzeCwgc3k7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0gKyBzd1tpXSArIHNoW2ldICsgdGhpcy5fYW5nbGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMuX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgLXNoW2ldIC8gMik7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhzd1tpXSAvIDIsIC1zaFtpXSAvIDIsIHN3W2ldIC8gMiwgc2hbaV0gLyAyLCAwLCBzaFtpXSAvIDIpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oLXN3W2ldIC8gMiwgc2hbaV0gLyAyLCAtc3dbaV0gLyAyLCAtc2hbaV0gLyAyLCAwLCAtc2hbaV0gLyAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucm90YXRlKC10aGlzLl9hbmdsZVtpXSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgT3ZhbFZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICB2YXIgZCwgZGF0YSwgaW5kaWNlcywgc2NhbGUsIHNoLCBzdywgc3gsIHN5O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgc3ggPSB7fTtcbiAgICAgICAgc3hbaW5kZXhdID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgc3kgPSB7fTtcbiAgICAgICAgc3lbaW5kZXhdID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgc2NhbGUgPSB0aGlzLnN3W2luZGV4XSAvIHRoaXMuc2hbaW5kZXhdO1xuICAgICAgICBkID0gTWF0aC5taW4oTWF0aC5hYnMoeDEgLSB4MCksIE1hdGguYWJzKHkxIC0geTApKSAqIDAuODtcbiAgICAgICAgc3cgPSB7fTtcbiAgICAgICAgc2ggPSB7fTtcbiAgICAgICAgaWYgKHNjYWxlID4gMSkge1xuICAgICAgICAgICAgc3dbaW5kZXhdID0gZDtcbiAgICAgICAgICAgIHNoW2luZGV4XSA9IGQgLyBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3W2luZGV4XSA9IGQgKiBzY2FsZTtcbiAgICAgICAgICAgIHNoW2luZGV4XSA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgIHN5OiBzeSxcbiAgICAgICAgICAgIHN3OiBzdyxcbiAgICAgICAgICAgIHNoOiBzaFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyKGN0eCwgaW5kaWNlcywgZGF0YSk7XG4gICAgfTtcbiAgICBPdmFsVmlldy5wcm90b3R5cGUuX2JvdW5kcyA9IGZ1bmN0aW9uIChiZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4X3doMl9ib3VuZHMoYmRzKTtcbiAgICB9O1xuICAgIHJldHVybiBPdmFsVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5PdmFsID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE92YWwsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE92YWwoKSB7XG4gICAgICAgIHJldHVybiBPdmFsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPdmFsLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLk92YWxWaWV3O1xuICAgIE92YWwucHJvdG90eXBlLnR5cGUgPSAnT3ZhbCc7XG4gICAgT3ZhbC5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgT3ZhbC5kZWZpbmUoe1xuICAgICAgICBhbmdsZTogW3AuQW5nbGVTcGVjLCAwLjBdLFxuICAgICAgICB3aWR0aDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgaGVpZ2h0OiBbcC5EaXN0YW5jZVNwZWNdXG4gICAgfSk7XG4gICAgcmV0dXJuIE92YWw7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbmV4cG9ydHMuUGF0Y2hWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBhdGNoVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGF0Y2hWaWV3KCkge1xuICAgICAgICByZXR1cm4gUGF0Y2hWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQYXRjaFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGssIGxlbiwgbGVuMSwgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3k7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMuZmlsbC5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHN4W2ldICsgc3lbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN4W2ldLCBzeVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGF0Y2hWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfYXJlYV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGNoVmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5QYXRjaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYXRjaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGF0Y2goKSB7XG4gICAgICAgIHJldHVybiBQYXRjaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGF0Y2gucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUGF0Y2hWaWV3O1xuICAgIFBhdGNoLnByb3RvdHlwZS50eXBlID0gJ1BhdGNoJztcbiAgICBQYXRjaC5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgcmV0dXJuIFBhdGNoO1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xuZXhwb3J0cy5QYXRjaGVzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYXRjaGVzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGF0Y2hlc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQYXRjaGVzVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLl9idWlsZF9kaXNjb250aW51b3VzX29iamVjdCA9IGZ1bmN0aW9uIChuYW5uZWRfcXMpIHtcbiAgICAgICAgdmFyIGRlbmFubmVkLCBkcywgaSwgaywgbmFuX2luZGV4LCBxLCBxcywgcXNfcGFydCwgcmVmO1xuICAgICAgICBkcyA9IHt9O1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbmFubmVkX3FzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBkc1tpXSA9IFtdO1xuICAgICAgICAgICAgcXMgPSBhcnJheV8xLmNvcHkobmFubmVkX3FzW2ldKTtcbiAgICAgICAgICAgIHdoaWxlIChxcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbmFuX2luZGV4ID0gYXJyYXlfMS5maW5kTGFzdEluZGV4KHFzLCBmdW5jdGlvbiAocSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5pc1N0cmljdE5hTihxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmFuX2luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXNfcGFydCA9IHFzLnNwbGljZShuYW5faW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcXNfcGFydCA9IHFzO1xuICAgICAgICAgICAgICAgICAgICBxcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZW5hbm5lZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuID0gcXNfcGFydC5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHFzX3BhcnRbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVzXzEuaXNTdHJpY3ROYU4ocSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBkc1tpXS5wdXNoKGRlbmFubmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHM7XG4gICAgfTtcbiAgICBQYXRjaGVzVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBqLCBrLCBsLCBwb2ludHMsIHJlZiwgcmVmMSwgeHMsIHhzcywgeXMsIHlzcztcbiAgICAgICAgeHNzID0gdGhpcy5fYnVpbGRfZGlzY29udGludW91c19vYmplY3QodGhpcy5feHMpO1xuICAgICAgICB5c3MgPSB0aGlzLl9idWlsZF9kaXNjb250aW51b3VzX29iamVjdCh0aGlzLl95cyk7XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gdGhpcy5feHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0geHNzW2ldLmxlbmd0aDsgMCA8PSByZWYxID8gbCA8IHJlZjEgOiBsID4gcmVmMTsgaiA9IDAgPD0gcmVmMSA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIHhzID0geHNzW2ldW2pdO1xuICAgICAgICAgICAgICAgIHlzID0geXNzW2ldW2pdO1xuICAgICAgICAgICAgICAgIGlmICh4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWluWDogYXJyYXlfMS5taW4oeHMpLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBhcnJheV8xLm1pbih5cyksXG4gICAgICAgICAgICAgICAgICAgIG1heFg6IGFycmF5XzEubWF4KHhzKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4WTogYXJyYXlfMS5tYXgoeXMpLFxuICAgICAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzcGF0aWFsXzEuUkJ1c2gocG9pbnRzKTtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5fbWFza19kYXRhID0gZnVuY3Rpb24gKGFsbF9pbmRpY2VzKSB7XG4gICAgICAgIHZhciBiYm94LCByZWYsIHJlZjEsIHgwLCB4MSwgeHIsIHkwLCB5MSwgeXI7XG4gICAgICAgIHhyID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcueF9yYW5nZTtcbiAgICAgICAgcmVmID0gW3hyLm1pbiwgeHIubWF4XSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICB5ciA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LnlfcmFuZ2U7XG4gICAgICAgIHJlZjEgPSBbeXIubWluLCB5ci5tYXhdLCB5MCA9IHJlZjFbMF0sIHkxID0gcmVmMVsxXTtcbiAgICAgICAgYmJveCA9IGhpdHRlc3QudmFsaWRhdGVfYmJveF9jb29yZHMoW3gwLCB4MV0sIFt5MCwgeTFdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBrLCBsLCBsZW4sIG0sIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0cywgc3gsIHN4cywgc3ksIHN5cztcbiAgICAgICAgc3hzID0gYXJnLnN4cywgc3lzID0gYXJnLnN5cztcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zeHNzID0gdGhpcy5fYnVpbGRfZGlzY29udGludW91c19vYmplY3Qoc3hzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zeXNzID0gdGhpcy5fYnVpbGRfZGlzY29udGludW91c19vYmplY3Qoc3lzKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgIHJlZiA9IFtzeHNbaV0sIHN5c1tpXV0sIHN4ID0gcmVmWzBdLCBzeSA9IHJlZlsxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCByZWYxID0gc3gubGVuZ3RoOyAwIDw9IHJlZjEgPyBsIDwgcmVmMSA6IGwgPiByZWYxOyBqID0gMCA8PSByZWYxID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN4W2pdLCBzeVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05hTihzeFtqXSArIHN5W2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzeFtqXSwgc3lbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gbSA9IDAsIHJlZjIgPSBzeC5sZW5ndGg7IDAgPD0gcmVmMiA/IG0gPCByZWYyIDogbSA+IHJlZjI7IGogPSAwIDw9IHJlZjIgPyArK20gOiAtLW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3hbal0sIHN5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHN4W2pdICsgc3lbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3hbal0sIHN5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzLCBoaXRzLCBpLCBpZHgsIGosIGssIGwsIHJlZiwgcmVmMSwgcmVmMiwgcmVzdWx0LCBzeCwgc3hzLCBzeSwgc3lzLCB2eCwgdnksIHgsIHk7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHN4ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KHZ4KTtcbiAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5LCB0cnVlKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgIG1heFg6IHgsXG4gICAgICAgICAgICBtYXhZOiB5XG4gICAgICAgIH0pO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gY2FuZGlkYXRlcy5sZW5ndGg7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlkeCA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBzeHMgPSB0aGlzLnJlbmRlcmVyLnN4c3NbaWR4XTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpZHhdO1xuICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjIgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZjIgPyBsIDwgcmVmMiA6IGwgPiByZWYyOyBqID0gMCA8PSByZWYyID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdHRlc3QucG9pbnRfaW5fcG9seShzeCwgc3ksIHN4c1tqXSwgc3lzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5fZ2V0X3NuYXBfY29vcmQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGssIGxlbiwgcywgc3VtO1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgcyA9IGFycmF5W2tdO1xuICAgICAgICAgICAgc3VtICs9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGFycmF5Lmxlbmd0aDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5zY3ggPSBmdW5jdGlvbiAoaSwgc3gsIHN5KSB7XG4gICAgICAgIHZhciBqLCBrLCByZWYsIHN4cywgc3lzO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zeHNzW2ldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9zbmFwX2Nvb3JkKHRoaXMuc3hzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN4cyA9IHRoaXMucmVuZGVyZXIuc3hzc1tpXTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwLCByZWYgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBqID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHN4LCBzeSwgc3hzW2pdLCBzeXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfc25hcF9jb29yZChzeHNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBhdGNoZXNWaWV3LnByb3RvdHlwZS5zY3kgPSBmdW5jdGlvbiAoaSwgc3gsIHN5KSB7XG4gICAgICAgIHZhciBqLCBrLCByZWYsIHN4cywgc3lzO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5zeXNzW2ldLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9zbmFwX2Nvb3JkKHRoaXMuc3lzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN4cyA9IHRoaXMucmVuZGVyZXIuc3hzc1tpXTtcbiAgICAgICAgICAgIHN5cyA9IHRoaXMucmVuZGVyZXIuc3lzc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwLCByZWYgPSBzeHMubGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBqID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHN4LCBzeSwgc3hzW2pdLCBzeXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfc25hcF9jb29yZChzeXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGF0Y2hlc1ZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19hcmVhX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlc1ZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlBhdGNoZXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGF0Y2hlcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGF0Y2hlcygpIHtcbiAgICAgICAgcmV0dXJuIFBhdGNoZXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBhdGNoZXMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUGF0Y2hlc1ZpZXc7XG4gICAgUGF0Y2hlcy5wcm90b3R5cGUudHlwZSA9ICdQYXRjaGVzJztcbiAgICBQYXRjaGVzLmNvb3JkcyhbWyd4cycsICd5cyddXSk7XG4gICAgUGF0Y2hlcy5taXhpbnMoWydsaW5lJywgJ2ZpbGwnXSk7XG4gICAgcmV0dXJuIFBhdGNoZXM7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xudmFyIGNhdGVnb3JpY2FsX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvY2F0ZWdvcmljYWxfbWFwcGVyXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xuZXhwb3J0cy5RdWFkVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChRdWFkVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUXVhZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBRdWFkVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiwgYm90dG9tLCBpLCBqLCBsLCBsZWZ0LCBtYXBfdG9fc3ludGhldGljLCBwb2ludHMsIHIsIHJlZiwgcmlnaHQsIHQsIHRvcDtcbiAgICAgICAgbWFwX3RvX3N5bnRoZXRpYyA9IGZ1bmN0aW9uIChtYXBwZXIsIGFycmF5KSB7XG4gICAgICAgICAgICBpZiAobWFwcGVyIGluc3RhbmNlb2YgY2F0ZWdvcmljYWxfbWFwcGVyXzEuQ2F0ZWdvcmljYWxNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwcGVyLnZfbWFwX3RvX3RhcmdldChhcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxlZnQgPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueG1hcHBlciwgdGhpcy5fbGVmdCk7XG4gICAgICAgIHJpZ2h0ID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3JpZ2h0KTtcbiAgICAgICAgdG9wID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnltYXBwZXIsIHRoaXMuX3RvcCk7XG4gICAgICAgIGJvdHRvbSA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci55bWFwcGVyLCB0aGlzLl9ib3R0b20pO1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGxlZnQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGwgPSBsZWZ0W2ldO1xuICAgICAgICAgICAgciA9IHJpZ2h0W2ldO1xuICAgICAgICAgICAgdCA9IHRvcFtpXTtcbiAgICAgICAgICAgIGIgPSBib3R0b21baV07XG4gICAgICAgICAgICBpZiAoaXNOYU4obCArIHIgKyB0ICsgYikgfHwgIWlzRmluaXRlKGwgKyByICsgdCArIGIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBiLFxuICAgICAgICAgICAgICAgIG1heFg6IHIsXG4gICAgICAgICAgICAgICAgbWF4WTogdCxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2JvdHRvbSwgc2xlZnQsIHNyaWdodCwgc3RvcDtcbiAgICAgICAgc2xlZnQgPSBhcmcuc2xlZnQsIHNyaWdodCA9IGFyZy5zcmlnaHQsIHN0b3AgPSBhcmcuc3RvcCwgc2JvdHRvbSA9IGFyZy5zYm90dG9tO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHNsZWZ0W2ldICsgc3RvcFtpXSArIHNyaWdodFtpXSArIHNib3R0b21baV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc2xlZnRbaV0sIHN0b3BbaV0sIHNyaWdodFtpXSAtIHNsZWZ0W2ldLCBzYm90dG9tW2ldIC0gc3RvcFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFF1YWRWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBoaXRzLCByZWYsIHJlc3VsdCwgdngsIHZ5LCB4LCB5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5LCB0cnVlKTtcbiAgICAgICAgaGl0cyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgIG1heFg6IHgsXG4gICAgICAgICAgICBtYXhZOiB5XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLmdldF9hbmNob3JfcG9pbnQgPSBmdW5jdGlvbiAoYW5jaG9yLCBpLCBzcHQpIHtcbiAgICAgICAgdmFyIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHRvcDtcbiAgICAgICAgbGVmdCA9IE1hdGgubWluKHRoaXMuc2xlZnRbaV0sIHRoaXMuc3JpZ2h0W2ldKTtcbiAgICAgICAgcmlnaHQgPSBNYXRoLm1heCh0aGlzLnNyaWdodFtpXSwgdGhpcy5zbGVmdFtpXSk7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRoaXMuc3RvcFtpXSwgdGhpcy5zYm90dG9tW2ldKTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgodGhpcy5zYm90dG9tW2ldLCB0aGlzLnN0b3BbaV0pO1xuICAgICAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgICAgICAgY2FzZSAndG9wX2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICd0b3BfY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICd0b3BfcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyX3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeTogKHRvcCArIGJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbV9yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGJvdHRvbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib3R0b21fY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHk6IGJvdHRvbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib3R0b21fbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgeTogYm90dG9tXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB5OiAodG9wICsgYm90dG9tKSAvIDJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHk6ICh0b3AgKyBib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1YWRWaWV3LnByb3RvdHlwZS5zY3ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2xlZnRbaV0gKyB0aGlzLnNyaWdodFtpXSkgLyAyO1xuICAgIH07XG4gICAgUXVhZFZpZXcucHJvdG90eXBlLnNjeSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdG9wW2ldICsgdGhpcy5zYm90dG9tW2ldKSAvIDI7XG4gICAgfTtcbiAgICBRdWFkVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBRdWFkVmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuUXVhZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChRdWFkLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBRdWFkKCkge1xuICAgICAgICByZXR1cm4gUXVhZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUXVhZC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5RdWFkVmlldztcbiAgICBRdWFkLnByb3RvdHlwZS50eXBlID0gJ1F1YWQnO1xuICAgIFF1YWQuY29vcmRzKFtbJ3JpZ2h0JywgJ2JvdHRvbSddLCBbJ2xlZnQnLCAndG9wJ11dKTtcbiAgICBRdWFkLm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICByZXR1cm4gUXVhZDtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX3FiYiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNwYXRpYWxfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvc3BhdGlhbFwiKTtcbnZhciBnbHlwaF8xID0gcmVxdWlyZShcIi4vZ2x5cGhcIik7XG5fcWJiID0gZnVuY3Rpb24gKHUsIHYsIHcpIHtcbiAgICB2YXIgYmQsIHQ7XG4gICAgaWYgKHYgPT09ICh1ICsgdykgLyAyKSB7XG4gICAgICAgIHJldHVybiBbdSwgd107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0ID0gKHUgLSB2KSAvICh1IC0gMiAqIHYgKyB3KTtcbiAgICAgICAgYmQgPSB1ICogTWF0aC5wb3coMSAtIHQsIDIpICsgMiAqIHYgKiAoMSAtIHQpICogdCArIHcgKiBNYXRoLnBvdyh0LCAyKTtcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1pbih1LCB3LCBiZCksIE1hdGgubWF4KHUsIHcsIGJkKV07XG4gICAgfVxufTtcbmV4cG9ydHMuUXVhZHJhdGljVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChRdWFkcmF0aWNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBRdWFkcmF0aWNWaWV3KCkge1xuICAgICAgICByZXR1cm4gUXVhZHJhdGljVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUXVhZHJhdGljVmlldy5wcm90b3R5cGUuX2luZGV4X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBqLCBwb2ludHMsIHJlZiwgcmVmMSwgcmVmMiwgeDAsIHgxLCB5MCwgeTE7XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5feDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLl94MFtpXSArIHRoaXMuX3gxW2ldICsgdGhpcy5feTBbaV0gKyB0aGlzLl95MVtpXSArIHRoaXMuX2N4W2ldICsgdGhpcy5fY3lbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYxID0gX3FiYih0aGlzLl94MFtpXSwgdGhpcy5fY3hbaV0sIHRoaXMuX3gxW2ldKSwgeDAgPSByZWYxWzBdLCB4MSA9IHJlZjFbMV07XG4gICAgICAgICAgICByZWYyID0gX3FiYih0aGlzLl95MFtpXSwgdGhpcy5fY3lbaV0sIHRoaXMuX3kxW2ldKSwgeTAgPSByZWYyWzBdLCB5MSA9IHJlZjJbMV07XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluWDogeDAsXG4gICAgICAgICAgICAgICAgbWluWTogeTAsXG4gICAgICAgICAgICAgICAgbWF4WDogeDEsXG4gICAgICAgICAgICAgICAgbWF4WTogeTEsXG4gICAgICAgICAgICAgICAgaTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzcGF0aWFsXzEuUkJ1c2gocG9pbnRzKTtcbiAgICB9O1xuICAgIFF1YWRyYXRpY1ZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2N4LCBzY3ksIHN4MCwgc3gxLCBzeTAsIHN5MTtcbiAgICAgICAgc3gwID0gYXJnLnN4MCwgc3kwID0gYXJnLnN5MCwgc3gxID0gYXJnLnN4MSwgc3kxID0gYXJnLnN5MSwgc2N4ID0gYXJnLnNjeCwgc2N5ID0gYXJnLnNjeTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc3gwW2ldICsgc3kwW2ldICsgc3gxW2ldICsgc3kxW2ldICsgc2N4W2ldICsgc2N5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3gwW2ldLCBzeTBbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHNjeFtpXSwgc2N5W2ldLCBzeDFbaV0sIHN5MVtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHguc3Ryb2tlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1YWRyYXRpY1ZpZXcucHJvdG90eXBlLmRyYXdfbGVnZW5kX2Zvcl9pbmRleCA9IGZ1bmN0aW9uIChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJpY19saW5lX2xlZ2VuZChjdHgsIHgwLCB4MSwgeTAsIHkxLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVhZHJhdGljVmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuUXVhZHJhdGljID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFF1YWRyYXRpYywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUXVhZHJhdGljKCkge1xuICAgICAgICByZXR1cm4gUXVhZHJhdGljLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBRdWFkcmF0aWMucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUXVhZHJhdGljVmlldztcbiAgICBRdWFkcmF0aWMucHJvdG90eXBlLnR5cGUgPSAnUXVhZHJhdGljJztcbiAgICBRdWFkcmF0aWMuY29vcmRzKFtbJ3gwJywgJ3kwJ10sIFsneDEnLCAneTEnXSwgWydjeCcsICdjeSddXSk7XG4gICAgUXVhZHJhdGljLm1peGlucyhbJ2xpbmUnXSk7XG4gICAgcmV0dXJuIFF1YWRyYXRpYztcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUmF5VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSYXlWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYXlWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmF5Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmF5Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGVuZ3RoID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gsIHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICBSYXlWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfYW5nbGUsIGhlaWdodCwgaSwgaW5mX2xlbiwgaiwgaywgbGVuLCByZWYsIHJlc3VsdHMsIHNsZW5ndGgsIHN4LCBzeSwgd2lkdGg7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc2xlbmd0aCA9IGFyZy5zbGVuZ3RoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLmhlaWdodDtcbiAgICAgICAgICAgIGluZl9sZW4gPSAyICogKHdpZHRoICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBzbGVuZ3RoLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsZW5ndGhbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2xlbmd0aFtpXSA9IGluZl9sZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgX2FuZ2xlW2ldICsgc2xlbmd0aFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKF9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzbGVuZ3RoW2ldLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLV9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC50cmFuc2xhdGUoLXN4W2ldLCAtc3lbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYXlWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyaWNfbGluZV9sZWdlbmQoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJheVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuUmF5ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJheSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmF5KCkge1xuICAgICAgICByZXR1cm4gUmF5Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSYXkucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmF5VmlldztcbiAgICBSYXkucHJvdG90eXBlLnR5cGUgPSAnUmF5JztcbiAgICBSYXkubWl4aW5zKFsnbGluZSddKTtcbiAgICBSYXkuZGVmaW5lKHtcbiAgICAgICAgbGVuZ3RoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBhbmdsZTogW3AuQW5nbGVTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBSYXk7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbnZhciBjYXRlZ29yaWNhbF9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tYXBwZXJzL2NhdGVnb3JpY2FsX21hcHBlclwiKTtcbmV4cG9ydHMuUmVjdFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVjdFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlY3RWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmVjdFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fc2V0X2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF4X3cyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWF4X3cyID0gdGhpcy5tYXhfd2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4X2gyID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy5oZWlnaHQudW5pdHMgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfaDIgPSB0aGlzLm1heF9oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWN0Vmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzLCBpLCByZWYsIHJlZjE7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvcGVydGllcy53aWR0aC51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuX21hcF9kaXN0X2Nvcm5lcl9mb3JfZGF0YV9zaWRlX2xlbmd0aCh0aGlzLl94LCB0aGlzLl93aWR0aCwgdGhpcy5yZW5kZXJlci54bWFwcGVyLCBjYW52YXMsIDApLCB0aGlzLnN3ID0gcmVmWzBdLCB0aGlzLnN4MCA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3cgPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3gwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB0aGlzLnN4Lmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zeFtpXSAtIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnByb3BlcnRpZXMuaGVpZ2h0LnVuaXRzID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMuX21hcF9kaXN0X2Nvcm5lcl9mb3JfZGF0YV9zaWRlX2xlbmd0aCh0aGlzLl95LCB0aGlzLl9oZWlnaHQsIHRoaXMucmVuZGVyZXIueW1hcHBlciwgY2FudmFzLCAxKSwgdGhpcy5zaCA9IHJlZjFbMF0sIHRoaXMuc3kxID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2ggPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnN5MSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosIHJlZjIsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYyID0gdGhpcy5zeS5sZW5ndGg7IDAgPD0gcmVmMiA/IGogPCByZWYyIDogaiA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuc3lbaV0gLSB0aGlzLnNoW2ldIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zc2VtaV9kaWFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYyLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjIgPSB0aGlzLnN3Lmxlbmd0aDsgMCA8PSByZWYyID8gaiA8IHJlZjIgOiBqID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChNYXRoLnNxcnQodGhpcy5zd1tpXSAvIDIgKiB0aGlzLnN3W2ldIC8gMiArIHRoaXMuc2hbaV0gLyAyICogdGhpcy5zaFtpXSAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIF9hbmdsZSwgaSwgaiwgaywgbGVuLCBsZW4xLCBzaCwgc3csIHN4LCBzeDAsIHN5LCBzeTE7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgc3gwID0gYXJnLnN4MCwgc3kxID0gYXJnLnN5MSwgc3cgPSBhcmcuc3csIHNoID0gYXJnLnNoLCBfYW5nbGUgPSBhcmcuX2FuZ2xlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgc3gwW2ldICsgc3kxW2ldICsgc3dbaV0gKyBzaFtpXSArIF9hbmdsZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoX2FuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShfYW5nbGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLXN3W2ldIC8gMiwgLXNoW2ldIC8gMiwgc3dbaV0sIHNoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc3hbaV0sIC1zeVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc3gwW2ldLCBzeTFbaV0sIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMubGluZS5kb2l0KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gaW5kaWNlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHN4MFtpXSArIHN5MVtpXSArIHN3W2ldICsgc2hbaV0gKyBfYW5nbGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3dbaV0gPT09IDAgfHwgc2hbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfYW5nbGVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKF9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KC1zd1tpXSAvIDIsIC1zaFtpXSAvIDIsIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLV9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXN4W2ldLCAtc3lbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3Qoc3gwW2ldLCBzeTFbaV0sIHN3W2ldLCBzaFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjdFZpZXcucHJvdG90eXBlLl9oaXRfcmVjdCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgYmJveCwgcmVmLCByZWYxLCByZXN1bHQsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW2dlb21ldHJ5LnZ4MCwgZ2VvbWV0cnkudngxXSwgdHJ1ZSksIHgwID0gcmVmWzBdLCB4MSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbZ2VvbWV0cnkudnkwLCBnZW9tZXRyeS52eTFdLCB0cnVlKSwgeTAgPSByZWYxWzBdLCB5MSA9IHJlZjFbMV07XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIHJlc3VsdCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICByZXN1bHRbJzFkJ10uaW5kaWNlcyA9IHRoaXMuaW5kZXguaW5kaWNlcyhiYm94KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBjLCBkLCBoZWlnaHRfaW4sIGhpdHMsIGksIGosIGxlbiwgbWF4X3gyX2RkaXN0LCBtYXhfeTJfZGRpc3QsIHB4LCBweSwgcmVmLCByZWYxLCByZXN1bHQsIHMsIHNjZW50ZXJfeCwgc2NlbnRlcl95LCBzeCwgc3ksIHZ4LCB2eSwgd2lkdGhfaW4sIHgsIHgwLCB4MSwgeSwgeTAsIHkxO1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5LCB0cnVlKTtcbiAgICAgICAgc2NlbnRlcl94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYxLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB0aGlzLnN4MC5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zeDBbaV0gKyB0aGlzLnN3W2ldIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgc2NlbnRlcl95ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYxLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB0aGlzLnN5MS5sZW5ndGg7IDAgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zeTFbaV0gKyB0aGlzLnNoW2ldIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgbWF4X3gyX2RkaXN0ID0gYXJyYXlfMS5tYXgodGhpcy5fZGRpc3QoMCwgc2NlbnRlcl94LCB0aGlzLnNzZW1pX2RpYWcpKTtcbiAgICAgICAgbWF4X3kyX2RkaXN0ID0gYXJyYXlfMS5tYXgodGhpcy5fZGRpc3QoMSwgc2NlbnRlcl95LCB0aGlzLnNzZW1pX2RpYWcpKTtcbiAgICAgICAgeDAgPSB4IC0gbWF4X3gyX2RkaXN0O1xuICAgICAgICB4MSA9IHggKyBtYXhfeDJfZGRpc3Q7XG4gICAgICAgIHkwID0geSAtIG1heF95Ml9kZGlzdDtcbiAgICAgICAgeTEgPSB5ICsgbWF4X3kyX2RkaXN0O1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIHJlZjEgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSByZWYxW2pdO1xuICAgICAgICAgICAgc3ggPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godngpO1xuICAgICAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyhzeCAtIHRoaXMuc3hbaV0sIDIpICsgTWF0aC5wb3coc3kgLSB0aGlzLnN5W2ldLCAyKSk7XG4gICAgICAgICAgICAgICAgcyA9IE1hdGguc2luKC10aGlzLl9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgYyA9IE1hdGguY29zKC10aGlzLl9hbmdsZVtpXSk7XG4gICAgICAgICAgICAgICAgcHggPSBjICogKHN4IC0gdGhpcy5zeFtpXSkgLSBzICogKHN5IC0gdGhpcy5zeVtpXSkgKyB0aGlzLnN4W2ldO1xuICAgICAgICAgICAgICAgIHB5ID0gcyAqIChzeCAtIHRoaXMuc3hbaV0pICsgYyAqIChzeSAtIHRoaXMuc3lbaV0pICsgdGhpcy5zeVtpXTtcbiAgICAgICAgICAgICAgICBzeCA9IHB4O1xuICAgICAgICAgICAgICAgIHN5ID0gcHk7XG4gICAgICAgICAgICAgICAgd2lkdGhfaW4gPSBNYXRoLmFicyh0aGlzLnN4W2ldIC0gc3gpIDw9IHRoaXMuc3dbaV0gLyAyO1xuICAgICAgICAgICAgICAgIGhlaWdodF9pbiA9IE1hdGguYWJzKHRoaXMuc3lbaV0gLSBzeSkgPD0gdGhpcy5zaFtpXSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aWR0aF9pbiA9IHN4IC0gdGhpcy5zeDBbaV0gPD0gdGhpcy5zd1tpXSAmJiBzeCAtIHRoaXMuc3gwW2ldID49IDA7XG4gICAgICAgICAgICAgICAgaGVpZ2h0X2luID0gc3kgLSB0aGlzLnN5MVtpXSA8PSB0aGlzLnNoW2ldICYmIHN5IC0gdGhpcy5zeTFbaV0gPj0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHRfaW4gJiYgd2lkdGhfaW4pIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdFsnMWQnXS5pbmRpY2VzID0gaGl0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fbWFwX2Rpc3RfY29ybmVyX2Zvcl9kYXRhX3NpZGVfbGVuZ3RoID0gZnVuY3Rpb24gKGNvb3JkLCBzaWRlX2xlbmd0aCwgbWFwcGVyLCBjYW52YXMsIGRpbSkge1xuICAgICAgICB2YXIgaSwgcHQwLCBwdDEsIHJldHVybl9zeW50aGV0aWMsIHNzaWRlX2xlbmd0aCwgc3ludGhldGljX3B0LCBzeW50aGV0aWNfcHRfY29ybmVyLCB2cHQwLCB2cHQxLCB2cHRfY29ybmVyO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyhjb29yZFswXSkgJiYgbWFwcGVyIGluc3RhbmNlb2YgY2F0ZWdvcmljYWxfbWFwcGVyXzEuQ2F0ZWdvcmljYWxNYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybl9zeW50aGV0aWMgPSB0cnVlO1xuICAgICAgICAgICAgc3ludGhldGljX3B0ID0gbWFwcGVyLnZfbWFwX3RvX3RhcmdldChjb29yZCwgcmV0dXJuX3N5bnRoZXRpYyk7XG4gICAgICAgICAgICBpZiAoZGltID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljX3B0X2Nvcm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvb3JkLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3ludGhldGljX3B0W2ldIC0gc2lkZV9sZW5ndGhbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljX3B0X2Nvcm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvb3JkLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3ludGhldGljX3B0W2ldICsgc2lkZV9sZW5ndGhbaV0gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdnB0X2Nvcm5lciA9IG1hcHBlci52X21hcF90b190YXJnZXQoc3ludGhldGljX3B0X2Nvcm5lcik7XG4gICAgICAgICAgICBzc2lkZV9sZW5ndGggPSB0aGlzLnNkaXN0KG1hcHBlciwgY29vcmQsIHNpZGVfbGVuZ3RoLCAnY2VudGVyJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHQwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY29vcmQubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE51bWJlcihjb29yZFtpXSkgLSBzaWRlX2xlbmd0aFtpXSAvIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBwdDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb29yZC5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goTnVtYmVyKGNvb3JkW2ldKSArIHNpZGVfbGVuZ3RoW2ldIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZwdDAgPSBtYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHB0MCk7XG4gICAgICAgICAgICB2cHQxID0gbWFwcGVyLnZfbWFwX3RvX3RhcmdldChwdDEpO1xuICAgICAgICAgICAgc3NpZGVfbGVuZ3RoID0gdGhpcy5zZGlzdChtYXBwZXIsIHB0MCwgc2lkZV9sZW5ndGgsICdlZGdlJywgdGhpcy5tb2RlbC5kaWxhdGUpO1xuICAgICAgICAgICAgaWYgKGRpbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZwdF9jb3JuZXIgPSB2cHQwWzBdIDwgdnB0MVswXSA/IHZwdDAgOiB2cHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdnB0X2Nvcm5lciA9IHZwdDBbMF0gPCB2cHQxWzBdID8gdnB0MSA6IHZwdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzc2lkZV9sZW5ndGgsIGNhbnZhcy52X3Z4X3RvX3N4KHZwdF9jb3JuZXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaW0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3NpZGVfbGVuZ3RoLCBjYW52YXMudl92eV90b19zeSh2cHRfY29ybmVyKV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fZGRpc3QgPSBmdW5jdGlvbiAoZGltLCBzcHRzLCBzcGFucykge1xuICAgICAgICB2YXIgaSwgbWFwcGVyLCBwdDAsIHB0MSwgdnB0MCwgdnB0MSwgdnB0cztcbiAgICAgICAgaWYgKGRpbSA9PT0gMCkge1xuICAgICAgICAgICAgdnB0cyA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3N4X3RvX3Z4KHNwdHMpO1xuICAgICAgICAgICAgbWFwcGVyID0gdGhpcy5yZW5kZXJlci54bWFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnB0cyA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3Z5X3RvX3N5KHNwdHMpO1xuICAgICAgICAgICAgbWFwcGVyID0gdGhpcy5yZW5kZXJlci55bWFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIHZwdDAgPSB2cHRzO1xuICAgICAgICB2cHQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdnB0MC5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2cHQwW2ldICsgc3BhbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHB0MCA9IG1hcHBlci52X21hcF9mcm9tX3RhcmdldCh2cHQwKTtcbiAgICAgICAgcHQxID0gbWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KHZwdDEpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcHQwLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKE1hdGguYWJzKHB0MVtpXSAtIHB0MFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBSZWN0Vmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIFJlY3RWaWV3LnByb3RvdHlwZS5fYm91bmRzID0gZnVuY3Rpb24gKGJkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhfd2gyX2JvdW5kcyhiZHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3RWaWV3O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoVmlldyk7XG5leHBvcnRzLlJlY3QgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVjdCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlY3QucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmVjdFZpZXc7XG4gICAgUmVjdC5wcm90b3R5cGUudHlwZSA9ICdSZWN0JztcbiAgICBSZWN0Lm1peGlucyhbJ2xpbmUnLCAnZmlsbCddKTtcbiAgICBSZWN0LmRlZmluZSh7XG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdLFxuICAgICAgICB3aWR0aDogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgaGVpZ2h0OiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICBkaWxhdGU6IFtwLkJvb2wsIGZhbHNlXVxuICAgIH0pO1xuICAgIHJldHVybiBSZWN0O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xuZXhwb3J0cy5TZWdtZW50VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWdtZW50Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2VnbWVudFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTZWdtZW50Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VnbWVudFZpZXcucHJvdG90eXBlLl9pbmRleF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgaiwgcG9pbnRzLCByZWY7XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5feDAubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4odGhpcy5feDBbaV0gKyB0aGlzLl94MVtpXSArIHRoaXMuX3kwW2ldICsgdGhpcy5feTFbaV0pKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbih0aGlzLl94MFtpXSwgdGhpcy5feDFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBNYXRoLm1pbih0aGlzLl95MFtpXSwgdGhpcy5feTFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBNYXRoLm1heCh0aGlzLl94MFtpXSwgdGhpcy5feDFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heCh0aGlzLl95MFtpXSwgdGhpcy5feTFbaV0pLFxuICAgICAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzcGF0aWFsXzEuUkJ1c2gocG9pbnRzKTtcbiAgICB9O1xuICAgIFNlZ21lbnRWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBpLCBqLCBsZW4sIHJlc3VsdHMsIHN4MCwgc3gxLCBzeTAsIHN5MTtcbiAgICAgICAgc3gwID0gYXJnLnN4MCwgc3kwID0gYXJnLnN5MCwgc3gxID0gYXJnLnN4MSwgc3kxID0gYXJnLnN5MTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc3gwW2ldICsgc3kwW2ldICsgc3gxW2ldICsgc3kxW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3gwW2ldLCBzeTBbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3gxW2ldLCBzeTFbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWdtZW50Vmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2xpbmVfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBTZWdtZW50Vmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuU2VnbWVudCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWdtZW50LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWdtZW50KCkge1xuICAgICAgICByZXR1cm4gU2VnbWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VnbWVudC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5TZWdtZW50VmlldztcbiAgICBTZWdtZW50LnByb3RvdHlwZS50eXBlID0gJ1NlZ21lbnQnO1xuICAgIFNlZ21lbnQuY29vcmRzKFtbJ3gwJywgJ3kwJ10sIFsneDEnLCAneTEnXV0pO1xuICAgIFNlZ21lbnQubWl4aW5zKFsnbGluZSddKTtcbiAgICByZXR1cm4gU2VnbWVudDtcbn0pKGdseXBoXzEuR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHh5X2dseXBoXzEgPSByZXF1aXJlKFwiLi94eV9nbHlwaFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuVGV4dFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGV4dFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHRWaWV3KCkge1xuICAgICAgICByZXR1cm4gVGV4dFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRleHRWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfYW5nbGUsIF90ZXh0LCBfeF9vZmZzZXQsIF95X29mZnNldCwgaSwgaiwgbGVuLCByZXN1bHRzLCBzeCwgc3k7XG4gICAgICAgIHN4ID0gYXJnLnN4LCBzeSA9IGFyZy5zeSwgX3hfb2Zmc2V0ID0gYXJnLl94X29mZnNldCwgX3lfb2Zmc2V0ID0gYXJnLl95X29mZnNldCwgX2FuZ2xlID0gYXJnLl9hbmdsZSwgX3RleHQgPSBhcmcuX3RleHQ7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIF94X29mZnNldFtpXSArIF95X29mZnNldFtpXSArIF9hbmdsZVtpXSkgfHwgKF90ZXh0W2ldID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLnRleHQuZG9pdCkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSArIF94X29mZnNldFtpXSwgc3lbaV0gKyBfeV9vZmZzZXRbaV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMudGV4dC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KF90ZXh0W2ldLCAwLCAwKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnJlc3RvcmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRleHRWaWV3LnByb3RvdHlwZS5kcmF3X2xlZ2VuZF9mb3JfaW5kZXggPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgaW5kZXgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy50ZXh0X3Byb3BzLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMudGV4dF9wcm9wcy5mb250X3ZhbHVlKCk7XG4gICAgICAgIGN0eC5mb250ID0gY3R4LmZvbnQucmVwbGFjZSgvXFxiW1xcZFxcLl0rW1xcd10rXFxiLywgJzEwcHQnKTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcInRleHRcIiwgeDIsICh5MSArIHkyKSAvIDIpO1xuICAgICAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0Vmlldztcbn0pKHh5X2dseXBoXzEuWFlHbHlwaFZpZXcpO1xuZXhwb3J0cy5UZXh0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRleHRWaWV3O1xuICAgIFRleHQucHJvdG90eXBlLnR5cGUgPSAnVGV4dCc7XG4gICAgVGV4dC5taXhpbnMoWyd0ZXh0J10pO1xuICAgIFRleHQuZGVmaW5lKHtcbiAgICAgICAgdGV4dDogW1xuICAgICAgICAgICAgcC5TdHJpbmdTcGVjLCB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdLFxuICAgICAgICB4X29mZnNldDogW3AuTnVtYmVyU3BlYywgMF0sXG4gICAgICAgIHlfb2Zmc2V0OiBbcC5OdW1iZXJTcGVjLCAwXVxuICAgIH0pO1xuICAgIHJldHVybiBUZXh0O1xufSkoeHlfZ2x5cGhfMS5YWUdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGF0aWFsXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3NwYXRpYWxcIik7XG52YXIgZ2x5cGhfMSA9IHJlcXVpcmUoXCIuL2dseXBoXCIpO1xudmFyIGNhdGVnb3JpY2FsX21hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvY2F0ZWdvcmljYWxfbWFwcGVyXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5WQmFyVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChWQmFyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVkJhclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBWQmFyVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVkJhclZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZiwgdmJvdHRvbSwgdnRvcDtcbiAgICAgICAgdGhpcy5zeCA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF90b190YXJnZXQodGhpcy5feCk7XG4gICAgICAgIHZ0b3AgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX3RvcCk7XG4gICAgICAgIHZib3R0b20gPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX2JvdHRvbSk7XG4gICAgICAgIHRoaXMuc3RvcCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3Z5X3RvX3N5KHZ0b3ApO1xuICAgICAgICB0aGlzLnNib3R0b20gPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eV90b19zeSh2Ym90dG9tKTtcbiAgICAgICAgdGhpcy5zbGVmdCA9IFtdO1xuICAgICAgICB0aGlzLnNyaWdodCA9IFtdO1xuICAgICAgICB0aGlzLnN3ID0gdGhpcy5zZGlzdCh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gsIHRoaXMuX3dpZHRoLCAnY2VudGVyJyk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLnN4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB0aGlzLnNsZWZ0LnB1c2godGhpcy5zeFtpXSAtIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgICAgIHRoaXMuc3JpZ2h0LnB1c2godGhpcy5zeFtpXSArIHRoaXMuc3dbaV0gLyAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5faW5kZXhfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIsIGJvdHRvbSwgaSwgaiwgbCwgbWFwX3RvX3N5bnRoZXRpYywgcG9pbnRzLCByLCByZWYsIHQsIHRvcCwgd2lkdGgsIHg7XG4gICAgICAgIG1hcF90b19zeW50aGV0aWMgPSBmdW5jdGlvbiAobWFwcGVyLCBhcnJheSkge1xuICAgICAgICAgICAgaWYgKG1hcHBlciBpbnN0YW5jZW9mIGNhdGVnb3JpY2FsX21hcHBlcl8xLkNhdGVnb3JpY2FsTWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBlci52X21hcF90b190YXJnZXQoYXJyYXksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4ID0gbWFwX3RvX3N5bnRoZXRpYyh0aGlzLnJlbmRlcmVyLnhtYXBwZXIsIHRoaXMuX3gpO1xuICAgICAgICB3aWR0aCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci54bWFwcGVyLCB0aGlzLl93aWR0aCk7XG4gICAgICAgIHRvcCA9IG1hcF90b19zeW50aGV0aWModGhpcy5yZW5kZXJlci55bWFwcGVyLCB0aGlzLl90b3ApO1xuICAgICAgICBib3R0b20gPSBtYXBfdG9fc3ludGhldGljKHRoaXMucmVuZGVyZXIueW1hcHBlciwgdGhpcy5fYm90dG9tKTtcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB4Lmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBsID0geFtpXSAtIHdpZHRoW2ldIC8gMjtcbiAgICAgICAgICAgIHIgPSB4W2ldICsgd2lkdGhbaV0gLyAyO1xuICAgICAgICAgICAgdCA9IHRvcFtpXTtcbiAgICAgICAgICAgIGIgPSBib3R0b21baV07XG4gICAgICAgICAgICBpZiAoaXNOYU4obCArIHIgKyB0ICsgYikgfHwgIWlzRmluaXRlKGwgKyByICsgdCArIGIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBiLFxuICAgICAgICAgICAgICAgIG1heFg6IHIsXG4gICAgICAgICAgICAgICAgbWF4WTogdCxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNwYXRpYWxfMS5SQnVzaChwb2ludHMpO1xuICAgIH07XG4gICAgVkJhclZpZXcucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgcmVzdWx0cywgc2JvdHRvbSwgc2xlZnQsIHNyaWdodCwgc3RvcDtcbiAgICAgICAgc2xlZnQgPSBhcmcuc2xlZnQsIHNyaWdodCA9IGFyZy5zcmlnaHQsIHN0b3AgPSBhcmcuc3RvcCwgc2JvdHRvbSA9IGFyZy5zYm90dG9tO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHNsZWZ0W2ldICsgc3RvcFtpXSArIHNyaWdodFtpXSArIHNib3R0b21baV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmZpbGwuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5maWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc2xlZnRbaV0sIHN0b3BbaV0sIHNyaWdodFtpXSAtIHNsZWZ0W2ldLCBzYm90dG9tW2ldIC0gc3RvcFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdChzbGVmdFtpXSwgc3RvcFtpXSwgc3JpZ2h0W2ldIC0gc2xlZnRbaV0sIHNib3R0b21baV0gLSBzdG9wW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbHMubGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN0eC5zdHJva2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFZCYXJWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBoaXRzLCByZWYsIHJlc3VsdCwgdngsIHZ5LCB4LCB5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF9mcm9tX3RhcmdldCh2eCwgdHJ1ZSk7XG4gICAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5LCB0cnVlKTtcbiAgICAgICAgaGl0cyA9IHRoaXMuaW5kZXguaW5kaWNlcyh7XG4gICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgbWluWTogeSxcbiAgICAgICAgICAgIG1heFg6IHgsXG4gICAgICAgICAgICBtYXhZOiB5XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVkJhclZpZXcucHJvdG90eXBlLnNjeSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdG9wW2ldICsgdGhpcy5zYm90dG9tW2ldKSAvIDI7XG4gICAgfTtcbiAgICBWQmFyVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBWQmFyVmlldztcbn0pKGdseXBoXzEuR2x5cGhWaWV3KTtcbmV4cG9ydHMuVkJhciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChWQmFyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBWQmFyKCkge1xuICAgICAgICByZXR1cm4gVkJhci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVkJhci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5WQmFyVmlldztcbiAgICBWQmFyLnByb3RvdHlwZS50eXBlID0gJ1ZCYXInO1xuICAgIFZCYXIubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIFZCYXIuZGVmaW5lKHtcbiAgICAgICAgeDogW3AuTnVtYmVyU3BlY10sXG4gICAgICAgIHdpZHRoOiBbcC5EaXN0YW5jZVNwZWNdLFxuICAgICAgICB0b3A6IFtwLk51bWJlclNwZWNdLFxuICAgICAgICBib3R0b206IFtwLk51bWJlclNwZWMsIDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIFZCYXI7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4veHlfZ2x5cGhcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9tYXRoXCIpO1xuZXhwb3J0cy5XZWRnZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2VkZ2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXZWRnZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBXZWRnZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdlZGdlVmlldy5wcm90b3R5cGUuX21hcF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNyYWRpdXMgPSB0aGlzLnNkaXN0KHRoaXMucmVuZGVyZXIueG1hcHBlciwgdGhpcy5feCwgdGhpcy5fcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNyYWRpdXMgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlZGdlVmlldy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIGFyZykge1xuICAgICAgICB2YXIgX2VuZF9hbmdsZSwgX3N0YXJ0X2FuZ2xlLCBkaXJlY3Rpb24sIGksIGosIGxlbiwgcmVzdWx0cywgc3JhZGl1cywgc3gsIHN5O1xuICAgICAgICBzeCA9IGFyZy5zeCwgc3kgPSBhcmcuc3ksIHNyYWRpdXMgPSBhcmcuc3JhZGl1cywgX3N0YXJ0X2FuZ2xlID0gYXJnLl9zdGFydF9hbmdsZSwgX2VuZF9hbmdsZSA9IGFyZy5fZW5kX2FuZ2xlO1xuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLm1vZGVsLnByb3BlcnRpZXMuZGlyZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3hbaV0gKyBzeVtpXSArIHNyYWRpdXNbaV0gKyBfc3RhcnRfYW5nbGVbaV0gKyBfZW5kX2FuZ2xlW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhzeFtpXSwgc3lbaV0sIHNyYWRpdXNbaV0sIF9zdGFydF9hbmdsZVtpXSwgX2VuZF9hbmdsZVtpXSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oc3hbaV0sIHN5W2ldKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbHMuZmlsbC5kb2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxzLmZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxzLmxpbmUuZG9pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFscy5saW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3R4LnN0cm9rZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgV2VkZ2VWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBhbmdsZSwgYmJveCwgY2FuZGlkYXRlcywgZGlyZWN0aW9uLCBkaXN0LCBoaXRzLCBpLCBqLCBrLCBsZW4sIGxlbjEsIHIyLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHN4LCBzeDAsIHN4MSwgc3ksIHN5MCwgc3kxLCB2eCwgdngwLCB2eDEsIHZ5LCB2eTAsIHZ5MSwgeCwgeDAsIHgxLCB5LCB5MCwgeTE7XG4gICAgICAgIHJlZiA9IFtnZW9tZXRyeS52eCwgZ2VvbWV0cnkudnldLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ4LCB0cnVlKTtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfZnJvbV90YXJnZXQodnksIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm9wZXJ0aWVzLnJhZGl1cy51bml0cyA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHgwID0geCAtIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHgxID0geCArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHkwID0geSAtIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgICAgIHkxID0geSArIHRoaXMubWF4X3JhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4MCA9IHZ4IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgdngxID0gdnggKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFt2eDAsIHZ4MV0sIHRydWUpLCB4MCA9IHJlZjFbMF0sIHgxID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHZ5MCA9IHZ5IC0gdGhpcy5tYXhfcmFkaXVzO1xuICAgICAgICAgICAgdnkxID0gdnkgKyB0aGlzLm1heF9yYWRpdXM7XG4gICAgICAgICAgICByZWYyID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFt2eTAsIHZ5MV0sIHRydWUpLCB5MCA9IHJlZjJbMF0sIHkxID0gcmVmMlsxXTtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGVzID0gW107XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIHJlZjMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGkgPSByZWYzW2pdO1xuICAgICAgICAgICAgcjIgPSBNYXRoLnBvdyh0aGlzLnNyYWRpdXNbaV0sIDIpO1xuICAgICAgICAgICAgc3gwID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLm1hcF90b190YXJnZXQoeCwgdHJ1ZSk7XG4gICAgICAgICAgICBzeDEgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIubWFwX3RvX3RhcmdldCh0aGlzLl94W2ldLCB0cnVlKTtcbiAgICAgICAgICAgIHN5MCA9IHRoaXMucmVuZGVyZXIueW1hcHBlci5tYXBfdG9fdGFyZ2V0KHksIHRydWUpO1xuICAgICAgICAgICAgc3kxID0gdGhpcy5yZW5kZXJlci55bWFwcGVyLm1hcF90b190YXJnZXQodGhpcy5feVtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5wb3coc3gwIC0gc3gxLCAyKSArIE1hdGgucG93KHN5MCAtIHN5MSwgMik7XG4gICAgICAgICAgICBpZiAoZGlzdCA8PSByMikge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChbaSwgZGlzdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMubW9kZWwucHJvcGVydGllcy5kaXJlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgaGl0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gY2FuZGlkYXRlcy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgIHJlZjQgPSBjYW5kaWRhdGVzW2tdLCBpID0gcmVmNFswXSwgZGlzdCA9IHJlZjRbMV07XG4gICAgICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgICAgICBzeSA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh2eSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoc3kgLSB0aGlzLnN5W2ldLCBzeCAtIHRoaXMuc3hbaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGhfMS5hbmdsZV9iZXR3ZWVuKC1hbmdsZSwgLXRoaXMuX3N0YXJ0X2FuZ2xlW2ldLCAtdGhpcy5fZW5kX2FuZ2xlW2ldLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaGl0cy5wdXNoKFtpLCBkaXN0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdHRlc3QuY3JlYXRlXzFkX2hpdF90ZXN0X3Jlc3VsdChoaXRzKTtcbiAgICB9O1xuICAgIFdlZGdlVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmljX2FyZWFfbGVnZW5kKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBXZWRnZVZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuV2VkZ2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2VkZ2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdlZGdlKCkge1xuICAgICAgICByZXR1cm4gV2VkZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdlZGdlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLldlZGdlVmlldztcbiAgICBXZWRnZS5wcm90b3R5cGUudHlwZSA9ICdXZWRnZSc7XG4gICAgV2VkZ2UubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIFdlZGdlLmRlZmluZSh7XG4gICAgICAgIGRpcmVjdGlvbjogW3AuRGlyZWN0aW9uLCAnYW50aWNsb2NrJ10sXG4gICAgICAgIHJhZGl1czogW3AuRGlzdGFuY2VTcGVjXSxcbiAgICAgICAgc3RhcnRfYW5nbGU6IFtwLkFuZ2xlU3BlY10sXG4gICAgICAgIGVuZF9hbmdsZTogW3AuQW5nbGVTcGVjXVxuICAgIH0pO1xuICAgIHJldHVybiBXZWRnZTtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc3BhdGlhbF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9zcGF0aWFsXCIpO1xudmFyIGdseXBoXzEgPSByZXF1aXJlKFwiLi9nbHlwaFwiKTtcbnZhciBjYXRlZ29yaWNhbF9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tYXBwZXJzL2NhdGVnb3JpY2FsX21hcHBlclwiKTtcbmV4cG9ydHMuWFlHbHlwaFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWFlHbHlwaFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFhZR2x5cGhWaWV3KCkge1xuICAgICAgICByZXR1cm4gWFlHbHlwaFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFhZR2x5cGhWaWV3LnByb3RvdHlwZS5faW5kZXhfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIHBvaW50cywgcmVmLCB4LCB4eCwgeSwgeXk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnhtYXBwZXIgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9tYXBwZXJfMS5DYXRlZ29yaWNhbE1hcHBlcikge1xuICAgICAgICAgICAgeHggPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX3gsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB0aGlzLl94O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnltYXBwZXIgaW5zdGFuY2VvZiBjYXRlZ29yaWNhbF9tYXBwZXJfMS5DYXRlZ29yaWNhbE1hcHBlcikge1xuICAgICAgICAgICAgeXkgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHRoaXMuX3ksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeXkgPSB0aGlzLl95O1xuICAgICAgICB9XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0geHgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHggPSB4eFtpXTtcbiAgICAgICAgICAgIGlmIChpc05hTih4KSB8fCAhaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSB5eVtpXTtcbiAgICAgICAgICAgIGlmIChpc05hTih5KSB8fCAhaXNGaW5pdGUoeSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtaW5YOiB4LFxuICAgICAgICAgICAgICAgIG1pblk6IHksXG4gICAgICAgICAgICAgICAgbWF4WDogeCxcbiAgICAgICAgICAgICAgICBtYXhZOiB5LFxuICAgICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc3BhdGlhbF8xLlJCdXNoKHBvaW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gWFlHbHlwaFZpZXc7XG59KShnbHlwaF8xLkdseXBoVmlldyk7XG5leHBvcnRzLlhZR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWFlHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gWFlHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIFhZR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFhZR2x5cGgucHJvdG90eXBlLnR5cGUgPSBcIlhZR2x5cGhcIjtcbiAgICBYWUdseXBoLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlhZR2x5cGhWaWV3O1xuICAgIFhZR2x5cGguY29vcmRzKFtbJ3gnLCAneSddXSk7XG4gICAgcmV0dXJuIFhZR2x5cGg7XG59KShnbHlwaF8xLkdseXBoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBndWlkZV9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmVycy9ndWlkZV9yZW5kZXJlclwiKTtcbnZhciByZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmVycy9yZW5kZXJlclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuR3JpZFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoR3JpZFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdyaWRWaWV3KCkge1xuICAgICAgICByZXR1cm4gR3JpZFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIEdyaWRWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl94X3JhbmdlX25hbWUgPSB0aGlzLm1vZGVsLnhfcmFuZ2VfbmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3lfcmFuZ2VfbmFtZSA9IHRoaXMubW9kZWwueV9yYW5nZV9uYW1lO1xuICAgIH07XG4gICAgR3JpZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuX2RyYXdfcmVnaW9ucyhjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3X21pbm9yX2dyaWRzKGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdfZ3JpZHMoY3R4KTtcbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBHcmlkVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlcXVlc3RfcmVuZGVyKTtcbiAgICB9O1xuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5fZHJhd19yZWdpb25zID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgaSwgaywgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzeDAsIHN4MSwgc3kwLCBzeTEsIHhzLCB5cztcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMuYmFuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmdyaWRfY29vcmRzKCdtYWpvcicsIGZhbHNlKSwgeHMgPSByZWZbMF0sIHlzID0gcmVmWzFdO1xuICAgICAgICB0aGlzLnZpc3VhbHMuYmFuZF9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IHhzLmxlbmd0aCAtIDE7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlZjIgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHhzW2ldLCB5c1tpXSwgdGhpcy5feF9yYW5nZV9uYW1lLCB0aGlzLl95X3JhbmdlX25hbWUpLCBzeDAgPSByZWYyWzBdLCBzeTAgPSByZWYyWzFdO1xuICAgICAgICAgICAgICAgIHJlZjMgPSB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHhzW2kgKyAxXSwgeXNbaSArIDFdLCB0aGlzLl94X3JhbmdlX25hbWUsIHRoaXMuX3lfcmFuZ2VfbmFtZSksIHN4MSA9IHJlZjNbMF0sIHN5MSA9IHJlZjNbMV07XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHN4MFswXSwgc3kwWzBdLCBzeDFbMV0gLSBzeDBbMF0sIHN5MVsxXSAtIHN5MFswXSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JpZFZpZXcucHJvdG90eXBlLl9kcmF3X2dyaWRzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgcmVmLCB4cywgeXM7XG4gICAgICAgIGlmICghdGhpcy52aXN1YWxzLmdyaWRfbGluZS5kb2l0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5ncmlkX2Nvb3JkcygnbWFqb3InKSwgeHMgPSByZWZbMF0sIHlzID0gcmVmWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd19ncmlkX2hlbHBlcihjdHgsIHRoaXMudmlzdWFscy5ncmlkX2xpbmUsIHhzLCB5cyk7XG4gICAgfTtcbiAgICBHcmlkVmlldy5wcm90b3R5cGUuX2RyYXdfbWlub3JfZ3JpZHMgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciByZWYsIHhzLCB5cztcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbHMubWlub3JfZ3JpZF9saW5lLmRvaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmdyaWRfY29vcmRzKCdtaW5vcicpLCB4cyA9IHJlZlswXSwgeXMgPSByZWZbMV07XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3X2dyaWRfaGVscGVyKGN0eCwgdGhpcy52aXN1YWxzLm1pbm9yX2dyaWRfbGluZSwgeHMsIHlzKTtcbiAgICB9O1xuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5fZHJhd19ncmlkX2hlbHBlciA9IGZ1bmN0aW9uIChjdHgsIHByb3BzLCB4cywgeXMpIHtcbiAgICAgICAgdmFyIGksIGssIGwsIHJlZiwgcmVmMSwgcmVmMiwgc3gsIHN5O1xuICAgICAgICBwcm9wcy5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IHhzLmxlbmd0aDsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5wbG90X3ZpZXcubWFwX3RvX3NjcmVlbih4c1tpXSwgeXNbaV0sIHRoaXMuX3hfcmFuZ2VfbmFtZSwgdGhpcy5feV9yYW5nZV9uYW1lKSwgc3ggPSByZWYxWzBdLCBzeSA9IHJlZjFbMV07XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKE1hdGgucm91bmQoc3hbMF0pLCBNYXRoLnJvdW5kKHN5WzBdKSk7XG4gICAgICAgICAgICBmb3IgKGkgPSBsID0gMSwgcmVmMiA9IHN4Lmxlbmd0aDsgMSA8PSByZWYyID8gbCA8IHJlZjIgOiBsID4gcmVmMjsgaSA9IDEgPD0gcmVmMiA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5yb3VuZChzeFtpXSksIE1hdGgucm91bmQoc3lbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyaWRWaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5HcmlkID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdyaWQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdyaWQoKSB7XG4gICAgICAgIHJldHVybiBHcmlkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHcmlkLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkdyaWRWaWV3O1xuICAgIEdyaWQucHJvdG90eXBlLnR5cGUgPSAnR3JpZCc7XG4gICAgR3JpZC5taXhpbnMoWydsaW5lOmdyaWRfJywgJ2xpbmU6bWlub3JfZ3JpZF8nLCAnZmlsbDpiYW5kXyddKTtcbiAgICBHcmlkLmRlZmluZSh7XG4gICAgICAgIGJvdW5kczogW3AuQW55LCAnYXV0byddLFxuICAgICAgICBkaW1lbnNpb246IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHRpY2tlcjogW3AuSW5zdGFuY2VdLFxuICAgICAgICB4X3JhbmdlX25hbWU6IFtwLlN0cmluZywgJ2RlZmF1bHQnXSxcbiAgICAgICAgeV9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J11cbiAgICB9KTtcbiAgICBHcmlkLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6IFwidW5kZXJsYXlcIixcbiAgICAgICAgYmFuZF9maWxsX2NvbG9yOiBudWxsLFxuICAgICAgICBiYW5kX2ZpbGxfYWxwaGE6IDAsXG4gICAgICAgIGdyaWRfbGluZV9jb2xvcjogJyNlNWU1ZTUnLFxuICAgICAgICBtaW5vcl9ncmlkX2xpbmVfY29sb3I6IG51bGxcbiAgICB9KTtcbiAgICBHcmlkLnByb3RvdHlwZS5yYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZSwgaSwgaiwgcmFuZ2VzO1xuICAgICAgICBpID0gdGhpcy5kaW1lbnNpb247XG4gICAgICAgIGogPSAoaSArIDEpICUgMjtcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3QucGxvdF9jYW52YXMuZnJhbWU7XG4gICAgICAgIHJhbmdlcyA9IFtmcmFtZS54X3Jhbmdlc1t0aGlzLnhfcmFuZ2VfbmFtZV0sIGZyYW1lLnlfcmFuZ2VzW3RoaXMueV9yYW5nZV9uYW1lXV07XG4gICAgICAgIHJldHVybiBbcmFuZ2VzW2ldLCByYW5nZXNbal1dO1xuICAgIH07XG4gICAgR3JpZC5wcm90b3R5cGUuY29tcHV0ZWRfYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Jvc3NfcmFuZ2UsIGVuZCwgcmFuZ2UsIHJhbmdlX2JvdW5kcywgcmVmLCBzdGFydCwgdXNlcl9ib3VuZHM7XG4gICAgICAgIHJlZiA9IHRoaXMucmFuZ2VzKCksIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgdXNlcl9ib3VuZHMgPSB0aGlzLmJvdW5kcztcbiAgICAgICAgcmFuZ2VfYm91bmRzID0gW3JhbmdlLm1pbiwgcmFuZ2UubWF4XTtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheSh1c2VyX2JvdW5kcykpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4odXNlcl9ib3VuZHNbMF0sIHVzZXJfYm91bmRzWzFdKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWF4KHVzZXJfYm91bmRzWzBdLCB1c2VyX2JvdW5kc1sxXSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCByYW5nZV9ib3VuZHNbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJhbmdlX2JvdW5kc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gcmFuZ2VfYm91bmRzWzFdKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHJhbmdlX2JvdW5kc1sxXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHJhbmdlX2JvdW5kc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA8IHJhbmdlX2JvdW5kc1swXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlX2JvdW5kc1swXSwgZW5kID0gcmFuZ2VfYm91bmRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfTtcbiAgICBHcmlkLnByb3RvdHlwZS5ncmlkX2Nvb3JkcyA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgZXhjbHVkZV9lbmRzKSB7XG4gICAgICAgIHZhciBOLCBjbWF4LCBjbWluLCBjb29yZHMsIGNyb3NzX3JhbmdlLCBkaW1faSwgZGltX2osIGVuZCwgaSwgaWksIGosIGssIGwsIGxvYywgbWF4LCBtaW4sIG4sIHJhbmdlLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHN0YXJ0LCB0aWNrcywgdG1wO1xuICAgICAgICBpZiAoZXhjbHVkZV9lbmRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVfZW5kcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHRoaXMuZGltZW5zaW9uO1xuICAgICAgICBqID0gKGkgKyAxKSAlIDI7XG4gICAgICAgIHJlZiA9IHRoaXMucmFuZ2VzKCksIHJhbmdlID0gcmVmWzBdLCBjcm9zc19yYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuY29tcHV0ZWRfYm91bmRzKCksIHN0YXJ0ID0gcmVmMVswXSwgZW5kID0gcmVmMVsxXTtcbiAgICAgICAgdG1wID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgICAgICBzdGFydCA9IHRtcDtcbiAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tlci5nZXRfdGlja3Moc3RhcnQsIGVuZCwgcmFuZ2UsIGNyb3NzX3JhbmdlLm1pbiwge30pW2xvY2F0aW9uXTtcbiAgICAgICAgbWluID0gcmFuZ2UubWluO1xuICAgICAgICBtYXggPSByYW5nZS5tYXg7XG4gICAgICAgIGNtaW4gPSBjcm9zc19yYW5nZS5taW47XG4gICAgICAgIGNtYXggPSBjcm9zc19yYW5nZS5tYXg7XG4gICAgICAgIGNvb3JkcyA9IFtbXSwgW11dO1xuICAgICAgICBmb3IgKGlpID0gayA9IDAsIHJlZjIgPSB0aWNrcy5sZW5ndGg7IDAgPD0gcmVmMiA/IGsgPCByZWYyIDogayA+IHJlZjI7IGlpID0gMCA8PSByZWYyID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICBpZiAoKHRpY2tzW2lpXSA9PT0gbWluIHx8IHRpY2tzW2lpXSA9PT0gbWF4KSAmJiBleGNsdWRlX2VuZHMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpbV9pID0gW107XG4gICAgICAgICAgICBkaW1faiA9IFtdO1xuICAgICAgICAgICAgTiA9IDI7XG4gICAgICAgICAgICBmb3IgKG4gPSBsID0gMCwgcmVmMyA9IE47IDAgPD0gcmVmMyA/IGwgPCByZWYzIDogbCA+IHJlZjM7IG4gPSAwIDw9IHJlZjMgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICBsb2MgPSBjbWluICsgKGNtYXggLSBjbWluKSAvIChOIC0gMSkgKiBuO1xuICAgICAgICAgICAgICAgIGRpbV9pLnB1c2godGlja3NbaWldKTtcbiAgICAgICAgICAgICAgICBkaW1fai5wdXNoKGxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb29yZHNbaV0ucHVzaChkaW1faSk7XG4gICAgICAgICAgICBjb29yZHNbal0ucHVzaChkaW1faik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9O1xuICAgIHJldHVybiBHcmlkO1xufSkoZ3VpZGVfcmVuZGVyZXJfMS5HdWlkZVJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuL2dyaWRcIik7XG5leHBvcnRzLkdyaWQgPSBncmlkXzEuR3JpZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Fubm90YXRpb25zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2F4ZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY2FsbGJhY2tzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NhbnZhc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9mb3JtYXR0ZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dseXBoc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ncmlkc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9sYXlvdXRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL21hcHBlcnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNmb3Jtc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tYXJrZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Bsb3RzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jhbmdlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZW5kZXJlcnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc291cmNlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90aWNrZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RpbGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Rvb2xzXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4vbGF5b3V0X2RvbVwiKTtcbmV4cG9ydHMuQm94VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQm94Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94VmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJveFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJveFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstZ3JpZFwiO1xuICAgIEJveFZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCb3hWaWV3Ll9fc3VwZXJfXy5iaW5kX2Jva2VoX2V2ZW50cy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmNoaWxkcmVuJywgdGhpcy5idWlsZF9jaGlsZF92aWV3cyk7XG4gICAgfTtcbiAgICBCb3hWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRfaGVpZ2h0cywgY2hpbGRyZW4sIGhlaWdodDtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGNoaWxkX2hlaWdodHMgPSBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX2hlaWdodC5fdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXJyYXlfMS5tYXgoY2hpbGRfaGVpZ2h0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcnJheV8xLnN1bShjaGlsZF9oZWlnaHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH07XG4gICAgQm94Vmlldy5wcm90b3R5cGUuZ2V0X3dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRfd2lkdGhzLCBjaGlsZHJlbiwgd2lkdGg7XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5tb2RlbC5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBjaGlsZF93aWR0aHMgPSBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX3dpZHRoLl92YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGFycmF5XzEuc3VtKGNoaWxkX3dpZHRocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IGFycmF5XzEubWF4KGNoaWxkX3dpZHRocyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIEJveFZpZXc7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NVmlldyk7XG5leHBvcnRzLkJveCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQm94LCBzdXBlckNsYXNzKTtcbiAgICBCb3gucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQm94VmlldztcbiAgICBmdW5jdGlvbiBCb3goYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQm94Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY2hpbGRfZXF1YWxfc2l6ZV93aWR0aCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9jaGlsZF9lcXVhbF9zaXplX2hlaWdodCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9ib3hfZXF1YWxfc2l6ZV90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fYm94X2VxdWFsX3NpemVfYm90dG9tID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9lcXVhbF9zaXplX2xlZnQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fYm94X2VxdWFsX3NpemVfcmlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fYm94X2NlbGxfYWxpZ25fdG9wID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9jZWxsX2FsaWduX2JvdHRvbSA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZSgpO1xuICAgICAgICB0aGlzLl9ib3hfY2VsbF9hbGlnbl9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHRoaXMuX2JveF9jZWxsX2FsaWduX3JpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgfVxuICAgIEJveC5kZWZpbmUoe1xuICAgICAgICBjaGlsZHJlbjogW3AuQXJyYXksIFtdXVxuICAgIH0pO1xuICAgIEJveC5pbnRlcm5hbCh7XG4gICAgICAgIHNwYWNpbmc6IFtwLk51bWJlciwgNl1cbiAgICB9KTtcbiAgICBCb3gucHJvdG90eXBlLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUudmFyaWFibGVzX3VwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaiwgbGVuLCByZWY7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltqXTtcbiAgICAgICAgICAgIGNoaWxkLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5nZXRfZWRpdF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgZWRpdF92YXJpYWJsZXMsIGosIGxlbiwgcmVmO1xuICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IEJveC5fX3N1cGVyX18uZ2V0X2VkaXRfdmFyaWFibGVzLmNhbGwodGhpcyk7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltqXTtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzID0gZWRpdF92YXJpYWJsZXMuY29uY2F0KGNoaWxkLmdldF9lZGl0X3ZhcmlhYmxlcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdF92YXJpYWJsZXM7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW5lZF92YXJpYWJsZXM7XG4gICAgICAgIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IEJveC5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcy5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdHJhaW5lZF92YXJpYWJsZXMgPSBvYmplY3RfMS5leHRlbmQoY29uc3RyYWluZWRfdmFyaWFibGVzLCB7XG4gICAgICAgICAgICAnYm94LWVxdWFsLXNpemUtdG9wJzogdGhpcy5fYm94X2VxdWFsX3NpemVfdG9wLFxuICAgICAgICAgICAgJ2JveC1lcXVhbC1zaXplLWJvdHRvbSc6IHRoaXMuX2JveF9lcXVhbF9zaXplX2JvdHRvbSxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1sZWZ0JzogdGhpcy5fYm94X2VxdWFsX3NpemVfbGVmdCxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1yaWdodCc6IHRoaXMuX2JveF9lcXVhbF9zaXplX3JpZ2h0LFxuICAgICAgICAgICAgJ2JveC1jZWxsLWFsaWduLXRvcCc6IHRoaXMuX2JveF9jZWxsX2FsaWduX3RvcCxcbiAgICAgICAgICAgICdib3gtY2VsbC1hbGlnbi1ib3R0b20nOiB0aGlzLl9ib3hfY2VsbF9hbGlnbl9ib3R0b20sXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tbGVmdCc6IHRoaXMuX2JveF9jZWxsX2FsaWduX2xlZnQsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tcmlnaHQnOiB0aGlzLl9ib3hfY2VsbF9hbGlnbl9yaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNoaWxkcmVuLCBjb25zdHJhaW50cywgaSwgaiwgaywgbGFzdCwgbGVuLCBuZXh0LCByZWN0LCByZWYsIHZhcl9rZXlzLCB2YXJzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgdGhpcy5fdGVzdF9sYXlvdXRhYmxlKGNoaWxkKTtcbiAgICAgICAgICAgIHZhcnMgPSBjaGlsZC5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICB2YXJfa2V5cyA9IE9iamVjdC5rZXlzKHZhcnMpO1xuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2NoaWxkX3JlY3QodmFycyk7XG4gICAgICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNfdmFyKCdoZWlnaHQnLCB2YXJfa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShyZWN0LmhlaWdodCwgWy0xLCB0aGlzLl9oZWlnaHRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc192YXIoJ3dpZHRoJywgdmFyX2tleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEocmVjdC53aWR0aCwgWy0xLCB0aGlzLl93aWR0aF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNfdmFyKFsnYm94LWVxdWFsLXNpemUtbGVmdCcsICdib3gtZXF1YWwtc2l6ZS1yaWdodCcsICd3aWR0aCddLCB2YXJfa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShbLTEsIHZhcnNbJ2JveC1lcXVhbC1zaXplLWxlZnQnXV0sIFstMSwgdmFyc1snYm94LWVxdWFsLXNpemUtcmlnaHQnXV0sIHZhcnNbJ3dpZHRoJ10sIHRoaXMuX2NoaWxkX2VxdWFsX3NpemVfd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzX3ZhcihbJ2JveC1lcXVhbC1zaXplLXRvcCcsICdib3gtZXF1YWwtc2l6ZS1ib3R0b20nLCAnaGVpZ2h0J10sIHZhcl9rZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKFstMSwgdmFyc1snYm94LWVxdWFsLXNpemUtdG9wJ11dLCBbLTEsIHZhcnNbJ2JveC1lcXVhbC1zaXplLWJvdHRvbSddXSwgdmFyc1snaGVpZ2h0J10sIHRoaXMuX2NoaWxkX2VxdWFsX3NpemVfaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQoY2hpbGQuZ2V0X2NvbnN0cmFpbnRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSB0aGlzLl9pbmZvKGNoaWxkcmVuWzBdLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEobGFzdC5zcGFuLnN0YXJ0LCAwKSk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAxLCByZWYgPSBjaGlsZHJlbi5sZW5ndGg7IDEgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAxIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgbmV4dCA9IHRoaXMuX2luZm8oY2hpbGRyZW5baV0uZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpKTtcbiAgICAgICAgICAgIGlmIChsYXN0LnNwYW4uc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEobGFzdC5zcGFuLnN0YXJ0LCBsYXN0LnNwYW4uc2l6ZSwgWy0xLCBuZXh0LnNwYW4uc3RhcnRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLldFQUtfRVEobGFzdC53aGl0ZXNwYWNlLmFmdGVyLCBuZXh0LndoaXRlc3BhY2UuYmVmb3JlLCAwIC0gdGhpcy5zcGFjaW5nKSk7XG4gICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKGxhc3Qud2hpdGVzcGFjZS5hZnRlciwgbmV4dC53aGl0ZXNwYWNlLmJlZm9yZSwgMCAtIHRoaXMuc3BhY2luZykpO1xuICAgICAgICAgICAgbGFzdCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNfdmFyKCd3aWR0aCcsIHZhcl9rZXlzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEobGFzdC5zcGFuLnN0YXJ0LCBsYXN0LnNwYW4uc2l6ZSwgWy0xLCB0aGlzLl93aWR0aF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNfdmFyKCdoZWlnaHQnLCB2YXJfa2V5cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKGxhc3Quc3Bhbi5zdGFydCwgbGFzdC5zcGFuLnNpemUsIFstMSwgdGhpcy5faGVpZ2h0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KHRoaXMuX2FsaWduX291dGVyX2VkZ2VzX2NvbnN0cmFpbnRzKHRydWUpKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fYWxpZ25fb3V0ZXJfZWRnZXNfY29uc3RyYWludHMoZmFsc2UpKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fYWxpZ25faW5uZXJfY2VsbF9lZGdlc19jb25zdHJhaW50cygpKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fYm94X2VxdWFsX3NpemVfYm91bmRzKHRydWUpKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fYm94X2VxdWFsX3NpemVfYm91bmRzKGZhbHNlKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KHRoaXMuX2JveF9jZWxsX2FsaWduX2JvdW5kcyh0cnVlKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KHRoaXMuX2JveF9jZWxsX2FsaWduX2JvdW5kcyhmYWxzZSkpO1xuICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdCh0aGlzLl9ib3hfd2hpdGVzcGFjZSh0cnVlKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KHRoaXMuX2JveF93aGl0ZXNwYWNlKGZhbHNlKSk7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2hhc192YXIgPSBmdW5jdGlvbiAobG9va191cCwgdmFyX2tleXMpIHtcbiAgICAgICAgdmFyIGxvb2tfdXBfbGlzdDtcbiAgICAgICAgbG9va191cF9saXN0ID0gdHlwZXNfMS5pc1N0cmluZyhsb29rX3VwKSA/IFtsb29rX3VwXSA6IGxvb2tfdXA7XG4gICAgICAgIHJldHVybiBhcnJheV8xLmFsbChsb29rX3VwX2xpc3QsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHZhcl9rZXlzLCB4KSA+PSAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX3Rlc3RfbGF5b3V0YWJsZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgaiwga2V5LCBsZW4sIHJlcXVpcmVkX2NvbnN0cmFpbmVkX3ZhcmlhYmxlcywgdmFycztcbiAgICAgICAgcmVxdWlyZWRfY29uc3RyYWluZWRfdmFyaWFibGVzID0gWydvcmlnaW4teCcsICdvcmlnaW4teScsICd3aGl0ZXNwYWNlLXRvcCcsICd3aGl0ZXNwYWNlLXJpZ2h0JywgJ3doaXRlc3BhY2UtYm90dG9tJywgJ3doaXRlc3BhY2UtbGVmdCddO1xuICAgICAgICBpZiAoY2hpbGQuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyBcIiBpcyBtaXNzaW5nIGdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMgPSBjaGlsZC5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzKCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlcXVpcmVkX2NvbnN0cmFpbmVkX3ZhcmlhYmxlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAga2V5ID0gcmVxdWlyZWRfY29uc3RyYWluZWRfdmFyaWFibGVzW2pdO1xuICAgICAgICAgICAgaWYgKGluZGV4T2YuY2FsbChPYmplY3Qua2V5cyh2YXJzKSwga2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyBcIiBpcyBtaXNzaW5nIGNvbnN0cmFpbmVkX3ZhcmlhYmxlIFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFyc1trZXldIGluc3RhbmNlb2Ygc29sdmVyXzEuVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyBcIiBcIiArIGtleSArIFwiIGlzIG5vdCBhIHNvbHZlciBWYXJpYWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2NoaWxkX3JlY3QgPSBmdW5jdGlvbiAodmFycykge1xuICAgICAgICB2YXIgaGVpZ2h0LCByZWYsIHdpZHRoLCB4LCB5O1xuICAgICAgICB3aWR0aCA9IHZhcnNbJ3dpZHRoJ107XG4gICAgICAgIGhlaWdodCA9IHZhcnNbJ2hlaWdodCddO1xuICAgICAgICByZWYgPSBbdmFyc1snb3JpZ2luLXgnXSwgdmFyc1snb3JpZ2luLXknXV0sIHggPSByZWZbMF0sIHkgPSByZWZbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9zcGFuID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHJlY3QueCxcbiAgICAgICAgICAgICAgICBzaXplOiByZWN0LndpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydDogcmVjdC55LFxuICAgICAgICAgICAgICAgIHNpemU6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9pbmZvID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgICAgICAgdmFyIHNwYW4sIHdoaXRlc3BhY2U7XG4gICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogdmFyc1snd2hpdGVzcGFjZS1sZWZ0J10sXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHZhcnNbJ3doaXRlc3BhY2UtcmlnaHQnXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiB2YXJzWyd3aGl0ZXNwYWNlLXRvcCddLFxuICAgICAgICAgICAgICAgIGFmdGVyOiB2YXJzWyd3aGl0ZXNwYWNlLWJvdHRvbSddXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4gPSB0aGlzLl9zcGFuKHRoaXMuX2NoaWxkX3JlY3QodmFycykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Bhbjogc3BhbixcbiAgICAgICAgICAgIHdoaXRlc3BhY2U6IHdoaXRlc3BhY2VcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2ZsYXR0ZW5fY2VsbF9lZGdlX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBhZGRfcGF0aCwgYWxsX3ZhcnMsIGFyaXR5LCBjZWxsLCBjZWxsX3ZhcnMsIGNoaWxkLCBjaGlsZHJlbiwgZGlyZWN0aW9uLCBmbGF0dGVuZWQsIGosIGssIGtleSwga2luZCwgbGVuLCBsZW4xLCBuYW1lLCBuZXdfa2V5LCBwYXJzZWQsIHBhdGgsIHJlbGV2YW50X2VkZ2VzLCB2YXJpYWJsZXM7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZWxldmFudF9lZGdlcyA9IEJveC5fdG9wX2JvdHRvbV9pbm5lcl9jZWxsX2VkZ2VfdmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVsZXZhbnRfZWRnZXMgPSBCb3guX2xlZnRfcmlnaHRfaW5uZXJfY2VsbF9lZGdlX3ZhcmlhYmxlcztcbiAgICAgICAgfVxuICAgICAgICBhZGRfcGF0aCA9IGhvcml6b250YWwgIT09IHRoaXMuX2hvcml6b250YWw7XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBhcml0eSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZmxhdHRlbmVkID0ge307XG4gICAgICAgIGNlbGwgPSAwO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJveCkge1xuICAgICAgICAgICAgICAgIGNlbGxfdmFycyA9IGNoaWxkLl9mbGF0dGVuX2NlbGxfZWRnZV92YXJpYWJsZXMoaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsX3ZhcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbF92YXJzID0gY2hpbGQuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHJlbGV2YW50X2VkZ2VzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSByZWxldmFudF9lZGdlc1trXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBhbGxfdmFycykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsX3ZhcnNbbmFtZV0gPSBbYWxsX3ZhcnNbbmFtZV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGNlbGxfdmFycykge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IGNlbGxfdmFyc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChhZGRfcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBrZXkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBraW5kID0gcGFyc2VkWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXJzZWRbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJyb3dcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFwiY29sXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3X2tleSA9IGtpbmQgKyBcIiBcIiArIGRpcmVjdGlvbiArIFwiLVwiICsgYXJpdHkgKyBcIi1cIiArIGNlbGwgKyBcIi1cIiArIHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3X2tleSBpbiBmbGF0dGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlbmVkW25ld19rZXldID0gZmxhdHRlbmVkW25ld19rZXldLmNvbmNhdCh2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlbmVkW25ld19rZXldID0gdmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGwgPSBjZWxsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fYWxpZ25faW5uZXJfY2VsbF9lZGdlc19jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzLCBmbGF0dGVuZWQsIGksIGosIGtleSwgbGFzdCwgcmVmLCB2YXJpYWJsZXM7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9pc19yb290KSB7XG4gICAgICAgICAgICBmbGF0dGVuZWQgPSB0aGlzLl9mbGF0dGVuX2NlbGxfZWRnZV92YXJpYWJsZXModGhpcy5faG9yaXpvbnRhbCk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBmbGF0dGVuZWQpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSBmbGF0dGVuZWRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHZhcmlhYmxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDEsIHJlZiA9IHZhcmlhYmxlcy5sZW5ndGg7IDEgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAxIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh2YXJpYWJsZXNbaV0sIFstMSwgbGFzdF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9maW5kX2VkZ2VfbGVhdmVzID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjaGlsZF9sZWF2ZXMsIGNoaWxkcmVuLCBlbmQsIGosIGxlYXZlcywgbGVuLCBzdGFydDtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGxlYXZlcyA9IFtbXSwgW11dO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwgPT09IGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVuZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCBpbnN0YW5jZW9mIEJveCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMF0gPSBsZWF2ZXNbMF0uY29uY2F0KHN0YXJ0Ll9maW5kX2VkZ2VfbGVhdmVzKGhvcml6b250YWwpWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlc1swXS5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZCBpbnN0YW5jZW9mIEJveCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMV0gPSBsZWF2ZXNbMV0uY29uY2F0KGVuZC5fZmluZF9lZGdlX2xlYXZlcyhob3Jpem9udGFsKVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMV0ucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRfbGVhdmVzID0gY2hpbGQuX2ZpbmRfZWRnZV9sZWF2ZXMoaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMF0gPSBsZWF2ZXNbMF0uY29uY2F0KGNoaWxkX2xlYXZlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMV0gPSBsZWF2ZXNbMV0uY29uY2F0KGNoaWxkX2xlYXZlc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMF0ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2ZXNbMV0ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlYXZlcztcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2FsaWduX291dGVyX2VkZ2VzX2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIGFkZF9hbGxfZXF1YWwsIGNvbGxlY3RfdmFycywgZW5kX2VkZ2VzLCBlbmRfbGVhdmVzLCBlbmRfdmFyaWFibGUsIHJlZiwgcmVzdWx0LCBzdGFydF9lZGdlcywgc3RhcnRfbGVhdmVzLCBzdGFydF92YXJpYWJsZTtcbiAgICAgICAgcmVmID0gdGhpcy5fZmluZF9lZGdlX2xlYXZlcyhob3Jpem9udGFsKSwgc3RhcnRfbGVhdmVzID0gcmVmWzBdLCBlbmRfbGVhdmVzID0gcmVmWzFdO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgc3RhcnRfdmFyaWFibGUgPSAnb24tZWRnZS1hbGlnbi1sZWZ0JztcbiAgICAgICAgICAgIGVuZF92YXJpYWJsZSA9ICdvbi1lZGdlLWFsaWduLXJpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0X3ZhcmlhYmxlID0gJ29uLWVkZ2UtYWxpZ24tdG9wJztcbiAgICAgICAgICAgIGVuZF92YXJpYWJsZSA9ICdvbi1lZGdlLWFsaWduLWJvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdF92YXJzID0gZnVuY3Rpb24gKGxlYXZlcywgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGVkZ2VzLCBqLCBsZWFmLCBsZW4sIHZhcnM7XG4gICAgICAgICAgICBlZGdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbGVhdmVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGVhZiA9IGxlYXZlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXJzID0gbGVhZi5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gdmFycykge1xuICAgICAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKHZhcnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGdlcztcbiAgICAgICAgfTtcbiAgICAgICAgc3RhcnRfZWRnZXMgPSBjb2xsZWN0X3ZhcnMoc3RhcnRfbGVhdmVzLCBzdGFydF92YXJpYWJsZSk7XG4gICAgICAgIGVuZF9lZGdlcyA9IGNvbGxlY3RfdmFycyhlbmRfbGVhdmVzLCBlbmRfdmFyaWFibGUpO1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgYWRkX2FsbF9lcXVhbCA9IGZ1bmN0aW9uIChlZGdlcykge1xuICAgICAgICAgICAgdmFyIGVkZ2UsIGZpcnN0LCBpLCBqLCByZWYxO1xuICAgICAgICAgICAgaWYgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGVkZ2VzWzBdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAxLCByZWYxID0gZWRnZXMubGVuZ3RoOyAxIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gMSA8PSByZWYxID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc29sdmVyXzEuRVEoWy0xLCBmaXJzdF0sIGVkZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZF9hbGxfZXF1YWwoc3RhcnRfZWRnZXMpO1xuICAgICAgICBhZGRfYWxsX2VxdWFsKGVuZF9lZGdlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9ib3hfaW5zZXRzX2Zyb21fY2hpbGRfaW5zZXRzID0gZnVuY3Rpb24gKGhvcml6b250YWwsIGNoaWxkX3ZhcmlhYmxlX3ByZWZpeCwgb3VyX3ZhcmlhYmxlX3ByZWZpeCwgbWluaW11bSkge1xuICAgICAgICB2YXIgYWRkX2NvbnN0cmFpbnRzLCBlbmRfbGVhdmVzLCBlbmRfdmFyaWFibGUsIG91cl9lbmQsIG91cl9zdGFydCwgcmVmLCByZXN1bHQsIHN0YXJ0X2xlYXZlcywgc3RhcnRfdmFyaWFibGU7XG4gICAgICAgIHJlZiA9IHRoaXMuX2ZpbmRfZWRnZV9sZWF2ZXMoaG9yaXpvbnRhbCksIHN0YXJ0X2xlYXZlcyA9IHJlZlswXSwgZW5kX2xlYXZlcyA9IHJlZlsxXTtcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN0YXJ0X3ZhcmlhYmxlID0gY2hpbGRfdmFyaWFibGVfcHJlZml4ICsgXCItbGVmdFwiO1xuICAgICAgICAgICAgZW5kX3ZhcmlhYmxlID0gY2hpbGRfdmFyaWFibGVfcHJlZml4ICsgXCItcmlnaHRcIjtcbiAgICAgICAgICAgIG91cl9zdGFydCA9IHRoaXNbb3VyX3ZhcmlhYmxlX3ByZWZpeCArIFwiX2xlZnRcIl07XG4gICAgICAgICAgICBvdXJfZW5kID0gdGhpc1tvdXJfdmFyaWFibGVfcHJlZml4ICsgXCJfcmlnaHRcIl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydF92YXJpYWJsZSA9IGNoaWxkX3ZhcmlhYmxlX3ByZWZpeCArIFwiLXRvcFwiO1xuICAgICAgICAgICAgZW5kX3ZhcmlhYmxlID0gY2hpbGRfdmFyaWFibGVfcHJlZml4ICsgXCItYm90dG9tXCI7XG4gICAgICAgICAgICBvdXJfc3RhcnQgPSB0aGlzW291cl92YXJpYWJsZV9wcmVmaXggKyBcIl90b3BcIl07XG4gICAgICAgICAgICBvdXJfZW5kID0gdGhpc1tvdXJfdmFyaWFibGVfcHJlZml4ICsgXCJfYm90dG9tXCJdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBhZGRfY29uc3RyYWludHMgPSBmdW5jdGlvbiAob3VycywgbGVhdmVzLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZWRnZXMsIGosIGxlYWYsIGxlbiwgdmFycztcbiAgICAgICAgICAgIGVkZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBsZWF2ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZWFmID0gbGVhdmVzW2pdO1xuICAgICAgICAgICAgICAgIHZhcnMgPSBsZWFmLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzb2x2ZXJfMS5HRShbLTEsIG91cnNdLCB2YXJzW25hbWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzb2x2ZXJfMS5FUShbLTEsIG91cnNdLCB2YXJzW25hbWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgYWRkX2NvbnN0cmFpbnRzKG91cl9zdGFydCwgc3RhcnRfbGVhdmVzLCBzdGFydF92YXJpYWJsZSk7XG4gICAgICAgIGFkZF9jb25zdHJhaW50cyhvdXJfZW5kLCBlbmRfbGVhdmVzLCBlbmRfdmFyaWFibGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQm94LnByb3RvdHlwZS5fYm94X2VxdWFsX3NpemVfYm91bmRzID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveF9pbnNldHNfZnJvbV9jaGlsZF9pbnNldHMoaG9yaXpvbnRhbCwgJ2JveC1lcXVhbC1zaXplJywgJ19ib3hfZXF1YWxfc2l6ZScsIGZhbHNlKTtcbiAgICB9O1xuICAgIEJveC5wcm90b3R5cGUuX2JveF9jZWxsX2FsaWduX2JvdW5kcyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hfaW5zZXRzX2Zyb21fY2hpbGRfaW5zZXRzKGhvcml6b250YWwsICdib3gtY2VsbC1hbGlnbicsICdfYm94X2NlbGxfYWxpZ24nLCBmYWxzZSk7XG4gICAgfTtcbiAgICBCb3gucHJvdG90eXBlLl9ib3hfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hfaW5zZXRzX2Zyb21fY2hpbGRfaW5zZXRzKGhvcml6b250YWwsICd3aGl0ZXNwYWNlJywgJ193aGl0ZXNwYWNlJywgdHJ1ZSk7XG4gICAgfTtcbiAgICBCb3guX2xlZnRfcmlnaHRfaW5uZXJfY2VsbF9lZGdlX3ZhcmlhYmxlcyA9IFsnYm94LWNlbGwtYWxpZ24tbGVmdCcsICdib3gtY2VsbC1hbGlnbi1yaWdodCddO1xuICAgIEJveC5fdG9wX2JvdHRvbV9pbm5lcl9jZWxsX2VkZ2VfdmFyaWFibGVzID0gWydib3gtY2VsbC1hbGlnbi10b3AnLCAnYm94LWNlbGwtYWxpZ24tYm90dG9tJ107XG4gICAgcmV0dXJuIEJveDtcbn0pKGxheW91dF9kb21fMS5MYXlvdXRET00pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJveF8xID0gcmVxdWlyZShcIi4vYm94XCIpO1xuZXhwb3J0cy5Db2x1bW5WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbHVtblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENvbHVtblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDb2x1bW5WaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb2x1bW5WaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLWdyaWQtY29sdW1uXCI7XG4gICAgcmV0dXJuIENvbHVtblZpZXc7XG59KShib3hfMS5Cb3hWaWV3KTtcbmV4cG9ydHMuQ29sdW1uID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENvbHVtbiwgc3VwZXJDbGFzcyk7XG4gICAgQ29sdW1uLnByb3RvdHlwZS50eXBlID0gJ0NvbHVtbic7XG4gICAgQ29sdW1uLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNvbHVtblZpZXc7XG4gICAgZnVuY3Rpb24gQ29sdW1uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIENvbHVtbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbHVtbjtcbn0pKGJveF8xLkJveCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBib3hfMSA9IHJlcXVpcmUoXCIuL2JveFwiKTtcbmV4cG9ydHMuQm94ID0gYm94XzEuQm94O1xudmFyIGNvbHVtbl8xID0gcmVxdWlyZShcIi4vY29sdW1uXCIpO1xuZXhwb3J0cy5Db2x1bW4gPSBjb2x1bW5fMS5Db2x1bW47XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4vbGF5b3V0X2RvbVwiKTtcbmV4cG9ydHMuTGF5b3V0RE9NID0gbGF5b3V0X2RvbV8xLkxheW91dERPTTtcbnZhciByb3dfMSA9IHJlcXVpcmUoXCIuL3Jvd1wiKTtcbmV4cG9ydHMuUm93ID0gcm93XzEuUm93O1xudmFyIHNwYWNlcl8xID0gcmVxdWlyZShcIi4vc3BhY2VyXCIpO1xuZXhwb3J0cy5TcGFjZXIgPSBzcGFjZXJfMS5TcGFjZXI7XG52YXIgd2lkZ2V0X2JveF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0X2JveFwiKTtcbmV4cG9ydHMuV2lkZ2V0Qm94ID0gd2lkZ2V0X2JveF8xLldpZGdldEJveDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBzb2x2ZXJfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9zb2x2ZXJcIik7XG52YXIgYnVpbGRfdmlld3NfMSA9IHJlcXVpcmUoXCJjb3JlL2J1aWxkX3ZpZXdzXCIpO1xudmFyIGJva2VoX3ZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL2Jva2VoX3ZpZXdcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5MYXlvdXRET01WaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShMYXlvdXRET01WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMYXlvdXRET01WaWV3KCkge1xuICAgICAgICByZXR1cm4gTGF5b3V0RE9NVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjbHMsIGksIGxlbiwgcmVmO1xuICAgICAgICBMYXlvdXRET01WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJtb2RlbGlkX1wiICsgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImJrLWxheW91dC1cIiArIHRoaXMubW9kZWwuc2l6aW5nX21vZGUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5jc3NfY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmNzc19jbGFzc2VzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2xzID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRfdmlld3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRfY2hpbGRfdmlld3MoZmFsc2UpO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUuYnVpbGRfY2hpbGRfdmlld3MgPSBmdW5jdGlvbiAoaW5pdF9zb2x2ZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjaGlsZF92aWV3LCBjaGlsZHJlbiwgaSwgbGVuO1xuICAgICAgICBpZiAoaW5pdF9zb2x2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5pdF9zb2x2ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5iaW5kX2Jva2VoX2V2ZW50cygpO1xuICAgICAgICBpZiAoaW5pdF9zb2x2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuX2ludmFsaWRhdGVfYWxsX21vZGVscygpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5kb2N1bWVudC5faW5pdF9zb2x2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMubW9kZWwuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5jaGlsZF92aWV3cyA9IHt9O1xuICAgICAgICBidWlsZF92aWV3c18xLmJ1aWxkX3ZpZXdzKHRoaXMuY2hpbGRfdmlld3MsIGNoaWxkcmVuKTtcbiAgICAgICAgZG9tXzEuZW1wdHkodGhpcy5lbCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGRfdmlldyA9IHRoaXMuY2hpbGRfdmlld3NbY2hpbGQuaWRdO1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChjaGlsZF92aWV3LmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kX2Jva2VoX2V2ZW50cygpO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUudW5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkLCByZWYsIHJlc3VsdHMsIHZpZXc7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICByZWYgPSB0aGlzLmNoaWxkX3ZpZXdzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaWQgaW4gcmVmKSB7XG4gICAgICAgICAgICB2aWV3ID0gcmVmW2lkXTtcbiAgICAgICAgICAgIHZpZXcuc3RvcExpc3RlbmluZygpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHR5cGVvZiB2aWV3LnVuYmluZF9ib2tlaF9ldmVudHMgPT09IFwiZnVuY3Rpb25cIiA/IHZpZXcudW5iaW5kX2Jva2VoX2V2ZW50cygpIDogdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2l6aW5nX21vZGVfbXNnO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNpemluZ19tb2RlID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLm1vZGVsLmRvY3VtZW50LnNvbHZlcigpLCAncmVzaXplJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmRvY3VtZW50LnNvbHZlcigpLCAncmVzaXplJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHNpemluZ19tb2RlX21zZyA9IFwiQ2hhbmdpbmcgc2l6aW5nX21vZGUgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6c2l6aW5nX21vZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKHNpemluZ19tb2RlX21zZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCBzLCB3aWR0aDtcbiAgICAgICAgcyA9IHRoaXMubW9kZWwuZG9jdW1lbnQuc29sdmVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNpemluZ19tb2RlID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm1vZGVsLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldF93aWR0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldF9oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMuc3VnZ2VzdF92YWx1ZSh0aGlzLm1vZGVsLl93aWR0aCwgd2lkdGgpO1xuICAgICAgICAgICAgcy5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX2hlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHMudXBkYXRlX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdzY2FsZV93aWR0aCcpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0X2hlaWdodCgpO1xuICAgICAgICAgICAgcy5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX2hlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHMudXBkYXRlX3ZhcmlhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHRoaXMubW9kZWwuX3dpZHRoLl92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0Ll92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRfd2lkdGgoKTtcbiAgICAgICAgICAgIHMuc3VnZ2VzdF92YWx1ZSh0aGlzLm1vZGVsLl93aWR0aCwgd2lkdGgpO1xuICAgICAgICAgICAgcy51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1vZGVsLl9oZWlnaHQuX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNpemluZ19tb2RlID09PSAnc3RyZXRjaF9ib3RoJykge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSB0aGlzLm1vZGVsLl9kb21fbGVmdC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRoaXMubW9kZWwuX2RvbV90b3AuX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHRoaXMubW9kZWwuX3dpZHRoLl92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheW91dERPTVZpZXcucHJvdG90eXBlLmdldF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGF5b3V0RE9NVmlldy5wcm90b3R5cGUuZ2V0X3dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXRET01WaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLkxheW91dERPTSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoTGF5b3V0RE9NLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMYXlvdXRET00oKSB7XG4gICAgICAgIHJldHVybiBMYXlvdXRET00uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExheW91dERPTS5wcm90b3R5cGUudHlwZSA9IFwiTGF5b3V0RE9NXCI7XG4gICAgTGF5b3V0RE9NLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIExheW91dERPTS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfd2lkdGggXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2hlaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2xlZnQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfcmlnaHQgXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fdG9wID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX3RvcCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9ib3R0b20gPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfYm90dG9tIFwiICsgdGhpcy5pZCk7XG4gICAgICAgIHRoaXMuX2RvbV90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoXCJfZG9tX3RvcCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9kb21fbGVmdCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcIl9kb21fbGVmdCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl93aWR0aF9taW51c19yaWdodCA9IG5ldyBzb2x2ZXJfMS5WYXJpYWJsZShcIl93aWR0aF9taW51c19yaWdodCBcIiArIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKFwiX2hlaWdodF9taW51c19ib3R0b20gXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV90b3AgPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV9ib3R0b20gPSBuZXcgc29sdmVyXzEuVmFyaWFibGUoKTtcbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV9sZWZ0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZXNwYWNlX3JpZ2h0ID0gbmV3IHNvbHZlcl8xLlZhcmlhYmxlKCk7XG4gICAgfTtcbiAgICBMYXlvdXRET00ucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2RvbV9sZWZ0KSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5fZG9tX3RvcCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuX2xlZnQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl93aWR0aCwgWy0xLCB0aGlzLl9yaWdodF0pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl90b3ApKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLl9oZWlnaHQsIFstMSwgdGhpcy5fYm90dG9tXSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX3dpZHRoX21pbnVzX3JpZ2h0LCBbLTEsIHRoaXMuX3dpZHRoXSwgdGhpcy5fcmlnaHQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tLCBbLTEsIHRoaXMuX2hlaWdodF0sIHRoaXMuX2JvdHRvbSkpO1xuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBMYXlvdXRET00ucHJvdG90eXBlLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBMYXlvdXRET00ucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVkaXRfdmFyaWFibGVzO1xuICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRpdF92YXJpYWJsZTogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgICAgc3RyZW5ndGg6IHNvbHZlcl8xLlN0cmVuZ3RoLnN0cm9uZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzY2FsZV93aWR0aCcpIHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICAgIHN0cmVuZ3RoOiBzb2x2ZXJfMS5TdHJlbmd0aC5zdHJvbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIExheW91dERPTS5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcztcbiAgICAgICAgY29uc3RyYWluZWRfdmFyaWFibGVzID0ge1xuICAgICAgICAgICAgJ29yaWdpbi14JzogdGhpcy5fZG9tX2xlZnQsXG4gICAgICAgICAgICAnb3JpZ2luLXknOiB0aGlzLl9kb21fdG9wLFxuICAgICAgICAgICAgJ3doaXRlc3BhY2UtdG9wJzogdGhpcy5fd2hpdGVzcGFjZV90b3AsXG4gICAgICAgICAgICAnd2hpdGVzcGFjZS1ib3R0b20nOiB0aGlzLl93aGl0ZXNwYWNlX2JvdHRvbSxcbiAgICAgICAgICAgICd3aGl0ZXNwYWNlLWxlZnQnOiB0aGlzLl93aGl0ZXNwYWNlX2xlZnQsXG4gICAgICAgICAgICAnd2hpdGVzcGFjZS1yaWdodCc6IHRoaXMuX3doaXRlc3BhY2VfcmlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzdHJldGNoX2JvdGgnKSB7XG4gICAgICAgICAgICBjb25zdHJhaW5lZF92YXJpYWJsZXMgPSBvYmplY3RfMS5leHRlbmQoY29uc3RyYWluZWRfdmFyaWFibGVzLCB7XG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IHRoaXMuX2hlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzY2FsZV93aWR0aCcpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IG9iamVjdF8xLmV4dGVuZChjb25zdHJhaW5lZF92YXJpYWJsZXMsIHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB0aGlzLl93aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzY2FsZV9oZWlnaHQnKSB7XG4gICAgICAgICAgICBjb25zdHJhaW5lZF92YXJpYWJsZXMgPSBvYmplY3RfMS5leHRlbmQoY29uc3RyYWluZWRfdmFyaWFibGVzLCB7XG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IHRoaXMuX2hlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIExheW91dERPTS5kZWZpbmUoe1xuICAgICAgICBoZWlnaHQ6IFtwLk51bWJlcl0sXG4gICAgICAgIHdpZHRoOiBbcC5OdW1iZXJdLFxuICAgICAgICBkaXNhYmxlZDogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBzaXppbmdfbW9kZTogW3AuU2l6aW5nTW9kZSwgXCJmaXhlZFwiXSxcbiAgICAgICAgY3NzX2NsYXNzZXM6IFtwLkFycmF5XVxuICAgIH0pO1xuICAgIExheW91dERPTS5pbnRlcm5hbCh7XG4gICAgICAgIGxheW91dGFibGU6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgcmV0dXJuIExheW91dERPTTtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJveF8xID0gcmVxdWlyZShcIi4vYm94XCIpO1xuZXhwb3J0cy5Sb3dWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJvd1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJvd1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBSb3dWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSb3dWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLWdyaWQtcm93XCI7XG4gICAgcmV0dXJuIFJvd1ZpZXc7XG59KShib3hfMS5Cb3hWaWV3KTtcbmV4cG9ydHMuUm93ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJvdywgc3VwZXJDbGFzcyk7XG4gICAgUm93LnByb3RvdHlwZS50eXBlID0gJ1Jvdyc7XG4gICAgUm93LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlJvd1ZpZXc7XG4gICAgZnVuY3Rpb24gUm93KGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIFJvdy5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gUm93O1xufSkoYm94XzEuQm94KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4vbGF5b3V0X2RvbVwiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5TcGFjZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShTcGFjZXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcGFjZXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3BhY2VyVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3BhY2VyVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1zcGFjZXItYm94XCI7XG4gICAgU3BhY2VyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBTcGFjZXJWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB0aGlzLm1vZGVsLndpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5tb2RlbC5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNwYWNlclZpZXcucHJvdG90eXBlLmdldF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgcmV0dXJuIFNwYWNlclZpZXc7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NVmlldyk7XG5leHBvcnRzLlNwYWNlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoU3BhY2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcGFjZXIoKSB7XG4gICAgICAgIHJldHVybiBTcGFjZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNwYWNlci5wcm90b3R5cGUudHlwZSA9ICdTcGFjZXInO1xuICAgIFNwYWNlci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5TcGFjZXJWaWV3O1xuICAgIFNwYWNlci5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcztcbiAgICAgICAgY29uc3RyYWluZWRfdmFyaWFibGVzID0gU3BhY2VyLl9fc3VwZXJfXy5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IG9iamVjdF8xLmV4dGVuZChjb25zdHJhaW5lZF92YXJpYWJsZXMsIHtcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLXRvcCc6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLWJvdHRvbSc6IHRoaXMuX2hlaWdodF9taW51c19ib3R0b20sXG4gICAgICAgICAgICAnb24tZWRnZS1hbGlnbi1sZWZ0JzogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLXJpZ2h0JzogdGhpcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tdG9wJzogdGhpcy5fdG9wLFxuICAgICAgICAgICAgJ2JveC1jZWxsLWFsaWduLWJvdHRvbSc6IHRoaXMuX2hlaWdodF9taW51c19ib3R0b20sXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tbGVmdCc6IHRoaXMuX2xlZnQsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tcmlnaHQnOiB0aGlzLl93aWR0aF9taW51c19yaWdodCxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS10b3AnOiB0aGlzLl90b3AsXG4gICAgICAgICAgICAnYm94LWVxdWFsLXNpemUtYm90dG9tJzogdGhpcy5faGVpZ2h0X21pbnVzX2JvdHRvbSxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1sZWZ0JzogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1yaWdodCc6IHRoaXMuX3dpZHRoX21pbnVzX3JpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29uc3RyYWluZWRfdmFyaWFibGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNwYWNlcjtcbn0pKGxheW91dF9kb21fMS5MYXlvdXRET00pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4uL2xheW91dHMvbGF5b3V0X2RvbVwiKTtcbmV4cG9ydHMuV2lkZ2V0Qm94VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoV2lkZ2V0Qm94Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2lkZ2V0Qm94VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldEJveFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdpZGdldEJveFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstd2lkZ2V0LWJveFwiO1xuICAgIFdpZGdldEJveFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBXaWRnZXRCb3hWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94Vmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFdpZGdldEJveFZpZXcuX19zdXBlcl9fLmJpbmRfYm9rZWhfZXZlbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6Y2hpbGRyZW4nLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5idWlsZF9jaGlsZF92aWV3cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3NzX3dpZHRoLCBoZWlnaHQsIHMsIHdpZHRoO1xuICAgICAgICBzID0gdGhpcy5tb2RlbC5kb2N1bWVudC5zb2x2ZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcgfHwgdGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2hlaWdodCcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRfd2lkdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLl93aWR0aC5fdmFsdWUgIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcy5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX3dpZHRoLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgcy51cGRhdGVfdmFyaWFibGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcgfHwgdGhpcy5tb2RlbC5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX3dpZHRoJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRfaGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5faGVpZ2h0Ll92YWx1ZSAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcy5zdWdnZXN0X3ZhbHVlKHRoaXMubW9kZWwuX2hlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzLnVwZGF0ZV92YXJpYWJsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlIC0gMjAgPiAwKSB7XG4gICAgICAgICAgICBjc3Nfd2lkdGggPSAodGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlIC0gMjApICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3NzX3dpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2l6aW5nX21vZGUgPT09ICdzdHJldGNoX2JvdGgnKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHRoaXMubW9kZWwuX2RvbV9sZWZ0Ll92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5tb2RlbC5faGVpZ2h0Ll92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlLndpZHRoID0gY3NzX3dpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaWRnZXRCb3hWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRfdmlldywgaGVpZ2h0LCBrZXksIHJlZjtcbiAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgcmVmID0gdGhpcy5jaGlsZF92aWV3cztcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjaGlsZF92aWV3ID0gcmVmW2tleV07XG4gICAgICAgICAgICBoZWlnaHQgKz0gY2hpbGRfdmlldy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodCArIDIwO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94Vmlldy5wcm90b3R5cGUuZ2V0X3dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRfdmlldywgY2hpbGRfd2lkdGgsIGtleSwgcmVmLCB3aWR0aDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZWwuc2Nyb2xsV2lkdGggKyAyMDtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuY2hpbGRfdmlld3M7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkX3ZpZXcgPSByZWZba2V5XTtcbiAgICAgICAgICAgICAgICBjaGlsZF93aWR0aCA9IGNoaWxkX3ZpZXcuZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkX3dpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjaGlsZF93aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXaWRnZXRCb3hWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5XaWRnZXRCb3ggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFdpZGdldEJveCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2lkZ2V0Qm94KCkge1xuICAgICAgICByZXR1cm4gV2lkZ2V0Qm94Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLnR5cGUgPSAnV2lkZ2V0Qm94JztcbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuV2lkZ2V0Qm94VmlldztcbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBXaWRnZXRCb3guX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdmaXhlZCcgJiYgdGhpcy53aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuaW5mbyhcIldpZGdldEJveCBtb2RlIGlzIGZpeGVkLCBidXQgbm8gd2lkdGggc3BlY2lmaWVkLiBVc2luZyBkZWZhdWx0IG9mIDMwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgPT09ICdzY2FsZV9oZWlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwic2l6aW5nX21vZGUgYHNjYWxlX2hlaWdodGAgaXMgbm90IGV4cGVyaW1lbnRhbCBmb3IgV2lkZ2V0Qm94LiBQbGVhc2UgcmVwb3J0IHlvdXIgcmVzdWx0cyB0byB0aGUgYm9rZWggZGV2IHRlYW0gc28gd2UgY2FuIGltcHJvdmUuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaWRnZXRCb3gucHJvdG90eXBlLmdldF9lZGl0X3ZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBlZGl0X3ZhcmlhYmxlcywgaSwgbGVuLCByZWY7XG4gICAgICAgIGVkaXRfdmFyaWFibGVzID0gV2lkZ2V0Qm94Ll9fc3VwZXJfXy5nZXRfZWRpdF92YXJpYWJsZXMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmVmID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBlZGl0X3ZhcmlhYmxlcy5jb25jYXQoY2hpbGQuZ2V0X2VkaXRfdmFyaWFibGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIFdpZGdldEJveC5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNvbnN0cmFpbnRzLCBpLCBsZW4sIHJlZjtcbiAgICAgICAgY29uc3RyYWludHMgPSBXaWRnZXRCb3guX19zdXBlcl9fLmdldF9jb25zdHJhaW50cy5jYWxsKHRoaXMpO1xuICAgICAgICByZWYgPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChjaGlsZC5nZXRfY29uc3RyYWludHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94LnByb3RvdHlwZS5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uc3RyYWluZWRfdmFyaWFibGVzO1xuICAgICAgICBjb25zdHJhaW5lZF92YXJpYWJsZXMgPSBXaWRnZXRCb3guX19zdXBlcl9fLmdldF9jb25zdHJhaW5lZF92YXJpYWJsZXMuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3RyYWluZWRfdmFyaWFibGVzID0gb2JqZWN0XzEuZXh0ZW5kKGNvbnN0cmFpbmVkX3ZhcmlhYmxlcywge1xuICAgICAgICAgICAgJ29uLWVkZ2UtYWxpZ24tdG9wJzogdGhpcy5fdG9wLFxuICAgICAgICAgICAgJ29uLWVkZ2UtYWxpZ24tYm90dG9tJzogdGhpcy5faGVpZ2h0X21pbnVzX2JvdHRvbSxcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLWxlZnQnOiB0aGlzLl9sZWZ0LFxuICAgICAgICAgICAgJ29uLWVkZ2UtYWxpZ24tcmlnaHQnOiB0aGlzLl93aWR0aF9taW51c19yaWdodCxcbiAgICAgICAgICAgICdib3gtY2VsbC1hbGlnbi10b3AnOiB0aGlzLl90b3AsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tYm90dG9tJzogdGhpcy5faGVpZ2h0X21pbnVzX2JvdHRvbSxcbiAgICAgICAgICAgICdib3gtY2VsbC1hbGlnbi1sZWZ0JzogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgICdib3gtY2VsbC1hbGlnbi1yaWdodCc6IHRoaXMuX3dpZHRoX21pbnVzX3JpZ2h0LFxuICAgICAgICAgICAgJ2JveC1lcXVhbC1zaXplLXRvcCc6IHRoaXMuX3RvcCxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1ib3R0b20nOiB0aGlzLl9oZWlnaHRfbWludXNfYm90dG9tXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgY29uc3RyYWluZWRfdmFyaWFibGVzID0gb2JqZWN0XzEuZXh0ZW5kKGNvbnN0cmFpbmVkX3ZhcmlhYmxlcywge1xuICAgICAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS1sZWZ0JzogdGhpcy5fbGVmdCxcbiAgICAgICAgICAgICAgICAnYm94LWVxdWFsLXNpemUtcmlnaHQnOiB0aGlzLl93aWR0aF9taW51c19yaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIFdpZGdldEJveC5wcm90b3R5cGUuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgV2lkZ2V0Qm94LmRlZmluZSh7XG4gICAgICAgICdjaGlsZHJlbic6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICByZXR1cm4gV2lkZ2V0Qm94O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi9jb2xvcl9tYXBwZXJcIik7XG5leHBvcnRzLkNhdGVnb3JpY2FsQ29sb3JNYXBwZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2F0ZWdvcmljYWxDb2xvck1hcHBlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxDb2xvck1hcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsQ29sb3JNYXBwZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhdGVnb3JpY2FsQ29sb3JNYXBwZXIucHJvdG90eXBlLnR5cGUgPSBcIkNhdGVnb3JpY2FsQ29sb3JNYXBwZXJcIjtcbiAgICBDYXRlZ29yaWNhbENvbG9yTWFwcGVyLmRlZmluZSh7XG4gICAgICAgIGZhY3RvcnM6IFtwLkFycmF5XVxuICAgIH0pO1xuICAgIENhdGVnb3JpY2FsQ29sb3JNYXBwZXIucHJvdG90eXBlLl9nZXRfdmFsdWVzID0gZnVuY3Rpb24gKGRhdGEsIHBhbGV0dGUpIHtcbiAgICAgICAgdmFyIGNvbG9yLCBkLCBpLCBrZXksIGxlbiwgdmFsdWVzO1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmZhY3RvcnMuaW5kZXhPZihkKTtcbiAgICAgICAgICAgIGlmIChrZXkgPCAwIHx8IGtleSA+PSBwYWxldHRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5uYW5fY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IHBhbGV0dGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3JpY2FsQ29sb3JNYXBwZXI7XG59KShjb2xvcl9tYXBwZXJfMS5Db2xvck1hcHBlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbGluZWFyX21hcHBlcl8xID0gcmVxdWlyZShcIi4vbGluZWFyX21hcHBlclwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90eXBlc1wiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxNYXBwZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2F0ZWdvcmljYWxNYXBwZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3JpY2FsTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxNYXBwZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhdGVnb3JpY2FsTWFwcGVyLnByb3RvdHlwZS5tYXBfdG9fdGFyZ2V0ID0gZnVuY3Rpb24gKHgsIHJldHVybl9zeW50aGV0aWMpIHtcbiAgICAgICAgdmFyIGZhY3RvciwgZmFjdG9ycywgcGVyY2VudCwgcmFuZ2UsIHJlZiwgcmVzdWx0O1xuICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5fc3ludGhldGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5fc3ludGhldGljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxNYXBwZXIuX19zdXBlcl9fLm1hcF90b190YXJnZXQuY2FsbCh0aGlzLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByYW5nZSA9IHRoaXMuc291cmNlX3JhbmdlO1xuICAgICAgICBmYWN0b3JzID0gcmFuZ2UuZmFjdG9ycztcbiAgICAgICAgaWYgKHguaW5kZXhPZignOicpID49IDApIHtcbiAgICAgICAgICAgIHJlZiA9IHguc3BsaXQoJzonKSwgZmFjdG9yID0gcmVmWzBdLCBwZXJjZW50ID0gcmVmWzFdO1xuICAgICAgICAgICAgcGVyY2VudCA9IHBhcnNlRmxvYXQocGVyY2VudCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3JzLmluZGV4T2YoZmFjdG9yKSArIDAuNSArIHJhbmdlLm9mZnNldCArIHBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3JzLmluZGV4T2YoeCkgKyAxICsgcmFuZ2Uub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXR1cm5fc3ludGhldGljKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsTWFwcGVyLl9fc3VwZXJfXy5tYXBfdG9fdGFyZ2V0LmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcmljYWxNYXBwZXIucHJvdG90eXBlLnZfbWFwX3RvX3RhcmdldCA9IGZ1bmN0aW9uICh4cywgcmV0dXJuX3N5bnRoZXRpYykge1xuICAgICAgICB2YXIgZmFjdG9yLCBmYWN0b3JzLCBpLCBqLCBwZXJjZW50LCByYW5nZSwgcmVmLCByZWYxLCByZXN1bHRzLCB4O1xuICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5fc3ludGhldGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzXzEuaXNOdW1iZXIoeHNbMF0pKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB4cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBDYXRlZ29yaWNhbE1hcHBlci5fX3N1cGVyX18udl9tYXBfdG9fdGFyZ2V0LmNhbGwodGhpcywgeHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhbmdlID0gdGhpcy5zb3VyY2VfcmFuZ2U7XG4gICAgICAgIGZhY3RvcnMgPSByYW5nZS5mYWN0b3JzO1xuICAgICAgICByZXN1bHRzID0gQXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHhzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB4ID0geHNbaV07XG4gICAgICAgICAgICBpZiAoeC5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlZjEgPSB4LnNwbGl0KCc6JyksIGZhY3RvciA9IHJlZjFbMF0sIHBlcmNlbnQgPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBwYXJzZUZsb2F0KHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBmYWN0b3JzLmluZGV4T2YoZmFjdG9yKSArIDAuNSArIHJhbmdlLm9mZnNldCArIHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gZmFjdG9ycy5pbmRleE9mKHgpICsgMSArIHJhbmdlLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0dXJuX3N5bnRoZXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxNYXBwZXIuX19zdXBlcl9fLnZfbWFwX3RvX3RhcmdldC5jYWxsKHRoaXMsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXRlZ29yaWNhbE1hcHBlci5wcm90b3R5cGUubWFwX2Zyb21fdGFyZ2V0ID0gZnVuY3Rpb24gKHhwcmltZSwgc2tpcF9jYXQpIHtcbiAgICAgICAgdmFyIGZhY3RvcnMsIHJhbmdlO1xuICAgICAgICBpZiAoc2tpcF9jYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2tpcF9jYXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB4cHJpbWUgPSBDYXRlZ29yaWNhbE1hcHBlci5fX3N1cGVyX18ubWFwX2Zyb21fdGFyZ2V0LmNhbGwodGhpcywgeHByaW1lKTtcbiAgICAgICAgaWYgKHNraXBfY2F0KSB7XG4gICAgICAgICAgICByZXR1cm4geHByaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlID0gdGhpcy5zb3VyY2VfcmFuZ2U7XG4gICAgICAgIGZhY3RvcnMgPSByYW5nZS5mYWN0b3JzO1xuICAgICAgICByZXR1cm4gZmFjdG9yc1tNYXRoLmZsb29yKHhwcmltZSAtIDAuNSAtIHJhbmdlLm9mZnNldCldO1xuICAgIH07XG4gICAgQ2F0ZWdvcmljYWxNYXBwZXIucHJvdG90eXBlLnZfbWFwX2Zyb21fdGFyZ2V0ID0gZnVuY3Rpb24gKHhwcmltZXMsIHNraXBfY2F0KSB7XG4gICAgICAgIHZhciBmYWN0b3JzLCBpLCBqLCBrLCByYW5nZSwgcmVmLCByZWYxLCByZXN1bHQsIHg7XG4gICAgICAgIGlmIChza2lwX2NhdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBza2lwX2NhdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHggPSBDYXRlZ29yaWNhbE1hcHBlci5fX3N1cGVyX18udl9tYXBfZnJvbV90YXJnZXQuY2FsbCh0aGlzLCB4cHJpbWVzKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHgubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHhbaV0gPSB4W2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwX2NhdCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoeCk7XG4gICAgICAgIHJhbmdlID0gdGhpcy5zb3VyY2VfcmFuZ2U7XG4gICAgICAgIGZhY3RvcnMgPSByYW5nZS5mYWN0b3JzO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IHhwcmltZXMubGVuZ3RoOyAwIDw9IHJlZjEgPyBrIDwgcmVmMSA6IGsgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBmYWN0b3JzW01hdGguZmxvb3IoeFtpXSAtIDAuNSAtIHJhbmdlLm9mZnNldCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcmljYWxNYXBwZXI7XG59KShsaW5lYXJfbWFwcGVyXzEuTGluZWFyTWFwcGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5Db2xvck1hcHBlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDb2xvck1hcHBlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sb3JNYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hcHBlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLnR5cGUgPSBcIkNvbG9yTWFwcGVyXCI7XG4gICAgQ29sb3JNYXBwZXIuZGVmaW5lKHtcbiAgICAgICAgcGFsZXR0ZTogW3AuQW55XSxcbiAgICAgICAgbmFuX2NvbG9yOiBbcC5Db2xvciwgXCJncmF5XCJdXG4gICAgfSk7XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgQ29sb3JNYXBwZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2xpdHRsZV9lbmRpYW4gPSB0aGlzLl9pc19saXR0bGVfZW5kaWFuKCk7XG4gICAgICAgIHRoaXMuX3BhbGV0dGUgPSB0aGlzLl9idWlsZF9wYWxldHRlKHRoaXMucGFsZXR0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFsZXR0ZSA9IHRoaXMuX2J1aWxkX3BhbGV0dGUodGhpcy5wYWxldHRlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2xvck1hcHBlci5wcm90b3R5cGUudl9tYXBfc2NyZWVuID0gZnVuY3Rpb24gKGRhdGEsIGltYWdlX2dseXBoKSB7XG4gICAgICAgIHZhciBidWYsIGNvbG9yLCBpLCBqLCBrLCByZWYsIHJlZjEsIHZhbHVlLCB2YWx1ZXM7XG4gICAgICAgIGlmIChpbWFnZV9nbHlwaCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbWFnZV9nbHlwaCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyA9IHRoaXMuX2dldF92YWx1ZXMoZGF0YSwgdGhpcy5fcGFsZXR0ZSwgaW1hZ2VfZ2x5cGgpO1xuICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGggKiA0KTtcbiAgICAgICAgY29sb3IgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgaWYgKHRoaXMuX2xpdHRsZV9lbmRpYW4pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBkYXRhLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29sb3JbaV0gPSAoMHhmZiA8PCAyNCkgfCAoKHZhbHVlICYgMHhmZjAwMDApID4+IDE2KSB8ICh2YWx1ZSAmIDB4ZmYwMCkgfCAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBkYXRhLmxlbmd0aDsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbG9yW2ldID0gKHZhbHVlIDw8IDgpIHwgMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcztcbiAgICAgICAgdmFsdWVzID0gdGhpcy5fZ2V0X3ZhbHVlcyh4cywgdGhpcy5wYWxldHRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIENvbG9yTWFwcGVyLnByb3RvdHlwZS5fZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uIChkYXRhLCBwYWxldHRlLCBpbWFnZV9nbHlwaCkge1xuICAgICAgICBpZiAoaW1hZ2VfZ2x5cGggPT0gbnVsbCkge1xuICAgICAgICAgICAgaW1hZ2VfZ2x5cGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBDb2xvck1hcHBlci5wcm90b3R5cGUuX2lzX2xpdHRsZV9lbmRpYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWYsIGJ1ZjMyLCBidWY4LCBsaXR0bGVfZW5kaWFuO1xuICAgICAgICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICBidWYzMiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICAgICAgICBidWYzMlsxXSA9IDB4MGEwYjBjMGQ7XG4gICAgICAgIGxpdHRsZV9lbmRpYW4gPSB0cnVlO1xuICAgICAgICBpZiAoYnVmOFs0XSA9PT0gMHgwYSAmJiBidWY4WzVdID09PSAweDBiICYmIGJ1ZjhbNl0gPT09IDB4MGMgJiYgYnVmOFs3XSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgbGl0dGxlX2VuZGlhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXR0bGVfZW5kaWFuO1xuICAgIH07XG4gICAgQ29sb3JNYXBwZXIucHJvdG90eXBlLl9idWlsZF9wYWxldHRlID0gZnVuY3Rpb24gKHBhbGV0dGUpIHtcbiAgICAgICAgdmFyIF9jb252ZXJ0LCBpLCBqLCBuZXdfcGFsZXR0ZSwgcmVmO1xuICAgICAgICBuZXdfcGFsZXR0ZSA9IG5ldyBVaW50MzJBcnJheShwYWxldHRlLmxlbmd0aCk7XG4gICAgICAgIF9jb252ZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUuc2xpY2UoMSksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHBhbGV0dGUubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIG5ld19wYWxldHRlW2ldID0gX2NvbnZlcnQocGFsZXR0ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld19wYWxldHRlO1xuICAgIH07XG4gICAgcmV0dXJuIENvbG9yTWFwcGVyO1xufSkobW9kZWxfMS5Nb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuR3JpZE1hcHBlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHcmlkTWFwcGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHcmlkTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gR3JpZE1hcHBlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR3JpZE1hcHBlci5wcm90b3R5cGUubWFwX3RvX3RhcmdldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB4cHJpbWUsIHlwcmltZTtcbiAgICAgICAgeHByaW1lID0gdGhpcy5kb21haW5fbWFwcGVyLm1hcF90b190YXJnZXQoeCk7XG4gICAgICAgIHlwcmltZSA9IHRoaXMuY29kb21haW5fbWFwcGVyLm1hcF90b190YXJnZXQoeSk7XG4gICAgICAgIHJldHVybiBbeHByaW1lLCB5cHJpbWVdO1xuICAgIH07XG4gICAgR3JpZE1hcHBlci5wcm90b3R5cGUudl9tYXBfdG9fdGFyZ2V0ID0gZnVuY3Rpb24gKHhzLCB5cykge1xuICAgICAgICB2YXIgeHByaW1lcywgeXByaW1lcztcbiAgICAgICAgeHByaW1lcyA9IHRoaXMuZG9tYWluX21hcHBlci52X21hcF90b190YXJnZXQoeHMpO1xuICAgICAgICB5cHJpbWVzID0gdGhpcy5jb2RvbWFpbl9tYXBwZXIudl9tYXBfdG9fdGFyZ2V0KHlzKTtcbiAgICAgICAgcmV0dXJuIFt4cHJpbWVzLCB5cHJpbWVzXTtcbiAgICB9O1xuICAgIEdyaWRNYXBwZXIucHJvdG90eXBlLm1hcF9mcm9tX3RhcmdldCA9IGZ1bmN0aW9uICh4cHJpbWUsIHlwcmltZSkge1xuICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgeCA9IHRoaXMuZG9tYWluX21hcHBlci5tYXBfZnJvbV90YXJnZXQoeHByaW1lKTtcbiAgICAgICAgeSA9IHRoaXMuY29kb21haW5fbWFwcGVyLm1hcF9mcm9tX3RhcmdldCh5cHJpbWUpO1xuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH07XG4gICAgR3JpZE1hcHBlci5wcm90b3R5cGUudl9tYXBfZnJvbV90YXJnZXQgPSBmdW5jdGlvbiAoeHByaW1lcywgeXByaW1lcykge1xuICAgICAgICB2YXIgeHMsIHlzO1xuICAgICAgICB4cyA9IHRoaXMuZG9tYWluX21hcHBlci52X21hcF9mcm9tX3RhcmdldCh4cHJpbWVzKTtcbiAgICAgICAgeXMgPSB0aGlzLmNvZG9tYWluX21hcHBlci52X21hcF9mcm9tX3RhcmdldCh5cHJpbWVzKTtcbiAgICAgICAgcmV0dXJuIFt4cywgeXNdO1xuICAgIH07XG4gICAgcmV0dXJuIEdyaWRNYXBwZXI7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhdGVnb3JpY2FsX2NvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vY2F0ZWdvcmljYWxfY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5DYXRlZ29yaWNhbENvbG9yTWFwcGVyID0gY2F0ZWdvcmljYWxfY29sb3JfbWFwcGVyXzEuQ2F0ZWdvcmljYWxDb2xvck1hcHBlcjtcbnZhciBjYXRlZ29yaWNhbF9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NhdGVnb3JpY2FsX21hcHBlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxNYXBwZXIgPSBjYXRlZ29yaWNhbF9tYXBwZXJfMS5DYXRlZ29yaWNhbE1hcHBlcjtcbnZhciBjb2xvcl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2NvbG9yX21hcHBlclwiKTtcbmV4cG9ydHMuQ29sb3JNYXBwZXIgPSBjb2xvcl9tYXBwZXJfMS5Db2xvck1hcHBlcjtcbnZhciBncmlkX21hcHBlcl8xID0gcmVxdWlyZShcIi4vZ3JpZF9tYXBwZXJcIik7XG5leHBvcnRzLkdyaWRNYXBwZXIgPSBncmlkX21hcHBlcl8xLkdyaWRNYXBwZXI7XG52YXIgbGluZWFyX2NvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vbGluZWFyX2NvbG9yX21hcHBlclwiKTtcbmV4cG9ydHMuTGluZWFyQ29sb3JNYXBwZXIgPSBsaW5lYXJfY29sb3JfbWFwcGVyXzEuTGluZWFyQ29sb3JNYXBwZXI7XG52YXIgbGluZWFyX21hcHBlcl8xID0gcmVxdWlyZShcIi4vbGluZWFyX21hcHBlclwiKTtcbmV4cG9ydHMuTGluZWFyTWFwcGVyID0gbGluZWFyX21hcHBlcl8xLkxpbmVhck1hcHBlcjtcbnZhciBsb2dfY29sb3JfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi9sb2dfY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5Mb2dDb2xvck1hcHBlciA9IGxvZ19jb2xvcl9tYXBwZXJfMS5Mb2dDb2xvck1hcHBlcjtcbnZhciBsb2dfbWFwcGVyXzEgPSByZXF1aXJlKFwiLi9sb2dfbWFwcGVyXCIpO1xuZXhwb3J0cy5Mb2dNYXBwZXIgPSBsb2dfbWFwcGVyXzEuTG9nTWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2NvbG9yXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGNvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vY29sb3JfbWFwcGVyXCIpO1xuZXhwb3J0cy5MaW5lYXJDb2xvck1hcHBlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMaW5lYXJDb2xvck1hcHBlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29sb3JNYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb2xvck1hcHBlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZWFyQ29sb3JNYXBwZXIucHJvdG90eXBlLnR5cGUgPSBcIkxpbmVhckNvbG9yTWFwcGVyXCI7XG4gICAgTGluZWFyQ29sb3JNYXBwZXIuZGVmaW5lKHtcbiAgICAgICAgaGlnaDogW3AuTnVtYmVyXSxcbiAgICAgICAgbG93OiBbcC5OdW1iZXJdLFxuICAgICAgICBoaWdoX2NvbG9yOiBbcC5Db2xvcl0sXG4gICAgICAgIGxvd19jb2xvcjogW3AuQ29sb3JdXG4gICAgfSk7XG4gICAgTGluZWFyQ29sb3JNYXBwZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgTGluZWFyQ29sb3JNYXBwZXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX25hbl9jb2xvciA9IHRoaXMuX2J1aWxkX3BhbGV0dGUoW2NvbG9yXzEuY29sb3IyaGV4KHRoaXMubmFuX2NvbG9yKV0pWzBdO1xuICAgICAgICB0aGlzLl9oaWdoX2NvbG9yID0gdGhpcy5oaWdoX2NvbG9yICE9IG51bGwgPyB0aGlzLl9idWlsZF9wYWxldHRlKFtjb2xvcl8xLmNvbG9yMmhleCh0aGlzLmhpZ2hfY29sb3IpXSlbMF0gOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb3dfY29sb3IgPSB0aGlzLmxvd19jb2xvciAhPSBudWxsID8gdGhpcy5fYnVpbGRfcGFsZXR0ZShbY29sb3JfMS5jb2xvcjJoZXgodGhpcy5sb3dfY29sb3IpXSlbMF0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICBMaW5lYXJDb2xvck1hcHBlci5wcm90b3R5cGUuX2dldF92YWx1ZXMgPSBmdW5jdGlvbiAoZGF0YSwgcGFsZXR0ZSwgaW1hZ2VfZ2x5cGgpIHtcbiAgICAgICAgdmFyIGQsIGhpZ2gsIGhpZ2hfY29sb3IsIGksIGtleSwgbGVuLCBsb3csIGxvd19jb2xvciwgbWF4X2tleSwgbmFuX2NvbG9yLCBub3JtX2ZhY3Rvciwgbm9ybWVkX2QsIG5vcm1lZF9pbnRlcnZhbCwgcmVmLCByZWYxLCB2YWx1ZXM7XG4gICAgICAgIGlmIChpbWFnZV9nbHlwaCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbWFnZV9nbHlwaCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxvdyA9IChyZWYgPSB0aGlzLmxvdykgIT0gbnVsbCA/IHJlZiA6IGFycmF5XzEubWluKGRhdGEpO1xuICAgICAgICBoaWdoID0gKHJlZjEgPSB0aGlzLmhpZ2gpICE9IG51bGwgPyByZWYxIDogYXJyYXlfMS5tYXgoZGF0YSk7XG4gICAgICAgIG1heF9rZXkgPSBwYWxldHRlLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICBuYW5fY29sb3IgPSBpbWFnZV9nbHlwaCA/IHRoaXMuX25hbl9jb2xvciA6IHRoaXMubmFuX2NvbG9yO1xuICAgICAgICBsb3dfY29sb3IgPSBpbWFnZV9nbHlwaCA/IHRoaXMuX2xvd19jb2xvciA6IHRoaXMubG93X2NvbG9yO1xuICAgICAgICBoaWdoX2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9oaWdoX2NvbG9yIDogdGhpcy5oaWdoX2NvbG9yO1xuICAgICAgICBub3JtX2ZhY3RvciA9IDEgLyAoaGlnaCAtIGxvdyk7XG4gICAgICAgIG5vcm1lZF9pbnRlcnZhbCA9IDEgLyBwYWxldHRlLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuYW5fY29sb3IpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQgPT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlW21heF9rZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1lZF9kID0gKGQgLSBsb3cpICogbm9ybV9mYWN0b3I7XG4gICAgICAgICAgICBrZXkgPSBNYXRoLmZsb29yKG5vcm1lZF9kIC8gbm9ybWVkX2ludGVydmFsKTtcbiAgICAgICAgICAgIGlmIChrZXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG93X2NvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobG93X2NvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhbGV0dGVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA+IG1heF9rZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdoX2NvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaGlnaF9jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlW21heF9rZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFyQ29sb3JNYXBwZXI7XG59KShjb2xvcl9tYXBwZXJfMS5Db2xvck1hcHBlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTGluZWFyTWFwcGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVhck1hcHBlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGluZWFyTWFwcGVyKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyTWFwcGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lYXJNYXBwZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgTGluZWFyTWFwcGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRlZmluZV9jb21wdXRlZF9wcm9wZXJ0eSgnbWFwcGVyX3N0YXRlJywgdGhpcy5fbWFwcGVyX3N0YXRlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRfZGVwZW5kZW5jaWVzKCdtYXBwZXJfc3RhdGUnLCB0aGlzLCBbJ3NvdXJjZV9yYW5nZScsICd0YXJnZXRfcmFuZ2UnXSk7XG4gICAgICAgIHRoaXMuYWRkX2RlcGVuZGVuY2llcygnbWFwcGVyX3N0YXRlJywgdGhpcy5zb3VyY2VfcmFuZ2UsIFsnc3RhcnQnLCAnZW5kJ10pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfZGVwZW5kZW5jaWVzKCdtYXBwZXJfc3RhdGUnLCB0aGlzLnRhcmdldF9yYW5nZSwgWydzdGFydCcsICdlbmQnXSk7XG4gICAgfTtcbiAgICBMaW5lYXJNYXBwZXIuZ2V0dGVycyh7XG4gICAgICAgIG1hcHBlcl9zdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb21wdXRlZCgnbWFwcGVyX3N0YXRlJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBMaW5lYXJNYXBwZXIucHJvdG90eXBlLm1hcF90b190YXJnZXQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgb2Zmc2V0LCByZWYsIHNjYWxlO1xuICAgICAgICByZWYgPSB0aGlzLm1hcHBlcl9zdGF0ZSwgc2NhbGUgPSByZWZbMF0sIG9mZnNldCA9IHJlZlsxXTtcbiAgICAgICAgcmV0dXJuIHNjYWxlICogeCArIG9mZnNldDtcbiAgICB9O1xuICAgIExpbmVhck1hcHBlci5wcm90b3R5cGUudl9tYXBfdG9fdGFyZ2V0ID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHZhciBpLCBpZHgsIGxlbiwgb2Zmc2V0LCByZWYsIHJlc3VsdCwgc2NhbGUsIHg7XG4gICAgICAgIHJlZiA9IHRoaXMubWFwcGVyX3N0YXRlLCBzY2FsZSA9IHJlZlswXSwgb2Zmc2V0ID0gcmVmWzFdO1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaWR4ID0gaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaWR4ID0gKytpKSB7XG4gICAgICAgICAgICB4ID0geHNbaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gc2NhbGUgKiB4ICsgb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMaW5lYXJNYXBwZXIucHJvdG90eXBlLm1hcF9mcm9tX3RhcmdldCA9IGZ1bmN0aW9uICh4cHJpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCwgcmVmLCBzY2FsZTtcbiAgICAgICAgcmVmID0gdGhpcy5tYXBwZXJfc3RhdGUsIHNjYWxlID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV07XG4gICAgICAgIHJldHVybiAoeHByaW1lIC0gb2Zmc2V0KSAvIHNjYWxlO1xuICAgIH07XG4gICAgTGluZWFyTWFwcGVyLnByb3RvdHlwZS52X21hcF9mcm9tX3RhcmdldCA9IGZ1bmN0aW9uICh4cHJpbWVzKSB7XG4gICAgICAgIHZhciBpLCBpZHgsIGxlbiwgb2Zmc2V0LCByZWYsIHJlc3VsdCwgc2NhbGUsIHhwcmltZTtcbiAgICAgICAgcmVmID0gdGhpcy5tYXBwZXJfc3RhdGUsIHNjYWxlID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV07XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHByaW1lcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGlkeCA9IGkgPSAwLCBsZW4gPSB4cHJpbWVzLmxlbmd0aDsgaSA8IGxlbjsgaWR4ID0gKytpKSB7XG4gICAgICAgICAgICB4cHJpbWUgPSB4cHJpbWVzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbaWR4XSA9ICh4cHJpbWUgLSBvZmZzZXQpIC8gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExpbmVhck1hcHBlci5wcm90b3R5cGUuX21hcHBlcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCwgc2NhbGUsIHNvdXJjZV9lbmQsIHNvdXJjZV9zdGFydCwgdGFyZ2V0X2VuZCwgdGFyZ2V0X3N0YXJ0O1xuICAgICAgICBzb3VyY2Vfc3RhcnQgPSB0aGlzLnNvdXJjZV9yYW5nZS5zdGFydDtcbiAgICAgICAgc291cmNlX2VuZCA9IHRoaXMuc291cmNlX3JhbmdlLmVuZDtcbiAgICAgICAgdGFyZ2V0X3N0YXJ0ID0gdGhpcy50YXJnZXRfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHRhcmdldF9lbmQgPSB0aGlzLnRhcmdldF9yYW5nZS5lbmQ7XG4gICAgICAgIHNjYWxlID0gKHRhcmdldF9lbmQgLSB0YXJnZXRfc3RhcnQpIC8gKHNvdXJjZV9lbmQgLSBzb3VyY2Vfc3RhcnQpO1xuICAgICAgICBvZmZzZXQgPSAtKHNjYWxlICogc291cmNlX3N0YXJ0KSArIHRhcmdldF9zdGFydDtcbiAgICAgICAgcmV0dXJuIFtzY2FsZSwgb2Zmc2V0XTtcbiAgICB9O1xuICAgIExpbmVhck1hcHBlci5pbnRlcm5hbCh7XG4gICAgICAgIHNvdXJjZV9yYW5nZTogW3AuQW55XSxcbiAgICAgICAgdGFyZ2V0X3JhbmdlOiBbcC5BbnldXG4gICAgfSk7XG4gICAgcmV0dXJuIExpbmVhck1hcHBlcjtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nMXAsIHJlZiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGNvbG9yXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2NvbG9yXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGNvbG9yX21hcHBlcl8xID0gcmVxdWlyZShcIi4vY29sb3JfbWFwcGVyXCIpO1xubG9nMXAgPSAocmVmID0gTWF0aC5sb2cxcCkgIT0gbnVsbCA/IHJlZiA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKDEgKyB4KTtcbn07XG5leHBvcnRzLkxvZ0NvbG9yTWFwcGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExvZ0NvbG9yTWFwcGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMb2dDb2xvck1hcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIExvZ0NvbG9yTWFwcGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMb2dDb2xvck1hcHBlci5wcm90b3R5cGUudHlwZSA9IFwiTG9nQ29sb3JNYXBwZXJcIjtcbiAgICBMb2dDb2xvck1hcHBlci5kZWZpbmUoe1xuICAgICAgICBoaWdoOiBbcC5OdW1iZXJdLFxuICAgICAgICBsb3c6IFtwLk51bWJlcl0sXG4gICAgICAgIGhpZ2hfY29sb3I6IFtwLkNvbG9yXSxcbiAgICAgICAgbG93X2NvbG9yOiBbcC5Db2xvcl1cbiAgICB9KTtcbiAgICBMb2dDb2xvck1hcHBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBMb2dDb2xvck1hcHBlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbmFuX2NvbG9yID0gdGhpcy5fYnVpbGRfcGFsZXR0ZShbY29sb3JfMS5jb2xvcjJoZXgodGhpcy5uYW5fY29sb3IpXSlbMF07XG4gICAgICAgIHRoaXMuX2hpZ2hfY29sb3IgPSB0aGlzLmhpZ2hfY29sb3IgIT0gbnVsbCA/IHRoaXMuX2J1aWxkX3BhbGV0dGUoW2NvbG9yXzEuY29sb3IyaGV4KHRoaXMuaGlnaF9jb2xvcildKVswXSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvd19jb2xvciA9IHRoaXMubG93X2NvbG9yICE9IG51bGwgPyB0aGlzLl9idWlsZF9wYWxldHRlKFtjb2xvcl8xLmNvbG9yMmhleCh0aGlzLmxvd19jb2xvcildKVswXSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIExvZ0NvbG9yTWFwcGVyLnByb3RvdHlwZS5fZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uIChkYXRhLCBwYWxldHRlLCBpbWFnZV9nbHlwaCkge1xuICAgICAgICB2YXIgZCwgaGlnaCwgaGlnaF9jb2xvciwgaSwga2V5LCBsZW4sIGxvZywgbG93LCBsb3dfY29sb3IsIG1heF9rZXksIG4sIG5hbl9jb2xvciwgcmVmMSwgcmVmMiwgc2NhbGUsIHZhbHVlcztcbiAgICAgICAgaWYgKGltYWdlX2dseXBoID09IG51bGwpIHtcbiAgICAgICAgICAgIGltYWdlX2dseXBoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHBhbGV0dGUubGVuZ3RoO1xuICAgICAgICBsb3cgPSAocmVmMSA9IHRoaXMubG93KSAhPSBudWxsID8gcmVmMSA6IGFycmF5XzEubWluKGRhdGEpO1xuICAgICAgICBoaWdoID0gKHJlZjIgPSB0aGlzLmhpZ2gpICE9IG51bGwgPyByZWYyIDogYXJyYXlfMS5tYXgoZGF0YSk7XG4gICAgICAgIHNjYWxlID0gbiAvIChsb2cxcChoaWdoKSAtIGxvZzFwKGxvdykpO1xuICAgICAgICBtYXhfa2V5ID0gcGFsZXR0ZS5sZW5ndGggLSAxO1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbmFuX2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9uYW5fY29sb3IgOiB0aGlzLm5hbl9jb2xvcjtcbiAgICAgICAgaGlnaF9jb2xvciA9IGltYWdlX2dseXBoID8gdGhpcy5faGlnaF9jb2xvciA6IHRoaXMuaGlnaF9jb2xvcjtcbiAgICAgICAgbG93X2NvbG9yID0gaW1hZ2VfZ2x5cGggPyB0aGlzLl9sb3dfY29sb3IgOiB0aGlzLmxvd19jb2xvcjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuYW5fY29sb3IpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQgPiBoaWdoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaF9jb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGhpZ2hfY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVttYXhfa2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQgPT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWxldHRlW21heF9rZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkIDwgbG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG93X2NvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobG93X2NvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhbGV0dGVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZyA9IGxvZzFwKGQpIC0gbG9nMXAobG93KTtcbiAgICAgICAgICAgIGtleSA9IE1hdGguZmxvb3IobG9nICogc2NhbGUpO1xuICAgICAgICAgICAgaWYgKGtleSA+IG1heF9rZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBtYXhfa2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFsZXR0ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ0NvbG9yTWFwcGVyO1xufSkoY29sb3JfbWFwcGVyXzEuQ29sb3JNYXBwZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkxvZ01hcHBlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dNYXBwZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExvZ01hcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIExvZ01hcHBlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9nTWFwcGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIExvZ01hcHBlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kZWZpbmVfY29tcHV0ZWRfcHJvcGVydHkoJ21hcHBlcl9zdGF0ZScsIHRoaXMuX21hcHBlcl9zdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkX2RlcGVuZGVuY2llcygnbWFwcGVyX3N0YXRlJywgdGhpcywgWydzb3VyY2VfcmFuZ2UnLCAndGFyZ2V0X3JhbmdlJ10pO1xuICAgICAgICB0aGlzLmFkZF9kZXBlbmRlbmNpZXMoJ21hcHBlcl9zdGF0ZScsIHRoaXMuc291cmNlX3JhbmdlLCBbJ3N0YXJ0JywgJ2VuZCddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2RlcGVuZGVuY2llcygnbWFwcGVyX3N0YXRlJywgdGhpcy50YXJnZXRfcmFuZ2UsIFsnc3RhcnQnLCAnZW5kJ10pO1xuICAgIH07XG4gICAgTG9nTWFwcGVyLmdldHRlcnMoe1xuICAgICAgICBtYXBwZXJfc3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29tcHV0ZWQoJ21hcHBlcl9zdGF0ZScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgTG9nTWFwcGVyLnByb3RvdHlwZS5tYXBfdG9fdGFyZ2V0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGludGVyX29mZnNldCwgaW50ZXJfc2NhbGUsIG9mZnNldCwgcmVmLCBzY2FsZSwgdmFsdWU7XG4gICAgICAgIHJlZiA9IHRoaXMubWFwcGVyX3N0YXRlLCBzY2FsZSA9IHJlZlswXSwgb2Zmc2V0ID0gcmVmWzFdLCBpbnRlcl9zY2FsZSA9IHJlZlsyXSwgaW50ZXJfb2Zmc2V0ID0gcmVmWzNdO1xuICAgICAgICBpZiAoaW50ZXJfc2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gKE1hdGgubG9nKHgpIC0gaW50ZXJfb2Zmc2V0KSAvIGludGVyX3NjYWxlO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIH07XG4gICAgTG9nTWFwcGVyLnByb3RvdHlwZS52X21hcF90b190YXJnZXQgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGksIGludGVyX29mZnNldCwgaW50ZXJfc2NhbGUsIGosIGssIGwsIG9mZnNldCwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZXN1bHQsIHNjYWxlLCB2YWx1ZTtcbiAgICAgICAgcmVmID0gdGhpcy5tYXBwZXJfc3RhdGUsIHNjYWxlID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV0sIGludGVyX3NjYWxlID0gcmVmWzJdLCBpbnRlcl9vZmZzZXQgPSByZWZbM107XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGludGVyX3NjYWxlID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHhzLmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMiA9IHhzLmxlbmd0aDsgMCA8PSByZWYyID8gayA8IHJlZjIgOiBrID4gcmVmMjsgaSA9IDAgPD0gcmVmMiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKE1hdGgubG9nKHhzW2ldKSAtIGludGVyX29mZnNldCkgLyBpbnRlcl9zY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBsID0gMCwgcmVmMyA9IHhzLmxlbmd0aDsgMCA8PSByZWYzID8gbCA8IHJlZjMgOiBsID4gcmVmMzsgaSA9IDAgPD0gcmVmMyA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldICogc2NhbGUgKyBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExvZ01hcHBlci5wcm90b3R5cGUubWFwX2Zyb21fdGFyZ2V0ID0gZnVuY3Rpb24gKHhwcmltZSkge1xuICAgICAgICB2YXIgaW50ZXJfb2Zmc2V0LCBpbnRlcl9zY2FsZSwgb2Zmc2V0LCByZWYsIHNjYWxlLCB2YWx1ZTtcbiAgICAgICAgcmVmID0gdGhpcy5tYXBwZXJfc3RhdGUsIHNjYWxlID0gcmVmWzBdLCBvZmZzZXQgPSByZWZbMV0sIGludGVyX3NjYWxlID0gcmVmWzJdLCBpbnRlcl9vZmZzZXQgPSByZWZbM107XG4gICAgICAgIHZhbHVlID0gKHhwcmltZSAtIG9mZnNldCkgLyBzY2FsZTtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKGludGVyX3NjYWxlICogdmFsdWUgKyBpbnRlcl9vZmZzZXQpO1xuICAgIH07XG4gICAgTG9nTWFwcGVyLnByb3RvdHlwZS52X21hcF9mcm9tX3RhcmdldCA9IGZ1bmN0aW9uICh4cHJpbWVzKSB7XG4gICAgICAgIHZhciBpLCBpbnRlcl9vZmZzZXQsIGludGVyX3NjYWxlLCBqLCBvZmZzZXQsIHJlZiwgcmVmMSwgcmVzdWx0LCBzY2FsZSwgdmFsdWU7XG4gICAgICAgIHJlZiA9IHRoaXMubWFwcGVyX3N0YXRlLCBzY2FsZSA9IHJlZlswXSwgb2Zmc2V0ID0gcmVmWzFdLCBpbnRlcl9zY2FsZSA9IHJlZlsyXSwgaW50ZXJfb2Zmc2V0ID0gcmVmWzNdO1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhwcmltZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZjEgPSB4cHJpbWVzLmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgdmFsdWUgPSAoeHByaW1lc1tpXSAtIG9mZnNldCkgLyBzY2FsZTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IE1hdGguZXhwKGludGVyX3NjYWxlICogdmFsdWUgKyBpbnRlcl9vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMb2dNYXBwZXIucHJvdG90eXBlLl9nZXRfc2FmZV9zY2FsZSA9IGZ1bmN0aW9uIChvcmlnX3N0YXJ0LCBvcmlnX2VuZCkge1xuICAgICAgICB2YXIgZW5kLCBsb2dfdmFsLCByZWYsIHN0YXJ0O1xuICAgICAgICBpZiAob3JpZ19zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb3JpZ19zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ19lbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gb3JpZ19lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlZiA9IFsxLCAxMF0sIHN0YXJ0ID0gcmVmWzBdLCBlbmQgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dfdmFsID0gTWF0aC5sb2coc3RhcnQpIC8gTWF0aC5sb2coMTApO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nX3ZhbCkpO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmNlaWwobG9nX3ZhbCkgIT09IE1hdGguZmxvb3IobG9nX3ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gTWF0aC5wb3coMTAsIE1hdGguY2VpbChsb2dfdmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLnBvdygxMCwgTWF0aC5jZWlsKGxvZ192YWwpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfTtcbiAgICBMb2dNYXBwZXIucHJvdG90eXBlLl9tYXBwZXJfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbmQsIGludGVyX29mZnNldCwgaW50ZXJfc2NhbGUsIG9mZnNldCwgcmVmLCBzY2FsZSwgc2NyZWVuX3JhbmdlLCBzb3VyY2VfZW5kLCBzb3VyY2Vfc3RhcnQsIHN0YXJ0LCB0YXJnZXRfZW5kLCB0YXJnZXRfc3RhcnQ7XG4gICAgICAgIHNvdXJjZV9zdGFydCA9IHRoaXMuc291cmNlX3JhbmdlLnN0YXJ0O1xuICAgICAgICBzb3VyY2VfZW5kID0gdGhpcy5zb3VyY2VfcmFuZ2UuZW5kO1xuICAgICAgICB0YXJnZXRfc3RhcnQgPSB0aGlzLnRhcmdldF9yYW5nZS5zdGFydDtcbiAgICAgICAgdGFyZ2V0X2VuZCA9IHRoaXMudGFyZ2V0X3JhbmdlLmVuZDtcbiAgICAgICAgc2NyZWVuX3JhbmdlID0gdGFyZ2V0X2VuZCAtIHRhcmdldF9zdGFydDtcbiAgICAgICAgcmVmID0gdGhpcy5fZ2V0X3NhZmVfc2NhbGUoc291cmNlX3N0YXJ0LCBzb3VyY2VfZW5kKSwgc3RhcnQgPSByZWZbMF0sIGVuZCA9IHJlZlsxXTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBpbnRlcl9zY2FsZSA9IE1hdGgubG9nKGVuZCk7XG4gICAgICAgICAgICBpbnRlcl9vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJfc2NhbGUgPSBNYXRoLmxvZyhlbmQpIC0gTWF0aC5sb2coc3RhcnQpO1xuICAgICAgICAgICAgaW50ZXJfb2Zmc2V0ID0gTWF0aC5sb2coc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlID0gc2NyZWVuX3JhbmdlO1xuICAgICAgICBvZmZzZXQgPSB0YXJnZXRfc3RhcnQ7XG4gICAgICAgIHJldHVybiBbc2NhbGUsIG9mZnNldCwgaW50ZXJfc2NhbGUsIGludGVyX29mZnNldF07XG4gICAgfTtcbiAgICBMb2dNYXBwZXIuaW50ZXJuYWwoe1xuICAgICAgICBzb3VyY2VfcmFuZ2U6IFtwLkFueV0sXG4gICAgICAgIHRhcmdldF9yYW5nZTogW3AuQW55XVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dNYXBwZXI7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNRMywgX21rX21vZGVsLCBfb25lX2Nyb3NzLCBfb25lX2RpYW1vbmQsIF9vbmVfdHJpLCBfb25lX3gsIGFzdGVyaXNrLCBjaXJjbGVfY3Jvc3MsIGNpcmNsZV94LCBjcm9zcywgZGlhbW9uZCwgZGlhbW9uZF9jcm9zcywgaW52ZXJ0ZWRfdHJpYW5nbGUsIHNxdWFyZSwgc3F1YXJlX2Nyb3NzLCBzcXVhcmVfeCwgdHJpYW5nbGUsIHgsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtYXJrZXJfMSA9IHJlcXVpcmUoXCIuL21hcmtlclwiKTtcblNRMyA9IE1hdGguc3FydCgzKTtcbl9vbmVfeCA9IGZ1bmN0aW9uIChjdHgsIHIpIHtcbiAgICBjdHgubW92ZVRvKC1yLCByKTtcbiAgICBjdHgubGluZVRvKHIsIC1yKTtcbiAgICBjdHgubW92ZVRvKC1yLCAtcik7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8ociwgcik7XG59O1xuX29uZV9jcm9zcyA9IGZ1bmN0aW9uIChjdHgsIHIpIHtcbiAgICBjdHgubW92ZVRvKDAsIHIpO1xuICAgIGN0eC5saW5lVG8oMCwgLXIpO1xuICAgIGN0eC5tb3ZlVG8oLXIsIDApO1xuICAgIHJldHVybiBjdHgubGluZVRvKHIsIDApO1xufTtcbl9vbmVfZGlhbW9uZCA9IGZ1bmN0aW9uIChjdHgsIHIpIHtcbiAgICBjdHgubW92ZVRvKDAsIHIpO1xuICAgIGN0eC5saW5lVG8ociAvIDEuNSwgMCk7XG4gICAgY3R4LmxpbmVUbygwLCAtcik7XG4gICAgY3R4LmxpbmVUbygtciAvIDEuNSwgMCk7XG4gICAgcmV0dXJuIGN0eC5jbG9zZVBhdGgoKTtcbn07XG5fb25lX3RyaSA9IGZ1bmN0aW9uIChjdHgsIHIpIHtcbiAgICB2YXIgYSwgaDtcbiAgICBoID0gciAqIFNRMztcbiAgICBhID0gaCAvIDM7XG4gICAgY3R4Lm1vdmVUbygtciwgYSk7XG4gICAgY3R4LmxpbmVUbyhyLCBhKTtcbiAgICBjdHgubGluZVRvKDAsIGEgLSBoKTtcbiAgICByZXR1cm4gY3R4LmNsb3NlUGF0aCgpO1xufTtcbmFzdGVyaXNrID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgdmFyIHIyO1xuICAgIHIyID0gciAqIDAuNjU7XG4gICAgX29uZV9jcm9zcyhjdHgsIHIpO1xuICAgIF9vbmVfeChjdHgsIHIyKTtcbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbmNpcmNsZV9jcm9zcyA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIGN0eC5hcmMoMCwgMCwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBfb25lX2Nyb3NzKGN0eCwgcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuY2lyY2xlX3ggPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBjdHguYXJjKDAsIDAsIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgX29uZV94KGN0eCwgcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuY3Jvc3MgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICBfb25lX2Nyb3NzKGN0eCwgcik7XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5kaWFtb25kID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgX29uZV9kaWFtb25kKGN0eCwgcik7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5kaWFtb25kX2Nyb3NzID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgX29uZV9kaWFtb25kKGN0eCwgcik7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgX29uZV9jcm9zcyhjdHgsIHIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcbmludmVydGVkX3RyaWFuZ2xlID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcbiAgICBfb25lX3RyaShjdHgsIHIpO1xuICAgIGN0eC5yb3RhdGUoLU1hdGguUEkpO1xuICAgIGlmIChmaWxsLmRvaXQpIHtcbiAgICAgICAgZmlsbC5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmIChsaW5lLmRvaXQpIHtcbiAgICAgICAgbGluZS5zZXRfdmVjdG9yaXplKGN0eCwgaSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuc3F1YXJlID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgdmFyIHNpemU7XG4gICAgc2l6ZSA9IDIgKiByO1xuICAgIGN0eC5yZWN0KC1yLCAtciwgc2l6ZSwgc2l6ZSk7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5zcXVhcmVfY3Jvc3MgPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzaXplID0gMiAqIHI7XG4gICAgY3R4LnJlY3QoLXIsIC1yLCBzaXplLCBzaXplKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBfb25lX2Nyb3NzKGN0eCwgcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuc3F1YXJlX3ggPSBmdW5jdGlvbiAoY3R4LCBpLCBzeCwgc3ksIHIsIGxpbmUsIGZpbGwpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzaXplID0gMiAqIHI7XG4gICAgY3R4LnJlY3QoLXIsIC1yLCBzaXplLCBzaXplKTtcbiAgICBpZiAoZmlsbC5kb2l0KSB7XG4gICAgICAgIGZpbGwuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAobGluZS5kb2l0KSB7XG4gICAgICAgIGxpbmUuc2V0X3ZlY3Rvcml6ZShjdHgsIGkpO1xuICAgICAgICBfb25lX3goY3R4LCByKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG50cmlhbmdsZSA9IGZ1bmN0aW9uIChjdHgsIGksIHN4LCBzeSwgciwgbGluZSwgZmlsbCkge1xuICAgIF9vbmVfdHJpKGN0eCwgcik7XG4gICAgaWYgKGZpbGwuZG9pdCkge1xuICAgICAgICBmaWxsLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG54ID0gZnVuY3Rpb24gKGN0eCwgaSwgc3gsIHN5LCByLCBsaW5lLCBmaWxsKSB7XG4gICAgX29uZV94KGN0eCwgcik7XG4gICAgaWYgKGxpbmUuZG9pdCkge1xuICAgICAgICBsaW5lLnNldF92ZWN0b3JpemUoY3R4LCBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5fbWtfbW9kZWwgPSBmdW5jdGlvbiAodHlwZSwgZikge1xuICAgIHZhciBtb2RlbCwgdmlldztcbiAgICB2aWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgICAgIGV4dGVuZCh2aWV3LCBzdXBlckNsYXNzKTtcbiAgICAgICAgZnVuY3Rpb24gdmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucHJvdG90eXBlLl9yZW5kZXJfb25lID0gZjtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSkobWFya2VyXzEuTWFya2VyVmlldyk7XG4gICAgbW9kZWwgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgZXh0ZW5kKG1vZGVsLCBzdXBlckNsYXNzKTtcbiAgICAgICAgZnVuY3Rpb24gbW9kZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IHZpZXc7XG4gICAgICAgIG1vZGVsLnByb3RvdHlwZS50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0pKG1hcmtlcl8xLk1hcmtlcik7XG4gICAgcmV0dXJuIG1vZGVsO1xufTtcbmV4cG9ydHMuQXN0ZXJpc2sgPSBfbWtfbW9kZWwoJ0FzdGVyaXNrJywgYXN0ZXJpc2spO1xuZXhwb3J0cy5DaXJjbGVDcm9zcyA9IF9ta19tb2RlbCgnQ2lyY2xlQ3Jvc3MnLCBjaXJjbGVfY3Jvc3MpO1xuZXhwb3J0cy5DaXJjbGVYID0gX21rX21vZGVsKCdDaXJjbGVYJywgY2lyY2xlX3gpO1xuZXhwb3J0cy5Dcm9zcyA9IF9ta19tb2RlbCgnQ3Jvc3MnLCBjcm9zcyk7XG5leHBvcnRzLkRpYW1vbmQgPSBfbWtfbW9kZWwoJ0RpYW1vbmQnLCBkaWFtb25kKTtcbmV4cG9ydHMuRGlhbW9uZENyb3NzID0gX21rX21vZGVsKCdEaWFtb25kQ3Jvc3MnLCBkaWFtb25kX2Nyb3NzKTtcbmV4cG9ydHMuSW52ZXJ0ZWRUcmlhbmdsZSA9IF9ta19tb2RlbCgnSW52ZXJ0ZWRUcmlhbmdsZScsIGludmVydGVkX3RyaWFuZ2xlKTtcbmV4cG9ydHMuU3F1YXJlID0gX21rX21vZGVsKCdTcXVhcmUnLCBzcXVhcmUpO1xuZXhwb3J0cy5TcXVhcmVDcm9zcyA9IF9ta19tb2RlbCgnU3F1YXJlQ3Jvc3MnLCBzcXVhcmVfY3Jvc3MpO1xuZXhwb3J0cy5TcXVhcmVYID0gX21rX21vZGVsKCdTcXVhcmVYJywgc3F1YXJlX3gpO1xuZXhwb3J0cy5UcmlhbmdsZSA9IF9ta19tb2RlbCgnVHJpYW5nbGUnLCB0cmlhbmdsZSk7XG5leHBvcnRzLlggPSBfbWtfbW9kZWwoJ1gnLCB4KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB4eV9nbHlwaF8xID0gcmVxdWlyZShcIi4uL2dseXBocy94eV9nbHlwaFwiKTtcbnZhciBoaXR0ZXN0ID0gcmVxdWlyZShcImNvcmUvaGl0dGVzdFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTWFya2VyVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNYXJrZXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXJrZXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gTWFya2VyVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWFya2VyVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmRfZm9yX2luZGV4ID0gZnVuY3Rpb24gKGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KSB7XG4gICAgICAgIHZhciBhbmdsZSwgZGF0YSwgaW5kaWNlcywgc2l6ZSwgc3gsIHN5O1xuICAgICAgICBpbmRpY2VzID0gW2luZGV4XTtcbiAgICAgICAgc3ggPSB7fTtcbiAgICAgICAgc3hbaW5kZXhdID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgc3kgPSB7fTtcbiAgICAgICAgc3lbaW5kZXhdID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgc2l6ZSA9IHt9O1xuICAgICAgICBzaXplW2luZGV4XSA9IE1hdGgubWluKE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSkgKiAwLjQ7XG4gICAgICAgIGFuZ2xlID0ge307XG4gICAgICAgIGFuZ2xlW2luZGV4XSA9IHRoaXMuX2FuZ2xlW2luZGV4XTtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgIHN5OiBzeSxcbiAgICAgICAgICAgIF9zaXplOiBzaXplLFxuICAgICAgICAgICAgX2FuZ2xlOiBhbmdsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyKGN0eCwgaW5kaWNlcywgZGF0YSk7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGN0eCwgaW5kaWNlcywgYXJnKSB7XG4gICAgICAgIHZhciBfYW5nbGUsIF9zaXplLCBpLCBqLCBsZW4sIHIsIHJlc3VsdHMsIHN4LCBzeTtcbiAgICAgICAgc3ggPSBhcmcuc3gsIHN5ID0gYXJnLnN5LCBfc2l6ZSA9IGFyZy5fc2l6ZSwgX2FuZ2xlID0gYXJnLl9hbmdsZTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBpID0gaW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGlmIChpc05hTihzeFtpXSArIHN5W2ldICsgX3NpemVbaV0gKyBfYW5nbGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gX3NpemVbaV0gLyAyO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzeFtpXSwgc3lbaV0pO1xuICAgICAgICAgICAgaWYgKF9hbmdsZVtpXSkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcl9vbmUoY3R4LCBpLCBzeFtpXSwgc3lbaV0sIHIsIHRoaXMudmlzdWFscy5saW5lLCB0aGlzLnZpc3VhbHMuZmlsbCk7XG4gICAgICAgICAgICBpZiAoX2FuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtX2FuZ2xlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdHgudHJhbnNsYXRlKC1zeFtpXSwgLXN5W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5fbWFza19kYXRhID0gZnVuY3Rpb24gKGFsbF9pbmRpY2VzKSB7XG4gICAgICAgIHZhciBiYm94LCBociwgcmVmLCByZWYxLCB2ciwgdngwLCB2eDEsIHZ5MCwgdnkxLCB4MCwgeDEsIHkwLCB5MTtcbiAgICAgICAgaHIgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5mcmFtZS5oX3JhbmdlO1xuICAgICAgICB2eDAgPSBoci5zdGFydCAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHZ4MSA9IGhyLmVuZCArIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHJlZiA9IHRoaXMucmVuZGVyZXIueG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdngwLCB2eDFdLCB0cnVlKSwgeDAgPSByZWZbMF0sIHgxID0gcmVmWzFdO1xuICAgICAgICB2ciA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmZyYW1lLnZfcmFuZ2U7XG4gICAgICAgIHZ5MCA9IHZyLnN0YXJ0IC0gdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgdnkxID0gdnIuZW5kICsgdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgcmVmMSA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdnkwLCB2eTFdLCB0cnVlKSwgeTAgPSByZWYxWzBdLCB5MSA9IHJlZjFbMV07XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5faGl0X3BvaW50ID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBiYm94LCBjYW5kaWRhdGVzLCBkaXN0LCBoaXRzLCBpLCBqLCBsZW4sIHJlZiwgcmVmMSwgcmVmMiwgczIsIHN4LCBzeSwgdngsIHZ4MCwgdngxLCB2eSwgdnkwLCB2eTEsIHgwLCB4MSwgeTAsIHkxO1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52eF90b19zeCh2eCk7XG4gICAgICAgIHN5ID0gdGhpcy5yZW5kZXJlci5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHZ5KTtcbiAgICAgICAgdngwID0gdnggLSB0aGlzLm1heF9zaXplO1xuICAgICAgICB2eDEgPSB2eCArIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHJlZjEgPSB0aGlzLnJlbmRlcmVyLnhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3Z4MCwgdngxXSwgdHJ1ZSksIHgwID0gcmVmMVswXSwgeDEgPSByZWYxWzFdO1xuICAgICAgICB2eTAgPSB2eSAtIHRoaXMubWF4X3NpemU7XG4gICAgICAgIHZ5MSA9IHZ5ICsgdGhpcy5tYXhfc2l6ZTtcbiAgICAgICAgcmVmMiA9IHRoaXMucmVuZGVyZXIueW1hcHBlci52X21hcF9mcm9tX3RhcmdldChbdnkwLCB2eTFdLCB0cnVlKSwgeTAgPSByZWYyWzBdLCB5MSA9IHJlZjJbMV07XG4gICAgICAgIGJib3ggPSBoaXR0ZXN0LnZhbGlkYXRlX2Jib3hfY29vcmRzKFt4MCwgeDFdLCBbeTAsIHkxXSk7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIGhpdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaSA9IGNhbmRpZGF0ZXNbal07XG4gICAgICAgICAgICBzMiA9IHRoaXMuX3NpemVbaV0gLyAyO1xuICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKHRoaXMuc3hbaV0gLSBzeCkgKyBNYXRoLmFicyh0aGlzLnN5W2ldIC0gc3kpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc3hbaV0gLSBzeCkgPD0gczIgJiYgTWF0aC5hYnModGhpcy5zeVtpXSAtIHN5KSA8PSBzMikge1xuICAgICAgICAgICAgICAgIGhpdHMucHVzaChbaSwgZGlzdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXR0ZXN0LmNyZWF0ZV8xZF9oaXRfdGVzdF9yZXN1bHQoaGl0cyk7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5faGl0X3JlY3QgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGJib3gsIHJlZiwgcmVmMSwgcmVzdWx0LCB4MCwgeDEsIHkwLCB5MTtcbiAgICAgICAgcmVmID0gdGhpcy5yZW5kZXJlci54bWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFtnZW9tZXRyeS52eDAsIGdlb21ldHJ5LnZ4MV0sIHRydWUpLCB4MCA9IHJlZlswXSwgeDEgPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLnJlbmRlcmVyLnltYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW2dlb21ldHJ5LnZ5MCwgZ2VvbWV0cnkudnkxXSwgdHJ1ZSksIHkwID0gcmVmMVswXSwgeTEgPSByZWYxWzFdO1xuICAgICAgICBiYm94ID0gaGl0dGVzdC52YWxpZGF0ZV9iYm94X2Nvb3JkcyhbeDAsIHgxXSwgW3kwLCB5MV0pO1xuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSB0aGlzLmluZGV4LmluZGljZXMoYmJveCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXJrZXJWaWV3LnByb3RvdHlwZS5faGl0X3BvbHkgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMsIGhpdHMsIGksIGlkeCwgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZXN1bHQsIHJlc3VsdHMsIHN4LCBzeSwgdngsIHZ5O1xuICAgICAgICByZWYgPSBbZ2VvbWV0cnkudngsIGdlb21ldHJ5LnZ5XSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICBzeCA9IHRoaXMucmVuZGVyZXIucGxvdF92aWV3LmNhbnZhcy52X3Z4X3RvX3N4KHZ4KTtcbiAgICAgICAgc3kgPSB0aGlzLnJlbmRlcmVyLnBsb3Rfdmlldy5jYW52YXMudl92eV90b19zeSh2eSk7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIHJlZjEgPSB0aGlzLnN4Lmxlbmd0aDsgMCA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgMCA8PSByZWYxID8gaisrIDogai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmFwcGx5KHRoaXMpO1xuICAgICAgICBoaXRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYyID0gY2FuZGlkYXRlcy5sZW5ndGg7IDAgPD0gcmVmMiA/IGsgPCByZWYyIDogayA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIGlkeCA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAoaGl0dGVzdC5wb2ludF9pbl9wb2x5KHRoaXMuc3hbaV0sIHRoaXMuc3lbaV0sIHN4LCBzeSkpIHtcbiAgICAgICAgICAgICAgICBoaXRzLnB1c2goaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBoaXR0ZXN0LmNyZWF0ZV9oaXRfdGVzdF9yZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0WycxZCddLmluZGljZXMgPSBoaXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtlclZpZXc7XG59KSh4eV9nbHlwaF8xLlhZR2x5cGhWaWV3KTtcbmV4cG9ydHMuTWFya2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1hcmtlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWFya2VyKCkge1xuICAgICAgICByZXR1cm4gTWFya2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNYXJrZXIubWl4aW5zKFsnbGluZScsICdmaWxsJ10pO1xuICAgIE1hcmtlci5kZWZpbmUoe1xuICAgICAgICBzaXplOiBbXG4gICAgICAgICAgICBwLkRpc3RhbmNlU3BlYywge1xuICAgICAgICAgICAgICAgIHVuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiA0XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFuZ2xlOiBbcC5BbmdsZVNwZWMsIDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIE1hcmtlcjtcbn0pKHh5X2dseXBoXzEuWFlHbHlwaCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBnbWFwX3Bsb3RfY2FudmFzXzEgPSByZXF1aXJlKFwiLi9nbWFwX3Bsb3RfY2FudmFzXCIpO1xudmFyIHBsb3RfMSA9IHJlcXVpcmUoXCIuL3Bsb3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuTWFwT3B0aW9ucyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNYXBPcHRpb25zLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXBPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gTWFwT3B0aW9ucy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWFwT3B0aW9ucy5wcm90b3R5cGUudHlwZSA9ICdNYXBPcHRpb25zJztcbiAgICBNYXBPcHRpb25zLmRlZmluZSh7XG4gICAgICAgIGxhdDogW3AuTnVtYmVyXSxcbiAgICAgICAgbG5nOiBbcC5OdW1iZXJdLFxuICAgICAgICB6b29tOiBbcC5OdW1iZXIsIDEyXVxuICAgIH0pO1xuICAgIHJldHVybiBNYXBPcHRpb25zO1xufSkobW9kZWxfMS5Nb2RlbCk7XG5leHBvcnRzLkdNYXBPcHRpb25zID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdNYXBPcHRpb25zLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHTWFwT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBPcHRpb25zLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHTWFwT3B0aW9ucy5wcm90b3R5cGUudHlwZSA9ICdHTWFwT3B0aW9ucyc7XG4gICAgR01hcE9wdGlvbnMuZGVmaW5lKHtcbiAgICAgICAgbWFwX3R5cGU6IFtwLlN0cmluZywgXCJyb2FkbWFwXCJdLFxuICAgICAgICBzY2FsZV9jb250cm9sOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIHN0eWxlczogW3AuU3RyaW5nXVxuICAgIH0pO1xuICAgIHJldHVybiBHTWFwT3B0aW9ucztcbn0pKGV4cG9ydHMuTWFwT3B0aW9ucyk7XG5leHBvcnRzLkdNYXBQbG90VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHTWFwUGxvdFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdNYXBQbG90VmlldygpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBQbG90Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEdNYXBQbG90Vmlldztcbn0pKHBsb3RfMS5QbG90Vmlldyk7XG5leHBvcnRzLkdNYXBQbG90ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdNYXBQbG90LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHTWFwUGxvdCgpIHtcbiAgICAgICAgcmV0dXJuIEdNYXBQbG90Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHTWFwUGxvdC5wcm90b3R5cGUudHlwZSA9ICdHTWFwUGxvdCc7XG4gICAgR01hcFBsb3QucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuR01hcFBsb3RWaWV3O1xuICAgIEdNYXBQbG90LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgR01hcFBsb3QuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLmFwaV9rZXkpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZXJyb3IoXCJhcGlfa2V5IGlzIHJlcXVpcmVkLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvZ2V0LWFwaS1rZXkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIG9idGFpbiB5b3VyIG93bi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxvdF9jYW52YXMgPSBuZXcgZ21hcF9wbG90X2NhbnZhc18xLkdNYXBQbG90Q2FudmFzKHtcbiAgICAgICAgICAgIHBsb3Q6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3RfY2FudmFzLnRvb2xiYXIgPSB0aGlzLnRvb2xiYXI7XG4gICAgfTtcbiAgICBHTWFwUGxvdC5kZWZpbmUoe1xuICAgICAgICBtYXBfb3B0aW9uczogW3AuSW5zdGFuY2VdLFxuICAgICAgICBhcGlfa2V5OiBbcC5TdHJpbmddXG4gICAgfSk7XG4gICAgcmV0dXJuIEdNYXBQbG90O1xufSkocGxvdF8xLlBsb3QpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9hZF9nb29nbGVfYXBpLCBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9qNF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9wcm9qNFwiKTtcbnZhciBwbG90X2NhbnZhc18xID0gcmVxdWlyZShcIi4vcGxvdF9jYW52YXNcIik7XG5sb2FkX2dvb2dsZV9hcGkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFwaV9rZXkpIHtcbiAgICB2YXIgcmVmLCBzY3JpcHQ7XG4gICAgaWYgKCgocmVmID0gd2luZG93Lmdvb2dsZSkgIT0gbnVsbCA/IHJlZi5tYXBzIDogdm9pZCAwKSA9PSBudWxsKSB7XG4gICAgICAgIHdpbmRvdy5fYm9rZWhfZ21hcF9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LnNyYyA9IFwiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT1cIiArIGFwaV9rZXkgKyBcIiZjYWxsYmFjaz1fYm9rZWhfZ21hcF9jYWxsYmFja1wiO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH1cbn07XG5leHBvcnRzLkdNYXBQbG90Q2FudmFzVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChHTWFwUGxvdENhbnZhc1ZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdNYXBQbG90Q2FudmFzVmlldygpIHtcbiAgICAgICAgdGhpcy5fc2V0X2Jva2VoX3JhbmdlcyA9IGJpbmQodGhpcy5fc2V0X2Jva2VoX3JhbmdlcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2dldF9wcm9qZWN0ZWRfYm91bmRzID0gYmluZCh0aGlzLl9nZXRfcHJvamVjdGVkX2JvdW5kcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2dldF9sYXRsb25fYm91bmRzID0gYmluZCh0aGlzLl9nZXRfbGF0bG9uX2JvdW5kcywgdGhpcyk7XG4gICAgICAgIHJldHVybiBHTWFwUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBtbztcbiAgICAgICAgR01hcFBsb3RDYW52YXNWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuem9vbV9jb3VudCA9IDA7XG4gICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICB0aGlzLmluaXRpYWxfem9vbSA9IG1vLnpvb207XG4gICAgICAgIHRoaXMuaW5pdGlhbF9sYXQgPSBtby5sYXQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbF9sbmcgPSBtby5sbmc7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcubWFwX2Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgcmV0dXJuIGxvYWRfZ29vZ2xlX2FwaSh0aGlzLnJlcXVlc3RfcmVuZGVyLCB0aGlzLm1vZGVsLnBsb3QuYXBpX2tleSk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVwZGF0ZV9yYW5nZSA9IGZ1bmN0aW9uIChyYW5nZV9pbmZvKSB7XG4gICAgICAgIHZhciBtbywgbmV3X21hcF96b29tLCBvbGRfbWFwX3pvb20sIHByb2pfeGVuZCwgcHJval94c3RhcnQsIHByb2pfeWVuZCwgcHJval95c3RhcnQsIHJlZiwgem9vbV9jaGFuZ2U7XG4gICAgICAgIGlmIChyYW5nZV9pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0Q2VudGVyKHtcbiAgICAgICAgICAgICAgICBsYXQ6IHRoaXMuaW5pdGlhbF9sYXQsXG4gICAgICAgICAgICAgICAgbG5nOiB0aGlzLmluaXRpYWxfbG5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHpvb206IHRoaXMuaW5pdGlhbF96b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEdNYXBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18udXBkYXRlX3JhbmdlLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlX2luZm8uc2R4ICE9IG51bGwpIHx8IChyYW5nZV9pbmZvLnNkeSAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAucGFuQnkocmFuZ2VfaW5mby5zZHgsIHJhbmdlX2luZm8uc2R5KTtcbiAgICAgICAgICAgIEdNYXBQbG90Q2FudmFzVmlldy5fX3N1cGVyX18udXBkYXRlX3JhbmdlLmNhbGwodGhpcywgcmFuZ2VfaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmFuZ2VfaW5mby5mYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbV9jb3VudCAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21fY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnpvb21fY291bnQgPSAwO1xuICAgICAgICAgICAgR01hcFBsb3RDYW52YXNWaWV3Ll9fc3VwZXJfXy51cGRhdGVfcmFuZ2UuY2FsbCh0aGlzLCByYW5nZV9pbmZvKTtcbiAgICAgICAgICAgIGlmIChyYW5nZV9pbmZvLmZhY3RvciA8IDApIHtcbiAgICAgICAgICAgICAgICB6b29tX2NoYW5nZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgem9vbV9jaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkX21hcF96b29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgbmV3X21hcF96b29tID0gb2xkX21hcF96b29tICsgem9vbV9jaGFuZ2U7XG4gICAgICAgICAgICBpZiAobmV3X21hcF96b29tID49IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXRab29tKG5ld19tYXBfem9vbSk7XG4gICAgICAgICAgICAgICAgcmVmID0gdGhpcy5fZ2V0X3Byb2plY3RlZF9ib3VuZHMoKSwgcHJval94c3RhcnQgPSByZWZbMF0sIHByb2pfeGVuZCA9IHJlZlsxXSwgcHJval95c3RhcnQgPSByZWZbMl0sIHByb2pfeWVuZCA9IHJlZlszXTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2pfeGVuZCAtIHByb2pfeHN0YXJ0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbShvbGRfbWFwX3pvb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRfYm9rZWhfcmFuZ2VzKCk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9idWlsZF9tYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXBfb3B0aW9ucywgbWFwcywgbW87XG4gICAgICAgIG1hcHMgPSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICAgIHRoaXMubWFwX3R5cGVzID0ge1xuICAgICAgICAgICAgc2F0ZWxsaXRlOiBtYXBzLk1hcFR5cGVJZC5TQVRFTExJVEUsXG4gICAgICAgICAgICB0ZXJyYWluOiBtYXBzLk1hcFR5cGVJZC5URVJSQUlOLFxuICAgICAgICAgICAgcm9hZG1hcDogbWFwcy5NYXBUeXBlSWQuUk9BRE1BUCxcbiAgICAgICAgICAgIGh5YnJpZDogbWFwcy5NYXBUeXBlSWQuSFlCUklEXG4gICAgICAgIH07XG4gICAgICAgIG1vID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zO1xuICAgICAgICBtYXBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IG1hcHMuTGF0TG5nKG1vLmxhdCwgbW8ubG5nKSxcbiAgICAgICAgICAgIHpvb206IG1vLnpvb20sXG4gICAgICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiB0cnVlLFxuICAgICAgICAgICAgbWFwVHlwZUlkOiB0aGlzLm1hcF90eXBlc1ttby5tYXBfdHlwZV0sXG4gICAgICAgICAgICBzY2FsZUNvbnRyb2w6IG1vLnNjYWxlX2NvbnRyb2xcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1vLnN0eWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBfb3B0aW9ucy5zdHlsZXMgPSBKU09OLnBhcnNlKG1vLnN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgbWFwcy5NYXAodGhpcy5jYW52YXNfdmlldy5tYXBfZGl2LCBtYXBfb3B0aW9ucyk7XG4gICAgICAgIG1hcHMuZXZlbnQuYWRkTGlzdGVuZXJPbmNlKHRoaXMubWFwLCAnaWRsZScsIHRoaXMuX3NldF9ib2tlaF9yYW5nZXMpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdCwgJ2NoYW5nZTptYXBfb3B0aW9ucycsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfb3B0aW9ucygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucywgJ2NoYW5nZTpzdHlsZXMnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX3N0eWxlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucywgJ2NoYW5nZTpsYXQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX2NlbnRlcignbGF0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLCAnY2hhbmdlOmxuZycsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfY2VudGVyKCdsbmcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMsICdjaGFuZ2U6em9vbScsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfem9vbSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucywgJ2NoYW5nZTptYXBfdHlwZScsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVfbWFwX3R5cGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLCAnY2hhbmdlOnNjYWxlX2NvbnRyb2wnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlX3NjYWxlX2NvbnRyb2woKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX2dldF9sYXRsb25fYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm90dG9tX2xlZnQsIGJvdW5kcywgdG9wX3JpZ2h0LCB4ZW5kLCB4c3RhcnQsIHllbmQsIHlzdGFydDtcbiAgICAgICAgYm91bmRzID0gdGhpcy5tYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHRvcF9yaWdodCA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKTtcbiAgICAgICAgYm90dG9tX2xlZnQgPSBib3VuZHMuZ2V0U291dGhXZXN0KCk7XG4gICAgICAgIHhzdGFydCA9IGJvdHRvbV9sZWZ0LmxuZygpO1xuICAgICAgICB4ZW5kID0gdG9wX3JpZ2h0LmxuZygpO1xuICAgICAgICB5c3RhcnQgPSBib3R0b21fbGVmdC5sYXQoKTtcbiAgICAgICAgeWVuZCA9IHRvcF9yaWdodC5sYXQoKTtcbiAgICAgICAgcmV0dXJuIFt4c3RhcnQsIHhlbmQsIHlzdGFydCwgeWVuZF07XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9nZXRfcHJvamVjdGVkX2JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb2pfeGVuZCwgcHJval94c3RhcnQsIHByb2pfeWVuZCwgcHJval95c3RhcnQsIHJlZiwgcmVmMSwgcmVmMiwgeGVuZCwgeHN0YXJ0LCB5ZW5kLCB5c3RhcnQ7XG4gICAgICAgIHJlZiA9IHRoaXMuX2dldF9sYXRsb25fYm91bmRzKCksIHhzdGFydCA9IHJlZlswXSwgeGVuZCA9IHJlZlsxXSwgeXN0YXJ0ID0gcmVmWzJdLCB5ZW5kID0gcmVmWzNdO1xuICAgICAgICByZWYxID0gcHJvajRfMS5wcm9qNChwcm9qNF8xLm1lcmNhdG9yLCBbeHN0YXJ0LCB5c3RhcnRdKSwgcHJval94c3RhcnQgPSByZWYxWzBdLCBwcm9qX3lzdGFydCA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IsIFt4ZW5kLCB5ZW5kXSksIHByb2pfeGVuZCA9IHJlZjJbMF0sIHByb2pfeWVuZCA9IHJlZjJbMV07XG4gICAgICAgIHJldHVybiBbcHJval94c3RhcnQsIHByb2pfeGVuZCwgcHJval95c3RhcnQsIHByb2pfeWVuZF07XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9zZXRfYm9rZWhfcmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJval94ZW5kLCBwcm9qX3hzdGFydCwgcHJval95ZW5kLCBwcm9qX3lzdGFydCwgcmVmO1xuICAgICAgICByZWYgPSB0aGlzLl9nZXRfcHJvamVjdGVkX2JvdW5kcygpLCBwcm9qX3hzdGFydCA9IHJlZlswXSwgcHJval94ZW5kID0gcmVmWzFdLCBwcm9qX3lzdGFydCA9IHJlZlsyXSwgcHJval95ZW5kID0gcmVmWzNdO1xuICAgICAgICB0aGlzLnhfcmFuZ2Uuc2V0dih7XG4gICAgICAgICAgICBzdGFydDogcHJval94c3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2pfeGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueV9yYW5nZS5zZXR2KHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9qX3lzdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJval95ZW5kXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX2NlbnRlciA9IGZ1bmN0aW9uIChmbGQpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIGMgPSB0aGlzLm1hcC5nZXRDZW50ZXIoKS50b0pTT04oKTtcbiAgICAgICAgY1tmbGRdID0gdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zW2ZsZF07XG4gICAgICAgIHRoaXMubWFwLnNldENlbnRlcihjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldF9ib2tlaF9yYW5nZXMoKTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9tYXBfdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcHM7XG4gICAgICAgIG1hcHMgPSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG1hcFR5cGVJZDogdGhpcy5tYXBfdHlwZXNbdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLm1hcF90eXBlXVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9zY2FsZV9jb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwcztcbiAgICAgICAgbWFwcyA9IHdpbmRvdy5nb29nbGUubWFwcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc2NhbGVDb250cm9sOiB0aGlzLm1vZGVsLnBsb3QubWFwX29wdGlvbnMuc2NhbGVfY29udHJvbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3VwZGF0ZV9vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVfc3R5bGVzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZV9jZW50ZXIoJ2xhdCcpO1xuICAgICAgICB0aGlzLl91cGRhdGVfY2VudGVyKCdsbmcnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlX3pvb20oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9tYXBfdHlwZSgpO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX3N0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgc3R5bGVzOiBKU09OLnBhcnNlKHRoaXMubW9kZWwucGxvdC5tYXBfb3B0aW9ucy5zdHlsZXMpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR01hcFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlX3pvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgem9vbTogdGhpcy5tb2RlbC5wbG90Lm1hcF9vcHRpb25zLnpvb21cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRfYm9rZWhfcmFuZ2VzKCk7XG4gICAgfTtcbiAgICBHTWFwUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9tYXBfaG9vayA9IGZ1bmN0aW9uIChjdHgsIGZyYW1lX2JveCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCBsZWZ0LCB0b3AsIHdpZHRoO1xuICAgICAgICBsZWZ0ID0gZnJhbWVfYm94WzBdLCB0b3AgPSBmcmFtZV9ib3hbMV0sIHdpZHRoID0gZnJhbWVfYm94WzJdLCBoZWlnaHQgPSBmcmFtZV9ib3hbM107XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcubWFwX2Rpdi5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcubWFwX2Rpdi5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5tYXBfZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcubWFwX2Rpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLm1hcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRfbWFwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdNYXBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuX3BhaW50X2VtcHR5ID0gZnVuY3Rpb24gKGN0eCwgZnJhbWVfYm94KSB7XG4gICAgICAgIHZhciBpaCwgaXcsIGxlZnQsIG9oLCBvdywgdG9wO1xuICAgICAgICBvdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICBvaCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgbGVmdCA9IGZyYW1lX2JveFswXSwgdG9wID0gZnJhbWVfYm94WzFdLCBpdyA9IGZyYW1lX2JveFsyXSwgaWggPSBmcmFtZV9ib3hbM107XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb3csIG9oKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIG9oKTtcbiAgICAgICAgY3R4LmxpbmVUbyhvdywgb2gpO1xuICAgICAgICBjdHgubGluZVRvKG93LCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyBpdywgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgaXcsIHRvcCArIGloKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3AgKyBpaCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgdG9wKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5tb2RlbC5wbG90LmJvcmRlcl9maWxsX2NvbG9yO1xuICAgICAgICByZXR1cm4gY3R4LmZpbGwoKTtcbiAgICB9O1xuICAgIHJldHVybiBHTWFwUGxvdENhbnZhc1ZpZXc7XG59KShwbG90X2NhbnZhc18xLlBsb3RDYW52YXNWaWV3KTtcbmV4cG9ydHMuR01hcFBsb3RDYW52YXMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoR01hcFBsb3RDYW52YXMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdNYXBQbG90Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gR01hcFBsb3RDYW52YXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdNYXBQbG90Q2FudmFzLnByb3RvdHlwZS50eXBlID0gJ0dNYXBQbG90Q2FudmFzJztcbiAgICBHTWFwUGxvdENhbnZhcy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5HTWFwUGxvdENhbnZhc1ZpZXc7XG4gICAgR01hcFBsb3RDYW52YXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51c2VfbWFwID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIEdNYXBQbG90Q2FudmFzLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEdNYXBQbG90Q2FudmFzO1xufSkocGxvdF9jYW52YXNfMS5QbG90Q2FudmFzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdtYXBfcGxvdF8xID0gcmVxdWlyZShcIi4vZ21hcF9wbG90XCIpO1xuZXhwb3J0cy5NYXBPcHRpb25zID0gZ21hcF9wbG90XzEuTWFwT3B0aW9ucztcbnZhciBnbWFwX3Bsb3RfMiA9IHJlcXVpcmUoXCIuL2dtYXBfcGxvdFwiKTtcbmV4cG9ydHMuR01hcE9wdGlvbnMgPSBnbWFwX3Bsb3RfMi5HTWFwT3B0aW9ucztcbnZhciBnbWFwX3Bsb3RfMyA9IHJlcXVpcmUoXCIuL2dtYXBfcGxvdFwiKTtcbmV4cG9ydHMuR01hcFBsb3QgPSBnbWFwX3Bsb3RfMy5HTWFwUGxvdDtcbnZhciBnbWFwX3Bsb3RfY2FudmFzXzEgPSByZXF1aXJlKFwiLi9nbWFwX3Bsb3RfY2FudmFzXCIpO1xuZXhwb3J0cy5HTWFwUGxvdENhbnZhcyA9IGdtYXBfcGxvdF9jYW52YXNfMS5HTWFwUGxvdENhbnZhcztcbnZhciBwbG90XzEgPSByZXF1aXJlKFwiLi9wbG90XCIpO1xuZXhwb3J0cy5QbG90ID0gcGxvdF8xLlBsb3Q7XG52YXIgcGxvdF9jYW52YXNfMSA9IHJlcXVpcmUoXCIuL3Bsb3RfY2FudmFzXCIpO1xuZXhwb3J0cy5QbG90Q2FudmFzID0gcGxvdF9jYW52YXNfMS5QbG90Q2FudmFzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBzb2x2ZXJfMSA9IHJlcXVpcmUoXCJjb3JlL2xheW91dC9zb2x2ZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG52YXIgdGl0bGVfMSA9IHJlcXVpcmUoXCIuLi9hbm5vdGF0aW9ucy90aXRsZVwiKTtcbnZhciB0b29sYmFyXzEgPSByZXF1aXJlKFwiLi4vdG9vbHMvdG9vbGJhclwiKTtcbnZhciB0b29sX2V2ZW50c18xID0gcmVxdWlyZShcIi4uL3Rvb2xzL3Rvb2xfZXZlbnRzXCIpO1xudmFyIHBsb3RfY2FudmFzXzEgPSByZXF1aXJlKFwiLi9wbG90X2NhbnZhc1wiKTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9zb3VyY2VzL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbnZhciBnbHlwaF9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmVycy9nbHlwaF9yZW5kZXJlclwiKTtcbnZhciBib2tlaF9ldmVudHNfMSA9IHJlcXVpcmUoXCJjb3JlL2Jva2VoX2V2ZW50c1wiKTtcbmV4cG9ydHMuUGxvdFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFBsb3RWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQbG90VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBsb3RWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQbG90Vmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1wbG90LWxheW91dFwiO1xuICAgIFBsb3RWaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpdGxlX21zZztcbiAgICAgICAgUGxvdFZpZXcuX19zdXBlcl9fLmJpbmRfYm9rZWhfZXZlbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRpdGxlX21zZyA9IFwiVGl0bGUgb2JqZWN0IGNhbm5vdCBiZSByZXBsYWNlZC4gVHJ5IGNoYW5naW5nIHByb3BlcnRpZXMgb24gdGl0bGUgdG8gdXBkYXRlIGl0IGFmdGVyIGluaXRpYWxpemF0aW9uLlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnRpdGxlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKHRpdGxlX21zZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBQbG90Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCByZWYsIHMsIHdpZHRoO1xuICAgICAgICBQbG90Vmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNpemluZ19tb2RlID09PSAnc2NhbGVfYm90aCcpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZ2V0X3dpZHRoX2hlaWdodCgpLCB3aWR0aCA9IHJlZlswXSwgaGVpZ2h0ID0gcmVmWzFdO1xuICAgICAgICAgICAgcyA9IHRoaXMubW9kZWwuZG9jdW1lbnQuc29sdmVyKCk7XG4gICAgICAgICAgICBzLnN1Z2dlc3RfdmFsdWUodGhpcy5tb2RlbC5fd2lkdGgsIHdpZHRoKTtcbiAgICAgICAgICAgIHMuc3VnZ2VzdF92YWx1ZSh0aGlzLm1vZGVsLl9oZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHRoaXMubW9kZWwuX2RvbV9sZWZ0Ll92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5tb2RlbC5fZG9tX3RvcC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gKHRoaXMubW9kZWwuX3dpZHRoLnZhbHVlKCkpICsgXCJweFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gKHRoaXMubW9kZWwuX2hlaWdodC52YWx1ZSgpKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdFZpZXcucHJvdG90eXBlLmdldF93aWR0aF9oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhciwgaGVpZ2h0LCBuZXdfaGVpZ2h0XzEsIG5ld19oZWlnaHRfMiwgbmV3X3dpZHRoXzEsIG5ld193aWR0aF8yLCBwYXJlbnRfaGVpZ2h0LCBwYXJlbnRfd2lkdGgsIHdpZHRoO1xuICAgICAgICBwYXJlbnRfaGVpZ2h0ID0gdGhpcy5lbC5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgcGFyZW50X3dpZHRoID0gdGhpcy5lbC5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICBhciA9IHRoaXMubW9kZWwuZ2V0X2FzcGVjdF9yYXRpbygpO1xuICAgICAgICBuZXdfd2lkdGhfMSA9IHBhcmVudF93aWR0aDtcbiAgICAgICAgbmV3X2hlaWdodF8xID0gcGFyZW50X3dpZHRoIC8gYXI7XG4gICAgICAgIG5ld193aWR0aF8yID0gcGFyZW50X2hlaWdodCAqIGFyO1xuICAgICAgICBuZXdfaGVpZ2h0XzIgPSBwYXJlbnRfaGVpZ2h0O1xuICAgICAgICBpZiAobmV3X3dpZHRoXzEgPCBuZXdfd2lkdGhfMikge1xuICAgICAgICAgICAgd2lkdGggPSBuZXdfd2lkdGhfMTtcbiAgICAgICAgICAgIGhlaWdodCA9IG5ld19oZWlnaHRfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gbmV3X3dpZHRoXzI7XG4gICAgICAgICAgICBoZWlnaHQgPSBuZXdfaGVpZ2h0XzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB9O1xuICAgIFBsb3RWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlIC8gdGhpcy5tb2RlbC5nZXRfYXNwZWN0X3JhdGlvKCk7XG4gICAgfTtcbiAgICBQbG90Vmlldy5wcm90b3R5cGUuZ2V0X3dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5faGVpZ2h0Ll92YWx1ZSAqIHRoaXMubW9kZWwuZ2V0X2FzcGVjdF9yYXRpbygpO1xuICAgIH07XG4gICAgUGxvdFZpZXcucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmlldztcbiAgICAgICAgcmV0dXJuICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVmID0gb2JqZWN0XzEudmFsdWVzKHRoaXMuY2hpbGRfdmlld3MpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIHBsb3RfY2FudmFzXzEuUGxvdENhbnZhc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKVswXS5zYXZlKG5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBsb3RWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5QbG90ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQbG90KCkge1xuICAgICAgICByZXR1cm4gUGxvdC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGxvdC5wcm90b3R5cGUudHlwZSA9ICdQbG90JztcbiAgICBQbG90LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlBsb3RWaWV3O1xuICAgIFBsb3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgaSwgaiwgbGVuLCBsZW4xLCBwbG90cywgcmVmLCByZWYxLCByZWYyLCB0aXRsZSwgeHIsIHlyO1xuICAgICAgICBQbG90Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJlZiA9IG9iamVjdF8xLnZhbHVlcyh0aGlzLmV4dHJhX3hfcmFuZ2VzKS5jb25jYXQodGhpcy54X3JhbmdlKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB4ciA9IHJlZltpXTtcbiAgICAgICAgICAgIHBsb3RzID0geHIucGxvdHM7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc0FycmF5KHBsb3RzKSkge1xuICAgICAgICAgICAgICAgIHBsb3RzID0gcGxvdHMuY29uY2F0KHRoaXMpO1xuICAgICAgICAgICAgICAgIHhyLnNldHYoJ3Bsb3RzJywgcGxvdHMsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmMSA9IG9iamVjdF8xLnZhbHVlcyh0aGlzLmV4dHJhX3lfcmFuZ2VzKS5jb25jYXQodGhpcy55X3JhbmdlKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICB5ciA9IHJlZjFbal07XG4gICAgICAgICAgICBwbG90cyA9IHlyLnBsb3RzO1xuICAgICAgICAgICAgaWYgKHR5cGVzXzEuaXNBcnJheShwbG90cykpIHtcbiAgICAgICAgICAgICAgICBwbG90cyA9IHBsb3RzLmNvbmNhdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB5ci5zZXR2KCdwbG90cycsIHBsb3RzLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKChyZWYyID0gdGhpcy50b29sYmFyX2xvY2F0aW9uKSA9PT0gJ2xlZnQnIHx8IHJlZjIgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbl9ib3JkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWluX2JvcmRlcl90b3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluX2JvcmRlcl90b3AgPSB0aGlzLm1pbl9ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5fYm9yZGVyX2JvdHRvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5fYm9yZGVyX2JvdHRvbSA9IHRoaXMubWluX2JvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbl9ib3JkZXJfbGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5fYm9yZGVyX2xlZnQgPSB0aGlzLm1pbl9ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5fYm9yZGVyX3JpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbl9ib3JkZXJfcmlnaHQgPSB0aGlzLm1pbl9ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0eXBlc18xLmlzU3RyaW5nKHRoaXMudGl0bGUpID8gbmV3IHRpdGxlXzEuVGl0bGUoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMudGl0bGVcbiAgICAgICAgICAgIH0pIDogdGhpcy50aXRsZTtcbiAgICAgICAgICAgIHRoaXMuYWRkX2xheW91dCh0aXRsZSwgdGhpcy50aXRsZV9sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxvdF9jYW52YXMgPSBuZXcgcGxvdF9jYW52YXNfMS5QbG90Q2FudmFzKHtcbiAgICAgICAgICAgIHBsb3Q6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbGJhci50b29sYmFyX2xvY2F0aW9uID0gdGhpcy50b29sYmFyX2xvY2F0aW9uO1xuICAgICAgICB0aGlzLnRvb2xiYXIudG9vbGJhcl9zdGlja3kgPSB0aGlzLnRvb2xiYXJfc3RpY2t5O1xuICAgICAgICB0aGlzLnBsb3RfY2FudmFzLnRvb2xiYXIgPSB0aGlzLnRvb2xiYXI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnBsb3Rfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCA9IHRoaXMucGxvdF9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3QuZ2V0dGVyKFwicGxvdF9jYW52YXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxvdF9jYW52YXM7XG4gICAgfSk7XG4gICAgUGxvdC5wcm90b3R5cGUuX2RvY19hdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGosIGxheW91dF9yZW5kZXJlcnMsIGxlbiwgbGVuMSwgciwgcmVmLCBzaWRlO1xuICAgICAgICByZWYgPSBbJ2Fib3ZlJywgJ2JlbG93JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzaWRlID0gcmVmW2ldO1xuICAgICAgICAgICAgbGF5b3V0X3JlbmRlcmVycyA9IHRoaXMuZ2V0dihzaWRlKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgIHIgPSBsYXlvdXRfcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgICAgIHRoaXMucGxvdF9jYW52YXMuYWRkX3JlbmRlcmVyX3RvX2NhbnZhc19zaWRlKHIsIHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxvdF9jYW52YXMuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLl9zZXRfb3JpZW50YXRpb25fdmFyaWFibGVzKHRoaXMpO1xuICAgICAgICB0aGlzLl9zZXRfb3JpZW50YXRpb25fdmFyaWFibGVzKHRoaXMudG9vbGJhcik7XG4gICAgICAgIHRoaXMuX3NldF9vcmllbnRhdGlvbl92YXJpYWJsZXModGhpcy5wbG90X2NhbnZhcyk7XG4gICAgICAgIHJldHVybiBQbG90Ll9fc3VwZXJfXy5fZG9jX2F0dGFjaGVkLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5hZGRfcmVuZGVyZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3X3JlbmRlcmVycywgcmVuZGVyZXJzO1xuICAgICAgICBuZXdfcmVuZGVyZXJzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICAgIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xuICAgICAgICByZW5kZXJlcnMgPSByZW5kZXJlcnMuY29uY2F0KG5ld19yZW5kZXJlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcnMgPSByZW5kZXJlcnM7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5hZGRfbGF5b3V0ID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzaWRlKSB7XG4gICAgICAgIHZhciBzaWRlX3JlbmRlcmVycztcbiAgICAgICAgaWYgKHNpZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2lkZSA9IFwiY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlcmVyLnByb3BzLnBsb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyZXIucGxvdCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRfcmVuZGVyZXJzKHJlbmRlcmVyKTtcbiAgICAgICAgaWYgKHNpZGUgIT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBzaWRlX3JlbmRlcmVycyA9IHRoaXMuZ2V0dihzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiBzaWRlX3JlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdC5wcm90b3R5cGUuYWRkX2dseXBoID0gZnVuY3Rpb24gKGdseXBoLCBzb3VyY2UsIGF0dHJzKSB7XG4gICAgICAgIHZhciByZW5kZXJlcjtcbiAgICAgICAgaWYgKGF0dHJzID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBuZXcgY29sdW1uX2RhdGFfc291cmNlXzEuQ29sdW1uRGF0YVNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzID0gb2JqZWN0XzEuZXh0ZW5kKHt9LCBhdHRycywge1xuICAgICAgICAgICAgZGF0YV9zb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGdseXBoOiBnbHlwaFxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIgPSBuZXcgZ2x5cGhfcmVuZGVyZXJfMS5HbHlwaFJlbmRlcmVyKGF0dHJzKTtcbiAgICAgICAgdGhpcy5hZGRfcmVuZGVyZXJzKHJlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH07XG4gICAgUGxvdC5wcm90b3R5cGUuYWRkX3Rvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXR0cnMsIG5ld190b29scywgdG9vbCwgdG9vbHM7XG4gICAgICAgIHRvb2xzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICAgIG5ld190b29scyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdG9vbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b29sID0gdG9vbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2wub3ZlcmxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkX3JlbmRlcmVycyh0b29sLm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9vbC5wbG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBvYmplY3RfMS5jbG9uZSh0b29sLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5wbG90ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyB0b29sLmNvbnN0cnVjdG9yKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXIudG9vbHMgPSB0aGlzLnRvb2xiYXIudG9vbHMuY29uY2F0KG5ld190b29scyk7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5nZXRfYXNwZWN0X3JhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIH07XG4gICAgUGxvdC5wcm90b3R5cGUuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgY2hpbGRyZW4gPSBbdGhpcy5wbG90X2NhbnZhc107XG4gICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbdGhpcy50b29sYmFyLCB0aGlzLnBsb3RfY2FudmFzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5nZXRfZWRpdF92YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgZWRpdF92YXJpYWJsZXMsIGksIGxlbiwgcmVmO1xuICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IFBsb3QuX19zdXBlcl9fLmdldF9lZGl0X3ZhcmlhYmxlcy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5zaXppbmdfbW9kZSA9PT0gJ3NjYWxlX2JvdGgnKSB7XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlZGl0X3ZhcmlhYmxlOiB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVkaXRfdmFyaWFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkaXRfdmFyaWFibGU6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICBzdHJlbmd0aDogc29sdmVyXzEuU3RyZW5ndGguc3Ryb25nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgICBlZGl0X3ZhcmlhYmxlcyA9IGVkaXRfdmFyaWFibGVzLmNvbmNhdChjaGlsZC5nZXRfZWRpdF92YXJpYWJsZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRfdmFyaWFibGVzO1xuICAgIH07XG4gICAgUGxvdC5wcm90b3R5cGUuZ2V0X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNvbnN0cmFpbnRzLCBpLCBsZW4sIHJlZiwgcmVmMSwgcmVmMiwgc3RpY2t5X2VkZ2U7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gUGxvdC5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9zdGlja3kgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX3NpemVhYmxlLCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX3NpemVhYmxlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl9zaXplYWJsZSwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl9zaXplYWJsZV0sIFstMSwgdGhpcy50b29sYmFyLl9zaXplYWJsZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5fZnVsbCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl9mdWxsXSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiA9PT0gJ2Fib3ZlJykge1xuICAgICAgICAgICAgICAgIHN0aWNreV9lZGdlID0gdGhpcy50b29sYmFyX3N0aWNreSA9PT0gdHJ1ZSA/IHRoaXMucGxvdF9jYW52YXMuX3RvcCA6IHRoaXMucGxvdF9jYW52YXMuX2RvbV90b3A7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUShzdGlja3lfZWRnZSwgWy0xLCB0aGlzLnRvb2xiYXIuX2RvbV90b3BdLCBbLTEsIHRoaXMudG9vbGJhci5faGVpZ2h0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiA9PT0gJ2JlbG93Jykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfc3RpY2t5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMudG9vbGJhci5fZG9tX3RvcCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl9oZWlnaHRdLCB0aGlzLnRvb2xiYXIuX2JvdHRvbSwgWy0xLCB0aGlzLnRvb2xiYXIuX2hlaWdodF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9zdGlja3kgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLnBsb3RfY2FudmFzLmJlbG93X3BhbmVsLl9oZWlnaHQsIFstMSwgdGhpcy50b29sYmFyLl9oZWlnaHRdKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuV0VBS19FUSh0aGlzLnRvb2xiYXIuX2RvbV90b3AsIFstMSwgdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0XSwgdGhpcy5wbG90X2NhbnZhcy5iZWxvd19wYW5lbC5faGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgc3RpY2t5X2VkZ2UgPSB0aGlzLnRvb2xiYXJfc3RpY2t5ID09PSB0cnVlID8gdGhpcy5wbG90X2NhbnZhcy5fbGVmdCA6IHRoaXMucGxvdF9jYW52YXMuX2RvbV9sZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEoc3RpY2t5X2VkZ2UsIFstMSwgdGhpcy50b29sYmFyLl9kb21fbGVmdF0sIFstMSwgdGhpcy50b29sYmFyLl93aWR0aF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJfbG9jYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b29sYmFyX3N0aWNreSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLnRvb2xiYXIuX2RvbV9sZWZ0LCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX3dpZHRoXSwgdGhpcy50b29sYmFyLl9yaWdodCwgWy0xLCB0aGlzLnRvb2xiYXIuX3dpZHRoXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b29sYmFyX3N0aWNreSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMucGxvdF9jYW52YXMucmlnaHRfcGFuZWwuX3dpZHRoLCBbLTEsIHRoaXMudG9vbGJhci5fd2lkdGhdKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuV0VBS19FUSh0aGlzLnRvb2xiYXIuX2RvbV9sZWZ0LCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX3dpZHRoXSwgdGhpcy5wbG90X2NhbnZhcy5yaWdodF9wYW5lbC5fd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHJlZiA9IHRoaXMudG9vbGJhcl9sb2NhdGlvbikgPT09ICdhYm92ZScgfHwgcmVmID09PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl93aWR0aCwgWy0xLCB0aGlzLnRvb2xiYXIuX3dpZHRoXSwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF9taW51c19yaWdodF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocmVmMSA9IHRoaXMudG9vbGJhcl9sb2NhdGlvbikgPT09ICdsZWZ0JyB8fCByZWYxID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl9oZWlnaHQsIFstMSwgdGhpcy50b29sYmFyLl9oZWlnaHRdLCBbLTEsIHRoaXMucGxvdF9jYW52YXMuYWJvdmVfcGFuZWwuX2hlaWdodF0pKTtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMudG9vbGJhci5fZG9tX3RvcCwgWy0xLCB0aGlzLnBsb3RfY2FudmFzLmFib3ZlX3BhbmVsLl9oZWlnaHRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9vbGJhcl9sb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuX3dpZHRoLCBbLTEsIHRoaXMucGxvdF9jYW52YXMuX3dpZHRoXSkpO1xuICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl9oZWlnaHQsIFstMSwgdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0XSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZjIgPSB0aGlzLmdldF9sYXlvdXRhYmxlX2NoaWxkcmVuKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmMltpXTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KGNoaWxkLmdldF9jb25zdHJhaW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uc3RyYWluZWRfdmFyaWFibGVzO1xuICAgICAgICBjb25zdHJhaW5lZF92YXJpYWJsZXMgPSBQbG90Ll9fc3VwZXJfXy5nZXRfY29uc3RyYWluZWRfdmFyaWFibGVzLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IG9iamVjdF8xLmV4dGVuZChjb25zdHJhaW5lZF92YXJpYWJsZXMsIHtcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLXRvcCc6IHRoaXMucGxvdF9jYW52YXMuX3RvcCxcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLWJvdHRvbSc6IHRoaXMucGxvdF9jYW52YXMuX2hlaWdodF9taW51c19ib3R0b20sXG4gICAgICAgICAgICAnb24tZWRnZS1hbGlnbi1sZWZ0JzogdGhpcy5wbG90X2NhbnZhcy5fbGVmdCxcbiAgICAgICAgICAgICdvbi1lZGdlLWFsaWduLXJpZ2h0JzogdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHQsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tdG9wJzogdGhpcy5wbG90X2NhbnZhcy5fdG9wLFxuICAgICAgICAgICAgJ2JveC1jZWxsLWFsaWduLWJvdHRvbSc6IHRoaXMucGxvdF9jYW52YXMuX2hlaWdodF9taW51c19ib3R0b20sXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tbGVmdCc6IHRoaXMucGxvdF9jYW52YXMuX2xlZnQsXG4gICAgICAgICAgICAnYm94LWNlbGwtYWxpZ24tcmlnaHQnOiB0aGlzLnBsb3RfY2FudmFzLl93aWR0aF9taW51c19yaWdodCxcbiAgICAgICAgICAgICdib3gtZXF1YWwtc2l6ZS10b3AnOiB0aGlzLnBsb3RfY2FudmFzLl90b3AsXG4gICAgICAgICAgICAnYm94LWVxdWFsLXNpemUtYm90dG9tJzogdGhpcy5wbG90X2NhbnZhcy5faGVpZ2h0X21pbnVzX2JvdHRvbVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuc2l6aW5nX21vZGUgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbmVkX3ZhcmlhYmxlcyA9IG9iamVjdF8xLmV4dGVuZChjb25zdHJhaW5lZF92YXJpYWJsZXMsIHtcbiAgICAgICAgICAgICAgICAnYm94LWVxdWFsLXNpemUtbGVmdCc6IHRoaXMucGxvdF9jYW52YXMuX2xlZnQsXG4gICAgICAgICAgICAgICAgJ2JveC1lcXVhbC1zaXplLXJpZ2h0JzogdGhpcy5wbG90X2NhbnZhcy5fd2lkdGhfbWludXNfcmlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW5lZF92YXJpYWJsZXM7XG4gICAgfTtcbiAgICBQbG90LnByb3RvdHlwZS5fc2V0X29yaWVudGF0aW9uX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1vZGVsLl9zaXplYWJsZSA9IG1vZGVsLl9oZWlnaHQ7XG4gICAgICAgICAgICBtb2RlbC5fZnVsbCA9IG1vZGVsLl93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faG9yaXpvbnRhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbW9kZWwuX3NpemVhYmxlID0gbW9kZWwuX3dpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLl9mdWxsID0gbW9kZWwuX2hlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdC5taXhpbnMoWydsaW5lOm91dGxpbmVfJywgJ2ZpbGw6YmFja2dyb3VuZF8nLCAnZmlsbDpib3JkZXJfJ10pO1xuICAgIFBsb3QuZGVmaW5lKHtcbiAgICAgICAgdG9vbGJhcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbGJhcl8xLlRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG9vbGJhcl9sb2NhdGlvbjogW3AuTG9jYXRpb24sICdyaWdodCddLFxuICAgICAgICB0b29sYmFyX3N0aWNreTogW3AuQm9vbCwgdHJ1ZV0sXG4gICAgICAgIHBsb3Rfd2lkdGg6IFtwLk51bWJlciwgNjAwXSxcbiAgICAgICAgcGxvdF9oZWlnaHQ6IFtwLk51bWJlciwgNjAwXSxcbiAgICAgICAgdGl0bGU6IFtcbiAgICAgICAgICAgIHAuQW55LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aXRsZV8xLlRpdGxlKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0aXRsZV9sb2NhdGlvbjogW3AuTG9jYXRpb24sICdhYm92ZSddLFxuICAgICAgICBoX3N5bW1ldHJ5OiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgdl9zeW1tZXRyeTogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBhYm92ZTogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYmVsb3c6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIGxlZnQ6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIHJpZ2h0OiBbcC5BcnJheSwgW11dLFxuICAgICAgICByZW5kZXJlcnM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIHhfcmFuZ2U6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgZXh0cmFfeF9yYW5nZXM6IFtwLkFueSwge31dLFxuICAgICAgICB5X3JhbmdlOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIGV4dHJhX3lfcmFuZ2VzOiBbcC5BbnksIHt9XSxcbiAgICAgICAgeF9tYXBwZXJfdHlwZTogW3AuU3RyaW5nLCAnYXV0byddLFxuICAgICAgICB5X21hcHBlcl90eXBlOiBbcC5TdHJpbmcsICdhdXRvJ10sXG4gICAgICAgIHRvb2xfZXZlbnRzOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX2V2ZW50c18xLlRvb2xFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbG9kX2ZhY3RvcjogW3AuTnVtYmVyLCAxMF0sXG4gICAgICAgIGxvZF9pbnRlcnZhbDogW3AuTnVtYmVyLCAzMDBdLFxuICAgICAgICBsb2RfdGhyZXNob2xkOiBbcC5OdW1iZXIsIDIwMDBdLFxuICAgICAgICBsb2RfdGltZW91dDogW3AuTnVtYmVyLCA1MDBdLFxuICAgICAgICB3ZWJnbDogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBoaWRwaTogW3AuQm9vbCwgdHJ1ZV0sXG4gICAgICAgIG1pbl9ib3JkZXI6IFtwLk51bWJlciwgNV0sXG4gICAgICAgIG1pbl9ib3JkZXJfdG9wOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBtaW5fYm9yZGVyX2xlZnQ6IFtwLk51bWJlciwgbnVsbF0sXG4gICAgICAgIG1pbl9ib3JkZXJfYm90dG9tOiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBtaW5fYm9yZGVyX3JpZ2h0OiBbcC5OdW1iZXIsIG51bGxdLFxuICAgICAgICBpbm5lcl93aWR0aDogW3AuTnVtYmVyXSxcbiAgICAgICAgaW5uZXJfaGVpZ2h0OiBbcC5OdW1iZXJdLFxuICAgICAgICBsYXlvdXRfd2lkdGg6IFtwLk51bWJlcl0sXG4gICAgICAgIGxheW91dF9oZWlnaHQ6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICBQbG90Lm92ZXJyaWRlKHtcbiAgICAgICAgb3V0bGluZV9saW5lX2NvbG9yOiAnI2U1ZTVlNScsXG4gICAgICAgIGJvcmRlcl9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYmFja2dyb3VuZF9maWxsX2NvbG9yOiBcIiNmZmZmZmZcIlxuICAgIH0pO1xuICAgIFBsb3QuZ2V0dGVycyh7XG4gICAgICAgIGFsbF9yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVuZGVyZXJzLCB0b29sO1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gdGhpcy5yZW5kZXJlcnM7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnRvb2xiYXIudG9vbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVycyA9IHJlbmRlcmVycy5jb25jYXQodG9vbC5zeW50aGV0aWNfcmVuZGVyZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUGxvdDtcbn0pKGxheW91dF9kb21fMS5MYXlvdXRET00pO1xuYm9rZWhfZXZlbnRzXzEucmVnaXN0ZXJfd2l0aF9ldmVudChib2tlaF9ldmVudHNfMS5VSUV2ZW50LCBleHBvcnRzLlBsb3QpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsX2dsY2FudmFzLCBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgY2FudmFzXzEgPSByZXF1aXJlKFwiLi4vY2FudmFzL2NhbnZhc1wiKTtcbnZhciBjYXJ0ZXNpYW5fZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9jYW52YXMvY2FydGVzaWFuX2ZyYW1lXCIpO1xudmFyIGRhdGFfcmFuZ2UxZF8xID0gcmVxdWlyZShcIi4uL3Jhbmdlcy9kYXRhX3JhbmdlMWRcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgbGF5b3V0X2RvbV8xID0gcmVxdWlyZShcIi4uL2xheW91dHMvbGF5b3V0X2RvbVwiKTtcbnZhciBidWlsZF92aWV3c18xID0gcmVxdWlyZShcImNvcmUvYnVpbGRfdmlld3NcIik7XG52YXIgdWlfZXZlbnRzXzEgPSByZXF1aXJlKFwiY29yZS91aV9ldmVudHNcIik7XG52YXIgYm9rZWhfZXZlbnRzXzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF9ldmVudHNcIik7XG52YXIgbGF5b3V0X2NhbnZhc18xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L2xheW91dF9jYW52YXNcIik7XG52YXIgdmlzdWFsc18xID0gcmVxdWlyZShcImNvcmUvdmlzdWFsc1wiKTtcbnZhciBib2tlaF92aWV3XzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF92aWV3XCIpO1xudmFyIHNvbHZlcl8xID0gcmVxdWlyZShcImNvcmUvbGF5b3V0L3NvbHZlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIGVudW1zID0gcmVxdWlyZShcImNvcmUvZW51bXNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGhyb3R0bGVfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdGhyb3R0bGVcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBjYWxsYmFja18xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jYWxsYmFja1wiKTtcbnZhciBzaWRlX3BhbmVsXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc2lkZV9wYW5lbFwiKTtcbmdsb2JhbF9nbGNhbnZhcyA9IG51bGw7XG5leHBvcnRzLlBsb3RDYW52YXNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShQbG90Q2FudmFzVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGxvdENhbnZhc1ZpZXcoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlID0gYmluZCh0aGlzLnJlbW92ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9yZW5kZXIgPSBiaW5kKHRoaXMucmVxdWVzdF9yZW5kZXIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLXBsb3Qtd3JhcHBlclwiO1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5zdGF0ZSA9IHtcbiAgICAgICAgaGlzdG9yeTogW10sXG4gICAgICAgIGluZGV4OiAtMVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnZpZXdfb3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLmV4dGVuZCh7XG4gICAgICAgICAgICBwbG90X3ZpZXc6IHRoaXNcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfcGF1c2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51bnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnJlcXVlc3RfcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNfcGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZF9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkLCByZWYsIHJlc3VsdHMsIHRvb2xfdmlldztcbiAgICAgICAgUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZWYgPSB0aGlzLnRvb2xfdmlld3M7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpZCBpbiByZWYpIHtcbiAgICAgICAgICAgIHRvb2xfdmlldyA9IHJlZltpZF07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godG9vbF92aWV3LnJlbW92ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgbGV2ZWwsIHJlZjtcbiAgICAgICAgUGxvdENhbnZhc1ZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmxvZF9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzdWFscyA9IG5ldyB2aXN1YWxzXzEuVmlzdWFscyh0aGlzLm1vZGVsLnBsb3QpO1xuICAgICAgICB0aGlzLl9pbml0aWFsX3N0YXRlX2luZm8gPSB7XG4gICAgICAgICAgICByYW5nZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjoge30sXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMubW9kZWwuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5tb2RlbC5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLm1vZGVsLmZyYW1lO1xuICAgICAgICB0aGlzLnhfcmFuZ2UgPSB0aGlzLmZyYW1lLnhfcmFuZ2VzWydkZWZhdWx0J107XG4gICAgICAgIHRoaXMueV9yYW5nZSA9IHRoaXMuZnJhbWUueV9yYW5nZXNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdGhpcy54bWFwcGVyID0gdGhpcy5mcmFtZS54X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdGhpcy55bWFwcGVyID0gdGhpcy5mcmFtZS55X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLm1vZGVsLmNhbnZhcztcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldyA9IG5ldyB0aGlzLmNhbnZhcy5kZWZhdWx0X3ZpZXcoe1xuICAgICAgICAgICAgJ21vZGVsJzogdGhpcy5jYW52YXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXNfdmlldy5lbCk7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcucmVuZGVyKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wbG90LndlYmdsKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfd2ViZ2woKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm90dGxlZF9yZW5kZXIgPSB0aHJvdHRsZV8xLnRocm90dGxlKHRoaXMucmVuZGVyLCAxNSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmRvY3VtZW50Ll91bnJlbmRlcmVkX3Bsb3RzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuX3VucmVuZGVyZWRfcGxvdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmRvY3VtZW50Ll91bnJlbmRlcmVkX3Bsb3RzW3RoaXMuaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51aV9ldmVudF9idXMgPSBuZXcgdWlfZXZlbnRzXzEuVUlFdmVudHModGhpcywgdGhpcy5tb2RlbC50b29sYmFyLCB0aGlzLmNhbnZhc192aWV3LmVsLCB0aGlzLm1vZGVsLnBsb3QpO1xuICAgICAgICB0aGlzLmxldmVscyA9IHt9O1xuICAgICAgICByZWYgPSBlbnVtcy5SZW5kZXJMZXZlbDtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHJlZltqXTtcbiAgICAgICAgICAgIHRoaXMubGV2ZWxzW2xldmVsXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXJfdmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy50b29sX3ZpZXdzID0ge307XG4gICAgICAgIHRoaXMuYnVpbGRfbGV2ZWxzKCk7XG4gICAgICAgIHRoaXMuYnVpbGRfdG9vbHMoKTtcbiAgICAgICAgdGhpcy5iaW5kX2Jva2VoX2V2ZW50cygpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9kYXRhcmFuZ2VzKCk7XG4gICAgICAgIHRoaXMudW5wYXVzZSgpO1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGxvdFZpZXcgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmdldF9jYW52YXNfZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzX3ZpZXcuY3R4LmNhbnZhcztcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5zZXRfY3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICBpZiAoY3Vyc29yID09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc192aWV3LmVsLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LmdldHRlcnMoe1xuICAgICAgICBjYW52YXNfb3ZlcmxheXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5iay1jYW52YXMtb3ZlcmxheXMnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5pbml0X3dlYmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4LCBnbGNhbnZhcywgb3B0cztcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIGdsY2FudmFzID0gZ2xvYmFsX2dsY2FudmFzO1xuICAgICAgICBpZiAoZ2xjYW52YXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2xvYmFsX2dsY2FudmFzID0gZ2xjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgJ3ByZW11bHRpcGxpZWRBbHBoYSc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbGNhbnZhcy5nbCA9IGdsY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBvcHRzKSB8fCBnbGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbGNhbnZhcy5nbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmdsY2FudmFzID0gZ2xjYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkLCBmYWxsaW5nIGJhY2sgdG8gMkQgY2FudmFzLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucHJlcGFyZV93ZWJnbCA9IGZ1bmN0aW9uIChyYXRpbywgZnJhbWVfYm94KSB7XG4gICAgICAgIHZhciBjYW52YXMsIGN0eCwgZmxpcHBlZF90b3AsIGdsO1xuICAgICAgICBjdHggPSB0aGlzLmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXNfdmlldy5nZXRfY2FudmFzX2VsZW1lbnQoKTtcbiAgICAgICAgaWYgKGN0eC5nbGNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmdsY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgY3R4LmdsY2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBnbCA9IGN0eC5nbGNhbnZhcy5nbDtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGN0eC5nbGNhbnZhcy53aWR0aCwgY3R4LmdsY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8fCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICAgICAgZmxpcHBlZF90b3AgPSBjdHguZ2xjYW52YXMuaGVpZ2h0IC0gcmF0aW8gKiAoZnJhbWVfYm94WzFdICsgZnJhbWVfYm94WzNdKTtcbiAgICAgICAgICAgIGdsLnNjaXNzb3IocmF0aW8gKiBmcmFtZV9ib3hbMF0sIGZsaXBwZWRfdG9wLCByYXRpbyAqIGZyYW1lX2JveFsyXSwgcmF0aW8gKiBmcmFtZV9ib3hbM10pO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIHJldHVybiBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5ibGl0X3dlYmdsID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgIHZhciBjdHg7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICBpZiAoY3R4LmdsY2FudmFzKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKCdkcmF3aW5nIHdpdGggV2ViR0wnKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGN0eC5nbGNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51cGRhdGVfZGF0YXJhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJkcywgYm91bmRzLCBib3VuZHNfdG9fdXNlLCBjYWxjdWxhdGVfbG9nX2JvdW5kcywgZm9sbG93X2VuYWJsZWQsIGZyYW1lLCBoYXNfYm91bmRzLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQsIGxvZ19iZHMsIGxvZ19ib3VuZHMsIG0sIG4sIG8sIHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgdiwgeHIsIHlyO1xuICAgICAgICBmcmFtZSA9IHRoaXMubW9kZWwuZnJhbWU7XG4gICAgICAgIGJvdW5kcyA9IHt9O1xuICAgICAgICBsb2dfYm91bmRzID0ge307XG4gICAgICAgIGNhbGN1bGF0ZV9sb2dfYm91bmRzID0gZmFsc2U7XG4gICAgICAgIHJlZiA9IG9iamVjdF8xLnZhbHVlcyhmcmFtZS54X3JhbmdlcykuY29uY2F0KG9iamVjdF8xLnZhbHVlcyhmcmFtZS55X3JhbmdlcykpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZbal07XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIGRhdGFfcmFuZ2UxZF8xLkRhdGFSYW5nZTFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIubWFwcGVyX2hpbnQgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlX2xvZ19ib3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWYxID0gdGhpcy5yZW5kZXJlcl92aWV3cztcbiAgICAgICAgZm9yIChrIGluIHJlZjEpIHtcbiAgICAgICAgICAgIHYgPSByZWYxW2tdO1xuICAgICAgICAgICAgYmRzID0gKHJlZjIgPSB2LmdseXBoKSAhPSBudWxsID8gdHlwZW9mIHJlZjIuYm91bmRzID09PSBcImZ1bmN0aW9uXCIgPyByZWYyLmJvdW5kcygpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGJkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzW2tdID0gYmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZV9sb2dfYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgbG9nX2JkcyA9IChyZWYzID0gdi5nbHlwaCkgIT0gbnVsbCA/IHR5cGVvZiByZWYzLmxvZ19ib3VuZHMgPT09IFwiZnVuY3Rpb25cIiA/IHJlZjMubG9nX2JvdW5kcygpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChsb2dfYmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nX2JvdW5kc1trXSA9IGxvZ19iZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvbGxvd19lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGhhc19ib3VuZHMgPSBmYWxzZTtcbiAgICAgICAgcmVmNCA9IG9iamVjdF8xLnZhbHVlcyhmcmFtZS54X3Jhbmdlcyk7XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSByZWY0Lmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgeHIgPSByZWY0W2xdO1xuICAgICAgICAgICAgaWYgKHhyIGluc3RhbmNlb2YgZGF0YV9yYW5nZTFkXzEuRGF0YVJhbmdlMWQpIHtcbiAgICAgICAgICAgICAgICBib3VuZHNfdG9fdXNlID0geHIubWFwcGVyX2hpbnQgPT09IFwibG9nXCIgPyBsb2dfYm91bmRzIDogYm91bmRzO1xuICAgICAgICAgICAgICAgIHhyLnVwZGF0ZShib3VuZHNfdG9fdXNlLCAwLCB0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoeHIuZm9sbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGxvd19lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeHIuYm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoYXNfYm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWY1ID0gb2JqZWN0XzEudmFsdWVzKGZyYW1lLnlfcmFuZ2VzKTtcbiAgICAgICAgZm9yIChtID0gMCwgbGVuMiA9IHJlZjUubGVuZ3RoOyBtIDwgbGVuMjsgbSsrKSB7XG4gICAgICAgICAgICB5ciA9IHJlZjVbbV07XG4gICAgICAgICAgICBpZiAoeXIgaW5zdGFuY2VvZiBkYXRhX3JhbmdlMWRfMS5EYXRhUmFuZ2UxZCkge1xuICAgICAgICAgICAgICAgIGJvdW5kc190b191c2UgPSB5ci5tYXBwZXJfaGludCA9PT0gXCJsb2dcIiA/IGxvZ19ib3VuZHMgOiBib3VuZHM7XG4gICAgICAgICAgICAgICAgeXIudXBkYXRlKGJvdW5kc190b191c2UsIDEsIHRoaXMubW9kZWwuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh5ci5mb2xsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93X2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ci5ib3VuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc19ib3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb2xsb3dfZW5hYmxlZCAmJiBoYXNfYm91bmRzKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ0ZvbGxvdyBlbmFibGVkIHNvIGJvdW5kcyBhcmUgdW5zZXQuJyk7XG4gICAgICAgICAgICByZWY2ID0gb2JqZWN0XzEudmFsdWVzKGZyYW1lLnhfcmFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobiA9IDAsIGxlbjMgPSByZWY2Lmxlbmd0aDsgbiA8IGxlbjM7IG4rKykge1xuICAgICAgICAgICAgICAgIHhyID0gcmVmNltuXTtcbiAgICAgICAgICAgICAgICB4ci5ib3VuZHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmNyA9IG9iamVjdF8xLnZhbHVlcyhmcmFtZS55X3Jhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKG8gPSAwLCBsZW40ID0gcmVmNy5sZW5ndGg7IG8gPCBsZW40OyBvKyspIHtcbiAgICAgICAgICAgICAgICB5ciA9IHJlZjdbb107XG4gICAgICAgICAgICAgICAgeXIuYm91bmRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZV91cGRhdGVfdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5tYXBfdG9fc2NyZWVuID0gZnVuY3Rpb24gKHgsIHksIHhfbmFtZSwgeV9uYW1lKSB7XG4gICAgICAgIGlmICh4X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeF9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5X25hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgeV9uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lLm1hcF90b19zY3JlZW4oeCwgeSwgdGhpcy5jYW52YXMsIHhfbmFtZSwgeV9uYW1lKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5wdXNoX3N0YXRlID0gZnVuY3Rpb24gKHR5cGUsIGluZm8pIHtcbiAgICAgICAgdmFyIHByZXZfaW5mbywgcmVmO1xuICAgICAgICBwcmV2X2luZm8gPSAoKHJlZiA9IHRoaXMuc3RhdGUuaGlzdG9yeVt0aGlzLnN0YXRlLmluZGV4XSkgIT0gbnVsbCA/IHJlZi5pbmZvIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgICAgaW5mbyA9IG9iamVjdF8xLmV4dGVuZCh7fSwgdGhpcy5faW5pdGlhbF9zdGF0ZV9pbmZvLCBwcmV2X2luZm8sIGluZm8pO1xuICAgICAgICB0aGlzLnN0YXRlLmhpc3Rvcnkuc2xpY2UoMCwgdGhpcy5zdGF0ZS5pbmRleCArIDEpO1xuICAgICAgICB0aGlzLnN0YXRlLmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaW5mbzogaW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbmRleCA9IHRoaXMuc3RhdGUuaGlzdG9yeS5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFwic3RhdGVfY2hhbmdlZFwiKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5jbGVhcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoXCJzdGF0ZV9jaGFuZ2VkXCIpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmNhbl91bmRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbmRleCA+PSAwO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmNhbl9yZWRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbmRleCA8IHRoaXMuc3RhdGUuaGlzdG9yeS5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbl91bmRvKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5kZXggLT0gMTtcbiAgICAgICAgICAgIHRoaXMuX2RvX3N0YXRlX2NoYW5nZSh0aGlzLnN0YXRlLmluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoXCJzdGF0ZV9jaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuX3JlZG8oKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbmRleCArPSAxO1xuICAgICAgICAgICAgdGhpcy5fZG9fc3RhdGVfY2hhbmdlKHRoaXMuc3RhdGUuaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihcInN0YXRlX2NoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fZG9fc3RhdGVfY2hhbmdlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpbmZvLCByZWY7XG4gICAgICAgIGluZm8gPSAoKHJlZiA9IHRoaXMuc3RhdGUuaGlzdG9yeVtpbmRleF0pICE9IG51bGwgPyByZWYuaW5mbyA6IHZvaWQgMCkgfHwgdGhpcy5faW5pdGlhbF9zdGF0ZV9pbmZvO1xuICAgICAgICBpZiAoaW5mby5yYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZV9yYW5nZShpbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5zZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVfc2VsZWN0aW9uKGluZm8uc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5kaW1lbnNpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhc192aWV3LnNldF9kaW1zKFtpbmZvLmRpbWVuc2lvbnMud2lkdGgsIGluZm8uZGltZW5zaW9ucy5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnJlc2V0X2RpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZV9kaW1lbnNpb25zKHRoaXMuY2FudmFzLmluaXRpYWxfd2lkdGgsIHRoaXMuY2FudmFzLmluaXRpYWxfaGVpZ2h0KTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51cGRhdGVfZGltZW5zaW9ucyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5wbG90LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMubW9kZWwucGxvdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQucmVzaXplKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVucGF1c2UoKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlbmRlcmVyLCBzZWxlY3RlZCwgc2VsZWN0aW9uO1xuICAgICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5wbG90LnJlbmRlcmVycztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHJlZltqXTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIGdseXBoX3JlbmRlcmVyXzEuR2x5cGhSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcmVuZGVyZXIuZGF0YV9zb3VyY2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW3JlbmRlcmVyLmlkXSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUudXBkYXRlX3NlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRzLCBqLCBsZW4sIHJlZiwgcmVmMSwgcmVuZGVyZXIsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwucGxvdC5yZW5kZXJlcnM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHJlZltqXTtcbiAgICAgICAgICAgIGlmICghKHJlbmRlcmVyIGluc3RhbmNlb2YgZ2x5cGhfcmVuZGVyZXJfMS5HbHlwaFJlbmRlcmVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHMgPSByZW5kZXJlci5kYXRhX3NvdXJjZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWYxID0gcmVuZGVyZXIuaWQsIGluZGV4T2YuY2FsbChzZWxlY3Rpb24sIHJlZjEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRzLnNlbGVjdGVkID0gc2VsZWN0aW9uW3JlbmRlcmVyLmlkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZHMuc2VsZWN0aW9uX21hbmFnZXIuY2xlYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVzZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVfc2VsZWN0aW9uKG51bGwpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl91cGRhdGVfcmFuZ2VzX3RvZ2V0aGVyID0gZnVuY3Rpb24gKHJhbmdlX2luZm9faXRlcikge1xuICAgICAgICB2YXIgaiwgbCwgbGVuLCBsZW4xLCByYW5nZV9pbmZvLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJuZywgd2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgPSAxLjA7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJhbmdlX2luZm9faXRlci5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgcmVmID0gcmFuZ2VfaW5mb19pdGVyW2pdLCBybmcgPSByZWZbMF0sIHJhbmdlX2luZm8gPSByZWZbMV07XG4gICAgICAgICAgICB3ZWlnaHQgPSBNYXRoLm1pbih3ZWlnaHQsIHRoaXMuX2dldF93ZWlnaHRfdG9fY29uc3RyYWluX2ludGVydmFsKHJuZywgcmFuZ2VfaW5mbykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4xID0gcmFuZ2VfaW5mb19pdGVyLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgICAgIHJlZjEgPSByYW5nZV9pbmZvX2l0ZXJbbF0sIHJuZyA9IHJlZjFbMF0sIHJhbmdlX2luZm8gPSByZWYxWzFdO1xuICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSB3ZWlnaHQgKiByYW5nZV9pbmZvWydzdGFydCddICsgKDEgLSB3ZWlnaHQpICogcm5nLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyYW5nZV9pbmZvWydlbmQnXSA9IHdlaWdodCAqIHJhbmdlX2luZm9bJ2VuZCddICsgKDEgLSB3ZWlnaHQpICogcm5nLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl91cGRhdGVfcmFuZ2VzX2luZGl2aWR1YWxseSA9IGZ1bmN0aW9uIChyYW5nZV9pbmZvX2l0ZXIsIGlzX3Bhbm5pbmcsIGlzX3Njcm9sbGluZykge1xuICAgICAgICB2YXIgaGl0X2JvdW5kLCBqLCBsLCBsZW4sIGxlbjEsIG1heCwgbWluLCBuZXdfaW50ZXJ2YWwsIHJhbmdlX2luZm8sIHJlZiwgcmVmMSwgcmVzdWx0cywgcmV2ZXJzZWQsIHJuZywgd2VpZ2h0O1xuICAgICAgICBoaXRfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmFuZ2VfaW5mb19pdGVyLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByZWYgPSByYW5nZV9pbmZvX2l0ZXJbal0sIHJuZyA9IHJlZlswXSwgcmFuZ2VfaW5mbyA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJldmVyc2VkID0gcm5nLnN0YXJ0ID4gcm5nLmVuZDtcbiAgICAgICAgICAgIGlmICghaXNfc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdGhpcy5fZ2V0X3dlaWdodF90b19jb25zdHJhaW5faW50ZXJ2YWwocm5nLCByYW5nZV9pbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZV9pbmZvWydzdGFydCddID0gd2VpZ2h0ICogcmFuZ2VfaW5mb1snc3RhcnQnXSArICgxIC0gd2VpZ2h0KSAqIHJuZy5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSB3ZWlnaHQgKiByYW5nZV9pbmZvWydlbmQnXSArICgxIC0gd2VpZ2h0KSAqIHJuZy5lbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJuZy5ib3VuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHJuZy5ib3VuZHNbMF07XG4gICAgICAgICAgICAgICAgbWF4ID0gcm5nLmJvdW5kc1sxXTtcbiAgICAgICAgICAgICAgICBuZXdfaW50ZXJ2YWwgPSBNYXRoLmFicyhyYW5nZV9pbmZvWydlbmQnXSAtIHJhbmdlX2luZm9bJ3N0YXJ0J10pO1xuICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPj0gcmFuZ2VfaW5mb1snZW5kJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ2VuZCddID0gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXNfcGFubmluZyAhPSBudWxsKSB8fCAoaXNfc2Nyb2xsaW5nICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSBtaW4gKyBuZXdfaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8PSByYW5nZV9pbmZvWydzdGFydCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0X2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZV9pbmZvWydzdGFydCddID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXNfcGFubmluZyAhPSBudWxsKSB8fCAoaXNfc2Nyb2xsaW5nICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ2VuZCddID0gbWF4IC0gbmV3X2ludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID49IHJhbmdlX2luZm9bJ3N0YXJ0J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2luZm9bJ3N0YXJ0J10gPSBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19wYW5uaW5nICE9IG51bGwpIHx8IChpc19zY3JvbGxpbmcgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSBtaW4gKyBuZXdfaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8PSByYW5nZV9pbmZvWydlbmQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snZW5kJ10gPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpc19wYW5uaW5nICE9IG51bGwpIHx8IChpc19zY3JvbGxpbmcgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VfaW5mb1snc3RhcnQnXSA9IG1heCAtIG5ld19pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3Njcm9sbGluZyAmJiBoaXRfYm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSByYW5nZV9pbmZvX2l0ZXIubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICByZWYxID0gcmFuZ2VfaW5mb19pdGVyW2xdLCBybmcgPSByZWYxWzBdLCByYW5nZV9pbmZvID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHJuZy5oYXZlX3VwZGF0ZWRfaW50ZXJhY3RpdmVseSA9IHRydWU7XG4gICAgICAgICAgICBpZiAocm5nLnN0YXJ0ICE9PSByYW5nZV9pbmZvWydzdGFydCddIHx8IHJuZy5lbmQgIT09IHJhbmdlX2luZm9bJ2VuZCddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJuZy5zZXR2KHJhbmdlX2luZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9nZXRfd2VpZ2h0X3RvX2NvbnN0cmFpbl9pbnRlcnZhbCA9IGZ1bmN0aW9uIChybmcsIHJhbmdlX2luZm8pIHtcbiAgICAgICAgdmFyIG1heCwgbWF4X2ludGVydmFsLCBtYXhfaW50ZXJ2YWwyLCBtaW4sIG1pbl9pbnRlcnZhbCwgbmV3X2ludGVydmFsLCBvbGRfaW50ZXJ2YWwsIHJlZiwgd2VpZ2h0O1xuICAgICAgICBtaW5faW50ZXJ2YWwgPSBybmcubWluX2ludGVydmFsO1xuICAgICAgICBtYXhfaW50ZXJ2YWwgPSBybmcubWF4X2ludGVydmFsO1xuICAgICAgICB3ZWlnaHQgPSAxLjA7XG4gICAgICAgIGlmIChybmcuYm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZiA9IHJuZy5ib3VuZHMsIG1pbiA9IHJlZlswXSwgbWF4ID0gcmVmWzFdO1xuICAgICAgICAgICAgaWYgKChtaW4gIT0gbnVsbCkgJiYgKG1heCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbDIgPSBNYXRoLmFicyhtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbCA9IG1heF9pbnRlcnZhbCAhPSBudWxsID8gTWF0aC5taW4obWF4X2ludGVydmFsLCBtYXhfaW50ZXJ2YWwyKSA6IG1heF9pbnRlcnZhbDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtaW5faW50ZXJ2YWwgIT0gbnVsbCkgfHwgKG1heF9pbnRlcnZhbCAhPSBudWxsKSkge1xuICAgICAgICAgICAgb2xkX2ludGVydmFsID0gTWF0aC5hYnMocm5nLmVuZCAtIHJuZy5zdGFydCk7XG4gICAgICAgICAgICBuZXdfaW50ZXJ2YWwgPSBNYXRoLmFicyhyYW5nZV9pbmZvWydlbmQnXSAtIHJhbmdlX2luZm9bJ3N0YXJ0J10pO1xuICAgICAgICAgICAgaWYgKG1pbl9pbnRlcnZhbCA+IDAgJiYgbmV3X2ludGVydmFsIDwgbWluX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gKG9sZF9pbnRlcnZhbCAtIG1pbl9pbnRlcnZhbCkgLyAob2xkX2ludGVydmFsIC0gbmV3X2ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhfaW50ZXJ2YWwgPiAwICYmIG5ld19pbnRlcnZhbCA+IG1heF9pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IChtYXhfaW50ZXJ2YWwgLSBvbGRfaW50ZXJ2YWwpIC8gKG5ld19pbnRlcnZhbCAtIG9sZF9pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3ZWlnaHQgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgd2VpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlaWdodDtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS51cGRhdGVfcmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VfaW5mbywgaXNfcGFubmluZywgaXNfc2Nyb2xsaW5nKSB7XG4gICAgICAgIHZhciBuYW1lLCByYW5nZV9pbmZvX2l0ZXIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcm5nO1xuICAgICAgICB0aGlzLnBhdXNlO1xuICAgICAgICBpZiAocmFuZ2VfaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLmZyYW1lLnhfcmFuZ2VzO1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgICAgIHJuZyA9IHJlZltuYW1lXTtcbiAgICAgICAgICAgICAgICBybmcucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLmZyYW1lLnlfcmFuZ2VzO1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIHJlZjEpIHtcbiAgICAgICAgICAgICAgICBybmcgPSByZWYxW25hbWVdO1xuICAgICAgICAgICAgICAgIHJuZy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVfZGF0YXJhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VfaW5mb19pdGVyID0gW107XG4gICAgICAgICAgICByZWYyID0gdGhpcy5mcmFtZS54X3JhbmdlcztcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiByZWYyKSB7XG4gICAgICAgICAgICAgICAgcm5nID0gcmVmMltuYW1lXTtcbiAgICAgICAgICAgICAgICByYW5nZV9pbmZvX2l0ZXIucHVzaChbcm5nLCByYW5nZV9pbmZvLnhyc1tuYW1lXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMyA9IHRoaXMuZnJhbWUueV9yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMykge1xuICAgICAgICAgICAgICAgIHJuZyA9IHJlZjNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmFuZ2VfaW5mb19pdGVyLnB1c2goW3JuZywgcmFuZ2VfaW5mby55cnNbbmFtZV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc19zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVfcmFuZ2VzX3RvZ2V0aGVyKHJhbmdlX2luZm9faXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVfcmFuZ2VzX2luZGl2aWR1YWxseShyYW5nZV9pbmZvX2l0ZXIsIGlzX3Bhbm5pbmcsIGlzX3Njcm9sbGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5wYXVzZSgpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnJlc2V0X3JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVfcmFuZ2UobnVsbCk7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuYnVpbGRfbGV2ZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRfLCBqLCBsLCBsZW4sIGxlbjEsIG1vZGVsLCBuZXdfcmVuZGVyZXJfdmlld3MsIG9sZF9yZW5kZXJlcnMsIHJlbmRlcmVyX21vZGVscywgcmVuZGVyZXJzX3RvX3JlbW92ZSwgdmlldztcbiAgICAgICAgcmVuZGVyZXJfbW9kZWxzID0gdGhpcy5tb2RlbC5wbG90LmFsbF9yZW5kZXJlcnM7XG4gICAgICAgIG9sZF9yZW5kZXJlcnMgPSBPYmplY3Qua2V5cyh0aGlzLnJlbmRlcmVyX3ZpZXdzKTtcbiAgICAgICAgbmV3X3JlbmRlcmVyX3ZpZXdzID0gYnVpbGRfdmlld3NfMS5idWlsZF92aWV3cyh0aGlzLnJlbmRlcmVyX3ZpZXdzLCByZW5kZXJlcl9tb2RlbHMsIHRoaXMudmlld19vcHRpb25zKCkpO1xuICAgICAgICByZW5kZXJlcnNfdG9fcmVtb3ZlID0gYXJyYXlfMS5kaWZmZXJlbmNlKG9sZF9yZW5kZXJlcnMsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVuZGVyZXJfbW9kZWxzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSByZW5kZXJlcl9tb2RlbHNbal07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVuZGVyZXJzX3RvX3JlbW92ZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaWRfID0gcmVuZGVyZXJzX3RvX3JlbW92ZVtqXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxldmVscy5nbHlwaFtpZF9dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBuZXdfcmVuZGVyZXJfdmlld3MubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICB2aWV3ID0gbmV3X3JlbmRlcmVyX3ZpZXdzW2xdO1xuICAgICAgICAgICAgdGhpcy5sZXZlbHNbdmlldy5tb2RlbC5sZXZlbF1bdmlldy5tb2RlbC5pZF0gPSB2aWV3O1xuICAgICAgICAgICAgdmlldy5iaW5kX2Jva2VoX2V2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLmdldF9yZW5kZXJlcl92aWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGosIGxlbiwgciwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLnBsb3QucmVuZGVyZXJzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgciA9IHJlZltqXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmxldmVsc1tyLmxldmVsXVtyLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUuYnVpbGRfdG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqLCBsZW4sIG5ld190b29sX3ZpZXdzLCByZXN1bHRzLCB0b29sX21vZGVscywgdG9vbF92aWV3O1xuICAgICAgICB0b29sX21vZGVscyA9IHRoaXMubW9kZWwucGxvdC50b29sYmFyLnRvb2xzO1xuICAgICAgICBuZXdfdG9vbF92aWV3cyA9IGJ1aWxkX3ZpZXdzXzEuYnVpbGRfdmlld3ModGhpcy50b29sX3ZpZXdzLCB0b29sX21vZGVscywgdGhpcy52aWV3X29wdGlvbnMoKSk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmV3X3Rvb2xfdmlld3MubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHRvb2xfdmlldyA9IG5ld190b29sX3ZpZXdzW2pdO1xuICAgICAgICAgICAgdG9vbF92aWV3LmJpbmRfYm9rZWhfZXZlbnRzKCk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy51aV9ldmVudF9idXMucmVnaXN0ZXJfdG9vbCh0b29sX3ZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5iaW5kX2Jva2VoX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUsIHJlZiwgcmVmMSwgcm5nO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmZyYW1lLnhfcmFuZ2VzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBybmcgPSByZWZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHJuZywgJ2NoYW5nZScsIHRoaXMucmVxdWVzdF9yZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSB0aGlzLm1vZGVsLmZyYW1lLnlfcmFuZ2VzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICAgICAgcm5nID0gcmVmMVtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8ocm5nLCAnY2hhbmdlJywgdGhpcy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnBsb3QsICdjaGFuZ2U6cmVuZGVyZXJzJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYnVpbGRfbGV2ZWxzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5wbG90LnRvb2xiYXIsICdjaGFuZ2U6dG9vbHMnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1aWxkX2xldmVscygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5idWlsZF90b29scygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdCwgJ2NoYW5nZScsIHRoaXMucmVxdWVzdF9yZW5kZXIpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwucGxvdCwgJ2Rlc3Ryb3knLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnBsb3QuZG9jdW1lbnQuc29sdmVyKCksICdsYXlvdXRfdXBkYXRlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnBsb3QuZG9jdW1lbnQuc29sdmVyKCksICdsYXlvdXRfdXBkYXRlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubW9kZWwucGxvdC5zZXR2KHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfd2lkdGg6IE1hdGgucm91bmQoX3RoaXMuZnJhbWUud2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICBpbm5lcl9oZWlnaHQ6IE1hdGgucm91bmQoX3RoaXMuZnJhbWUuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0X3dpZHRoOiBNYXRoLnJvdW5kKF90aGlzLmNhbnZhcy53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIGxheW91dF9oZWlnaHQ6IE1hdGgucm91bmQoX3RoaXMuY2FudmFzLmhlaWdodClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLnBsb3QuZG9jdW1lbnQuc29sdmVyKCksICdyZXNpemUnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNpemUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5jYW52YXMsICdjaGFuZ2U6cGl4ZWxfcmF0aW8nLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnNldF9pbml0aWFsX3JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ29vZF92YWxzLCBuYW1lLCByZWYsIHJlZjEsIHJuZywgeHJzLCB5cnM7XG4gICAgICAgIGdvb2RfdmFscyA9IHRydWU7XG4gICAgICAgIHhycyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLmZyYW1lLnhfcmFuZ2VzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBybmcgPSByZWZbbmFtZV07XG4gICAgICAgICAgICBpZiAoKHJuZy5zdGFydCA9PSBudWxsKSB8fCAocm5nLmVuZCA9PSBudWxsKSB8fCB0eXBlc18xLmlzU3RyaWN0TmFOKHJuZy5zdGFydCArIHJuZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgZ29vZF92YWxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4cnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHJuZy5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHJuZy5lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvb2RfdmFscykge1xuICAgICAgICAgICAgeXJzID0ge307XG4gICAgICAgICAgICByZWYxID0gdGhpcy5mcmFtZS55X3JhbmdlcztcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgcm5nID0gcmVmMVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoKHJuZy5zdGFydCA9PSBudWxsKSB8fCAocm5nLmVuZCA9PSBudWxsKSB8fCB0eXBlc18xLmlzU3RyaWN0TmFOKHJuZy5zdGFydCArIHJuZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2RfdmFscyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeXJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcm5nLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHJuZy5lbmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnb29kX3ZhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxfc3RhdGVfaW5mby5yYW5nZSA9IHRoaXMuaW5pdGlhbF9yYW5nZV9pbmZvID0ge1xuICAgICAgICAgICAgICAgIHhyczogeHJzLFxuICAgICAgICAgICAgICAgIHlyczogeXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJpbml0aWFsIHJhbmdlcyBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdjb3VsZCBub3Qgc2V0IGluaXRpYWwgcmFuZ2VzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZm9yY2VfY2FudmFzKSB7XG4gICAgICAgIHZhciBjdHgsIGV2ZW50LCBmcmFtZV9ib3gsIGssIGxvZF90aW1lb3V0LCByYXRpbywgcmVmLCB2O1xuICAgICAgICBpZiAoZm9yY2VfY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcmNlX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIudHJhY2UoXCJQbG90Q2FudmFzLnJlbmRlcihmb3JjZV9jYW52YXM9XCIgKyBmb3JjZV9jYW52YXMgKyBcIikgZm9yIFwiICsgdGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmRvY3VtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuaW50ZXJhY3RpdmVfdGltZXN0YW1wIDwgdGhpcy5tb2RlbC5wbG90LmxvZF9pbnRlcnZhbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxvZF9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5wbG90LnRyaWdnZXJfZXZlbnQobmV3IGJva2VoX2V2ZW50c18xLkxPRFN0YXJ0KHt9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2Rfc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZF90aW1lb3V0ID0gdGhpcy5tb2RlbC5wbG90LmxvZF90aW1lb3V0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmludGVyYWN0aXZlICYmIChEYXRlLm5vdygpIC0gX3RoaXMuaW50ZXJhY3RpdmVfdGltZXN0YW1wKSA+IGxvZF90aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXF1ZXN0X3JlbmRlcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKSwgbG9kX3RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9kX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnBsb3QudHJpZ2dlcl9ldmVudChuZXcgYm9rZWhfZXZlbnRzXzEuTE9ERW5kKHt9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2Rfc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHRoaXMucmVuZGVyZXJfdmlld3M7XG4gICAgICAgIGZvciAoayBpbiByZWYpIHtcbiAgICAgICAgICAgIHYgPSByZWZba107XG4gICAgICAgICAgICBpZiAoKHRoaXMucmFuZ2VfdXBkYXRlX3RpbWVzdGFtcCA9PSBudWxsKSB8fCB2LnNldF9kYXRhX3RpbWVzdGFtcCA+IHRoaXMucmFuZ2VfdXBkYXRlX3RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlX2RhdGFyYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZV9jb25zdHJhaW50cygpO1xuICAgICAgICB0aGlzLm1vZGVsLmZyYW1lLl91cGRhdGVfbWFwcGVycygpO1xuICAgICAgICBjdHggPSB0aGlzLmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnBpeGVsX3JhdGlvID0gcmF0aW8gPSB0aGlzLmNhbnZhc192aWV3LnBpeGVsX3JhdGlvO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XG4gICAgICAgIGZyYW1lX2JveCA9IFt0aGlzLmNhbnZhcy52eF90b19zeCh0aGlzLmZyYW1lLmxlZnQpLCB0aGlzLmNhbnZhcy52eV90b19zeSh0aGlzLmZyYW1lLnRvcCksIHRoaXMuZnJhbWUud2lkdGgsIHRoaXMuZnJhbWUuaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5fbWFwX2hvb2soY3R4LCBmcmFtZV9ib3gpO1xuICAgICAgICB0aGlzLl9wYWludF9lbXB0eShjdHgsIGZyYW1lX2JveCk7XG4gICAgICAgIHRoaXMucHJlcGFyZV93ZWJnbChyYXRpbywgZnJhbWVfYm94KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFscy5vdXRsaW5lX2xpbmUuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLm91dGxpbmVfbGluZS5zZXRfdmFsdWUoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0LmFwcGx5KGN0eCwgZnJhbWVfYm94KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJfbGV2ZWxzKGN0eCwgWydpbWFnZScsICd1bmRlcmxheScsICdnbHlwaCddLCBmcmFtZV9ib3gpO1xuICAgICAgICB0aGlzLmJsaXRfd2ViZ2wocmF0aW8pO1xuICAgICAgICB0aGlzLl9yZW5kZXJfbGV2ZWxzKGN0eCwgWydhbm5vdGF0aW9uJ10sIGZyYW1lX2JveCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcl9sZXZlbHMoY3R4LCBbJ292ZXJsYXknXSk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxfcmFuZ2VfaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldF9pbml0aWFsX3JhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZG9jdW1lbnQuX3VucmVuZGVyZWRfcGxvdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubW9kZWwuZG9jdW1lbnQuX3VucmVuZGVyZWRfcGxvdHNbdGhpcy5pZF07XG4gICAgICAgICAgICBpZiAob2JqZWN0XzEuaXNFbXB0eSh0aGlzLm1vZGVsLmRvY3VtZW50Ll91bnJlbmRlcmVkX3Bsb3RzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuX3VucmVuZGVyZWRfcGxvdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrXzEuZGVmZXIodGhpcy5tb2RlbC5kb2N1bWVudC5yZXNpemUuYmluZCh0aGlzLm1vZGVsLmRvY3VtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoXCJib2tlaDpyZW5kZXJlZFwiLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzVmlldy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcbiAgICAgICAgd2lkdGggPSB0aGlzLm1vZGVsLl93aWR0aC5fdmFsdWU7XG4gICAgICAgIGhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC5fdmFsdWU7XG4gICAgICAgIHRoaXMuY2FudmFzX3ZpZXcuc2V0X2RpbXMoW3dpZHRoLCBoZWlnaHRdLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jYW52YXNfdmlldy5wcmVwYXJlX2NhbnZhcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9jb25zdHJhaW50cygpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gdGhpcy5tb2RlbC5fZG9tX2xlZnQuX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRoaXMubW9kZWwuX2RvbV90b3AuX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5tb2RlbC5fd2lkdGguX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1vZGVsLl9oZWlnaHQuX3ZhbHVlICsgXCJweFwiO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnVwZGF0ZV9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGVsX2lkLCByZWYsIHMsIHZpZXc7XG4gICAgICAgIHMgPSB0aGlzLm1vZGVsLmRvY3VtZW50LnNvbHZlcigpO1xuICAgICAgICBzLnN1Z2dlc3RfdmFsdWUodGhpcy5mcmFtZS5fd2lkdGgsIHRoaXMuY2FudmFzLndpZHRoIC0gMSk7XG4gICAgICAgIHMuc3VnZ2VzdF92YWx1ZSh0aGlzLmZyYW1lLl9oZWlnaHQsIHRoaXMuY2FudmFzLmhlaWdodCAtIDEpO1xuICAgICAgICByZWYgPSB0aGlzLnJlbmRlcmVyX3ZpZXdzO1xuICAgICAgICBmb3IgKG1vZGVsX2lkIGluIHJlZikge1xuICAgICAgICAgICAgdmlldyA9IHJlZlttb2RlbF9pZF07XG4gICAgICAgICAgICBpZiAodmlldy5tb2RlbC5wYW5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2lkZV9wYW5lbF8xLnVwZGF0ZV9jb25zdHJhaW50cyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcy51cGRhdGVfdmFyaWFibGVzKGZhbHNlKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fcmVuZGVyX2xldmVscyA9IGZ1bmN0aW9uIChjdHgsIGxldmVscywgY2xpcF9yZWdpb24pIHtcbiAgICAgICAgdmFyIGksIGluZGljZXMsIGosIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGV2ZWwsIG0sIHJlZiwgcmVuZGVyZXIsIHJlbmRlcmVyX3ZpZXcsIHJlbmRlcmVyX3ZpZXdzLCBzb3J0S2V5O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAoY2xpcF9yZWdpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QuYXBwbHkoY3R4LCBjbGlwX3JlZ2lvbik7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5wbG90LnJlbmRlcmVycztcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gcmVmW2ldO1xuICAgICAgICAgICAgaW5kaWNlc1tyZW5kZXJlci5pZF0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRLZXkgPSBmdW5jdGlvbiAocmVuZGVyZXJfdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbcmVuZGVyZXJfdmlldy5tb2RlbC5pZF07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBsZXZlbHMubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBsZXZlbCA9IGxldmVsc1tsXTtcbiAgICAgICAgICAgIHJlbmRlcmVyX3ZpZXdzID0gYXJyYXlfMS5zb3J0Qnkob2JqZWN0XzEudmFsdWVzKHRoaXMubGV2ZWxzW2xldmVsXSksIHNvcnRLZXkpO1xuICAgICAgICAgICAgZm9yIChtID0gMCwgbGVuMiA9IHJlbmRlcmVyX3ZpZXdzLmxlbmd0aDsgbSA8IGxlbjI7IG0rKykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyX3ZpZXcgPSByZW5kZXJlcl92aWV3c1ttXTtcbiAgICAgICAgICAgICAgICByZW5kZXJlcl92aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLl9tYXBfaG9vayA9IGZ1bmN0aW9uIChjdHgsIGZyYW1lX2JveCkgeyB9O1xuICAgIFBsb3RDYW52YXNWaWV3LnByb3RvdHlwZS5fcGFpbnRfZW1wdHkgPSBmdW5jdGlvbiAoY3R4LCBmcmFtZV9ib3gpIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhc192aWV3Lm1vZGVsLndpZHRoLCB0aGlzLmNhbnZhc192aWV3Lm1vZGVsLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYm9yZGVyX2ZpbGwuZG9pdCkge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzLmJvcmRlcl9maWxsLnNldF92YWx1ZShjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzX3ZpZXcubW9kZWwud2lkdGgsIHRoaXMuY2FudmFzX3ZpZXcubW9kZWwuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QuYXBwbHkoY3R4LCBmcmFtZV9ib3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbHMuYmFja2dyb3VuZF9maWxsLmRvaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFscy5iYWNrZ3JvdW5kX2ZpbGwuc2V0X3ZhbHVlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmZpbGxSZWN0LmFwcGx5KGN0eCwgZnJhbWVfYm94KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxvdENhbnZhc1ZpZXcucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgYmxvYiwgY2FudmFzLCBsaW5rO1xuICAgICAgICBjYW52YXMgPSB0aGlzLmdldF9jYW52YXNfZWxlbWVudCgpO1xuICAgICAgICBpZiAoY2FudmFzLm1zVG9CbG9iICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJsb2IgPSBjYW52YXMubXNUb0Jsb2IoKTtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgbGluay5ocmVmID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gbmFtZTtcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgICAgICAgICAgIHJldHVybiBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGxvdENhbnZhc1ZpZXc7XG59KShib2tlaF92aWV3XzEuQm9rZWhWaWV3KTtcbmV4cG9ydHMuUGxvdENhbnZhcyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoUGxvdENhbnZhcywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGxvdENhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIFBsb3RDYW52YXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLnR5cGUgPSAnUGxvdENhbnZhcyc7XG4gICAgUGxvdENhbnZhcy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5QbG90Q2FudmFzVmlldztcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIFBsb3RDYW52YXMuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IGNhbnZhc18xLkNhbnZhcyh7XG4gICAgICAgICAgICBtYXA6IChyZWYgPSB0aGlzLnVzZV9tYXApICE9IG51bGwgPyByZWYgOiBmYWxzZSxcbiAgICAgICAgICAgIGluaXRpYWxfd2lkdGg6IHRoaXMucGxvdC5wbG90X3dpZHRoLFxuICAgICAgICAgICAgaW5pdGlhbF9oZWlnaHQ6IHRoaXMucGxvdC5wbG90X2hlaWdodCxcbiAgICAgICAgICAgIHVzZV9oaWRwaTogdGhpcy5wbG90LmhpZHBpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYW1lID0gbmV3IGNhcnRlc2lhbl9mcmFtZV8xLkNhcnRlc2lhbkZyYW1lKHtcbiAgICAgICAgICAgIHhfcmFuZ2U6IHRoaXMucGxvdC54X3JhbmdlLFxuICAgICAgICAgICAgZXh0cmFfeF9yYW5nZXM6IHRoaXMucGxvdC5leHRyYV94X3JhbmdlcyxcbiAgICAgICAgICAgIHhfbWFwcGVyX3R5cGU6IHRoaXMucGxvdC54X21hcHBlcl90eXBlLFxuICAgICAgICAgICAgeV9yYW5nZTogdGhpcy5wbG90LnlfcmFuZ2UsXG4gICAgICAgICAgICBleHRyYV95X3JhbmdlczogdGhpcy5wbG90LmV4dHJhX3lfcmFuZ2VzLFxuICAgICAgICAgICAgeV9tYXBwZXJfdHlwZTogdGhpcy5wbG90LnlfbWFwcGVyX3R5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWJvdmVfcGFuZWwgPSBuZXcgbGF5b3V0X2NhbnZhc18xLkxheW91dENhbnZhcygpO1xuICAgICAgICB0aGlzLmJlbG93X3BhbmVsID0gbmV3IGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5sZWZ0X3BhbmVsID0gbmV3IGxheW91dF9jYW52YXNfMS5MYXlvdXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5yaWdodF9wYW5lbCA9IG5ldyBsYXlvdXRfY2FudmFzXzEuTGF5b3V0Q2FudmFzKCk7XG4gICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGxvdENhbnZhcyBpbml0aWFsaXplZFwiKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLmFkZF9yZW5kZXJlcl90b19jYW52YXNfc2lkZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc2lkZSkge1xuICAgICAgICBpZiAoc2lkZSAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlci5hZGRfcGFuZWwoc2lkZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLl9kb2NfYXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5mcmFtZS5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMuYWJvdmVfcGFuZWwuYXR0YWNoX2RvY3VtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmJlbG93X3BhbmVsLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5sZWZ0X3BhbmVsLmF0dGFjaF9kb2N1bWVudCh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5yaWdodF9wYW5lbC5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiUGxvdENhbnZhcyBhdHRhY2hlZCB0byBkb2N1bWVudFwiKTtcbiAgICB9O1xuICAgIFBsb3RDYW52YXMub3ZlcnJpZGUoe1xuICAgICAgICBzaXppbmdfbW9kZTogJ3N0cmV0Y2hfYm90aCdcbiAgICB9KTtcbiAgICBQbG90Q2FudmFzLmludGVybmFsKHtcbiAgICAgICAgcGxvdDogW3AuSW5zdGFuY2VdLFxuICAgICAgICB0b29sYmFyOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIGNhbnZhczogW3AuSW5zdGFuY2VdLFxuICAgICAgICBmcmFtZTogW3AuSW5zdGFuY2VdXG4gICAgfSk7XG4gICAgUGxvdENhbnZhcy5wcm90b3R5cGUuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiwgY29sbGVjdF9wYW5lbHM7XG4gICAgICAgIGNoaWxkcmVuID0gW3RoaXMuYWJvdmVfcGFuZWwsIHRoaXMuYmVsb3dfcGFuZWwsIHRoaXMubGVmdF9wYW5lbCwgdGhpcy5yaWdodF9wYW5lbCwgdGhpcy5jYW52YXMsIHRoaXMuZnJhbWVdO1xuICAgICAgICBjb2xsZWN0X3BhbmVscyA9IGZ1bmN0aW9uIChsYXlvdXRfcmVuZGVyZXJzKSB7XG4gICAgICAgICAgICB2YXIgaiwgbGVuLCByLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbGF5b3V0X3JlbmRlcmVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHIgPSBsYXlvdXRfcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChyLnBhbmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkcmVuLnB1c2goci5wYW5lbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbGxlY3RfcGFuZWxzKHRoaXMucGxvdC5hYm92ZSk7XG4gICAgICAgIGNvbGxlY3RfcGFuZWxzKHRoaXMucGxvdC5iZWxvdyk7XG4gICAgICAgIGNvbGxlY3RfcGFuZWxzKHRoaXMucGxvdC5sZWZ0KTtcbiAgICAgICAgY29sbGVjdF9wYW5lbHModGhpcy5wbG90LnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgUGxvdENhbnZhcy5wcm90b3R5cGUuZ2V0X2VkaXRfdmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGVkaXRfdmFyaWFibGVzLCBqLCBsZW4sIHJlZjtcbiAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgcmVmID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBlZGl0X3ZhcmlhYmxlcy5jb25jYXQoY2hpbGQuZ2V0X2VkaXRfdmFyaWFibGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjb25zdHJhaW50cywgaiwgbGVuLCByZWY7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gUGxvdENhbnZhcy5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KHRoaXMuX2dldF9jb25zdGFudF9jb25zdHJhaW50cygpKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQodGhpcy5fZ2V0X3NpZGVfY29uc3RyYWludHMoKSk7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltqXTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KGNoaWxkLmdldF9jb25zdHJhaW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5fZ2V0X2NvbnN0YW50X2NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uc3RyYWludHMsIG1pbl9ib3JkZXJfYm90dG9tLCBtaW5fYm9yZGVyX2xlZnQsIG1pbl9ib3JkZXJfcmlnaHQsIG1pbl9ib3JkZXJfdG9wO1xuICAgICAgICBtaW5fYm9yZGVyX3RvcCA9IHRoaXMucGxvdC5taW5fYm9yZGVyX3RvcDtcbiAgICAgICAgbWluX2JvcmRlcl9ib3R0b20gPSB0aGlzLnBsb3QubWluX2JvcmRlcl9ib3R0b207XG4gICAgICAgIG1pbl9ib3JkZXJfbGVmdCA9IHRoaXMucGxvdC5taW5fYm9yZGVyX2xlZnQ7XG4gICAgICAgIG1pbl9ib3JkZXJfcmlnaHQgPSB0aGlzLnBsb3QubWluX2JvcmRlcl9yaWdodDtcbiAgICAgICAgY29uc3RyYWludHMgPSBbXTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5HRSh0aGlzLmFib3ZlX3BhbmVsLl9oZWlnaHQsIC1taW5fYm9yZGVyX3RvcCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMuYmVsb3dfcGFuZWwuX2hlaWdodCwgLW1pbl9ib3JkZXJfYm90dG9tKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuR0UodGhpcy5sZWZ0X3BhbmVsLl93aWR0aCwgLW1pbl9ib3JkZXJfbGVmdCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkdFKHRoaXMucmlnaHRfcGFuZWwuX3dpZHRoLCAtbWluX2JvcmRlcl9yaWdodCkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuYWJvdmVfcGFuZWwuX3RvcCwgWy0xLCB0aGlzLmNhbnZhcy5fdG9wXSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuYWJvdmVfcGFuZWwuX2JvdHRvbSwgWy0xLCB0aGlzLmZyYW1lLl90b3BdKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5iZWxvd19wYW5lbC5fYm90dG9tLCBbLTEsIHRoaXMuY2FudmFzLl9ib3R0b21dKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5iZWxvd19wYW5lbC5fdG9wLCBbLTEsIHRoaXMuZnJhbWUuX2JvdHRvbV0pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLmxlZnRfcGFuZWwuX2xlZnQsIFstMSwgdGhpcy5jYW52YXMuX2xlZnRdKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5sZWZ0X3BhbmVsLl9yaWdodCwgWy0xLCB0aGlzLmZyYW1lLl9sZWZ0XSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMucmlnaHRfcGFuZWwuX3JpZ2h0LCBbLTEsIHRoaXMuY2FudmFzLl9yaWdodF0pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLnJpZ2h0X3BhbmVsLl9sZWZ0LCBbLTEsIHRoaXMuZnJhbWUuX3JpZ2h0XSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMuYWJvdmVfcGFuZWwuX2hlaWdodCwgWy0xLCB0aGlzLl90b3BdKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5hYm92ZV9wYW5lbC5faGVpZ2h0LCBbLTEsIHRoaXMuY2FudmFzLl90b3BdLCB0aGlzLmZyYW1lLl90b3ApKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLmJlbG93X3BhbmVsLl9oZWlnaHQsIFstMSwgdGhpcy5faGVpZ2h0XSwgdGhpcy5fYm90dG9tKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5iZWxvd19wYW5lbC5faGVpZ2h0LCBbLTEsIHRoaXMuZnJhbWUuX2JvdHRvbV0pKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLmxlZnRfcGFuZWwuX3dpZHRoLCBbLTEsIHRoaXMuX2xlZnRdKSk7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2goc29sdmVyXzEuRVEodGhpcy5sZWZ0X3BhbmVsLl93aWR0aCwgWy0xLCB0aGlzLmZyYW1lLl9sZWZ0XSkpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKHNvbHZlcl8xLkVRKHRoaXMucmlnaHRfcGFuZWwuX3dpZHRoLCBbLTEsIHRoaXMuX3dpZHRoXSwgdGhpcy5fcmlnaHQpKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLnJpZ2h0X3BhbmVsLl93aWR0aCwgWy0xLCB0aGlzLmNhbnZhcy5fcmlnaHRdLCB0aGlzLmZyYW1lLl9yaWdodCkpO1xuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBQbG90Q2FudmFzLnByb3RvdHlwZS5fZ2V0X3NpZGVfY29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50LCBjb25zdHJhaW50cywgaiwgbCwgbGFzdCwgbGF5b3V0X3JlbmRlcmVycywgbGVuLCBsZW4xLCByLCByZWYsIHNpZGUsIHNpZGVzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgICBzaWRlcyA9IFtbJ2Fib3ZlJywgdGhpcy5wbG90LmFib3ZlXSwgWydiZWxvdycsIHRoaXMucGxvdC5iZWxvd10sIFsnbGVmdCcsIHRoaXMucGxvdC5sZWZ0XSwgWydyaWdodCcsIHRoaXMucGxvdC5yaWdodF1dO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBzaWRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgcmVmID0gc2lkZXNbal0sIHNpZGUgPSByZWZbMF0sIGxheW91dF9yZW5kZXJlcnMgPSByZWZbMV07XG4gICAgICAgICAgICBsYXN0ID0gdGhpcy5mcmFtZTtcbiAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjEgPSBsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aDsgbCA8IGxlbjE7IGwrKykge1xuICAgICAgICAgICAgICAgIHIgPSBsYXlvdXRfcmVuZGVyZXJzW2xdO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl90b3AsIFstMSwgci5wYW5lbC5fYm90dG9tXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmVsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fYm90dG9tLCBbLTEsIHIucGFuZWwuX3RvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fbGVmdCwgWy0xLCByLnBhbmVsLl9yaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHZlcl8xLkVRKGxhc3QucGFuZWwuX3JpZ2h0LCBbLTEsIHIucGFuZWwuX2xlZnRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRfcmVuZGVyZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhYm92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl90b3AsIFstMSwgdGhpcy5hYm92ZV9wYW5lbC5fdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmVsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fYm90dG9tLCBbLTEsIHRoaXMuYmVsb3dfcGFuZWwuX2JvdHRvbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdmVyXzEuRVEobGFzdC5wYW5lbC5fbGVmdCwgWy0xLCB0aGlzLmxlZnRfcGFuZWwuX2xlZnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZXJfMS5FUShsYXN0LnBhbmVsLl9yaWdodCwgWy0xLCB0aGlzLnJpZ2h0X3BhbmVsLl9yaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIFBsb3RDYW52YXMucHJvdG90eXBlLnBsb3RfY2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBQbG90Q2FudmFzO1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5EYXRhUmFuZ2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0YVJhbmdlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEYXRhUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBEYXRhUmFuZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERhdGFSYW5nZS5wcm90b3R5cGUudHlwZSA9ICdEYXRhUmFuZ2UnO1xuICAgIERhdGFSYW5nZS5kZWZpbmUoe1xuICAgICAgICBuYW1lczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgcmVuZGVyZXJzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFSYW5nZTtcbn0pKHJhbmdlXzEuUmFuZ2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGRhdGFfcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2RhdGFfcmFuZ2VcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBiYm94ID0gcmVxdWlyZShcImNvcmUvdXRpbC9iYm94XCIpO1xuZXhwb3J0cy5EYXRhUmFuZ2UxZCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRhUmFuZ2UxZCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0YVJhbmdlMWQoKSB7XG4gICAgICAgIHJldHVybiBEYXRhUmFuZ2UxZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLnR5cGUgPSAnRGF0YVJhbmdlMWQnO1xuICAgIERhdGFSYW5nZTFkLmRlZmluZSh7XG4gICAgICAgIHN0YXJ0OiBbcC5OdW1iZXJdLFxuICAgICAgICBlbmQ6IFtwLk51bWJlcl0sXG4gICAgICAgIHJhbmdlX3BhZGRpbmc6IFtwLk51bWJlciwgMC4xXSxcbiAgICAgICAgZmxpcHBlZDogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBmb2xsb3c6IFtwLlN0cmluZ10sXG4gICAgICAgIGZvbGxvd19pbnRlcnZhbDogW3AuTnVtYmVyXSxcbiAgICAgICAgZGVmYXVsdF9zcGFuOiBbcC5OdW1iZXIsIDJdLFxuICAgICAgICBib3VuZHM6IFtwLkFueV0sXG4gICAgICAgIG1pbl9pbnRlcnZhbDogW3AuQW55XSxcbiAgICAgICAgbWF4X2ludGVydmFsOiBbcC5BbnldXG4gICAgfSk7XG4gICAgRGF0YVJhbmdlMWQuaW50ZXJuYWwoe1xuICAgICAgICBtYXBwZXJfaGludDogW3AuU3RyaW5nLCAnYXV0byddXG4gICAgfSk7XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgRGF0YVJhbmdlMWQuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGxvdF9ib3VuZHMgPSB7fTtcbiAgICAgICAgdGhpcy5oYXZlX3VwZGF0ZWRfaW50ZXJhY3RpdmVseSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsX3N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdGhpcy5faW5pdGlhbF9lbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5faW5pdGlhbF9yYW5nZV9wYWRkaW5nID0gdGhpcy5yYW5nZV9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9pbml0aWFsX2ZvbGxvdyA9IHRoaXMuZm9sbG93O1xuICAgICAgICB0aGlzLl9pbml0aWFsX2ZvbGxvd19pbnRlcnZhbCA9IHRoaXMuZm9sbG93X2ludGVydmFsO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbF9kZWZhdWx0X3NwYW4gPSB0aGlzLmRlZmF1bHRfc3BhbjtcbiAgICB9O1xuICAgIERhdGFSYW5nZTFkLmdldHRlcnMoe1xuICAgICAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1heDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERhdGFSYW5nZTFkLnByb3RvdHlwZS5jb21wdXRlZF9yZW5kZXJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbGxfcmVuZGVyZXJzLCBpLCBqLCBsZW4sIGxlbjEsIG5hbWVzLCBwbG90LCByLCByZWYsIHJlbmRlcmVycywgcnM7XG4gICAgICAgIG5hbWVzID0gdGhpcy5uYW1lcztcbiAgICAgICAgcmVuZGVyZXJzID0gdGhpcy5yZW5kZXJlcnM7XG4gICAgICAgIGlmIChyZW5kZXJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnBsb3RzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGxvdCA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBhbGxfcmVuZGVyZXJzID0gcGxvdC5yZW5kZXJlcnM7XG4gICAgICAgICAgICAgICAgcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiwgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gYWxsX3JlbmRlcmVycy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhbGxfcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlcnMgPSByZW5kZXJlcnMuY29uY2F0KHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlbmRlcmVycy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJlbmRlcmVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzLmluZGV4T2Yoci5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJjb21wdXRlZCBcIiArIHJlbmRlcmVycy5sZW5ndGggKyBcIiByZW5kZXJlcnMgZm9yIERhdGFSYW5nZTFkIFwiICsgdGhpcy5pZCk7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIiAtIFwiICsgci50eXBlICsgXCIgXCIgKyByLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgIH07XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLl9jb21wdXRlX3Bsb3RfYm91bmRzID0gZnVuY3Rpb24gKHJlbmRlcmVycywgYm91bmRzKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHIsIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gYmJveC5lbXB0eSgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZW5kZXJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHIgPSByZW5kZXJlcnNbaV07XG4gICAgICAgICAgICBpZiAoYm91bmRzW3IuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBiYm94LnVuaW9uKHJlc3VsdCwgYm91bmRzW3IuaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLl9jb21wdXRlX21pbl9tYXggPSBmdW5jdGlvbiAocGxvdF9ib3VuZHMsIGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgaywgbWF4LCBtaW4sIG92ZXJhbGwsIHJlZiwgcmVmMSwgdjtcbiAgICAgICAgb3ZlcmFsbCA9IGJib3guZW1wdHkoKTtcbiAgICAgICAgZm9yIChrIGluIHBsb3RfYm91bmRzKSB7XG4gICAgICAgICAgICB2ID0gcGxvdF9ib3VuZHNba107XG4gICAgICAgICAgICBvdmVyYWxsID0gYmJveC51bmlvbihvdmVyYWxsLCB2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAwKSB7XG4gICAgICAgICAgICByZWYgPSBbb3ZlcmFsbC5taW5YLCBvdmVyYWxsLm1heFhdLCBtaW4gPSByZWZbMF0sIG1heCA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjEgPSBbb3ZlcmFsbC5taW5ZLCBvdmVyYWxsLm1heFldLCBtaW4gPSByZWYxWzBdLCBtYXggPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH07XG4gICAgRGF0YVJhbmdlMWQucHJvdG90eXBlLl9jb21wdXRlX3JhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBjZW50ZXIsIGVuZCwgZm9sbG93X2ludGVydmFsLCBmb2xsb3dfc2lnbiwgbG9nX21heCwgbG9nX21pbiwgcmFuZ2VfcGFkZGluZywgcmVmLCByZWYxLCByZWYyLCByZWYzLCBzcGFuLCBzdGFydDtcbiAgICAgICAgcmFuZ2VfcGFkZGluZyA9IHRoaXMucmFuZ2VfcGFkZGluZztcbiAgICAgICAgaWYgKChyYW5nZV9wYWRkaW5nICE9IG51bGwpICYmIHJhbmdlX3BhZGRpbmcgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBwZXJfaGludCA9PT0gXCJsb2dcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pIHx8IG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpIHx8IG1heCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAwLjE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBtYXggLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKFwiY291bGQgbm90IGRldGVybWluZSBtaW5pbXVtIGRhdGEgdmFsdWUgZm9yIGxvZyBheGlzLCBEYXRhUmFuZ2UxZCB1c2luZyB2YWx1ZSBcIiArIG1pbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpIHx8IG1heCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW4pIHx8ICFpc0Zpbml0ZShtaW4pIHx8IG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1pbiAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oXCJjb3VsZCBub3QgZGV0ZXJtaW5lIG1heGltdW0gZGF0YSB2YWx1ZSBmb3IgbG9nIGF4aXMsIERhdGFSYW5nZTFkIHVzaW5nIHZhbHVlIFwiICsgbWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nX21pbiA9IE1hdGgubG9nKG1pbikgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgbG9nX21heCA9IE1hdGgubG9nKG1heCkgLyBNYXRoLmxvZygxMCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4gPSB0aGlzLmRlZmF1bHRfc3BhbiArIDAuMDAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9IChsb2dfbWF4IC0gbG9nX21pbikgKiAoMSArIHJhbmdlX3BhZGRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZW50ZXIgPSAobG9nX21pbiArIGxvZ19tYXgpIC8gMi4wO1xuICAgICAgICAgICAgICAgIHJlZiA9IFtNYXRoLnBvdygxMCwgY2VudGVyIC0gc3BhbiAvIDIuMCksIE1hdGgucG93KDEwLCBjZW50ZXIgKyBzcGFuIC8gMi4wKV0sIHN0YXJ0ID0gcmVmWzBdLCBlbmQgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9IHRoaXMuZGVmYXVsdF9zcGFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9IChtYXggLSBtaW4pICogKDEgKyByYW5nZV9wYWRkaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VudGVyID0gKG1heCArIG1pbikgLyAyLjA7XG4gICAgICAgICAgICAgICAgcmVmMSA9IFtjZW50ZXIgLSBzcGFuIC8gMi4wLCBjZW50ZXIgKyBzcGFuIC8gMi4wXSwgc3RhcnQgPSByZWYxWzBdLCBlbmQgPSByZWYxWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMiA9IFttaW4sIG1heF0sIHN0YXJ0ID0gcmVmMlswXSwgZW5kID0gcmVmMlsxXTtcbiAgICAgICAgfVxuICAgICAgICBmb2xsb3dfc2lnbiA9ICsxO1xuICAgICAgICBpZiAodGhpcy5mbGlwcGVkKSB7XG4gICAgICAgICAgICByZWYzID0gW2VuZCwgc3RhcnRdLCBzdGFydCA9IHJlZjNbMF0sIGVuZCA9IHJlZjNbMV07XG4gICAgICAgICAgICBmb2xsb3dfc2lnbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvbGxvd19pbnRlcnZhbCA9IHRoaXMuZm9sbG93X2ludGVydmFsO1xuICAgICAgICBpZiAoKGZvbGxvd19pbnRlcnZhbCAhPSBudWxsKSAmJiBNYXRoLmFicyhzdGFydCAtIGVuZCkgPiBmb2xsb3dfaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdyA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgZm9sbG93X3NpZ24gKiBmb2xsb3dfaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZvbGxvdyA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZCAtIGZvbGxvd19zaWduICogZm9sbG93X2ludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfTtcbiAgICBEYXRhUmFuZ2UxZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJvdW5kcywgZGltZW5zaW9uLCBib3VuZHNfaWQpIHtcbiAgICAgICAgdmFyIF9lbmQsIF9zdGFydCwgZW5kLCBtYXgsIG1pbiwgbmV3X3JhbmdlLCByZWYsIHJlZjEsIHJlZjIsIHJlbmRlcmVycywgc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmhhdmVfdXBkYXRlZF9pbnRlcmFjdGl2ZWx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJzID0gdGhpcy5jb21wdXRlZF9yZW5kZXJlcnMoKTtcbiAgICAgICAgdGhpcy5wbG90X2JvdW5kc1tib3VuZHNfaWRdID0gdGhpcy5fY29tcHV0ZV9wbG90X2JvdW5kcyhyZW5kZXJlcnMsIGJvdW5kcyk7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NvbXB1dGVfbWluX21heCh0aGlzLnBsb3RfYm91bmRzLCBkaW1lbnNpb24pLCBtaW4gPSByZWZbMF0sIG1heCA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMuX2NvbXB1dGVfcmFuZ2UobWluLCBtYXgpLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsX3N0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcHBlcl9oaW50ID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxfc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5faW5pdGlhbF9zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2luaXRpYWxfc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxfZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcHBlcl9oaW50ID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxfZW5kID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9pbml0aWFsX2VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9pbml0aWFsX2VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWYyID0gW3RoaXMuc3RhcnQsIHRoaXMuZW5kXSwgX3N0YXJ0ID0gcmVmMlswXSwgX2VuZCA9IHJlZjJbMV07XG4gICAgICAgIGlmIChzdGFydCAhPT0gX3N0YXJ0IHx8IGVuZCAhPT0gX2VuZCkge1xuICAgICAgICAgICAgbmV3X3JhbmdlID0ge307XG4gICAgICAgICAgICBpZiAoc3RhcnQgIT09IF9zdGFydCkge1xuICAgICAgICAgICAgICAgIG5ld19yYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCAhPT0gX2VuZCkge1xuICAgICAgICAgICAgICAgIG5ld19yYW5nZS5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHYobmV3X3JhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3VuZHMgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBib3VuZHM6IFtzdGFydCwgZW5kXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfTtcbiAgICBEYXRhUmFuZ2UxZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGF2ZV91cGRhdGVkX2ludGVyYWN0aXZlbHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgIHJhbmdlX3BhZGRpbmc6IHRoaXMuX2luaXRpYWxfcmFuZ2VfcGFkZGluZyxcbiAgICAgICAgICAgIGZvbGxvdzogdGhpcy5faW5pdGlhbF9mb2xsb3csXG4gICAgICAgICAgICBmb2xsb3dfaW50ZXJ2YWw6IHRoaXMuX2luaXRpYWxfZm9sbG93X2ludGVydmFsLFxuICAgICAgICAgICAgZGVmYXVsdF9zcGFuOiB0aGlzLl9pbml0aWFsX2RlZmF1bHRfc3BhblxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFSYW5nZTFkO1xufSkoZGF0YV9yYW5nZV8xLkRhdGFSYW5nZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5GYWN0b3JSYW5nZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGYWN0b3JSYW5nZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRmFjdG9yUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBGYWN0b3JSYW5nZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLnR5cGUgPSAnRmFjdG9yUmFuZ2UnO1xuICAgIEZhY3RvclJhbmdlLmRlZmluZSh7XG4gICAgICAgIG9mZnNldDogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgZmFjdG9yczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYm91bmRzOiBbcC5BbnldLFxuICAgICAgICBtaW5faW50ZXJ2YWw6IFtwLkFueV0sXG4gICAgICAgIG1heF9pbnRlcnZhbDogW3AuQW55XVxuICAgIH0pO1xuICAgIEZhY3RvclJhbmdlLmludGVybmFsKHtcbiAgICAgICAgX2JvdW5kc19hc19mYWN0b3JzOiBbcC5BbnldLFxuICAgICAgICBzdGFydDogW3AuTnVtYmVyXSxcbiAgICAgICAgZW5kOiBbcC5OdW1iZXJdXG4gICAgfSk7XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgRmFjdG9yUmFuZ2UuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIGlmICgodGhpcy5ib3VuZHMgIT0gbnVsbCkgJiYgdGhpcy5ib3VuZHMgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBfYm91bmRzX2FzX2ZhY3RvcnM6IHRoaXMuYm91bmRzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dih7XG4gICAgICAgICAgICAgICAgX2JvdW5kc19hc19mYWN0b3JzOiB0aGlzLmZhY3RvcnNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCAnY2hhbmdlOmZhY3RvcnMnLCB0aGlzLl91cGRhdGVfZmFjdG9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6b2Zmc2V0JywgdGhpcy5faW5pdCk7XG4gICAgfTtcbiAgICBGYWN0b3JSYW5nZS5nZXR0ZXJzKHtcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBGYWN0b3JSYW5nZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfTtcbiAgICBGYWN0b3JSYW5nZS5wcm90b3R5cGUuX3VwZGF0ZV9mYWN0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldHYoJ19ib3VuZHNfYXNfZmFjdG9ycycsIHRoaXMuZmFjdG9ycywge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdCgpO1xuICAgIH07XG4gICAgRmFjdG9yUmFuZ2UucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW5kLCBmYWN0b3JzLCBzdGFydDtcbiAgICAgICAgZmFjdG9ycyA9IHRoaXMuZmFjdG9ycztcbiAgICAgICAgaWYgKCh0aGlzLmJvdW5kcyAhPSBudWxsKSAmJiB0aGlzLmJvdW5kcyAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBmYWN0b3JzID0gdGhpcy5fYm91bmRzX2FzX2ZhY3RvcnM7XG4gICAgICAgICAgICB0aGlzLnNldHYoe1xuICAgICAgICAgICAgICAgIGZhY3RvcnM6IGZhY3RvcnNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMC41ICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIGVuZCA9IGZhY3RvcnMubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHRoaXMuc2V0dih7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBib3VuZHM6IFtzdGFydCwgZW5kXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGYWN0b3JSYW5nZTtcbn0pKHJhbmdlXzEuUmFuZ2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9yYW5nZV8xID0gcmVxdWlyZShcIi4vZGF0YV9yYW5nZVwiKTtcbmV4cG9ydHMuRGF0YVJhbmdlID0gZGF0YV9yYW5nZV8xLkRhdGFSYW5nZTtcbnZhciBkYXRhX3JhbmdlMWRfMSA9IHJlcXVpcmUoXCIuL2RhdGFfcmFuZ2UxZFwiKTtcbmV4cG9ydHMuRGF0YVJhbmdlMWQgPSBkYXRhX3JhbmdlMWRfMS5EYXRhUmFuZ2UxZDtcbnZhciBmYWN0b3JfcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2ZhY3Rvcl9yYW5nZVwiKTtcbmV4cG9ydHMuRmFjdG9yUmFuZ2UgPSBmYWN0b3JfcmFuZ2VfMS5GYWN0b3JSYW5nZTtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG5leHBvcnRzLlJhbmdlID0gcmFuZ2VfMS5SYW5nZTtcbnZhciByYW5nZTFkXzEgPSByZXF1aXJlKFwiLi9yYW5nZTFkXCIpO1xuZXhwb3J0cy5SYW5nZTFkID0gcmFuZ2UxZF8xLlJhbmdlMWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUmFuZ2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmFuZ2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJhbmdlKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJhbmdlLnByb3RvdHlwZS50eXBlID0gJ1JhbmdlJztcbiAgICBSYW5nZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFJhbmdlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcykgOiB2b2lkIDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UuZGVmaW5lKHtcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIFJhbmdlLmludGVybmFsKHtcbiAgICAgICAgcGxvdHM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBSYW5nZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFwiVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHJlaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhbmQgZW5zdXJlIHRoYXRcXG50aGUgY2FsbGJhY2ssIGlmIGV4aXN0cywgaXMgZXhlY3V0ZWQgYXQgY29tcGxldGlvbi5cIjtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2U7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlJhbmdlMWQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmFuZ2UxZCwgc3VwZXJDbGFzcyk7XG4gICAgUmFuZ2UxZC5wcm90b3R5cGUudHlwZSA9ICdSYW5nZTFkJztcbiAgICBSYW5nZTFkLmRlZmluZSh7XG4gICAgICAgIHN0YXJ0OiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBlbmQ6IFtwLk51bWJlciwgMV0sXG4gICAgICAgIGJvdW5kczogW3AuQW55XSxcbiAgICAgICAgbWluX2ludGVydmFsOiBbcC5BbnldLFxuICAgICAgICBtYXhfaW50ZXJ2YWw6IFtwLkFueV1cbiAgICB9KTtcbiAgICBSYW5nZTFkLnByb3RvdHlwZS5fc2V0X2F1dG9fYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4LCBtaW47XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbih0aGlzLl9pbml0aWFsX3N0YXJ0LCB0aGlzLl9pbml0aWFsX2VuZCk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heCh0aGlzLl9pbml0aWFsX3N0YXJ0LCB0aGlzLl9pbml0aWFsX2VuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR2KHtcbiAgICAgICAgICAgICAgICBib3VuZHM6IFttaW4sIG1heF1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBSYW5nZTFkKCkge1xuICAgICAgICB2YXIgZW5kLCBzdGFydDtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYW5nZTFkKSB7XG4gICAgICAgICAgICByZXR1cm4gUmFuZ2UxZC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gYXJndW1lbnRzWzBdLCBlbmQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlMWQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UxZC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBSYW5nZTFkLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0aWFsX3N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdGhpcy5faW5pdGlhbF9lbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldF9hdXRvX2JvdW5kcygpO1xuICAgIH07XG4gICAgUmFuZ2UxZC5nZXR0ZXJzKHtcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBSYW5nZTFkLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0X2F1dG9fYm91bmRzKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB0aGlzLl9pbml0aWFsX3N0YXJ0IHx8IHRoaXMuZW5kICE9PSB0aGlzLl9pbml0aWFsX2VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX2luaXRpYWxfc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLl9pbml0aWFsX2VuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlMWQ7XG59KShyYW5nZV8xLlJhbmdlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZDEgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyXCIpO1xudmFyIHJlbW90ZV9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4uL3NvdXJjZXMvcmVtb3RlX2RhdGFfc291cmNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbmV4cG9ydHMuR2x5cGhSZW5kZXJlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKEdseXBoUmVuZGVyZXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHbHlwaFJlbmRlcmVyVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEdseXBoUmVuZGVyZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBiYXNlX2dseXBoLCBkZWNpbWF0ZWRfZ2x5cGgsIGdseXBoX2F0dHJzLCBoYXNfZmlsbCwgaGFzX2xpbmUsIGhvdmVyX2dseXBoLCBta19nbHlwaCwgbXV0ZWRfZ2x5cGgsIG5vbnNlbGVjdGlvbl9nbHlwaCwgc2VsZWN0aW9uX2dseXBoO1xuICAgICAgICBHbHlwaFJlbmRlcmVyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBiYXNlX2dseXBoID0gdGhpcy5tb2RlbC5nbHlwaDtcbiAgICAgICAgaGFzX2ZpbGwgPSBpbmRleE9mLmNhbGwoYmFzZV9nbHlwaC5taXhpbnMsIFwiZmlsbFwiKSA+PSAwO1xuICAgICAgICBoYXNfbGluZSA9IGluZGV4T2YuY2FsbChiYXNlX2dseXBoLm1peGlucywgXCJsaW5lXCIpID49IDA7XG4gICAgICAgIGdseXBoX2F0dHJzID0gb2JqZWN0XzEuY2xvbmUoYmFzZV9nbHlwaC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZGVsZXRlIGdseXBoX2F0dHJzLmlkO1xuICAgICAgICBta19nbHlwaCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICAgICAgICAgICAgdmFyIGF0dHJzO1xuICAgICAgICAgICAgYXR0cnMgPSBvYmplY3RfMS5jbG9uZShnbHlwaF9hdHRycyk7XG4gICAgICAgICAgICBpZiAoaGFzX2ZpbGwpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RfMS5leHRlbmQoYXR0cnMsIGRlZmF1bHRzLmZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc19saW5lKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0XzEuZXh0ZW5kKGF0dHJzLCBkZWZhdWx0cy5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgYmFzZV9nbHlwaC5jb25zdHJ1Y3RvcihhdHRycyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2x5cGggPSB0aGlzLmJ1aWxkX2dseXBoX3ZpZXcoYmFzZV9nbHlwaCk7XG4gICAgICAgIHNlbGVjdGlvbl9nbHlwaCA9IHRoaXMubW9kZWwuc2VsZWN0aW9uX2dseXBoO1xuICAgICAgICBpZiAoc2VsZWN0aW9uX2dseXBoID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9nbHlwaCA9IG1rX2dseXBoKHtcbiAgICAgICAgICAgICAgICBmaWxsOiB7fSxcbiAgICAgICAgICAgICAgICBsaW5lOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uX2dseXBoID09PSBcImF1dG9cIikge1xuICAgICAgICAgICAgc2VsZWN0aW9uX2dseXBoID0gbWtfZ2x5cGgodGhpcy5tb2RlbC5zZWxlY3Rpb25fZGVmYXVsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uX2dseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KHNlbGVjdGlvbl9nbHlwaCk7XG4gICAgICAgIG5vbnNlbGVjdGlvbl9nbHlwaCA9IHRoaXMubW9kZWwubm9uc2VsZWN0aW9uX2dseXBoO1xuICAgICAgICBpZiAobm9uc2VsZWN0aW9uX2dseXBoID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vbnNlbGVjdGlvbl9nbHlwaCA9IG1rX2dseXBoKHtcbiAgICAgICAgICAgICAgICBmaWxsOiB7fSxcbiAgICAgICAgICAgICAgICBsaW5lOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9uc2VsZWN0aW9uX2dseXBoID09PSBcImF1dG9cIikge1xuICAgICAgICAgICAgbm9uc2VsZWN0aW9uX2dseXBoID0gbWtfZ2x5cGgodGhpcy5tb2RlbC5ub25zZWxlY3Rpb25fZGVmYXVsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9uc2VsZWN0aW9uX2dseXBoID0gdGhpcy5idWlsZF9nbHlwaF92aWV3KG5vbnNlbGVjdGlvbl9nbHlwaCk7XG4gICAgICAgIGhvdmVyX2dseXBoID0gdGhpcy5tb2RlbC5ob3Zlcl9nbHlwaDtcbiAgICAgICAgaWYgKGhvdmVyX2dseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJfZ2x5cGggPSB0aGlzLmJ1aWxkX2dseXBoX3ZpZXcoaG92ZXJfZ2x5cGgpO1xuICAgICAgICB9XG4gICAgICAgIG11dGVkX2dseXBoID0gdGhpcy5tb2RlbC5tdXRlZF9nbHlwaDtcbiAgICAgICAgaWYgKG11dGVkX2dseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubXV0ZWRfZ2x5cGggPSB0aGlzLmJ1aWxkX2dseXBoX3ZpZXcobXV0ZWRfZ2x5cGgpO1xuICAgICAgICB9XG4gICAgICAgIGRlY2ltYXRlZF9nbHlwaCA9IG1rX2dseXBoKHRoaXMubW9kZWwuZGVjaW1hdGVkX2RlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5kZWNpbWF0ZWRfZ2x5cGggPSB0aGlzLmJ1aWxkX2dseXBoX3ZpZXcoZGVjaW1hdGVkX2dseXBoKTtcbiAgICAgICAgdGhpcy54bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueF9tYXBwZXJzW3RoaXMubW9kZWwueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy55bWFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUueV9tYXBwZXJzW3RoaXMubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgdGhpcy5zZXRfZGF0YShmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmRhdGFfc291cmNlIGluc3RhbmNlb2YgcmVtb3RlX2RhdGFfc291cmNlXzEuUmVtb3RlRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGF0YV9zb3VyY2Uuc2V0dXAodGhpcy5wbG90X3ZpZXcsIHRoaXMuZ2x5cGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuYnVpbGRfZ2x5cGhfdmlldyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsLmRlZmF1bHRfdmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICAgIHBsb3RfdmlldzogdGhpcy5wbG90X3ZpZXdcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMucmVxdWVzdF9yZW5kZXIpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuZGF0YV9zb3VyY2UsICdjaGFuZ2UnLCB0aGlzLnNldF9kYXRhKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmRhdGFfc291cmNlLCAncGF0Y2gnLCB0aGlzLnNldF9kYXRhKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmRhdGFfc291cmNlLCAnc3RyZWFtJywgdGhpcy5zZXRfZGF0YSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbC5kYXRhX3NvdXJjZSwgJ3NlbGVjdCcsIHRoaXMucmVxdWVzdF9yZW5kZXIpO1xuICAgICAgICBpZiAodGhpcy5ob3Zlcl9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuZGF0YV9zb3VyY2UsICdpbnNwZWN0JywgdGhpcy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmdseXBoLCAndHJhbnNmb3JtY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0X2RhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwuZ2x5cGgsICdwcm9wY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nbHlwaC5zZXRfdmlzdWFscyh0aGlzLm1vZGVsLmRhdGFfc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlclZpZXcucHJvdG90eXBlLmhhdmVfc2VsZWN0aW9uX2dseXBocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlbGVjdGlvbl9nbHlwaCAhPSBudWxsKSAmJiAodGhpcy5ub25zZWxlY3Rpb25fZ2x5cGggIT0gbnVsbCk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuc2V0X2RhdGEgPSBmdW5jdGlvbiAocmVxdWVzdF9yZW5kZXIsIGFyZykge1xuICAgICAgICB2YXIgZHQsIGksIGosIGssIGxlbmd0aCwgbG9kX2ZhY3RvciwgcmVmLCByZXN1bHRzLCBzb3VyY2UsIHQwO1xuICAgICAgICBpZiAocmVxdWVzdF9yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdF9yZW5kZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHQwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5tb2RlbC5kYXRhX3NvdXJjZTtcbiAgICAgICAgdGhpcy5nbHlwaC5tb2RlbC5zZXR2KHtcbiAgICAgICAgICAgIHhfcmFuZ2VfbmFtZTogdGhpcy5tb2RlbC54X3JhbmdlX25hbWUsXG4gICAgICAgICAgICB5X3JhbmdlX25hbWU6IHRoaXMubW9kZWwueV9yYW5nZV9uYW1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nbHlwaC5zZXRfZGF0YShzb3VyY2UsIGFyZyk7XG4gICAgICAgIHRoaXMuZ2x5cGguc2V0X3Zpc3VhbHMoc291cmNlKTtcbiAgICAgICAgdGhpcy5kZWNpbWF0ZWRfZ2x5cGguc2V0X3Zpc3VhbHMoc291cmNlKTtcbiAgICAgICAgaWYgKHRoaXMuaGF2ZV9zZWxlY3Rpb25fZ2x5cGhzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX2dseXBoLnNldF92aXN1YWxzKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLm5vbnNlbGVjdGlvbl9nbHlwaC5zZXRfdmlzdWFscyhzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvdmVyX2dseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJfZ2x5cGguc2V0X3Zpc3VhbHMoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tdXRlZF9nbHlwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm11dGVkX2dseXBoLnNldF92aXN1YWxzKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmdldF9sZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsX2luZGljZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IDAgPD0gbGVuZ3RoID8gaiA8IGxlbmd0aCA6IGogPiBsZW5ndGg7IDAgPD0gbGVuZ3RoID8gaisrIDogai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmFwcGx5KHRoaXMpO1xuICAgICAgICBsb2RfZmFjdG9yID0gdGhpcy5wbG90X21vZGVsLnBsb3QubG9kX2ZhY3RvcjtcbiAgICAgICAgdGhpcy5kZWNpbWF0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZiA9IE1hdGguZmxvb3IodGhpcy5hbGxfaW5kaWNlcy5sZW5ndGggLyBsb2RfZmFjdG9yKTsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2ltYXRlZC5wdXNoKHRoaXMuYWxsX2luZGljZXNbaSAqIGxvZF9mYWN0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBkdCA9IERhdGUubm93KCkgLSB0MDtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1Zyh0aGlzLmdseXBoLm1vZGVsLnR5cGUgKyBcIiBHbHlwaFJlbmRlcmVyIChcIiArIHRoaXMubW9kZWwuaWQgKyBcIik6IHNldF9kYXRhIGZpbmlzaGVkIGluIFwiICsgZHQgKyBcIm1zXCIpO1xuICAgICAgICB0aGlzLnNldF9kYXRhX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0X3JlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdF9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCwgZHRtYXAsIGR0bWFzaywgZHRyZW5kZXIsIGR0c2VsZWN0LCBkdHRvdCwgZ2xzdXBwb3J0LCBnbHlwaCwgaSwgaW5kaWNlcywgaW5zcGVjdGVkLCBqLCBrLCBsZW4sIGxlbjEsIGxvZF90aHJlc2hvbGQsIG5vbnNlbGVjdGVkLCBub25zZWxlY3Rpb25fZ2x5cGgsIHNlbGVjdGVkLCBzZWxlY3RlZF9tYXNrLCBzZWxlY3Rpb25fZ2x5cGgsIHQwLCB0bWFwLCB0bWFzaywgdHJlbmRlciwgdHNlbGVjdDtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0MCA9IERhdGUubm93KCk7XG4gICAgICAgIGdsc3VwcG9ydCA9IHRoaXMuZ2x5cGguZ2xnbHlwaDtcbiAgICAgICAgdG1hcCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuZ2x5cGgubWFwX2RhdGEoKTtcbiAgICAgICAgZHRtYXAgPSBEYXRlLm5vdygpIC0gdDA7XG4gICAgICAgIHRtYXNrID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaW5kaWNlcyA9IHRoaXMuZ2x5cGgubWFza19kYXRhKHRoaXMuYWxsX2luZGljZXMpO1xuICAgICAgICBkdG1hc2sgPSBEYXRlLm5vdygpIC0gdG1hc2s7XG4gICAgICAgIGN0eCA9IHRoaXMucGxvdF92aWV3LmNhbnZhc192aWV3LmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLm1vZGVsLmRhdGFfc291cmNlLnNlbGVjdGVkO1xuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFsnMGQnXS5nbHlwaCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaW5kaWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkWycxZCddLmluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWRbJzFkJ10uaW5kaWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5zcGVjdGVkID0gdGhpcy5tb2RlbC5kYXRhX3NvdXJjZS5pbnNwZWN0ZWQ7XG4gICAgICAgIGlmICghaW5zcGVjdGVkIHx8IGluc3BlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGluc3BlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluc3BlY3RlZFsnMGQnXS5nbHlwaCkge1xuICAgICAgICAgICAgICAgIGluc3BlY3RlZCA9IGluZGljZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnNwZWN0ZWRbJzFkJ10uaW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkID0gaW5zcGVjdGVkWycxZCddLmluZGljZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2RfdGhyZXNob2xkID0gdGhpcy5wbG90X21vZGVsLnBsb3QubG9kX3RocmVzaG9sZDtcbiAgICAgICAgaWYgKHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlICYmICFnbHN1cHBvcnQgJiYgKGxvZF90aHJlc2hvbGQgIT0gbnVsbCkgJiYgdGhpcy5hbGxfaW5kaWNlcy5sZW5ndGggPiBsb2RfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBpbmRpY2VzID0gdGhpcy5kZWNpbWF0ZWQ7XG4gICAgICAgICAgICBnbHlwaCA9IHRoaXMuZGVjaW1hdGVkX2dseXBoO1xuICAgICAgICAgICAgbm9uc2VsZWN0aW9uX2dseXBoID0gdGhpcy5kZWNpbWF0ZWRfZ2x5cGg7XG4gICAgICAgICAgICBzZWxlY3Rpb25fZ2x5cGggPSB0aGlzLnNlbGVjdGlvbl9nbHlwaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoID0gdGhpcy5tb2RlbC5tdXRlZCAmJiAodGhpcy5tdXRlZF9nbHlwaCAhPSBudWxsKSA/IHRoaXMubXV0ZWRfZ2x5cGggOiB0aGlzLmdseXBoO1xuICAgICAgICAgICAgbm9uc2VsZWN0aW9uX2dseXBoID0gdGhpcy5ub25zZWxlY3Rpb25fZ2x5cGg7XG4gICAgICAgICAgICBzZWxlY3Rpb25fZ2x5cGggPSB0aGlzLnNlbGVjdGlvbl9nbHlwaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuaG92ZXJfZ2x5cGggIT0gbnVsbCkgJiYgaW5zcGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5kaWNlcyA9IGFycmF5XzEuZGlmZmVyZW5jZShpbmRpY2VzLCBpbnNwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNlbGVjdGVkLmxlbmd0aCAmJiB0aGlzLmhhdmVfc2VsZWN0aW9uX2dseXBocygpKSkge1xuICAgICAgICAgICAgdHJlbmRlciA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBnbHlwaC5yZW5kZXIoY3R4LCBpbmRpY2VzLCB0aGlzLmdseXBoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyX2dseXBoICYmIGluc3BlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyX2dseXBoLnJlbmRlcihjdHgsIGluc3BlY3RlZCwgdGhpcy5nbHlwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdHJlbmRlciA9IERhdGUubm93KCkgLSB0cmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHNlbGVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBzZWxlY3RlZF9tYXNrID0ge307XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBzZWxlY3RlZC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGkgPSBzZWxlY3RlZFtqXTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9tYXNrW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBub25zZWxlY3RlZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGluZGljZXMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgaSA9IGluZGljZXNba107XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkX21hc2tbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uc2VsZWN0ZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdHNlbGVjdCA9IERhdGUubm93KCkgLSB0c2VsZWN0O1xuICAgICAgICAgICAgdHJlbmRlciA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBub25zZWxlY3Rpb25fZ2x5cGgucmVuZGVyKGN0eCwgbm9uc2VsZWN0ZWQsIHRoaXMuZ2x5cGgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2dseXBoLnJlbmRlcihjdHgsIHNlbGVjdGVkLCB0aGlzLmdseXBoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyX2dseXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyX2dseXBoLnJlbmRlcihjdHgsIGluc3BlY3RlZCwgdGhpcy5nbHlwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdHJlbmRlciA9IERhdGUubm93KCkgLSB0cmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdF9kdHJlbmRlciA9IGR0cmVuZGVyO1xuICAgICAgICBkdHRvdCA9IERhdGUubm93KCkgLSB0MDtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1Zyh0aGlzLmdseXBoLm1vZGVsLnR5cGUgKyBcIiBHbHlwaFJlbmRlcmVyIChcIiArIHRoaXMubW9kZWwuaWQgKyBcIik6IHJlbmRlciBmaW5pc2hlZCBpbiBcIiArIGR0dG90ICsgXCJtc1wiKTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIiAtIG1hcF9kYXRhIGZpbmlzaGVkIGluICAgICAgIDogXCIgKyBkdG1hcCArIFwibXNcIik7XG4gICAgICAgIGlmIChkdG1hc2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci50cmFjZShcIiAtIG1hc2tfZGF0YSBmaW5pc2hlZCBpbiAgICAgIDogXCIgKyBkdG1hc2sgKyBcIm1zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdHNlbGVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLnRyYWNlKFwiIC0gc2VsZWN0aW9uIG1hc2sgZmluaXNoZWQgaW4gOiBcIiArIGR0c2VsZWN0ICsgXCJtc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLnRyYWNlKFwiIC0gZ2x5cGggcmVuZGVycyBmaW5pc2hlZCBpbiAgOiBcIiArIGR0cmVuZGVyICsgXCJtc1wiKTtcbiAgICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUubWFwX3RvX3NjcmVlbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMubW9kZWwueF9yYW5nZV9uYW1lLCB0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZSk7XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyVmlldy5wcm90b3R5cGUuZHJhd19sZWdlbmQgPSBmdW5jdGlvbiAoY3R4LCB4MCwgeDEsIHkwLCB5MSwgZmllbGQsIGxhYmVsKSB7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaW5kZXggPSB0aGlzLm1vZGVsLmdldF9yZWZlcmVuY2VfcG9pbnQoZmllbGQsIGxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGguZHJhd19sZWdlbmRfZm9yX2luZGV4KGN0eCwgeDAsIHgxLCB5MCwgeTEsIGluZGV4KTtcbiAgICB9O1xuICAgIEdseXBoUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5oaXRfdGVzdCA9IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaC5oaXRfdGVzdChnZW9tZXRyeSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2x5cGhSZW5kZXJlclZpZXc7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyVmlldyk7XG5leHBvcnRzLkdseXBoUmVuZGVyZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKEdseXBoUmVuZGVyZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdseXBoUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBHbHlwaFJlbmRlcmVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkdseXBoUmVuZGVyZXJWaWV3O1xuICAgIEdseXBoUmVuZGVyZXIucHJvdG90eXBlLnR5cGUgPSAnR2x5cGhSZW5kZXJlcic7XG4gICAgR2x5cGhSZW5kZXJlci5wcm90b3R5cGUuZ2V0X3JlZmVyZW5jZV9wb2ludCA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEsIGksIGluZGV4O1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGlmICgoZmllbGQgIT0gbnVsbCkgJiYgKHRoaXMuZGF0YV9zb3VyY2UuZ2V0X2NvbHVtbiAhPSBudWxsKSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YV9zb3VyY2UuZ2V0X2NvbHVtbihmaWVsZCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGkgPSBkYXRhLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIEdseXBoUmVuZGVyZXIuZGVmaW5lKHtcbiAgICAgICAgeF9yYW5nZV9uYW1lOiBbcC5TdHJpbmcsICdkZWZhdWx0J10sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCAnZGVmYXVsdCddLFxuICAgICAgICBkYXRhX3NvdXJjZTogW3AuSW5zdGFuY2VdLFxuICAgICAgICBnbHlwaDogW3AuSW5zdGFuY2VdLFxuICAgICAgICBob3Zlcl9nbHlwaDogW3AuSW5zdGFuY2VdLFxuICAgICAgICBub25zZWxlY3Rpb25fZ2x5cGg6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgc2VsZWN0aW9uX2dseXBoOiBbcC5BbnksICdhdXRvJ10sXG4gICAgICAgIG11dGVkX2dseXBoOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIG11dGVkOiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICBHbHlwaFJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICdnbHlwaCdcbiAgICB9KTtcbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3Rpb25fZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpbGw6IHt9LFxuICAgICAgICBsaW5lOiB7fVxuICAgIH07XG4gICAgR2x5cGhSZW5kZXJlci5wcm90b3R5cGUuZGVjaW1hdGVkX2RlZmF1bHRzID0ge1xuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBmaWxsX2FscGhhOiAwLjMsXG4gICAgICAgICAgICBmaWxsX2NvbG9yOiBcImdyZXlcIlxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICBsaW5lX2FscGhhOiAwLjMsXG4gICAgICAgICAgICBsaW5lX2NvbG9yOiBcImdyZXlcIlxuICAgICAgICB9XG4gICAgfTtcbiAgICBHbHlwaFJlbmRlcmVyLnByb3RvdHlwZS5ub25zZWxlY3Rpb25fZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGZpbGxfYWxwaGE6IDAuMixcbiAgICAgICAgICAgIGxpbmVfYWxwaGE6IDAuMlxuICAgICAgICB9LFxuICAgICAgICBsaW5lOiB7fVxuICAgIH07XG4gICAgcmV0dXJuIEdseXBoUmVuZGVyZXI7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciByZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vcmVuZGVyZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkd1aWRlUmVuZGVyZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoR3VpZGVSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR3VpZGVSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIEd1aWRlUmVuZGVyZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEd1aWRlUmVuZGVyZXIucHJvdG90eXBlLnR5cGUgPSAnR3VpZGVSZW5kZXJlcic7XG4gICAgR3VpZGVSZW5kZXJlci5kZWZpbmUoe1xuICAgICAgICBwbG90OiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICBHdWlkZVJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICdvdmVybGF5J1xuICAgIH0pO1xuICAgIHJldHVybiBHdWlkZVJlbmRlcmVyO1xufSkocmVuZGVyZXJfMS5SZW5kZXJlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbHlwaF9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vZ2x5cGhfcmVuZGVyZXJcIik7XG5leHBvcnRzLkdseXBoUmVuZGVyZXIgPSBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXI7XG52YXIgZ3VpZGVfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2d1aWRlX3JlbmRlcmVyXCIpO1xuZXhwb3J0cy5HdWlkZVJlbmRlcmVyID0gZ3VpZGVfcmVuZGVyZXJfMS5HdWlkZVJlbmRlcmVyO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbmV4cG9ydHMuUmVuZGVyZXIgPSByZW5kZXJlcl8xLlJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kMSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBib2tlaF92aWV3XzEgPSByZXF1aXJlKFwiY29yZS9ib2tlaF92aWV3XCIpO1xudmFyIHZpc3VhbHNfMSA9IHJlcXVpcmUoXCJjb3JlL3Zpc3VhbHNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgcHJvaiA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvcHJvamVjdGlvbnNcIik7XG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL29iamVjdFwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5SZW5kZXJlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKFJlbmRlcmVyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZW5kZXJlclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBSZW5kZXJlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcgPSBvcHRpb25zLnBsb3RfdmlldztcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFscyA9IG5ldyB2aXN1YWxzXzEuVmlzdWFscyh0aGlzLm1vZGVsKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyVmlldy5nZXR0ZXJzKHtcbiAgICAgICAgcGxvdF9tb2RlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3Lm1vZGVsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5yZXF1ZXN0X3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlclZpZXcucHJvdG90eXBlLnNldF9kYXRhID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgZGF0YSwgcmVmLCByZWYxO1xuICAgICAgICBkYXRhID0gdGhpcy5tb2RlbC5tYXRlcmlhbGl6ZV9kYXRhc3BlY3Moc291cmNlKTtcbiAgICAgICAgb2JqZWN0XzEuZXh0ZW5kKHRoaXMsIGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wbG90X21vZGVsLnVzZV9tYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBwcm9qLnByb2plY3RfeHkodGhpcy5feCwgdGhpcy5feSksIHRoaXMuX3ggPSByZWZbMF0sIHRoaXMuX3kgPSByZWZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5feHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYxID0gcHJvai5wcm9qZWN0X3hzeXModGhpcy5feHMsIHRoaXMuX3lzKSwgdGhpcy5feHMgPSByZWYxWzBdLCB0aGlzLl95cyA9IHJlZjFbMV0sIHJlZjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyVmlldy5wcm90b3R5cGUubWFwX3RvX3NjcmVlbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5tYXBfdG9fc2NyZWVuKHgsIHksIHRoaXMubW9kZWwueF9yYW5nZV9uYW1lLCB0aGlzLm1vZGVsLnlfcmFuZ2VfbmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyZXJWaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLlJlbmRlcmVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBSZW5kZXJlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnR5cGUgPSBcIlJlbmRlcmVyXCI7XG4gICAgUmVuZGVyZXIuZGVmaW5lKHtcbiAgICAgICAgbGV2ZWw6IFtwLlJlbmRlckxldmVsLCBudWxsXSxcbiAgICAgICAgdmlzaWJsZTogW3AuQm9vbCwgdHJ1ZV1cbiAgICB9KTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIG1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHJlbW90ZV9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vcmVtb3RlX2RhdGFfc291cmNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkFqYXhEYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFqYXhEYXRhU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBamF4RGF0YVNvdXJjZSgpIHtcbiAgICAgICAgdGhpcy5nZXRfZGF0YSA9IGJpbmQodGhpcy5nZXRfZGF0YSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXAgPSBiaW5kKHRoaXMuc2V0dXAsIHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBiaW5kKHRoaXMuZGVzdHJveSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBBamF4RGF0YVNvdXJjZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWpheERhdGFTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnQWpheERhdGFTb3VyY2UnO1xuICAgIEFqYXhEYXRhU291cmNlLmRlZmluZSh7XG4gICAgICAgIG1vZGU6IFtwLlN0cmluZywgJ3JlcGxhY2UnXSxcbiAgICAgICAgY29udGVudF90eXBlOiBbcC5TdHJpbmcsICdhcHBsaWNhdGlvbi9qc29uJ10sXG4gICAgICAgIGh0dHBfaGVhZGVyczogW3AuQW55LCB7fV0sXG4gICAgICAgIG1heF9zaXplOiBbcC5OdW1iZXJdLFxuICAgICAgICBtZXRob2Q6IFtwLlN0cmluZywgJ1BPU1QnXSxcbiAgICAgICAgaWZfbW9kaWZpZWQ6IFtwLkJvb2wsIGZhbHNlXVxuICAgIH0pO1xuICAgIEFqYXhEYXRhU291cmNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheERhdGFTb3VyY2UucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHBsb3RfdmlldywgZ2x5cGgpIHtcbiAgICAgICAgdGhpcy5wdiA9IHBsb3RfdmlldztcbiAgICAgICAgdGhpcy5nZXRfZGF0YSh0aGlzLm1vZGUpO1xuICAgICAgICBpZiAodGhpcy5wb2xsaW5nX2ludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuZ2V0X2RhdGEsIHRoaXMucG9sbGluZ19pbnRlcnZhbCwgdGhpcy5tb2RlLCB0aGlzLm1heF9zaXplLCB0aGlzLmlmX21vZGlmaWVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheERhdGFTb3VyY2UucHJvdG90eXBlLmdldF9kYXRhID0gZnVuY3Rpb24gKG1vZGUsIG1heF9zaXplLCBpZl9tb2RpZmllZCkge1xuICAgICAgICB2YXIgbmFtZSwgcmVmLCB2YWx1ZSwgeGhyO1xuICAgICAgICBpZiAobWF4X3NpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4X3NpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZl9tb2RpZmllZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZl9tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy5kYXRhX3VybCwgdHJ1ZSk7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgdGhpcy5jb250ZW50X3R5cGUpO1xuICAgICAgICByZWYgPSB0aGlzLmh0dHBfaGVhZGVycztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiwgZGF0YSwgaSwgbGVuLCBvcmlnaW5hbF9kYXRhLCByZWYxO1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXBwZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbF9kYXRhID0gX3RoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYxID0gX3RoaXMuY29sdW1ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gcmVmMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtjb2x1bW5dID0gb3JpZ2luYWxfZGF0YVtjb2x1bW5dLmNvbmNhdChkYXRhW2NvbHVtbl0pLnNsaWNlKC1tYXhfc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIEpTT04gZnJvbSBcIiArIF90aGlzLmRhdGFfdXJsICsgXCIgd2l0aCBjb2RlIFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFqYXhEYXRhU291cmNlO1xufSkocmVtb3RlX2RhdGFfc291cmNlXzEuUmVtb3RlRGF0YVNvdXJjZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgY29sdW1uYXJfZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbmFyX2RhdGFfc291cmNlXCIpO1xudmFyIGhhc19wcm9wc18xID0gcmVxdWlyZShcImNvcmUvaGFzX3Byb3BzXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHNlcmlhbGl6YXRpb24gPSByZXF1aXJlKFwiY29yZS91dGlsL3NlcmlhbGl6YXRpb25cIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5leHBvcnRzLmNvbmNhdF90eXBlZF9hcnJheXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBjO1xuICAgIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBjLnNldChhLCAwKTtcbiAgICBjLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGM7XG59O1xuZXhwb3J0cy5zdHJlYW1fdG9fY29sdW1uID0gZnVuY3Rpb24gKGNvbCwgbmV3X2NvbCwgcm9sbG92ZXIpIHtcbiAgICB2YXIgZW5kLCBpLCBqLCBsLCByZWYsIHJlZjEsIHJlZjIsIHN0YXJ0LCB0bXAsIHRvdGFsX2xlbjtcbiAgICBpZiAoY29sLmNvbmNhdCAhPSBudWxsKSB7XG4gICAgICAgIGNvbCA9IGNvbC5jb25jYXQobmV3X2NvbCk7XG4gICAgICAgIGlmIChjb2wubGVuZ3RoID4gcm9sbG92ZXIpIHtcbiAgICAgICAgICAgIGNvbCA9IGNvbC5zbGljZSgtcm9sbG92ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICAgIHRvdGFsX2xlbiA9IGNvbC5sZW5ndGggKyBuZXdfY29sLmxlbmd0aDtcbiAgICBpZiAoKHJvbGxvdmVyICE9IG51bGwpICYmIHRvdGFsX2xlbiA+IHJvbGxvdmVyKSB7XG4gICAgICAgIHN0YXJ0ID0gdG90YWxfbGVuIC0gcm9sbG92ZXI7XG4gICAgICAgIGVuZCA9IGNvbC5sZW5ndGg7XG4gICAgICAgIGlmIChjb2wubGVuZ3RoIDwgcm9sbG92ZXIpIHtcbiAgICAgICAgICAgIHRtcCA9IG5ldyBjb2wuY29uc3RydWN0b3Iocm9sbG92ZXIpO1xuICAgICAgICAgICAgdG1wLnNldChjb2wsIDApO1xuICAgICAgICAgICAgY29sID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGogPSByZWYgPSBzdGFydCwgcmVmMSA9IGVuZDsgcmVmIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIGNvbFtpIC0gc3RhcnRdID0gY29sW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGwgPSAwLCByZWYyID0gbmV3X2NvbC5sZW5ndGg7IDAgPD0gcmVmMiA/IGwgPCByZWYyIDogbCA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIGNvbFtpICsgKGVuZCAtIHN0YXJ0KV0gPSBuZXdfY29sW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICAgIHRtcCA9IG5ldyBjb2wuY29uc3RydWN0b3IobmV3X2NvbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0X3R5cGVkX2FycmF5cyhjb2wsIHRtcCk7XG59O1xuZXhwb3J0cy5wYXRjaF90b19jb2x1bW4gPSBmdW5jdGlvbiAoY29sLCBwYXRjaCkge1xuICAgIHZhciBpLCBpbmQsIGosIHJlZiwgcmVmMSwgcmVzdWx0cywgdmFsdWU7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBwYXRjaC5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICByZWYxID0gcGF0Y2hbaV0sIGluZCA9IHJlZjFbMF0sIHZhbHVlID0gcmVmMVsxXTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGNvbFtpbmRdID0gdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5leHBvcnRzLkNvbHVtbkRhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sdW1uRGF0YVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29sdW1uRGF0YVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIENvbHVtbkRhdGFTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbHVtbkRhdGFTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnQ29sdW1uRGF0YVNvdXJjZSc7XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIENvbHVtbkRhdGFTb3VyY2UuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlZiA9IHNlcmlhbGl6YXRpb24uZGVjb2RlX2NvbHVtbl9kYXRhKHRoaXMuZGF0YSksIHRoaXMuZGF0YSA9IHJlZlswXSwgdGhpcy5fc2hhcGVzID0gcmVmWzFdLCByZWY7XG4gICAgfTtcbiAgICBDb2x1bW5EYXRhU291cmNlLmRlZmluZSh7XG4gICAgICAgIGRhdGE6IFtwLkFueSwge31dXG4gICAgfSk7XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5wcm90b3R5cGUuYXR0cmlidXRlc19hc19qc29uID0gZnVuY3Rpb24gKGluY2x1ZGVfZGVmYXVsdHMsIHZhbHVlX3RvX2pzb24pIHtcbiAgICAgICAgdmFyIGF0dHJzLCBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZGVmYXVsdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZV90b19qc29uID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlX3RvX2pzb24gPSBDb2x1bW5EYXRhU291cmNlLl92YWx1ZV90b19qc29uO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMuc2VyaWFsaXphYmxlX2F0dHJpYnV0ZXMoKTtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXJpYWxpemF0aW9uLmVuY29kZV9jb2x1bW5fZGF0YSh2YWx1ZSwgdGhpcy5fc2hhcGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHRoaXMuX3NldF9hZnRlcl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVfdG9fanNvbihcImF0dHJpYnV0ZXNcIiwgYXR0cnMsIHRoaXMpO1xuICAgIH07XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5fdmFsdWVfdG9fanNvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25hbF9wYXJlbnRfb2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlc18xLmlzT2JqZWN0KHZhbHVlKSAmJiBrZXkgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb24uZW5jb2RlX2NvbHVtbl9kYXRhKHZhbHVlLCBvcHRpb25hbF9wYXJlbnRfb2JqZWN0Ll9zaGFwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhc19wcm9wc18xLkhhc1Byb3BzLl92YWx1ZV90b19qc29uKGtleSwgdmFsdWUsIG9wdGlvbmFsX3BhcmVudF9vYmplY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2x1bW5EYXRhU291cmNlLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiAobmV3X2RhdGEsIHJvbGxvdmVyKSB7XG4gICAgICAgIHZhciBkYXRhLCBrLCB2O1xuICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGsgaW4gbmV3X2RhdGEpIHtcbiAgICAgICAgICAgIHYgPSBuZXdfZGF0YVtrXTtcbiAgICAgICAgICAgIGRhdGFba10gPSBleHBvcnRzLnN0cmVhbV90b19jb2x1bW4oZGF0YVtrXSwgbmV3X2RhdGFba10sIHJvbGxvdmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHYoJ2RhdGEnLCBkYXRhLCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3N0cmVhbScpO1xuICAgIH07XG4gICAgQ29sdW1uRGF0YVNvdXJjZS5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgICAgICB2YXIgZGF0YSwgaywgcGF0Y2g7XG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAoayBpbiBwYXRjaGVzKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNba107XG4gICAgICAgICAgICBleHBvcnRzLnBhdGNoX3RvX2NvbHVtbihkYXRhW2tdLCBwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR2KCdkYXRhJywgZGF0YSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdwYXRjaCcpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbHVtbkRhdGFTb3VyY2U7XG59KShjb2x1bW5hcl9kYXRhX3NvdXJjZV8xLkNvbHVtbmFyRGF0YVNvdXJjZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2RhdGFfc291cmNlXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgc2VsZWN0aW9uX21hbmFnZXJfMSA9IHJlcXVpcmUoXCJjb3JlL3NlbGVjdGlvbl9tYW5hZ2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuZXhwb3J0cy5Db2x1bW5hckRhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29sdW1uYXJEYXRhU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb2x1bW5hckRhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBDb2x1bW5hckRhdGFTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbHVtbmFyRGF0YVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdDb2x1bW5hckRhdGFTb3VyY2UnO1xuICAgIENvbHVtbmFyRGF0YVNvdXJjZS5kZWZpbmUoe1xuICAgICAgICBjb2x1bW5fbmFtZXM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBDb2x1bW5hckRhdGFTb3VyY2UuaW50ZXJuYWwoe1xuICAgICAgICBzZWxlY3Rpb25fbWFuYWdlcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNlbGVjdGlvbl9tYW5hZ2VyXzEuU2VsZWN0aW9uTWFuYWdlcih7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc2VsZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpbnNwZWN0ZWQ6IFtwLkFueV0sXG4gICAgICAgIF9zaGFwZXM6IFtwLkFueSwge31dXG4gICAgfSk7XG4gICAgQ29sdW1uYXJEYXRhU291cmNlLnByb3RvdHlwZS5nZXRfY29sdW1uID0gZnVuY3Rpb24gKGNvbG5hbWUpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmRhdGFbY29sbmFtZV0pICE9IG51bGwgPyByZWYgOiBudWxsO1xuICAgIH07XG4gICAgQ29sdW1uYXJEYXRhU291cmNlLnByb3RvdHlwZS5jb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIENvbHVtbmFyRGF0YVNvdXJjZS5wcm90b3R5cGUuZ2V0X2xlbmd0aCA9IGZ1bmN0aW9uIChzb2Z0KSB7XG4gICAgICAgIHZhciBfa2V5LCBsZW5ndGhzLCBtc2csIHZhbDtcbiAgICAgICAgaWYgKHNvZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc29mdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RocyA9IGFycmF5XzEudW5pcSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2tleSBpbiByZWYpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSByZWZbX2tleV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBzd2l0Y2ggKGxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aHNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1zZyA9IFwiZGF0YSBzb3VyY2UgaGFzIGNvbHVtbnMgb2YgaW5jb25zaXN0ZW50IGxlbmd0aHNcIjtcbiAgICAgICAgICAgICAgICBpZiAoc29mdCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aHMuc29ydCgpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29sdW1uYXJEYXRhU291cmNlO1xufSkoZGF0YV9zb3VyY2VfMS5EYXRhU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIGhpdHRlc3QgPSByZXF1aXJlKFwiY29yZS9oaXR0ZXN0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5EYXRhU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGFTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGFTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiBEYXRhU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0RhdGFTb3VyY2UnO1xuICAgIERhdGFTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgc2VsZWN0ZWQ6IFtwLkFueSwgaGl0dGVzdC5jcmVhdGVfaGl0X3Rlc3RfcmVzdWx0KCldLFxuICAgICAgICBjYWxsYmFjazogW3AuQW55XVxuICAgIH0pO1xuICAgIERhdGFTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBEYXRhU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6c2VsZWN0ZWQnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF90aGlzLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlc18xLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmV4ZWN1dGUoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFTb3VyY2U7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb2x1bW5hcl9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vY29sdW1uYXJfZGF0YV9zb3VyY2VcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcImNvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuR2VvSlNPTkRhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoR2VvSlNPTkRhdGFTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEdlb0pTT05EYXRhU291cmNlKCkge1xuICAgICAgICByZXR1cm4gR2VvSlNPTkRhdGFTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0dlb0pTT05EYXRhU291cmNlJztcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5kZWZpbmUoe1xuICAgICAgICBnZW9qc29uOiBbcC5BbnldXG4gICAgfSk7XG4gICAgR2VvSlNPTkRhdGFTb3VyY2UuaW50ZXJuYWwoe1xuICAgICAgICBkYXRhOiBbcC5BbnksIHt9XVxuICAgIH0pO1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgR2VvSlNPTkRhdGFTb3VyY2UuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlX2RhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcywgJ2NoYW5nZTpnZW9qc29uJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3VwZGF0ZV9kYXRhKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUuX3VwZGF0ZV9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gdGhpcy5nZW9qc29uX3RvX2NvbHVtbl9kYXRhKCk7XG4gICAgfTtcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUuX2dldF9uZXdfbGlzdF9hcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGksIGssIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbGVuZ3RoOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUuX2dldF9uZXdfbmFuX2FycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIgaSwgaywgcmVmLCByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBsZW5ndGg7IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDAgLyAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fZmxhdHRlbl9mdW5jdGlvbiA9IGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgY3VycmVudEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yLmNvbmNhdChbWzAgLyAwLCAwIC8gMCwgMCAvIDBdXSkuY29uY2F0KGN1cnJlbnRJdGVtKTtcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fYWRkX3Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoaXRlbSwgZGF0YSwgaSwgaXRlbV9jb3VudCkge1xuICAgICAgICB2YXIgcHJvcGVydHksIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBpdGVtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3Byb3BlcnR5XSA9IHRoaXMuX2dldF9uZXdfbmFuX2FycmF5KGl0ZW1fY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGFbcHJvcGVydHldW2ldID0gaXRlbS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBHZW9KU09ORGF0YVNvdXJjZS5wcm90b3R5cGUuX2FkZF9nZW9tZXRyeSA9IGZ1bmN0aW9uIChnZW9tZXRyeSwgZGF0YSwgaSkge1xuICAgICAgICB2YXIgY29vcmRfbGlzdCwgY29vcmRzLCBleHRlcmlvcl9yaW5nLCBleHRlcmlvcl9yaW5ncywgZmxhdHRlbmVkX2Nvb3JkX2xpc3QsIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbGVuNCwgbSwgbiwgbywgcG9seWdvbiwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZXN1bHRzLCByZXN1bHRzMSwgcmVzdWx0czIsIHJlc3VsdHMzO1xuICAgICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIGRhdGEueFtpXSA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICBkYXRhLnlbaV0gPSBjb29yZHNbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEueltpXSA9IChyZWYgPSBjb29yZHNbMl0pICE9IG51bGwgPyByZWYgOiAwIC8gMDtcbiAgICAgICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY29vcmRfbGlzdCA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBrID0gMCwgbGVuID0gY29vcmRfbGlzdC5sZW5ndGg7IGsgPCBsZW47IGogPSArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gY29vcmRfbGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS54c1tpXVtqXSA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55c1tpXVtqXSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuenNbaV1bal0gPSAocmVmMSA9IGNvb3Jkc1syXSkgIT0gbnVsbCA/IHJlZjEgOiAwIC8gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ0Jva2VoIGRvZXMgbm90IHN1cHBvcnQgUG9seWdvbnMgd2l0aCBob2xlcyBpbiwgb25seSBleHRlcmlvciByaW5nIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dGVyaW9yX3JpbmcgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCBsZW4xID0gZXh0ZXJpb3JfcmluZy5sZW5ndGg7IGwgPCBsZW4xOyBqID0gKytsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IGV4dGVyaW9yX3Jpbmdbal07XG4gICAgICAgICAgICAgICAgICAgIGRhdGEueHNbaV1bal0gPSBjb29yZHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGEueXNbaV1bal0gPSBjb29yZHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goZGF0YS56c1tpXVtqXSA9IChyZWYyID0gY29vcmRzWzJdKSAhPSBudWxsID8gcmVmMiA6IDAgLyAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdNdWx0aVBvaW50IG5vdCBzdXBwb3J0ZWQgaW4gQm9rZWgnKTtcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBmbGF0dGVuZWRfY29vcmRfbGlzdCA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzLnJlZHVjZSh0aGlzLl9mbGF0dGVuX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzMiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IG0gPSAwLCBsZW4yID0gZmxhdHRlbmVkX2Nvb3JkX2xpc3QubGVuZ3RoOyBtIDwgbGVuMjsgaiA9ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBmbGF0dGVuZWRfY29vcmRfbGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS54c1tpXVtqXSA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55c1tpXVtqXSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czIucHVzaChkYXRhLnpzW2ldW2pdID0gKHJlZjMgPSBjb29yZHNbMl0pICE9IG51bGwgPyByZWYzIDogMCAvIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgZXh0ZXJpb3JfcmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICByZWY0ID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMCwgbGVuMyA9IHJlZjQubGVuZ3RoOyBuIDwgbGVuMzsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24gPSByZWY0W25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLndhcm4oJ0Jva2VoIGRvZXMgbm90IHN1cHBvcnQgUG9seWdvbnMgd2l0aCBob2xlcyBpbiwgb25seSBleHRlcmlvciByaW5nIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJpb3JfcmluZ3MucHVzaChwb2x5Z29uWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkX2Nvb3JkX2xpc3QgPSBleHRlcmlvcl9yaW5ncy5yZWR1Y2UodGhpcy5fZmxhdHRlbl9mdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzdWx0czMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBvID0gMCwgbGVuNCA9IGZsYXR0ZW5lZF9jb29yZF9saXN0Lmxlbmd0aDsgbyA8IGxlbjQ7IGogPSArK28pIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gZmxhdHRlbmVkX2Nvb3JkX2xpc3Rbal07XG4gICAgICAgICAgICAgICAgICAgIGRhdGEueHNbaV1bal0gPSBjb29yZHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGEueXNbaV1bal0gPSBjb29yZHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMzLnB1c2goZGF0YS56c1tpXVtqXSA9IChyZWY1ID0gY29vcmRzWzJdKSAhPSBudWxsID8gcmVmNSA6IDAgLyAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZSAnICsgZ2VvbWV0cnkudHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5fZ2V0X2l0ZW1zX2xlbmd0aCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB2YXIgY291bnQsIGcsIGdlb21ldHJ5LCBpLCBpdGVtLCBqLCBrLCBsLCBsZW4sIGxlbjEsIHJlZjtcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBrIDwgbGVuOyBpID0gKytrKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGl0ZW0udHlwZSA9PT0gJ0ZlYXR1cmUnID8gaXRlbS5nZW9tZXRyeSA6IGl0ZW07XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBnZW9tZXRyeS5nZW9tZXRyaWVzO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgbCA8IGxlbjE7IGogPSArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgZyA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIEdlb0pTT05EYXRhU291cmNlLnByb3RvdHlwZS5nZW9qc29uX3RvX2NvbHVtbl9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyX2luZGV4LCBkYXRhLCBnLCBnZW9qc29uLCBnZW9tZXRyeSwgaSwgaXRlbSwgaXRlbV9jb3VudCwgaXRlbXMsIGosIGssIGwsIGxlbiwgbGVuMSwgcmVmLCByZWYxO1xuICAgICAgICBnZW9qc29uID0gSlNPTi5wYXJzZSh0aGlzLmdlb2pzb24pO1xuICAgICAgICBpZiAoKHJlZiA9IGdlb2pzb24udHlwZSkgIT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nICYmIHJlZiAhPT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2tlaCBvbmx5IHN1cHBvcnRzIHR5cGUgR2VvbWV0cnlDb2xsZWN0aW9uIGFuZCBGZWF0dXJlQ29sbGVjdGlvbiBhdCB0b3AgbGV2ZWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvanNvbi50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGdlb2pzb24uZ2VvbWV0cmllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyaWVzIGZvdW5kIGluIEdlb21ldHJ5Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdlb2pzb24uZ2VvbWV0cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24uZ2VvbWV0cmllcyBtdXN0IGhhdmUgb25lIG9yIG1vcmUgaXRlbXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zID0gZ2VvanNvbi5nZW9tZXRyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChnZW9qc29uLmZlYXR1cmVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZlYXR1cmVzIGZvdW5kIGluIEZlYXR1cmVzQ29sbGVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW9qc29uLmZlYXR1cmVzIG11c3QgaGF2ZSBvbmUgb3IgbW9yZSBpdGVtcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMgPSBnZW9qc29uLmZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1fY291bnQgPSB0aGlzLl9nZXRfaXRlbXNfbGVuZ3RoKGl0ZW1zKTtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICd4JzogdGhpcy5fZ2V0X25ld19uYW5fYXJyYXkoaXRlbV9jb3VudCksXG4gICAgICAgICAgICAneSc6IHRoaXMuX2dldF9uZXdfbmFuX2FycmF5KGl0ZW1fY291bnQpLFxuICAgICAgICAgICAgJ3onOiB0aGlzLl9nZXRfbmV3X25hbl9hcnJheShpdGVtX2NvdW50KSxcbiAgICAgICAgICAgICd4cyc6IHRoaXMuX2dldF9uZXdfbGlzdF9hcnJheShpdGVtX2NvdW50KSxcbiAgICAgICAgICAgICd5cyc6IHRoaXMuX2dldF9uZXdfbGlzdF9hcnJheShpdGVtX2NvdW50KSxcbiAgICAgICAgICAgICd6cyc6IHRoaXMuX2dldF9uZXdfbGlzdF9hcnJheShpdGVtX2NvdW50KVxuICAgICAgICB9O1xuICAgICAgICBhcnJfaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBrIDwgbGVuOyBpID0gKytrKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGl0ZW0udHlwZSA9PT0gJ0ZlYXR1cmUnID8gaXRlbS5nZW9tZXRyeSA6IGl0ZW07XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZWYxID0gZ2VvbWV0cnkuZ2VvbWV0cmllcztcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBsIDwgbGVuMTsgaiA9ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICBnID0gcmVmMVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkX2dlb21ldHJ5KGcsIGRhdGEsIGFycl9pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkX3Byb3BlcnRpZXMoaXRlbSwgZGF0YSwgYXJyX2luZGV4LCBpdGVtX2NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnJfaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRfZ2VvbWV0cnkoZ2VvbWV0cnksIGRhdGEsIGFycl9pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZF9wcm9wZXJ0aWVzKGl0ZW0sIGRhdGEsIGFycl9pbmRleCwgaXRlbV9jb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycl9pbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEdlb0pTT05EYXRhU291cmNlO1xufSkoY29sdW1uYXJfZGF0YV9zb3VyY2VfMS5Db2x1bW5hckRhdGFTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWpheF9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vYWpheF9kYXRhX3NvdXJjZVwiKTtcbmV4cG9ydHMuQWpheERhdGFTb3VyY2UgPSBhamF4X2RhdGFfc291cmNlXzEuQWpheERhdGFTb3VyY2U7XG52YXIgY29sdW1uX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5fZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLkNvbHVtbkRhdGFTb3VyY2UgPSBjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlO1xudmFyIGNvbHVtbmFyX2RhdGFfc291cmNlXzEgPSByZXF1aXJlKFwiLi9jb2x1bW5hcl9kYXRhX3NvdXJjZVwiKTtcbmV4cG9ydHMuQ29sdW1uYXJEYXRhU291cmNlID0gY29sdW1uYXJfZGF0YV9zb3VyY2VfMS5Db2x1bW5hckRhdGFTb3VyY2U7XG52YXIgZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2RhdGFfc291cmNlXCIpO1xuZXhwb3J0cy5EYXRhU291cmNlID0gZGF0YV9zb3VyY2VfMS5EYXRhU291cmNlO1xudmFyIGdlb2pzb25fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2dlb2pzb25fZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLkdlb0pTT05EYXRhU291cmNlID0gZ2VvanNvbl9kYXRhX3NvdXJjZV8xLkdlb0pTT05EYXRhU291cmNlO1xudmFyIHJlbW90ZV9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vcmVtb3RlX2RhdGFfc291cmNlXCIpO1xuZXhwb3J0cy5SZW1vdGVEYXRhU291cmNlID0gcmVtb3RlX2RhdGFfc291cmNlXzEuUmVtb3RlRGF0YVNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb2x1bW5fZGF0YV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvbHVtbl9kYXRhX3NvdXJjZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuUmVtb3RlRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSZW1vdGVEYXRhU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZW1vdGVEYXRhU291cmNlKCkge1xuICAgICAgICByZXR1cm4gUmVtb3RlRGF0YVNvdXJjZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVtb3RlRGF0YVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdSZW1vdGVEYXRhU291cmNlJztcbiAgICBSZW1vdGVEYXRhU291cmNlLmRlZmluZSh7XG4gICAgICAgIGRhdGFfdXJsOiBbcC5TdHJpbmddLFxuICAgICAgICBwb2xsaW5nX2ludGVydmFsOiBbcC5OdW1iZXJdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlbW90ZURhdGFTb3VyY2U7XG59KShjb2x1bW5fZGF0YV9zb3VyY2VfMS5Db2x1bW5EYXRhU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsYW1wLCBsb2csIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBjb250aW51b3VzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY29udGludW91c190aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG5jbGFtcCA9IGZ1bmN0aW9uICh4LCBtaW5fdmFsLCBtYXhfdmFsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbl92YWwsIE1hdGgubWluKG1heF92YWwsIHgpKTtcbn07XG5sb2cgPSBmdW5jdGlvbiAoeCwgYmFzZSkge1xuICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgYmFzZSA9IE1hdGguRTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5sb2coYmFzZSk7XG59O1xuZXhwb3J0cy5BZGFwdGl2ZVRpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBZGFwdGl2ZVRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQWRhcHRpdmVUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBBZGFwdGl2ZVRpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWRhcHRpdmVUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnQWRhcHRpdmVUaWNrZXInO1xuICAgIEFkYXB0aXZlVGlja2VyLmRlZmluZSh7XG4gICAgICAgIGJhc2U6IFtwLk51bWJlciwgMTAuMF0sXG4gICAgICAgIG1hbnRpc3NhczogW3AuQXJyYXksIFsxLCAyLCA1XV0sXG4gICAgICAgIG1pbl9pbnRlcnZhbDogW3AuTnVtYmVyLCAwLjBdLFxuICAgICAgICBtYXhfaW50ZXJ2YWw6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICBBZGFwdGl2ZVRpY2tlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJlZml4X21hbnRpc3NhLCBzdWZmaXhfbWFudGlzc2E7XG4gICAgICAgIEFkYXB0aXZlVGlja2VyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICBwcmVmaXhfbWFudGlzc2EgPSBhcnJheV8xLm50aCh0aGlzLm1hbnRpc3NhcywgLTEpIC8gdGhpcy5iYXNlO1xuICAgICAgICBzdWZmaXhfbWFudGlzc2EgPSBhcnJheV8xLm50aCh0aGlzLm1hbnRpc3NhcywgMCkgKiB0aGlzLmJhc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRfbWFudGlzc2FzID0gW3ByZWZpeF9tYW50aXNzYV0uY29uY2F0KHNsaWNlLmNhbGwodGhpcy5tYW50aXNzYXMpLCBbc3VmZml4X21hbnRpc3NhXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VfZmFjdG9yID0gdGhpcy5nZXRfbWluX2ludGVydmFsKCkgPT09IDAuMCA/IDEuMCA6IHRoaXMuZ2V0X21pbl9pbnRlcnZhbCgpO1xuICAgIH07XG4gICAgQWRhcHRpdmVUaWNrZXIucHJvdG90eXBlLmdldF9pbnRlcnZhbCA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGJlc3RfbWFudGlzc2EsIGNhbmRpZGF0ZV9tYW50aXNzYXMsIGRhdGFfcmFuZ2UsIGVycm9ycywgaWRlYWxfaW50ZXJ2YWwsIGlkZWFsX21hZ25pdHVkZSwgaWRlYWxfbWFudGlzc2EsIGludGVydmFsLCBpbnRlcnZhbF9leHBvbmVudDtcbiAgICAgICAgZGF0YV9yYW5nZSA9IGRhdGFfaGlnaCAtIGRhdGFfbG93O1xuICAgICAgICBpZGVhbF9pbnRlcnZhbCA9IHRoaXMuZ2V0X2lkZWFsX2ludGVydmFsKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgIGludGVydmFsX2V4cG9uZW50ID0gTWF0aC5mbG9vcihsb2coaWRlYWxfaW50ZXJ2YWwgLyB0aGlzLmJhc2VfZmFjdG9yLCB0aGlzLmJhc2UpKTtcbiAgICAgICAgaWRlYWxfbWFnbml0dWRlID0gTWF0aC5wb3codGhpcy5iYXNlLCBpbnRlcnZhbF9leHBvbmVudCkgKiB0aGlzLmJhc2VfZmFjdG9yO1xuICAgICAgICBpZGVhbF9tYW50aXNzYSA9IGlkZWFsX2ludGVydmFsIC8gaWRlYWxfbWFnbml0dWRlO1xuICAgICAgICBjYW5kaWRhdGVfbWFudGlzc2FzID0gdGhpcy5leHRlbmRlZF9tYW50aXNzYXM7XG4gICAgICAgIGVycm9ycyA9IGNhbmRpZGF0ZV9tYW50aXNzYXMubWFwKGZ1bmN0aW9uIChtYW50aXNzYSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRlc2lyZWRfbl90aWNrcyAtIChkYXRhX3JhbmdlIC8gKG1hbnRpc3NhICogaWRlYWxfbWFnbml0dWRlKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmVzdF9tYW50aXNzYSA9IGNhbmRpZGF0ZV9tYW50aXNzYXNbYXJyYXlfMS5hcmdtaW4oZXJyb3JzKV07XG4gICAgICAgIGludGVydmFsID0gYmVzdF9tYW50aXNzYSAqIGlkZWFsX21hZ25pdHVkZTtcbiAgICAgICAgcmV0dXJuIGNsYW1wKGludGVydmFsLCB0aGlzLmdldF9taW5faW50ZXJ2YWwoKSwgdGhpcy5nZXRfbWF4X2ludGVydmFsKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYXB0aXZlVGlja2VyO1xufSkoY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhZGFwdGl2ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2FkYXB0aXZlX3RpY2tlclwiKTtcbmV4cG9ydHMuQmFzaWNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQmFzaWNUaWNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJhc2ljVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gQmFzaWNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJhc2ljVGlja2VyLnByb3RvdHlwZS50eXBlID0gJ0Jhc2ljVGlja2VyJztcbiAgICByZXR1cm4gQmFzaWNUaWNrZXI7XG59KShhZGFwdGl2ZV90aWNrZXJfMS5BZGFwdGl2ZVRpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgdGlja2VyXzEgPSByZXF1aXJlKFwiLi90aWNrZXJcIik7XG5leHBvcnRzLkNhdGVnb3JpY2FsVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENhdGVnb3JpY2FsVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDYXRlZ29yaWNhbFRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3JpY2FsVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYXRlZ29yaWNhbFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdDYXRlZ29yaWNhbFRpY2tlcic7XG4gICAgQ2F0ZWdvcmljYWxUaWNrZXIucHJvdG90eXBlLmdldF90aWNrcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCByYW5nZSwgY3Jvc3NfbG9jLCBhcmcpIHtcbiAgICAgICAgdmFyIGRlc2lyZWRfbl90aWNrcywgZmFjdG9ycywgaSwgaWksIGosIG1ham9ycywgcmVmO1xuICAgICAgICBkZXNpcmVkX25fdGlja3MgPSBhcmcuZGVzaXJlZF9uX3RpY2tzO1xuICAgICAgICBtYWpvcnMgPSBbXTtcbiAgICAgICAgZmFjdG9ycyA9IHJhbmdlLmZhY3RvcnM7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBmYWN0b3JzLmxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICBpaSA9IGkgKyByYW5nZS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoKGlpICsgMSkgPiBzdGFydCAmJiAoaWkgKyAxKSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIG1ham9ycy5wdXNoKGZhY3RvcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcIm1ham9yXCI6IG1ham9ycyxcbiAgICAgICAgICAgIFwibWlub3JcIjogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yaWNhbFRpY2tlcjtcbn0pKHRpY2tlcl8xLlRpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgY29udGludW91c190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfdGlja2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuZXhwb3J0cy5Db21wb3NpdGVUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29tcG9zaXRlVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDb21wb3NpdGVUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBDb21wb3NpdGVUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbXBvc2l0ZVRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdDb21wb3NpdGVUaWNrZXInO1xuICAgIENvbXBvc2l0ZVRpY2tlci5kZWZpbmUoe1xuICAgICAgICB0aWNrZXJzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgQ29tcG9zaXRlVGlja2VyLmdldHRlcnMoe1xuICAgICAgICBtaW5faW50ZXJ2YWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZWYsIHJlc3VsdHMsIHRpY2tlcjtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMudGlja2VycztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRpY2tlciA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGlja2VyLmdldF9taW5faW50ZXJ2YWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSxcbiAgICAgICAgbWF4X2ludGVydmFsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzLCB0aWNrZXI7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnRpY2tlcnM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrZXIgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpY2tlci5nZXRfbWF4X2ludGVydmFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIG1pbl9pbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluX2ludGVydmFsc1swXTtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4X2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhfaW50ZXJ2YWxzWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ29tcG9zaXRlVGlja2VyLnByb3RvdHlwZS5nZXRfYmVzdF90aWNrZXIgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBiZXN0X2luZGV4LCBiZXN0X3RpY2tlciwgYmVzdF90aWNrZXJfbmR4LCBkYXRhX3JhbmdlLCBlcnJvcnMsIGlkZWFsX2ludGVydmFsLCBpbnRlcnZhbHMsIHRpY2tlcl9uZHhzO1xuICAgICAgICBkYXRhX3JhbmdlID0gZGF0YV9oaWdoIC0gZGF0YV9sb3c7XG4gICAgICAgIGlkZWFsX2ludGVydmFsID0gdGhpcy5nZXRfaWRlYWxfaW50ZXJ2YWwoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgdGlja2VyX25keHMgPSBbYXJyYXlfMS5zb3J0ZWRJbmRleCh0aGlzLm1pbl9pbnRlcnZhbHMsIGlkZWFsX2ludGVydmFsKSAtIDEsIGFycmF5XzEuc29ydGVkSW5kZXgodGhpcy5tYXhfaW50ZXJ2YWxzLCBpZGVhbF9pbnRlcnZhbCldO1xuICAgICAgICBpbnRlcnZhbHMgPSBbdGhpcy5taW5faW50ZXJ2YWxzW3RpY2tlcl9uZHhzWzBdXSwgdGhpcy5tYXhfaW50ZXJ2YWxzW3RpY2tlcl9uZHhzWzFdXV07XG4gICAgICAgIGVycm9ycyA9IGludGVydmFscy5tYXAoZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGVzaXJlZF9uX3RpY2tzIC0gKGRhdGFfcmFuZ2UgLyBpbnRlcnZhbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmVzdF9pbmRleCA9IGFycmF5XzEuYXJnbWluKGVycm9ycyk7XG4gICAgICAgIGlmIChiZXN0X2luZGV4ID09PSAyZTMwOCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlja2Vyc1swXTtcbiAgICAgICAgfVxuICAgICAgICBiZXN0X3RpY2tlcl9uZHggPSB0aWNrZXJfbmR4c1tiZXN0X2luZGV4XTtcbiAgICAgICAgYmVzdF90aWNrZXIgPSB0aGlzLnRpY2tlcnNbYmVzdF90aWNrZXJfbmR4XTtcbiAgICAgICAgcmV0dXJuIGJlc3RfdGlja2VyO1xuICAgIH07XG4gICAgQ29tcG9zaXRlVGlja2VyLnByb3RvdHlwZS5nZXRfaW50ZXJ2YWwgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBiZXN0X3RpY2tlcjtcbiAgICAgICAgYmVzdF90aWNrZXIgPSB0aGlzLmdldF9iZXN0X3RpY2tlcihkYXRhX2xvdywgZGF0YV9oaWdoLCBkZXNpcmVkX25fdGlja3MpO1xuICAgICAgICByZXR1cm4gYmVzdF90aWNrZXIuZ2V0X2ludGVydmFsKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgfTtcbiAgICBDb21wb3NpdGVUaWNrZXIucHJvdG90eXBlLmdldF90aWNrc19ub19kZWZhdWx0cyA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBjcm9zc19sb2MsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgYmVzdF90aWNrZXIsIHRpY2tzO1xuICAgICAgICBiZXN0X3RpY2tlciA9IHRoaXMuZ2V0X2Jlc3RfdGlja2VyKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgIHRpY2tzID0gYmVzdF90aWNrZXIuZ2V0X3RpY2tzX25vX2RlZmF1bHRzKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBvc2l0ZVRpY2tlcjtcbn0pKGNvbnRpbnVvdXNfdGlja2VyXzEuQ29udGludW91c1RpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgdGlja2VyXzEgPSByZXF1aXJlKFwiLi90aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkNvbnRpbnVvdXNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ29udGludW91c1RpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ29udGludW91c1RpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVvdXNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRpbnVvdXNUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnQ29udGludW91c1RpY2tlcic7XG4gICAgQ29udGludW91c1RpY2tlci5kZWZpbmUoe1xuICAgICAgICBudW1fbWlub3JfdGlja3M6IFtwLk51bWJlciwgNV0sXG4gICAgICAgIGRlc2lyZWRfbnVtX3RpY2tzOiBbcC5OdW1iZXIsIDZdXG4gICAgfSk7XG4gICAgQ29udGludW91c1RpY2tlci5wcm90b3R5cGUuZ2V0X2ludGVydmFsID0gdm9pZCAwO1xuICAgIENvbnRpbnVvdXNUaWNrZXIucHJvdG90eXBlLmdldF9taW5faW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbl9pbnRlcnZhbDtcbiAgICB9O1xuICAgIENvbnRpbnVvdXNUaWNrZXIucHJvdG90eXBlLmdldF9tYXhfaW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiAocmVmID0gdGhpcy5tYXhfaW50ZXJ2YWwpICE9IG51bGwgPyByZWYgOiAyZTMwODtcbiAgICB9O1xuICAgIENvbnRpbnVvdXNUaWNrZXIucHJvdG90eXBlLmdldF9pZGVhbF9pbnRlcnZhbCA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGRhdGFfcmFuZ2U7XG4gICAgICAgIGRhdGFfcmFuZ2UgPSBkYXRhX2hpZ2ggLSBkYXRhX2xvdztcbiAgICAgICAgcmV0dXJuIGRhdGFfcmFuZ2UgLyBkZXNpcmVkX25fdGlja3M7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGludW91c1RpY2tlcjtcbn0pKHRpY2tlcl8xLlRpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPTkVfSE9VUiwgT05FX01JTExJLCBPTkVfTUlOVVRFLCBPTkVfTU9OVEgsIE9ORV9TRUNPTkQsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBhZGFwdGl2ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2FkYXB0aXZlX3RpY2tlclwiKTtcbnZhciBjb21wb3NpdGVfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9jb21wb3NpdGVfdGlja2VyXCIpO1xudmFyIGRheXNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9kYXlzX3RpY2tlclwiKTtcbnZhciBtb250aHNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9tb250aHNfdGlja2VyXCIpO1xudmFyIHllYXJzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4veWVhcnNfdGlja2VyXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuT05FX01JTExJID0gdXRpbC5PTkVfTUlMTEk7XG5PTkVfU0VDT05EID0gdXRpbC5PTkVfU0VDT05EO1xuT05FX01JTlVURSA9IHV0aWwuT05FX01JTlVURTtcbk9ORV9IT1VSID0gdXRpbC5PTkVfSE9VUjtcbk9ORV9NT05USCA9IHV0aWwuT05FX01PTlRIO1xuZXhwb3J0cy5EYXRldGltZVRpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRldGltZVRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZXRpbWVUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBEYXRldGltZVRpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0ZXRpbWVUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnRGF0ZXRpbWVUaWNrZXInO1xuICAgIERhdGV0aW1lVGlja2VyLm92ZXJyaWRlKHtcbiAgICAgICAgbnVtX21pbm9yX3RpY2tzOiAwLFxuICAgICAgICB0aWNrZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBhZGFwdGl2ZV90aWNrZXJfMS5BZGFwdGl2ZVRpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhczogWzEsIDIsIDVdLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgbWluX2ludGVydmFsOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXhfaW50ZXJ2YWw6IDUwMCAqIE9ORV9NSUxMSSxcbiAgICAgICAgICAgICAgICAgICAgbnVtX21pbm9yX3RpY2tzOiAwXG4gICAgICAgICAgICAgICAgfSksIG5ldyBhZGFwdGl2ZV90aWNrZXJfMS5BZGFwdGl2ZVRpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhczogWzEsIDIsIDUsIDEwLCAxNSwgMjAsIDMwXSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogNjAsXG4gICAgICAgICAgICAgICAgICAgIG1pbl9pbnRlcnZhbDogT05FX1NFQ09ORCxcbiAgICAgICAgICAgICAgICAgICAgbWF4X2ludGVydmFsOiAzMCAqIE9ORV9NSU5VVEUsXG4gICAgICAgICAgICAgICAgICAgIG51bV9taW5vcl90aWNrczogMFxuICAgICAgICAgICAgICAgIH0pLCBuZXcgYWRhcHRpdmVfdGlja2VyXzEuQWRhcHRpdmVUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYXM6IFsxLCAyLCA0LCA2LCA4LCAxMl0sXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IDI0LjAsXG4gICAgICAgICAgICAgICAgICAgIG1pbl9pbnRlcnZhbDogT05FX0hPVVIsXG4gICAgICAgICAgICAgICAgICAgIG1heF9pbnRlcnZhbDogMTIgKiBPTkVfSE9VUixcbiAgICAgICAgICAgICAgICAgICAgbnVtX21pbm9yX3RpY2tzOiAwXG4gICAgICAgICAgICAgICAgfSksIG5ldyBkYXlzX3RpY2tlcl8xLkRheXNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBkYXlzOiBhcnJheV8xLnJhbmdlKDEsIDMyKVxuICAgICAgICAgICAgICAgIH0pLCBuZXcgZGF5c190aWNrZXJfMS5EYXlzVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZGF5czogYXJyYXlfMS5yYW5nZSgxLCAzMSwgMylcbiAgICAgICAgICAgICAgICB9KSwgbmV3IGRheXNfdGlja2VyXzEuRGF5c1RpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRheXM6IFsxLCA4LCAxNSwgMjJdXG4gICAgICAgICAgICAgICAgfSksIG5ldyBkYXlzX3RpY2tlcl8xLkRheXNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBkYXlzOiBbMSwgMTVdXG4gICAgICAgICAgICAgICAgfSksIG5ldyBtb250aHNfdGlja2VyXzEuTW9udGhzVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzOiBhcnJheV8xLnJhbmdlKDAsIDEyLCAxKVxuICAgICAgICAgICAgICAgIH0pLCBuZXcgbW9udGhzX3RpY2tlcl8xLk1vbnRoc1RpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoczogYXJyYXlfMS5yYW5nZSgwLCAxMiwgMilcbiAgICAgICAgICAgICAgICB9KSwgbmV3IG1vbnRoc190aWNrZXJfMS5Nb250aHNUaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBtb250aHM6IGFycmF5XzEucmFuZ2UoMCwgMTIsIDQpXG4gICAgICAgICAgICAgICAgfSksIG5ldyBtb250aHNfdGlja2VyXzEuTW9udGhzVGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzOiBhcnJheV8xLnJhbmdlKDAsIDEyLCA2KVxuICAgICAgICAgICAgICAgIH0pLCBuZXcgeWVhcnNfdGlja2VyXzEuWWVhcnNUaWNrZXIoe30pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGV0aW1lVGlja2VyO1xufSkoY29tcG9zaXRlX3RpY2tlcl8xLkNvbXBvc2l0ZVRpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPTkVfREFZLCBjb3B5X2RhdGUsIGRhdGVfcmFuZ2VfYnlfbW9udGgsIGxhc3RfbW9udGhfbm9fbGF0ZXJfdGhhbiwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNpbmdsZV9pbnRlcnZhbF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3NpbmdsZV9pbnRlcnZhbF90aWNrZXJcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG5jb3B5X2RhdGUgPSB1dGlsLmNvcHlfZGF0ZTtcbmxhc3RfbW9udGhfbm9fbGF0ZXJfdGhhbiA9IHV0aWwubGFzdF9tb250aF9ub19sYXRlcl90aGFuO1xuT05FX0RBWSA9IHV0aWwuT05FX0RBWTtcbmRhdGVfcmFuZ2VfYnlfbW9udGggPSBmdW5jdGlvbiAoc3RhcnRfdGltZSwgZW5kX3RpbWUpIHtcbiAgICB2YXIgZGF0ZSwgZGF0ZXMsIGVuZF9kYXRlLCBwcmV2X2VuZF9kYXRlLCBzdGFydF9kYXRlO1xuICAgIHN0YXJ0X2RhdGUgPSBsYXN0X21vbnRoX25vX2xhdGVyX3RoYW4obmV3IERhdGUoc3RhcnRfdGltZSkpO1xuICAgIGVuZF9kYXRlID0gbGFzdF9tb250aF9ub19sYXRlcl90aGFuKG5ldyBEYXRlKGVuZF90aW1lKSk7XG4gICAgcHJldl9lbmRfZGF0ZSA9IGNvcHlfZGF0ZShlbmRfZGF0ZSk7XG4gICAgZW5kX2RhdGUuc2V0VVRDTW9udGgoZW5kX2RhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRhdGVzID0gW107XG4gICAgZGF0ZSA9IHN0YXJ0X2RhdGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZGF0ZXMucHVzaChjb3B5X2RhdGUoZGF0ZSkpO1xuICAgICAgICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgICAgICBpZiAoZGF0ZSA+IGVuZF9kYXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG59O1xuZXhwb3J0cy5EYXlzVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERheXNUaWNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERheXNUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBEYXlzVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXlzVGlja2VyLnByb3RvdHlwZS50eXBlID0gJ0RheXNUaWNrZXInO1xuICAgIERheXNUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgZGF5czogW3AuQXJyYXksIFtdXVxuICAgIH0pO1xuICAgIERheXNUaWNrZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRheXMsIGludGVydmFsO1xuICAgICAgICBhdHRycy5udW1fbWlub3JfdGlja3MgPSAwO1xuICAgICAgICBEYXlzVGlja2VyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICBkYXlzID0gdGhpcy5kYXlzO1xuICAgICAgICBpbnRlcnZhbCA9IGRheXMubGVuZ3RoID4gMSA/IChkYXlzWzFdIC0gZGF5c1swXSkgKiBPTkVfREFZIDogMzEgKiBPTkVfREFZO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIH07XG4gICAgRGF5c1RpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBhbGxfdGlja3MsIGRhdGUsIGRheV9kYXRlLCBkYXlfZGF0ZXMsIGRheXMsIGRheXNfb2ZfbW9udGgsIGludGVydmFsLCBtb250aF9kYXRlcywgdGlja3NfaW5fcmFuZ2U7XG4gICAgICAgIG1vbnRoX2RhdGVzID0gZGF0ZV9yYW5nZV9ieV9tb250aChkYXRhX2xvdywgZGF0YV9oaWdoKTtcbiAgICAgICAgZGF5cyA9IHRoaXMuZGF5cztcbiAgICAgICAgZGF5c19vZl9tb250aCA9IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9udGhfZGF0ZSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZXMsIGRheSwgZGF5X2RhdGUsIGZ1dHVyZV9kYXRlLCBpLCBsZW47XG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheSA9IGRheXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGRheV9kYXRlID0gY29weV9kYXRlKG1vbnRoX2RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBkYXlfZGF0ZS5zZXRVVENEYXRlKGRheSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZV9kYXRlID0gbmV3IERhdGUoZGF5X2RhdGUuZ2V0VGltZSgpICsgKGludGVydmFsIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnV0dXJlX2RhdGUuZ2V0VVRDTW9udGgoKSA9PT0gbW9udGhfZGF0ZS5nZXRVVENNb250aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRheV9kYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuICAgICAgICBkYXlfZGF0ZXMgPSBhcnJheV8xLmNvbmNhdCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1vbnRoX2RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1vbnRoX2RhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXlzX29mX21vbnRoKGRhdGUsIGludGVydmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKSk7XG4gICAgICAgIGFsbF90aWNrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF5X2RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF5X2RhdGUgPSBkYXlfZGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRheV9kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGlja3NfaW5fcmFuZ2UgPSBhbGxfdGlja3MuZmlsdGVyKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGFfbG93IDw9IHRpY2sgJiYgdGljayA8PSBkYXRhX2hpZ2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogdGlja3NfaW5fcmFuZ2UsXG4gICAgICAgICAgICBcIm1pbm9yXCI6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRGF5c1RpY2tlcjtcbn0pKHNpbmdsZV9pbnRlcnZhbF90aWNrZXJfMS5TaW5nbGVJbnRlcnZhbFRpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgY29udGludW91c190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NvbnRpbnVvdXNfdGlja2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5GaXhlZFRpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChGaXhlZFRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRml4ZWRUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBGaXhlZFRpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRml4ZWRUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnRml4ZWRUaWNrZXInO1xuICAgIEZpeGVkVGlja2VyLmRlZmluZSh7XG4gICAgICAgIHRpY2tzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgRml4ZWRUaWNrZXIucHJvdG90eXBlLmdldF90aWNrc19ub19kZWZhdWx0cyA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBjcm9zc19sb2MsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFqb3I6IHRoaXMudGlja3MsXG4gICAgICAgICAgICBtaW5vcjogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBGaXhlZFRpY2tlcjtcbn0pKGNvbnRpbnVvdXNfdGlja2VyXzEuQ29udGludW91c1RpY2tlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhZGFwdGl2ZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2FkYXB0aXZlX3RpY2tlclwiKTtcbmV4cG9ydHMuQWRhcHRpdmVUaWNrZXIgPSBhZGFwdGl2ZV90aWNrZXJfMS5BZGFwdGl2ZVRpY2tlcjtcbnZhciBiYXNpY190aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2Jhc2ljX3RpY2tlclwiKTtcbmV4cG9ydHMuQmFzaWNUaWNrZXIgPSBiYXNpY190aWNrZXJfMS5CYXNpY1RpY2tlcjtcbnZhciBjYXRlZ29yaWNhbF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NhdGVnb3JpY2FsX3RpY2tlclwiKTtcbmV4cG9ydHMuQ2F0ZWdvcmljYWxUaWNrZXIgPSBjYXRlZ29yaWNhbF90aWNrZXJfMS5DYXRlZ29yaWNhbFRpY2tlcjtcbnZhciBjb21wb3NpdGVfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9jb21wb3NpdGVfdGlja2VyXCIpO1xuZXhwb3J0cy5Db21wb3NpdGVUaWNrZXIgPSBjb21wb3NpdGVfdGlja2VyXzEuQ29tcG9zaXRlVGlja2VyO1xudmFyIGNvbnRpbnVvdXNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9jb250aW51b3VzX3RpY2tlclwiKTtcbmV4cG9ydHMuQ29udGludW91c1RpY2tlciA9IGNvbnRpbnVvdXNfdGlja2VyXzEuQ29udGludW91c1RpY2tlcjtcbnZhciBkYXRldGltZV90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGV0aW1lX3RpY2tlclwiKTtcbmV4cG9ydHMuRGF0ZXRpbWVUaWNrZXIgPSBkYXRldGltZV90aWNrZXJfMS5EYXRldGltZVRpY2tlcjtcbnZhciBkYXlzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vZGF5c190aWNrZXJcIik7XG5leHBvcnRzLkRheXNUaWNrZXIgPSBkYXlzX3RpY2tlcl8xLkRheXNUaWNrZXI7XG52YXIgZml4ZWRfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9maXhlZF90aWNrZXJcIik7XG5leHBvcnRzLkZpeGVkVGlja2VyID0gZml4ZWRfdGlja2VyXzEuRml4ZWRUaWNrZXI7XG52YXIgbG9nX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vbG9nX3RpY2tlclwiKTtcbmV4cG9ydHMuTG9nVGlja2VyID0gbG9nX3RpY2tlcl8xLkxvZ1RpY2tlcjtcbnZhciBtZXJjYXRvcl90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL21lcmNhdG9yX3RpY2tlclwiKTtcbmV4cG9ydHMuTWVyY2F0b3JUaWNrZXIgPSBtZXJjYXRvcl90aWNrZXJfMS5NZXJjYXRvclRpY2tlcjtcbnZhciBtb250aHNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9tb250aHNfdGlja2VyXCIpO1xuZXhwb3J0cy5Nb250aHNUaWNrZXIgPSBtb250aHNfdGlja2VyXzEuTW9udGhzVGlja2VyO1xudmFyIHNpbmdsZV9pbnRlcnZhbF90aWNrZXJfMSA9IHJlcXVpcmUoXCIuL3NpbmdsZV9pbnRlcnZhbF90aWNrZXJcIik7XG5leHBvcnRzLlNpbmdsZUludGVydmFsVGlja2VyID0gc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xLlNpbmdsZUludGVydmFsVGlja2VyO1xudmFyIHRpY2tlcl8xID0gcmVxdWlyZShcIi4vdGlja2VyXCIpO1xuZXhwb3J0cy5UaWNrZXIgPSB0aWNrZXJfMS5UaWNrZXI7XG52YXIgeWVhcnNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi95ZWFyc190aWNrZXJcIik7XG5leHBvcnRzLlllYXJzVGlja2VyID0geWVhcnNfdGlja2VyXzEuWWVhcnNUaWNrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG52YXIgYWRhcHRpdmVfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9hZGFwdGl2ZV90aWNrZXJcIik7XG5leHBvcnRzLkxvZ1RpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2dUaWNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIExvZ1RpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIExvZ1RpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9nVGlja2VyLnByb3RvdHlwZS50eXBlID0gJ0xvZ1RpY2tlcic7XG4gICAgTG9nVGlja2VyLm92ZXJyaWRlKHtcbiAgICAgICAgbWFudGlzc2FzOiBbMSwgNV1cbiAgICB9KTtcbiAgICBMb2dUaWNrZXIucHJvdG90eXBlLmdldF90aWNrc19ub19kZWZhdWx0cyA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBjcm9zc19sb2MsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgYmFzZSwgZW5kX2ZhY3RvciwgZW5kbG9nLCBmYWN0b3IsIGZhY3RvcnMsIGksIGludGVydmFsLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQsIGxlbjUsIGxvZ19oaWdoLCBsb2dfaW50ZXJ2YWwsIGxvZ19sb3csIG0sIG1pbm9yX2ludGVydmFsLCBtaW5vcl9vZmZzZXRzLCBtaW5vcl90aWNrcywgbiwgbnVtX21pbm9yX3RpY2tzLCBvLCBzdGFydF9mYWN0b3IsIHN0YXJ0bG9nLCB0aWNrLCB0aWNrcywgeDtcbiAgICAgICAgbnVtX21pbm9yX3RpY2tzID0gdGhpcy5udW1fbWlub3JfdGlja3M7XG4gICAgICAgIG1pbm9yX3RpY2tzID0gW107XG4gICAgICAgIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgIGxvZ19sb3cgPSBNYXRoLmxvZyhkYXRhX2xvdykgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICAgICAgbG9nX2hpZ2ggPSBNYXRoLmxvZyhkYXRhX2hpZ2gpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgICAgIGxvZ19pbnRlcnZhbCA9IGxvZ19oaWdoIC0gbG9nX2xvdztcbiAgICAgICAgaWYgKGxvZ19pbnRlcnZhbCA8IDIpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gdGhpcy5nZXRfaW50ZXJ2YWwoZGF0YV9sb3csIGRhdGFfaGlnaCwgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9IE1hdGguZmxvb3IoZGF0YV9sb3cgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICBlbmRfZmFjdG9yID0gTWF0aC5jZWlsKGRhdGFfaGlnaCAvIGludGVydmFsKTtcbiAgICAgICAgICAgIGlmICh0eXBlc18xLmlzU3RyaWN0TmFOKHN0YXJ0X2ZhY3RvcikgfHwgdHlwZXNfMS5pc1N0cmljdE5hTihlbmRfZmFjdG9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBhcnJheV8xLnJhbmdlKHN0YXJ0X2ZhY3RvciwgZW5kX2ZhY3RvciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGlja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGZhY3RvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gZmFjdG9yc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhY3RvciAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZhY3RvciAqIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpZiAobnVtX21pbm9yX3RpY2tzID4gMSkge1xuICAgICAgICAgICAgICAgIG1pbm9yX2ludGVydmFsID0gaW50ZXJ2YWwgLyBudW1fbWlub3JfdGlja3M7XG4gICAgICAgICAgICAgICAgbWlub3Jfb2Zmc2V0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDEsIHJlZiA9IG51bV9taW5vcl90aWNrczsgMSA8PSByZWYgPyBqIDw9IHJlZiA6IGogPj0gcmVmOyBpID0gMSA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpICogbWlub3JfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbWlub3Jfb2Zmc2V0cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbWlub3Jfb2Zmc2V0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbWlub3JfdGlja3MucHVzaCh0aWNrc1swXSAtIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdGlja3MubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrc1trXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMiA9IG1pbm9yX29mZnNldHMubGVuZ3RoOyBsIDwgbGVuMjsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbWlub3Jfb2Zmc2V0c1tsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGljayArIHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRsb2cgPSBNYXRoLmNlaWwobG9nX2xvdyk7XG4gICAgICAgICAgICBlbmRsb2cgPSBNYXRoLmZsb29yKGxvZ19oaWdoKTtcbiAgICAgICAgICAgIGludGVydmFsID0gTWF0aC5jZWlsKChlbmRsb2cgLSBzdGFydGxvZykgLyA5LjApO1xuICAgICAgICAgICAgdGlja3MgPSBhcnJheV8xLnJhbmdlKHN0YXJ0bG9nLCBlbmRsb2csIGludGVydmFsKTtcbiAgICAgICAgICAgIGlmICgoZW5kbG9nIC0gc3RhcnRsb2cpICUgaW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRpY2tzLmNvbmNhdChbZW5kbG9nXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWNrcyA9IHRpY2tzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhiYXNlLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG51bV9taW5vcl90aWNrcyA+IDEpIHtcbiAgICAgICAgICAgICAgICBtaW5vcl9pbnRlcnZhbCA9IE1hdGgucG93KGJhc2UsIGludGVydmFsKSAvIG51bV9taW5vcl90aWNrcztcbiAgICAgICAgICAgICAgICBtaW5vcl9vZmZzZXRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBtID0gMSwgcmVmID0gbnVtX21pbm9yX3RpY2tzOyAxIDw9IHJlZiA/IG0gPD0gcmVmIDogbSA+PSByZWY7IGkgPSAxIDw9IHJlZiA/ICsrbSA6IC0tbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkgKiBtaW5vcl9pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKG0gPSAwLCBsZW4zID0gbWlub3Jfb2Zmc2V0cy5sZW5ndGg7IG0gPCBsZW4zOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbbV07XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGlja3NbMF0gLyB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMCwgbGVuNCA9IHRpY2tzLmxlbmd0aDsgbiA8IGxlbjQ7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrID0gdGlja3Nbbl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IDAsIGxlbjUgPSBtaW5vcl9vZmZzZXRzLmxlbmd0aDsgbyA8IGxlbjU7IG8rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbb107XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vcl90aWNrcy5wdXNoKHRpY2sgKiB4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFqb3I6IHRpY2tzLFxuICAgICAgICAgICAgbWlub3I6IG1pbm9yX3RpY2tzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTG9nVGlja2VyO1xufSkoYWRhcHRpdmVfdGlja2VyXzEuQWRhcHRpdmVUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJhc2ljX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vYmFzaWNfdGlja2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHByb2o0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3Byb2o0XCIpO1xuZXhwb3J0cy5NZXJjYXRvclRpY2tlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNZXJjYXRvclRpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWVyY2F0b3JUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBNZXJjYXRvclRpY2tlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVyY2F0b3JUaWNrZXIucHJvdG90eXBlLnR5cGUgPSAnTWVyY2F0b3JUaWNrZXInO1xuICAgIE1lcmNhdG9yVGlja2VyLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbjogW3AuTGF0TG9uXVxuICAgIH0pO1xuICAgIE1lcmNhdG9yVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIF8sIGksIGosIGssIGwsIGxhdCwgbGVuLCBsZW4xLCBsZW4yLCBsZW4zLCBsb24sIHByb2pfY3Jvc3NfbG9jLCBwcm9qX2hpZ2gsIHByb2pfbG93LCBwcm9qX3RpY2tzLCByZWYsIHJlZjEsIHJlZjEwLCByZWYxMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVmOCwgcmVmOSwgdGljaywgdGlja3M7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXJjYXRvclRpY2tlci5kaW1lbnNpb24gbm90IGNvbmZpZ3VyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9uID09PSBcImxvblwiKSB7XG4gICAgICAgICAgICByZWYgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmludmVyc2UoW2RhdGFfbG93LCBjcm9zc19sb2NdKSwgcHJval9sb3cgPSByZWZbMF0sIHByb2pfY3Jvc3NfbG9jID0gcmVmWzFdO1xuICAgICAgICAgICAgcmVmMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbZGF0YV9oaWdoLCBjcm9zc19sb2NdKSwgcHJval9oaWdoID0gcmVmMVswXSwgcHJval9jcm9zc19sb2MgPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMiA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuaW52ZXJzZShbY3Jvc3NfbG9jLCBkYXRhX2xvd10pLCBwcm9qX2Nyb3NzX2xvYyA9IHJlZjJbMF0sIHByb2pfbG93ID0gcmVmMlsxXTtcbiAgICAgICAgICAgIHJlZjMgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmludmVyc2UoW2Nyb3NzX2xvYywgZGF0YV9oaWdoXSksIHByb2pfY3Jvc3NfbG9jID0gcmVmM1swXSwgcHJval9oaWdoID0gcmVmM1sxXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qX3RpY2tzID0gTWVyY2F0b3JUaWNrZXIuX19zdXBlcl9fLmdldF90aWNrc19ub19kZWZhdWx0cy5jYWxsKHRoaXMsIHByb2pfbG93LCBwcm9qX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKTtcbiAgICAgICAgdGlja3MgPSB7XG4gICAgICAgICAgICBtYWpvcjogW10sXG4gICAgICAgICAgICBtaW5vcjogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9uID09PSBcImxvblwiKSB7XG4gICAgICAgICAgICByZWY0ID0gcHJval90aWNrcy5tYWpvcjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gcmVmNFtpXTtcbiAgICAgICAgICAgICAgICByZWY1ID0gcHJvajRfMS5wcm9qNChwcm9qNF8xLm1lcmNhdG9yKS5mb3J3YXJkKFt0aWNrLCBwcm9qX2Nyb3NzX2xvY10pLCBsb24gPSByZWY1WzBdLCBfID0gcmVmNVsxXTtcbiAgICAgICAgICAgICAgICB0aWNrcy5tYWpvci5wdXNoKGxvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWY2ID0gcHJval90aWNrcy5taW5vcjtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWY2Lmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSByZWY2W2pdO1xuICAgICAgICAgICAgICAgIHJlZjcgPSBwcm9qNF8xLnByb2o0KHByb2o0XzEubWVyY2F0b3IpLmZvcndhcmQoW3RpY2ssIHByb2pfY3Jvc3NfbG9jXSksIGxvbiA9IHJlZjdbMF0sIF8gPSByZWY3WzFdO1xuICAgICAgICAgICAgICAgIHRpY2tzLm1pbm9yLnB1c2gobG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjggPSBwcm9qX3RpY2tzLm1ham9yO1xuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjgubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgdGljayA9IHJlZjhba107XG4gICAgICAgICAgICAgICAgcmVmOSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuZm9yd2FyZChbcHJval9jcm9zc19sb2MsIHRpY2tdKSwgXyA9IHJlZjlbMF0sIGxhdCA9IHJlZjlbMV07XG4gICAgICAgICAgICAgICAgdGlja3MubWFqb3IucHVzaChsYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmMTAgPSBwcm9qX3RpY2tzLm1pbm9yO1xuICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMyA9IHJlZjEwLmxlbmd0aDsgbCA8IGxlbjM7IGwrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSByZWYxMFtsXTtcbiAgICAgICAgICAgICAgICByZWYxMSA9IHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvcikuZm9yd2FyZChbcHJval9jcm9zc19sb2MsIHRpY2tdKSwgXyA9IHJlZjExWzBdLCBsYXQgPSByZWYxMVsxXTtcbiAgICAgICAgICAgICAgICB0aWNrcy5taW5vci5wdXNoKGxhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmNhdG9yVGlja2VyO1xufSkoYmFzaWNfdGlja2VyXzEuQmFzaWNUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT05FX01PTlRILCBjb3B5X2RhdGUsIGRhdGVfcmFuZ2VfYnlfeWVhciwgbGFzdF95ZWFyX25vX2xhdGVyX3RoYW4sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzaW5nbGVfaW50ZXJ2YWxfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9zaW5nbGVfaW50ZXJ2YWxfdGlja2VyXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xuY29weV9kYXRlID0gdXRpbC5jb3B5X2RhdGU7XG5sYXN0X3llYXJfbm9fbGF0ZXJfdGhhbiA9IHV0aWwubGFzdF95ZWFyX25vX2xhdGVyX3RoYW47XG5PTkVfTU9OVEggPSB1dGlsLk9ORV9NT05USDtcbmRhdGVfcmFuZ2VfYnlfeWVhciA9IGZ1bmN0aW9uIChzdGFydF90aW1lLCBlbmRfdGltZSkge1xuICAgIHZhciBkYXRlLCBkYXRlcywgZW5kX2RhdGUsIHN0YXJ0X2RhdGU7XG4gICAgc3RhcnRfZGF0ZSA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKHN0YXJ0X3RpbWUpKTtcbiAgICBlbmRfZGF0ZSA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKGVuZF90aW1lKSk7XG4gICAgZW5kX2RhdGUuc2V0VVRDRnVsbFllYXIoZW5kX2RhdGUuZ2V0VVRDRnVsbFllYXIoKSArIDEpO1xuICAgIGRhdGVzID0gW107XG4gICAgZGF0ZSA9IHN0YXJ0X2RhdGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZGF0ZXMucHVzaChjb3B5X2RhdGUoZGF0ZSkpO1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIDEpO1xuICAgICAgICBpZiAoZGF0ZSA+IGVuZF9kYXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG59O1xuZXhwb3J0cy5Nb250aHNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTW9udGhzVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNb250aHNUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBNb250aHNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbnRoc1RpY2tlci5wcm90b3R5cGUudHlwZSA9ICdNb250aHNUaWNrZXInO1xuICAgIE1vbnRoc1RpY2tlci5kZWZpbmUoe1xuICAgICAgICBtb250aHM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBNb250aHNUaWNrZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGludGVydmFsLCBtb250aHM7XG4gICAgICAgIE1vbnRoc1RpY2tlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5tb250aHM7XG4gICAgICAgIGludGVydmFsID0gbW9udGhzLmxlbmd0aCA+IDEgPyAobW9udGhzWzFdIC0gbW9udGhzWzBdKSAqIE9ORV9NT05USCA6IDEyICogT05FX01PTlRIO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIH07XG4gICAgTW9udGhzVGlja2VyLnByb3RvdHlwZS5nZXRfdGlja3Nfbm9fZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCBkZXNpcmVkX25fdGlja3MpIHtcbiAgICAgICAgdmFyIGFsbF90aWNrcywgZGF0ZSwgbW9udGhfZGF0ZSwgbW9udGhfZGF0ZXMsIG1vbnRocywgbW9udGhzX29mX3llYXIsIHRpY2tzX2luX3JhbmdlLCB5ZWFyX2RhdGVzO1xuICAgICAgICB5ZWFyX2RhdGVzID0gZGF0ZV9yYW5nZV9ieV95ZWFyKGRhdGFfbG93LCBkYXRhX2hpZ2gpO1xuICAgICAgICBtb250aHMgPSB0aGlzLm1vbnRocztcbiAgICAgICAgbW9udGhzX29mX3llYXIgPSBmdW5jdGlvbiAoeWVhcl9kYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhzLm1hcChmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhfZGF0ZTtcbiAgICAgICAgICAgICAgICBtb250aF9kYXRlID0gY29weV9kYXRlKHllYXJfZGF0ZSk7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF0ZS5zZXRVVENNb250aChtb250aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoX2RhdGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbW9udGhfZGF0ZXMgPSBhcnJheV8xLmNvbmNhdCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHllYXJfZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRlID0geWVhcl9kYXRlc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobW9udGhzX29mX3llYXIoZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCkpO1xuICAgICAgICBhbGxfdGlja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1vbnRoX2RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF0ZSA9IG1vbnRoX2RhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChtb250aF9kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGlja3NfaW5fcmFuZ2UgPSBhbGxfdGlja3MuZmlsdGVyKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGFfbG93IDw9IHRpY2sgJiYgdGljayA8PSBkYXRhX2hpZ2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwibWFqb3JcIjogdGlja3NfaW5fcmFuZ2UsXG4gICAgICAgICAgICBcIm1pbm9yXCI6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGhzVGlja2VyO1xufSkoc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xLlNpbmdsZUludGVydmFsVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjb250aW51b3VzX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vY29udGludW91c190aWNrZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlNpbmdsZUludGVydmFsVGlja2VyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNpbmdsZUludGVydmFsVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTaW5nbGVJbnRlcnZhbFRpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIFNpbmdsZUludGVydmFsVGlja2VyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTaW5nbGVJbnRlcnZhbFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdTaW5nbGVJbnRlcnZhbFRpY2tlcic7XG4gICAgU2luZ2xlSW50ZXJ2YWxUaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgaW50ZXJ2YWw6IFtwLk51bWJlcl1cbiAgICB9KTtcbiAgICBTaW5nbGVJbnRlcnZhbFRpY2tlci5nZXR0ZXJzKHtcbiAgICAgICAgbWluX2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4X2ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNpbmdsZUludGVydmFsVGlja2VyLnByb3RvdHlwZS5nZXRfaW50ZXJ2YWwgPSBmdW5jdGlvbiAoZGF0YV9sb3csIGRhdGFfaGlnaCwgbl9kZXNpcmVkX3RpY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZUludGVydmFsVGlja2VyO1xufSkoY29udGludW91c190aWNrZXJfMS5Db250aW51b3VzVGlja2VyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5UaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGlja2VyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpY2tlci5wcm90b3R5cGUudHlwZSA9ICdUaWNrZXInO1xuICAgIFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIHJhbmdlLCBjcm9zc19sb2MsIGFyZykge1xuICAgICAgICB2YXIgZGVzaXJlZF9uX3RpY2tzO1xuICAgICAgICBkZXNpcmVkX25fdGlja3MgPSBhcmcuZGVzaXJlZF9uX3RpY2tzO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfdGlja3Nfbm9fZGVmYXVsdHMoZGF0YV9sb3csIGRhdGFfaGlnaCwgY3Jvc3NfbG9jLCB0aGlzLmRlc2lyZWRfbnVtX3RpY2tzKTtcbiAgICB9O1xuICAgIFRpY2tlci5wcm90b3R5cGUuZ2V0X3RpY2tzX25vX2RlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGNyb3NzX2xvYywgZGVzaXJlZF9uX3RpY2tzKSB7XG4gICAgICAgIHZhciBlbmRfZmFjdG9yLCBmYWN0b3IsIGZhY3RvcnMsIGksIGludGVydmFsLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIG1pbm9yX2ludGVydmFsLCBtaW5vcl9vZmZzZXRzLCBtaW5vcl90aWNrcywgbnVtX21pbm9yX3RpY2tzLCBzdGFydF9mYWN0b3IsIHRpY2ssIHRpY2tzLCB4O1xuICAgICAgICBpbnRlcnZhbCA9IHRoaXMuZ2V0X2ludGVydmFsKGRhdGFfbG93LCBkYXRhX2hpZ2gsIGRlc2lyZWRfbl90aWNrcyk7XG4gICAgICAgIHN0YXJ0X2ZhY3RvciA9IE1hdGguZmxvb3IoZGF0YV9sb3cgLyBpbnRlcnZhbCk7XG4gICAgICAgIGVuZF9mYWN0b3IgPSBNYXRoLmNlaWwoZGF0YV9oaWdoIC8gaW50ZXJ2YWwpO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmljdE5hTihzdGFydF9mYWN0b3IpIHx8IHR5cGVzXzEuaXNTdHJpY3ROYU4oZW5kX2ZhY3RvcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvcnMgPSBhcnJheV8xLnJhbmdlKHN0YXJ0X2ZhY3RvciwgZW5kX2ZhY3RvciArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBmYWN0b3JzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID0gZmFjdG9yc1tqXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFjdG9yICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIG51bV9taW5vcl90aWNrcyA9IHRoaXMubnVtX21pbm9yX3RpY2tzO1xuICAgICAgICBtaW5vcl90aWNrcyA9IFtdO1xuICAgICAgICBpZiAobnVtX21pbm9yX3RpY2tzID4gMSkge1xuICAgICAgICAgICAgbWlub3JfaW50ZXJ2YWwgPSBpbnRlcnZhbCAvIG51bV9taW5vcl90aWNrcztcbiAgICAgICAgICAgIG1pbm9yX29mZnNldHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAxLCByZWYgPSBudW1fbWlub3JfdGlja3M7IDEgPD0gcmVmID8gaiA8PSByZWYgOiBqID49IHJlZjsgaSA9IDEgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpICogbWlub3JfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBtaW5vcl9vZmZzZXRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbal07XG4gICAgICAgICAgICAgICAgbWlub3JfdGlja3MucHVzaCh0aWNrc1swXSAtIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHRpY2tzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrc1trXTtcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4yID0gbWlub3Jfb2Zmc2V0cy5sZW5ndGg7IGwgPCBsZW4yOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pbm9yX29mZnNldHNbbF07XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yX3RpY2tzLnB1c2godGljayArIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJtYWpvclwiOiB0aWNrcyxcbiAgICAgICAgICAgIFwibWlub3JcIjogbWlub3JfdGlja3NcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaWNrZXI7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PTkVfTUlMTEkgPSAxLjA7XG5leHBvcnRzLk9ORV9TRUNPTkQgPSAxMDAwLjA7XG5leHBvcnRzLk9ORV9NSU5VVEUgPSA2MC4wICogZXhwb3J0cy5PTkVfU0VDT05EO1xuZXhwb3J0cy5PTkVfSE9VUiA9IDYwICogZXhwb3J0cy5PTkVfTUlOVVRFO1xuZXhwb3J0cy5PTkVfREFZID0gMjQgKiBleHBvcnRzLk9ORV9IT1VSO1xuZXhwb3J0cy5PTkVfTU9OVEggPSAzMCAqIGV4cG9ydHMuT05FX0RBWTtcbmV4cG9ydHMuT05FX1lFQVIgPSAzNjUgKiBleHBvcnRzLk9ORV9EQVk7XG5leHBvcnRzLmNvcHlfZGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbn07XG5leHBvcnRzLmxhc3RfbW9udGhfbm9fbGF0ZXJfdGhhbiA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgZGF0ZSA9IGV4cG9ydHMuY29weV9kYXRlKGRhdGUpO1xuICAgIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDApO1xuICAgIGRhdGUuc2V0VVRDTWludXRlcygwKTtcbiAgICBkYXRlLnNldFVUQ1NlY29uZHMoMCk7XG4gICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gICAgcmV0dXJuIGRhdGU7XG59O1xuZXhwb3J0cy5sYXN0X3llYXJfbm9fbGF0ZXJfdGhhbiA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgZGF0ZSA9IGV4cG9ydHMubGFzdF9tb250aF9ub19sYXRlcl90aGFuKGRhdGUpO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCk7XG4gICAgcmV0dXJuIGRhdGU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT05FX1lFQVIsIGxhc3RfeWVhcl9ub19sYXRlcl90aGFuLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYmFzaWNfdGlja2VyXzEgPSByZXF1aXJlKFwiLi9iYXNpY190aWNrZXJcIik7XG52YXIgc2luZ2xlX2ludGVydmFsX3RpY2tlcl8xID0gcmVxdWlyZShcIi4vc2luZ2xlX2ludGVydmFsX3RpY2tlclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmxhc3RfeWVhcl9ub19sYXRlcl90aGFuID0gdXRpbC5sYXN0X3llYXJfbm9fbGF0ZXJfdGhhbjtcbk9ORV9ZRUFSID0gdXRpbC5PTkVfWUVBUjtcbmV4cG9ydHMuWWVhcnNUaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWWVhcnNUaWNrZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFllYXJzVGlja2VyKCkge1xuICAgICAgICByZXR1cm4gWWVhcnNUaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFllYXJzVGlja2VyLnByb3RvdHlwZS50eXBlID0gJ1llYXJzVGlja2VyJztcbiAgICBZZWFyc1RpY2tlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBZZWFyc1RpY2tlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IE9ORV9ZRUFSO1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNpY190aWNrZXIgPSBuZXcgYmFzaWNfdGlja2VyXzEuQmFzaWNUaWNrZXIoe1xuICAgICAgICAgICAgbnVtX21pbm9yX3RpY2tzOiAwXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWWVhcnNUaWNrZXIucHJvdG90eXBlLmdldF90aWNrc19ub19kZWZhdWx0cyA9IGZ1bmN0aW9uIChkYXRhX2xvdywgZGF0YV9oaWdoLCBjcm9zc19sb2MsIGRlc2lyZWRfbl90aWNrcykge1xuICAgICAgICB2YXIgYWxsX3RpY2tzLCBlbmRfeWVhciwgc3RhcnRfeWVhciwgdGlja3NfaW5fcmFuZ2UsIHllYXIsIHllYXJzO1xuICAgICAgICBzdGFydF95ZWFyID0gbGFzdF95ZWFyX25vX2xhdGVyX3RoYW4obmV3IERhdGUoZGF0YV9sb3cpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBlbmRfeWVhciA9IGxhc3RfeWVhcl9ub19sYXRlcl90aGFuKG5ldyBEYXRlKGRhdGFfaGlnaCkpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIHllYXJzID0gdGhpcy5iYXNpY190aWNrZXIuZ2V0X3RpY2tzX25vX2RlZmF1bHRzKHN0YXJ0X3llYXIsIGVuZF95ZWFyLCBjcm9zc19sb2MsIGRlc2lyZWRfbl90aWNrcykubWFqb3I7XG4gICAgICAgIGFsbF90aWNrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0geWVhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0geWVhcnNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKERhdGUuVVRDKHllYXIsIDAsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aWNrc19pbl9yYW5nZSA9IGFsbF90aWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YV9sb3cgPD0gdGljayAmJiB0aWNrIDw9IGRhdGFfaGlnaCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFqb3I6IHRpY2tzX2luX3JhbmdlLFxuICAgICAgICAgICAgbWlub3I6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gWWVhcnNUaWNrZXI7XG59KShzaW5nbGVfaW50ZXJ2YWxfdGlja2VyXzEuU2luZ2xlSW50ZXJ2YWxUaWNrZXIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1lcmNhdG9yX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tZXJjYXRvcl90aWxlX3NvdXJjZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQkJveFRpbGVTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQkJveFRpbGVTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJCb3hUaWxlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gQkJveFRpbGVTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJCb3hUaWxlU291cmNlLnByb3RvdHlwZS50eXBlID0gJ0JCb3hUaWxlU291cmNlJztcbiAgICBCQm94VGlsZVNvdXJjZS5kZWZpbmUoe1xuICAgICAgICB1c2VfbGF0bG9uOiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICBCQm94VGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2ltYWdlX3VybCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBpbWFnZV91cmwsIHJlZiwgcmVmMSwgeG1heCwgeG1pbiwgeW1heCwgeW1pbjtcbiAgICAgICAgaW1hZ2VfdXJsID0gdGhpcy5zdHJpbmdfbG9va3VwX3JlcGxhY2UodGhpcy51cmwsIHRoaXMuZXh0cmFfdXJsX3ZhcnMpO1xuICAgICAgICBpZiAodGhpcy51c2VfbGF0bG9uKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLmdldF90aWxlX2dlb2dyYXBoaWNfYm91bmRzKHgsIHksIHopLCB4bWluID0gcmVmWzBdLCB5bWluID0gcmVmWzFdLCB4bWF4ID0gcmVmWzJdLCB5bWF4ID0gcmVmWzNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHgsIHksIHopLCB4bWluID0gcmVmMVswXSwgeW1pbiA9IHJlZjFbMV0sIHhtYXggPSByZWYxWzJdLCB5bWF4ID0gcmVmMVszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VfdXJsLnJlcGxhY2UoXCJ7WE1JTn1cIiwgeG1pbikucmVwbGFjZShcIntZTUlOfVwiLCB5bWluKS5yZXBsYWNlKFwie1hNQVh9XCIsIHhtYXgpLnJlcGxhY2UoXCJ7WU1BWH1cIiwgeW1heCk7XG4gICAgfTtcbiAgICByZXR1cm4gQkJveFRpbGVTb3VyY2U7XG59KShtZXJjYXRvcl90aWxlX3NvdXJjZV8xLk1lcmNhdG9yVGlsZVNvdXJjZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciByZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3JlbmRlcmVycy9yZW5kZXJlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5EeW5hbWljSW1hZ2VWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKER5bmFtaWNJbWFnZVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIER5bmFtaWNJbWFnZVZpZXcoKSB7XG4gICAgICAgIHRoaXMuX29uX2ltYWdlX2Vycm9yID0gYmluZCh0aGlzLl9vbl9pbWFnZV9lcnJvciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX29uX2ltYWdlX2xvYWQgPSBiaW5kKHRoaXMuX29uX2ltYWdlX2xvYWQsIHRoaXMpO1xuICAgICAgICByZXR1cm4gRHluYW1pY0ltYWdlVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRHluYW1pY0ltYWdlVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlcXVlc3RfcmVuZGVyKTtcbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLmdldF9leHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy54X3JhbmdlLnN0YXJ0LCB0aGlzLnlfcmFuZ2Uuc3RhcnQsIHRoaXMueF9yYW5nZS5lbmQsIHRoaXMueV9yYW5nZS5lbmRdO1xuICAgIH07XG4gICAgRHluYW1pY0ltYWdlVmlldy5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hcF9wbG90ID0gdGhpcy5wbG90X3ZpZXcubW9kZWwucGxvdDtcbiAgICAgICAgdGhpcy5tYXBfY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuY3R4O1xuICAgICAgICB0aGlzLm1hcF9mcmFtZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICB0aGlzLnhfcmFuZ2UgPSB0aGlzLm1hcF9wbG90LnhfcmFuZ2U7XG4gICAgICAgIHRoaXMueF9tYXBwZXIgPSB0aGlzLm1hcF9mcmFtZS54X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdGhpcy55X3JhbmdlID0gdGhpcy5tYXBfcGxvdC55X3JhbmdlO1xuICAgICAgICB0aGlzLnlfbWFwcGVyID0gdGhpcy5tYXBfZnJhbWUueV9tYXBwZXJzWydkZWZhdWx0J107XG4gICAgICAgIHRoaXMubGFzdEltYWdlID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbnQgPSB0aGlzLmdldF9leHRlbnQoKTtcbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLl9tYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbF9leHRlbnQgPSB0aGlzLmdldF9leHRlbnQoKTtcbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLl9vbl9pbWFnZV9sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGltYWdlX2RhdGE7XG4gICAgICAgIGltYWdlX2RhdGEgPSBlLnRhcmdldC5pbWFnZV9kYXRhO1xuICAgICAgICBpbWFnZV9kYXRhLmltZyA9IGUudGFyZ2V0O1xuICAgICAgICBpbWFnZV9kYXRhLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdEltYWdlID0gaW1hZ2VfZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0X2V4dGVudCgpLmpvaW4oJzonKSA9PT0gaW1hZ2VfZGF0YS5jYWNoZV9rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLl9vbl9pbWFnZV9lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpbWFnZV9kYXRhO1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIGltYWdlOiAje2UudGFyZ2V0LnNyY30nKTtcbiAgICAgICAgaW1hZ2VfZGF0YSA9IGUudGFyZ2V0LmltYWdlX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmltYWdlX3NvdXJjZS5yZW1vdmVfaW1hZ2UoaW1hZ2VfZGF0YSk7XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fY3JlYXRlX2ltYWdlID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICB2YXIgaW1hZ2U7XG4gICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IHRoaXMuX29uX2ltYWdlX2xvYWQ7XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSB0aGlzLl9vbl9pbWFnZV9lcnJvcjtcbiAgICAgICAgaW1hZ2UuYWx0ID0gJyc7XG4gICAgICAgIGltYWdlLmltYWdlX2RhdGEgPSB7XG4gICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICBjYWNoZV9rZXk6IGJvdW5kcy5qb2luKCc6JylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5pbWFnZV9zb3VyY2UuYWRkX2ltYWdlKGltYWdlLmltYWdlX2RhdGEpO1xuICAgICAgICBpbWFnZS5zcmMgPSB0aGlzLm1vZGVsLmltYWdlX3NvdXJjZS5nZXRfaW1hZ2VfdXJsKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIGJvdW5kc1szXSwgTWF0aC5jZWlsKHRoaXMubWFwX2ZyYW1lLmhlaWdodCksIE1hdGguY2VpbCh0aGlzLm1hcF9mcmFtZS53aWR0aCkpO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmdzKSB7XG4gICAgICAgIHZhciBleHRlbnQsIGltYWdlX29iajtcbiAgICAgICAgaWYgKHRoaXMubWFwX2luaXRpYWxpemVkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldF9kYXRhKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXBfZGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5tYXBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVudCA9IHRoaXMuZ2V0X2V4dGVudCgpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJfdGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbmRlcl90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2Vfb2JqID0gdGhpcy5tb2RlbC5pbWFnZV9zb3VyY2UuaW1hZ2VzW2V4dGVudC5qb2luKCc6JyldO1xuICAgICAgICBpZiAoKGltYWdlX29iaiAhPSBudWxsKSAmJiBpbWFnZV9vYmoubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X2ltYWdlKGV4dGVudC5qb2luKCc6JykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3X2ltYWdlKHRoaXMubGFzdEltYWdlLmNhY2hlX2tleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlX29iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJfdGltZXIgPSBzZXRUaW1lb3V0KCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVfaW1hZ2UoZXh0ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcykpLCAxMjUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEeW5hbWljSW1hZ2VWaWV3LnByb3RvdHlwZS5fZHJhd19pbWFnZSA9IGZ1bmN0aW9uIChpbWFnZV9rZXkpIHtcbiAgICAgICAgdmFyIGltYWdlX29iaiwgcmVmLCByZWYxLCBzaCwgc3csIHN4LCBzeG1heCwgc3htaW4sIHN5LCBzeW1heCwgc3ltaW47XG4gICAgICAgIGltYWdlX29iaiA9IHRoaXMubW9kZWwuaW1hZ2Vfc291cmNlLmltYWdlc1tpbWFnZV9rZXldO1xuICAgICAgICBpZiAoaW1hZ2Vfb2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWFwX2NhbnZhcy5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRfcmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5tYXBfY2FudmFzLmdsb2JhbEFscGhhID0gdGhpcy5tb2RlbC5hbHBoYTtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMucGxvdF92aWV3LmZyYW1lLm1hcF90b19zY3JlZW4oW2ltYWdlX29iai5ib3VuZHNbMF1dLCBbaW1hZ2Vfb2JqLmJvdW5kc1szXV0sIHRoaXMucGxvdF92aWV3LmNhbnZhcyksIHN4bWluID0gcmVmWzBdLCBzeW1pbiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5tYXBfdG9fc2NyZWVuKFtpbWFnZV9vYmouYm91bmRzWzJdXSwgW2ltYWdlX29iai5ib3VuZHNbMV1dLCB0aGlzLnBsb3Rfdmlldy5jYW52YXMpLCBzeG1heCA9IHJlZjFbMF0sIHN5bWF4ID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHN4bWluID0gc3htaW5bMF07XG4gICAgICAgICAgICBzeW1pbiA9IHN5bWluWzBdO1xuICAgICAgICAgICAgc3htYXggPSBzeG1heFswXTtcbiAgICAgICAgICAgIHN5bWF4ID0gc3ltYXhbMF07XG4gICAgICAgICAgICBzdyA9IHN4bWF4IC0gc3htaW47XG4gICAgICAgICAgICBzaCA9IHN5bWF4IC0gc3ltaW47XG4gICAgICAgICAgICBzeCA9IHN4bWluO1xuICAgICAgICAgICAgc3kgPSBzeW1pbjtcbiAgICAgICAgICAgIHRoaXMubWFwX2NhbnZhcy5kcmF3SW1hZ2UoaW1hZ2Vfb2JqLmltZywgc3gsIHN5LCBzdywgc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwX2NhbnZhcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIER5bmFtaWNJbWFnZVZpZXcucHJvdG90eXBlLl9zZXRfcmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGgsIGwsIG91dGxpbmVfd2lkdGgsIHQsIHc7XG4gICAgICAgIG91dGxpbmVfd2lkdGggPSB0aGlzLnBsb3RfbW9kZWwucGxvdC5wcm9wZXJ0aWVzLm91dGxpbmVfbGluZV93aWR0aC52YWx1ZSgpO1xuICAgICAgICBsID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ4X3RvX3N4KHRoaXMubWFwX2ZyYW1lLmxlZnQpICsgKG91dGxpbmVfd2lkdGggLyAyKTtcbiAgICAgICAgdCA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy52eV90b19zeSh0aGlzLm1hcF9mcmFtZS50b3ApICsgKG91dGxpbmVfd2lkdGggLyAyKTtcbiAgICAgICAgdyA9IHRoaXMubWFwX2ZyYW1lLndpZHRoIC0gb3V0bGluZV93aWR0aDtcbiAgICAgICAgaCA9IHRoaXMubWFwX2ZyYW1lLmhlaWdodCAtIG91dGxpbmVfd2lkdGg7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5yZWN0KGwsIHQsIHcsIGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBfY2FudmFzLmNsaXAoKTtcbiAgICB9O1xuICAgIHJldHVybiBEeW5hbWljSW1hZ2VWaWV3O1xufSkocmVuZGVyZXJfMS5SZW5kZXJlclZpZXcpO1xuZXhwb3J0cy5EeW5hbWljSW1hZ2VSZW5kZXJlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEeW5hbWljSW1hZ2VSZW5kZXJlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRHluYW1pY0ltYWdlUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBEeW5hbWljSW1hZ2VSZW5kZXJlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRHluYW1pY0ltYWdlUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRHluYW1pY0ltYWdlVmlldztcbiAgICBEeW5hbWljSW1hZ2VSZW5kZXJlci5wcm90b3R5cGUudHlwZSA9ICdEeW5hbWljSW1hZ2VSZW5kZXJlcic7XG4gICAgRHluYW1pY0ltYWdlUmVuZGVyZXIuZGVmaW5lKHtcbiAgICAgICAgYWxwaGE6IFtwLk51bWJlciwgMS4wXSxcbiAgICAgICAgaW1hZ2Vfc291cmNlOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIHJlbmRlcl9wYXJlbnRzOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIER5bmFtaWNJbWFnZVJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICd1bmRlcmxheSdcbiAgICB9KTtcbiAgICByZXR1cm4gRHluYW1pY0ltYWdlUmVuZGVyZXI7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbWFnZVBvb2wgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltYWdlUG9vbCgpIHtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB9XG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWc7XG4gICAgICAgIGltZyA9IHRoaXMuaW1hZ2VzLnBvcCgpO1xuICAgICAgICBpZiAoaW1nICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlUG9vbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VzLmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmltYWdlcywgaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlcy5wdXNoKGltZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVBvb2w7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLkltYWdlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEltYWdlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdJbWFnZVNvdXJjZSc7XG4gICAgSW1hZ2VTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgdXJsOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgZXh0cmFfdXJsX3ZhcnM6IFtwLkFueSwge31dXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gSW1hZ2VTb3VyY2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgSW1hZ2VTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAgIHRoaXMubm9ybWFsaXplX2Nhc2UoKTtcbiAgICB9XG4gICAgSW1hZ2VTb3VyY2UucHJvdG90eXBlLm5vcm1hbGl6ZV9jYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAnTm90ZTogc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgaW50byBzdWJjbGFzc2VzLic7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htaW59JywgJ3tYTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltaW59JywgJ3tZTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htYXh9JywgJ3tYTUFYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltYXh9JywgJ3tZTUFYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne2hlaWdodH0nLCAne0hFSUdIVH0nKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t3aWR0aH0nLCAne1dJRFRIfScpO1xuICAgICAgICByZXR1cm4gdGhpcy51cmwgPSB1cmw7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuc3RyaW5nX2xvb2t1cF9yZXBsYWNlID0gZnVuY3Rpb24gKHN0ciwgbG9va3VwKSB7XG4gICAgICAgIHZhciBrZXksIHJlc3VsdF9zdHIsIHZhbHVlO1xuICAgICAgICByZXN1bHRfc3RyID0gc3RyO1xuICAgICAgICBmb3IgKGtleSBpbiBsb29rdXApIHtcbiAgICAgICAgICAgIHZhbHVlID0gbG9va3VwW2tleV07XG4gICAgICAgICAgICByZXN1bHRfc3RyID0gcmVzdWx0X3N0ci5yZXBsYWNlKCd7JyArIGtleSArICd9JywgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF9zdHI7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuYWRkX2ltYWdlID0gZnVuY3Rpb24gKGltYWdlX29iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaW1hZ2Vfb2JqLmNhY2hlX2tleV0gPSBpbWFnZV9vYmo7XG4gICAgfTtcbiAgICBJbWFnZVNvdXJjZS5wcm90b3R5cGUucmVtb3ZlX2ltYWdlID0gZnVuY3Rpb24gKGltYWdlX29iaikge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuaW1hZ2VzW2ltYWdlX29iai5jYWNoZV9rZXldO1xuICAgIH07XG4gICAgSW1hZ2VTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeG1pbiwgeW1pbiwgeG1heCwgeW1heCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsO1xuICAgICAgICBpbWFnZV91cmwgPSB0aGlzLnN0cmluZ19sb29rdXBfcmVwbGFjZSh0aGlzLnVybCwgdGhpcy5leHRyYV91cmxfdmFycyk7XG4gICAgICAgIHJldHVybiBpbWFnZV91cmwucmVwbGFjZShcIntYTUlOfVwiLCB4bWluKS5yZXBsYWNlKFwie1lNSU59XCIsIHltaW4pLnJlcGxhY2UoXCJ7WE1BWH1cIiwgeG1heCkucmVwbGFjZShcIntZTUFYfVwiLCB5bWF4KS5yZXBsYWNlKFwie1dJRFRIfVwiLCB3aWR0aCkucmVwbGFjZShcIntIRUlHSFR9XCIsIGhlaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VTb3VyY2U7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJib3hfdGlsZV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2Jib3hfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLkJCb3hUaWxlU291cmNlID0gYmJveF90aWxlX3NvdXJjZV8xLkJCb3hUaWxlU291cmNlO1xudmFyIGR5bmFtaWNfaW1hZ2VfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL2R5bmFtaWNfaW1hZ2VfcmVuZGVyZXJcIik7XG5leHBvcnRzLkR5bmFtaWNJbWFnZVJlbmRlcmVyID0gZHluYW1pY19pbWFnZV9yZW5kZXJlcl8xLkR5bmFtaWNJbWFnZVJlbmRlcmVyO1xudmFyIGltYWdlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vaW1hZ2Vfc291cmNlXCIpO1xuZXhwb3J0cy5JbWFnZVNvdXJjZSA9IGltYWdlX3NvdXJjZV8xLkltYWdlU291cmNlO1xudmFyIG1lcmNhdG9yX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tZXJjYXRvcl90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuTWVyY2F0b3JUaWxlU291cmNlID0gbWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2U7XG52YXIgcXVhZGtleV90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vcXVhZGtleV90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuUVVBREtFWVRpbGVTb3VyY2UgPSBxdWFka2V5X3RpbGVfc291cmNlXzEuUVVBREtFWVRpbGVTb3VyY2U7XG52YXIgdGlsZV9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vdGlsZV9yZW5kZXJlclwiKTtcbmV4cG9ydHMuVGlsZVJlbmRlcmVyID0gdGlsZV9yZW5kZXJlcl8xLlRpbGVSZW5kZXJlcjtcbnZhciB0aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlRpbGVTb3VyY2UgPSB0aWxlX3NvdXJjZV8xLlRpbGVTb3VyY2U7XG52YXIgdG1zX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi90bXNfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlRNU1RpbGVTb3VyY2UgPSB0bXNfdGlsZV9zb3VyY2VfMS5UTVNUaWxlU291cmNlO1xudmFyIHdtdHNfdGlsZV9zb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3dtdHNfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLldNVFNUaWxlU291cmNlID0gd210c190aWxlX3NvdXJjZV8xLldNVFNUaWxlU291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIHRpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi90aWxlX3NvdXJjZVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuTWVyY2F0b3JUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1lcmNhdG9yVGlsZVNvdXJjZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTWVyY2F0b3JUaWxlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gTWVyY2F0b3JUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnR5cGUgPSAnTWVyY2F0b3JUaWxlU291cmNlJztcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgd3JhcF9hcm91bmQ6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLm92ZXJyaWRlKHtcbiAgICAgICAgeF9vcmlnaW5fb2Zmc2V0OiAyMDAzNzUwOC4zNCxcbiAgICAgICAgeV9vcmlnaW5fb2Zmc2V0OiAyMDAzNzUwOC4zNCxcbiAgICAgICAgaW5pdGlhbF9yZXNvbHV0aW9uOiAxNTY1NDMuMDMzOTI4MDQwOTdcbiAgICB9KTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgejtcbiAgICAgICAgTWVyY2F0b3JUaWxlU291cmNlLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoeiA9IGogPSAwOyBqIDw9IDMwOyB6ID0gKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2V0X3Jlc29sdXRpb24oeikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLl9jb21wdXRlZF9pbml0aWFsX3Jlc29sdXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxfcmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsX3Jlc29sdXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gdGhpcy50aWxlX3NpemU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuaXNfdmFsaWRfdGlsZSA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIGlmICghdGhpcy53cmFwX2Fyb3VuZCkge1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gTWF0aC5wb3coMiwgeikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gTWF0aC5wb3coMiwgeikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX2NoaWxkcmVuID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHZhciBrZXksIG1heF96b29tLCBtaW5fem9vbSwgcXVhZGtleSwgcmVmLCByZXN1bHRzLCB0aWxlO1xuICAgICAgICBxdWFka2V5ID0gcmVmZXJlbmNlX3RpbGUucXVhZGtleTtcbiAgICAgICAgbWluX3pvb20gPSBxdWFka2V5Lmxlbmd0aDtcbiAgICAgICAgbWF4X3pvb20gPSBtaW5fem9vbSArIDM7XG4gICAgICAgIHJlZiA9IHRoaXMudGlsZXM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmW2tleV07XG4gICAgICAgICAgICBpZiAodGlsZS5xdWFka2V5LmluZGV4T2YocXVhZGtleSkgPT09IDAgJiYgdGlsZS5xdWFka2V5Lmxlbmd0aCA+IG1pbl96b29tICYmIHRpbGUucXVhZGtleS5sZW5ndGggPD0gbWF4X3pvb20pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGlsZS5yZXRhaW4gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5yZXRhaW5fbmVpZ2hib3JzID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHZhciBrZXksIG5laWdoYm9yX3JhZGl1cywgbmVpZ2hib3JfeCwgbmVpZ2hib3JfeSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZXN1bHRzLCB0aWxlLCB0eCwgdHksIHR6LCB4LCB5O1xuICAgICAgICBuZWlnaGJvcl9yYWRpdXMgPSA0O1xuICAgICAgICByZWYgPSByZWZlcmVuY2VfdGlsZS50aWxlX2Nvb3JkcywgdHggPSByZWZbMF0sIHR5ID0gcmVmWzFdLCB0eiA9IHJlZlsyXTtcbiAgICAgICAgbmVpZ2hib3JfeCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaiwgcmVmMSwgcmVmMiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoeCA9IGogPSByZWYxID0gdHggLSBuZWlnaGJvcl9yYWRpdXMsIHJlZjIgPSB0eCArIG5laWdoYm9yX3JhZGl1czsgcmVmMSA8PSByZWYyID8gaiA8PSByZWYyIDogaiA+PSByZWYyOyB4ID0gcmVmMSA8PSByZWYyID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIG5laWdoYm9yX3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZjEsIHJlZjIsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHkgPSBqID0gcmVmMSA9IHR5IC0gbmVpZ2hib3JfcmFkaXVzLCByZWYyID0gdHkgKyBuZWlnaGJvcl9yYWRpdXM7IHJlZjEgPD0gcmVmMiA/IGogPD0gcmVmMiA6IGogPj0gcmVmMjsgeSA9IHJlZjEgPD0gcmVmMiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZWYxID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYxKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmMVtrZXldO1xuICAgICAgICAgICAgaWYgKHRpbGUudGlsZV9jb29yZHNbMl0gPT09IHR6ICYmIChyZWYyID0gdGlsZS50aWxlX2Nvb3Jkc1swXSwgaW5kZXhPZi5jYWxsKG5laWdoYm9yX3gsIHJlZjIpID49IDApICYmIChyZWYzID0gdGlsZS50aWxlX2Nvb3Jkc1sxXSwgaW5kZXhPZi5jYWxsKG5laWdoYm9yX3ksIHJlZjMpID49IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpbGUucmV0YWluID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX3BhcmVudHMgPSBmdW5jdGlvbiAocmVmZXJlbmNlX3RpbGUpIHtcbiAgICAgICAgdmFyIGtleSwgcXVhZGtleSwgcmVmLCByZXN1bHRzLCB0aWxlO1xuICAgICAgICBxdWFka2V5ID0gcmVmZXJlbmNlX3RpbGUucXVhZGtleTtcbiAgICAgICAgcmVmID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICAgIHRpbGUgPSByZWZba2V5XTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aWxlLnJldGFpbiA9IHF1YWRrZXkuaW5kZXhPZih0aWxlLnF1YWRrZXkpID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuY2hpbGRyZW5fYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgYiwgY2hpbGRfdGlsZV94eXosIGksIGosIHF1YWRfa2V5LCByZWYsIHJlZjEsIHJlZjIsIHdvcmxkX3g7XG4gICAgICAgIHdvcmxkX3ggPSB0aGlzLmNhbGN1bGF0ZV93b3JsZF94X2J5X3RpbGVfeHl6KHgsIHksIHopO1xuICAgICAgICBpZiAod29ybGRfeCAhPT0gMCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5ub3JtYWxpemVfeHl6KHgsIHksIHopLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdLCB6ID0gcmVmWzJdO1xuICAgICAgICB9XG4gICAgICAgIHF1YWRfa2V5ID0gdGhpcy50aWxlX3h5el90b19xdWFka2V5KHgsIHksIHopO1xuICAgICAgICBjaGlsZF90aWxlX3h5eiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBqID0gMDsgaiA8PSAzOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHF1YWRfa2V5ICsgaS50b1N0cmluZygpKSwgeCA9IHJlZjFbMF0sIHkgPSByZWYxWzFdLCB6ID0gcmVmMVsyXTtcbiAgICAgICAgICAgIGlmICh3b3JsZF94ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVmMiA9IHRoaXMuZGVub3JtYWxpemVfeHl6KHgsIHksIHosIHdvcmxkX3gpLCB4ID0gcmVmMlswXSwgeSA9IHJlZjJbMV0sIHogPSByZWYyWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHgsIHksIHopO1xuICAgICAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkX3RpbGVfeHl6LnB1c2goW3gsIHksIHosIGJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRfdGlsZV94eXo7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnBhcmVudF9ieV90aWxlX3h5eiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBwYXJlbnRfcXVhZF9rZXksIHF1YWRfa2V5O1xuICAgICAgICBxdWFkX2tleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgcGFyZW50X3F1YWRfa2V5ID0gcXVhZF9rZXkuc3Vic3RyaW5nKDAsIHF1YWRfa2V5Lmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHBhcmVudF9xdWFkX2tleSk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9yZXNvbHV0aW9uID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlZF9pbml0aWFsX3Jlc29sdXRpb24oKSAvIE1hdGgucG93KDIsIGxldmVsKTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X3Jlc29sdXRpb25fYnlfZXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICB2YXIgeF9ycywgeV9ycztcbiAgICAgICAgeF9ycyA9IChleHRlbnRbMl0gLSBleHRlbnRbMF0pIC8gd2lkdGg7XG4gICAgICAgIHlfcnMgPSAoZXh0ZW50WzNdIC0gZXh0ZW50WzFdKSAvIGhlaWdodDtcbiAgICAgICAgcmV0dXJuIFt4X3JzLCB5X3JzXTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2xldmVsX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGksIGosIGxlbiwgciwgcmVmLCByZXNvbHV0aW9uLCB4X3JzLCB5X3JzO1xuICAgICAgICB4X3JzID0gKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyB3aWR0aDtcbiAgICAgICAgeV9ycyA9IChleHRlbnRbM10gLSBleHRlbnRbMV0pIC8gaGVpZ2h0O1xuICAgICAgICByZXNvbHV0aW9uID0gTWF0aC5tYXgoeF9ycywgeV9ycyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICByZWYgPSB0aGlzLl9yZXNvbHV0aW9ucztcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICByID0gcmVmW2pdO1xuICAgICAgICAgICAgaWYgKHJlc29sdXRpb24gPiByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9jbG9zZXN0X2xldmVsX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QsIHJlc29sdXRpb24sIHJlc3MsIHhfcnMsIHlfcnM7XG4gICAgICAgIHhfcnMgPSAoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIHdpZHRoO1xuICAgICAgICB5X3JzID0gKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyBoZWlnaHQ7XG4gICAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1heCh4X3JzLCB5X3JzKTtcbiAgICAgICAgcmVzcyA9IHRoaXMuX3Jlc29sdXRpb25zO1xuICAgICAgICBjbG9zZXN0ID0gdGhpcy5fcmVzb2x1dGlvbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnQgLSByZXNvbHV0aW9uKSA8IE1hdGguYWJzKHByZXZpb3VzIC0gcmVzb2x1dGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9ucy5pbmRleE9mKGNsb3Nlc3QpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5zbmFwX3RvX3pvb20gPSBmdW5jdGlvbiAoZXh0ZW50LCBoZWlnaHQsIHdpZHRoLCBsZXZlbCkge1xuICAgICAgICB2YXIgZGVzaXJlZF9yZXMsIGRlc2lyZWRfeF9kZWx0YSwgZGVzaXJlZF95X2RlbHRhLCB4X2FkanVzdCwgeG1heCwgeG1pbiwgeV9hZGp1c3QsIHltYXgsIHltaW47XG4gICAgICAgIGRlc2lyZWRfcmVzID0gdGhpcy5fcmVzb2x1dGlvbnNbbGV2ZWxdO1xuICAgICAgICBkZXNpcmVkX3hfZGVsdGEgPSB3aWR0aCAqIGRlc2lyZWRfcmVzO1xuICAgICAgICBkZXNpcmVkX3lfZGVsdGEgPSBoZWlnaHQgKiBkZXNpcmVkX3JlcztcbiAgICAgICAgeG1pbiA9IGV4dGVudFswXSwgeW1pbiA9IGV4dGVudFsxXSwgeG1heCA9IGV4dGVudFsyXSwgeW1heCA9IGV4dGVudFszXTtcbiAgICAgICAgeF9hZGp1c3QgPSAoZGVzaXJlZF94X2RlbHRhIC0gKHhtYXggLSB4bWluKSkgLyAyO1xuICAgICAgICB5X2FkanVzdCA9IChkZXNpcmVkX3lfZGVsdGEgLSAoeW1heCAtIHltaW4pKSAvIDI7XG4gICAgICAgIHJldHVybiBbeG1pbiAtIHhfYWRqdXN0LCB5bWluIC0geV9hZGp1c3QsIHhtYXggKyB4X2FkanVzdCwgeW1heCArIHlfYWRqdXN0XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUudG1zX3RvX3dtdHMgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICAnTm90ZSB0aGlzIHdvcmtzIGJvdGggd2F5cyc7XG4gICAgICAgIHJldHVybiBbeCwgTWF0aC5wb3coMiwgeikgLSAxIC0geSwgel07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLndtdHNfdG9fdG1zID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgJ05vdGUgdGhpcyB3b3JrcyBib3RoIHdheXMnO1xuICAgICAgICByZXR1cm4gW3gsIE1hdGgucG93KDIsIHopIC0gMSAtIHksIHpdO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fbWV0ZXJzID0gZnVuY3Rpb24gKHB4LCBweSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIG14LCBteSwgcmVzO1xuICAgICAgICByZXMgPSB0aGlzLmdldF9yZXNvbHV0aW9uKGxldmVsKTtcbiAgICAgICAgbXggPSBweCAqIHJlcyAtIHRoaXMueF9vcmlnaW5fb2Zmc2V0O1xuICAgICAgICBteSA9IHB5ICogcmVzIC0gdGhpcy55X29yaWdpbl9vZmZzZXQ7XG4gICAgICAgIHJldHVybiBbbXgsIG15XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUubWV0ZXJzX3RvX3BpeGVscyA9IGZ1bmN0aW9uIChteCwgbXksIGxldmVsKSB7XG4gICAgICAgIHZhciBweCwgcHksIHJlcztcbiAgICAgICAgcmVzID0gdGhpcy5nZXRfcmVzb2x1dGlvbihsZXZlbCk7XG4gICAgICAgIHB4ID0gKG14ICsgdGhpcy54X29yaWdpbl9vZmZzZXQpIC8gcmVzO1xuICAgICAgICBweSA9IChteSArIHRoaXMueV9vcmlnaW5fb2Zmc2V0KSAvIHJlcztcbiAgICAgICAgcmV0dXJuIFtweCwgcHldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fdGlsZSA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgdmFyIHR4LCB0eTtcbiAgICAgICAgdHggPSBNYXRoLmNlaWwocHggLyBwYXJzZUZsb2F0KHRoaXMudGlsZV9zaXplKSk7XG4gICAgICAgIHR4ID0gdHggPT09IDAgPyB0eCA6IHR4IC0gMTtcbiAgICAgICAgdHkgPSBNYXRoLm1heChNYXRoLmNlaWwocHkgLyBwYXJzZUZsb2F0KHRoaXMudGlsZV9zaXplKSkgLSAxLCAwKTtcbiAgICAgICAgcmV0dXJuIFt0eCwgdHldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5waXhlbHNfdG9fcmFzdGVyID0gZnVuY3Rpb24gKHB4LCBweSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIG1hcFNpemU7XG4gICAgICAgIG1hcFNpemUgPSB0aGlzLnRpbGVfc2l6ZSA8PCBsZXZlbDtcbiAgICAgICAgcmV0dXJuIFtweCwgbWFwU2l6ZSAtIHB5XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUubWV0ZXJzX3RvX3RpbGUgPSBmdW5jdGlvbiAobXgsIG15LCBsZXZlbCkge1xuICAgICAgICB2YXIgcHgsIHB5LCByZWY7XG4gICAgICAgIHJlZiA9IHRoaXMubWV0ZXJzX3RvX3BpeGVscyhteCwgbXksIGxldmVsKSwgcHggPSByZWZbMF0sIHB5ID0gcmVmWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5waXhlbHNfdG9fdGlsZShweCwgcHkpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfdGlsZV9tZXRlcl9ib3VuZHMgPSBmdW5jdGlvbiAodHgsIHR5LCBsZXZlbCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCB4bWF4LCB4bWluLCB5bWF4LCB5bWluO1xuICAgICAgICByZWYgPSB0aGlzLnBpeGVsc190b19tZXRlcnModHggKiB0aGlzLnRpbGVfc2l6ZSwgdHkgKiB0aGlzLnRpbGVfc2l6ZSwgbGV2ZWwpLCB4bWluID0gcmVmWzBdLCB5bWluID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5waXhlbHNfdG9fbWV0ZXJzKCh0eCArIDEpICogdGhpcy50aWxlX3NpemUsICh0eSArIDEpICogdGhpcy50aWxlX3NpemUsIGxldmVsKSwgeG1heCA9IHJlZjFbMF0sIHltYXggPSByZWYxWzFdO1xuICAgICAgICBpZiAoKHhtaW4gIT0gbnVsbCkgJiYgKHltaW4gIT0gbnVsbCkgJiYgKHhtYXggIT0gbnVsbCkgJiYgKHltYXggIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmdldF90aWxlX2dlb2dyYXBoaWNfYm91bmRzID0gZnVuY3Rpb24gKHR4LCB0eSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGJvdW5kcywgbWF4TGF0LCBtYXhMb24sIG1pbkxhdCwgbWluTG9uLCByZWY7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHR4LCB0eSwgbGV2ZWwpO1xuICAgICAgICByZWYgPSB0aGlzLnV0aWxzLm1ldGVyc19leHRlbnRfdG9fZ2VvZ3JhcGhpYyhib3VuZHMpLCBtaW5Mb24gPSByZWZbMF0sIG1pbkxhdCA9IHJlZlsxXSwgbWF4TG9uID0gcmVmWzJdLCBtYXhMYXQgPSByZWZbM107XG4gICAgICAgIHJldHVybiBbbWluTG9uLCBtaW5MYXQsIG1heExvbiwgbWF4TGF0XTtcbiAgICB9O1xuICAgIE1lcmNhdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X3RpbGVzX2J5X2V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGxldmVsLCB0aWxlX2JvcmRlcikge1xuICAgICAgICB2YXIgaiwgaywgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCB0aWxlcywgdHgsIHR4bWF4LCB0eG1pbiwgdHksIHR5bWF4LCB0eW1pbiwgeG1heCwgeG1pbiwgeW1heCwgeW1pbjtcbiAgICAgICAgaWYgKHRpbGVfYm9yZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbGVfYm9yZGVyID0gMTtcbiAgICAgICAgfVxuICAgICAgICB4bWluID0gZXh0ZW50WzBdLCB5bWluID0gZXh0ZW50WzFdLCB4bWF4ID0gZXh0ZW50WzJdLCB5bWF4ID0gZXh0ZW50WzNdO1xuICAgICAgICByZWYgPSB0aGlzLm1ldGVyc190b190aWxlKHhtaW4sIHltaW4sIGxldmVsKSwgdHhtaW4gPSByZWZbMF0sIHR5bWluID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gdGhpcy5tZXRlcnNfdG9fdGlsZSh4bWF4LCB5bWF4LCBsZXZlbCksIHR4bWF4ID0gcmVmMVswXSwgdHltYXggPSByZWYxWzFdO1xuICAgICAgICB0eG1pbiAtPSB0aWxlX2JvcmRlcjtcbiAgICAgICAgdHltaW4gLT0gdGlsZV9ib3JkZXI7XG4gICAgICAgIHR4bWF4ICs9IHRpbGVfYm9yZGVyO1xuICAgICAgICB0eW1heCArPSB0aWxlX2JvcmRlcjtcbiAgICAgICAgdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yICh0eSA9IGogPSByZWYyID0gdHltYXgsIHJlZjMgPSB0eW1pbjsgaiA+PSByZWYzOyB0eSA9IGogKz0gLTEpIHtcbiAgICAgICAgICAgIGZvciAodHggPSBrID0gcmVmNCA9IHR4bWluLCByZWY1ID0gdHhtYXg7IGsgPD0gcmVmNTsgdHggPSBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc192YWxpZF90aWxlKHR4LCB0eSwgbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzLnB1c2goW3R4LCB0eSwgbGV2ZWwsIHRoaXMuZ2V0X3RpbGVfbWV0ZXJfYm91bmRzKHR4LCB0eSwgbGV2ZWwpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbGVzID0gdGhpcy5zb3J0X3RpbGVzX2Zyb21fY2VudGVyKHRpbGVzLCBbdHhtaW4sIHR5bWluLCB0eG1heCwgdHltYXhdKTtcbiAgICAgICAgcmV0dXJuIHRpbGVzO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5xdWFka2V5X3RvX3RpbGVfeHl6ID0gZnVuY3Rpb24gKHF1YWRLZXkpIHtcbiAgICAgICAgJ0NvbXB1dGVzIHRpbGUgeCwgeSBhbmQgeiB2YWx1ZXMgYmFzZWQgb24gcXVhZEtleS4nO1xuICAgICAgICB2YXIgaSwgaiwgbWFzaywgcmVmLCB0aWxlWCwgdGlsZVksIHRpbGVaLCB2YWx1ZTtcbiAgICAgICAgdGlsZVggPSAwO1xuICAgICAgICB0aWxlWSA9IDA7XG4gICAgICAgIHRpbGVaID0gcXVhZEtleS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aWxlWjsgaiA+IDA7IGkgPSBqICs9IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1YWRLZXkuY2hhckF0KHRpbGVaIC0gaSk7XG4gICAgICAgICAgICBtYXNrID0gMSA8PCAoaSAtIDEpO1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICAgICAgdGlsZVggfD0gbWFzaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgICAgIHRpbGVZIHw9IG1hc2s7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgICAgICAgICB0aWxlWCB8PSBtYXNrO1xuICAgICAgICAgICAgICAgICAgICB0aWxlWSB8PSBtYXNrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBRdWFka2V5OiBcIiArIHF1YWRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGlsZVgsIHRpbGVZLCB0aWxlWl07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLnRpbGVfeHl6X3RvX3F1YWRrZXkgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICAnQ29tcHV0ZXMgcXVhZGtleSB2YWx1ZSBiYXNlZCBvbiB0aWxlIHgsIHkgYW5kIHogdmFsdWVzLic7XG4gICAgICAgIHZhciBkaWdpdCwgaSwgaiwgbWFzaywgcXVhZEtleSwgcmVmO1xuICAgICAgICBxdWFkS2V5ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB6OyBqID4gMDsgaSA9IGogKz0gLTEpIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gMDtcbiAgICAgICAgICAgIG1hc2sgPSAxIDw8IChpIC0gMSk7XG4gICAgICAgICAgICBpZiAoKHggJiBtYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHkgJiBtYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWFkS2V5ICs9IGRpZ2l0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1YWRLZXk7XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLmNoaWxkcmVuX2J5X3RpbGVfeHl6ID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGIsIGNoaWxkX3RpbGVfeHl6LCBpLCBqLCBxdWFkX2tleSwgcmVmO1xuICAgICAgICBxdWFkX2tleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgY2hpbGRfdGlsZV94eXogPSBbXTtcbiAgICAgICAgZm9yIChpID0gaiA9IDA7IGogPD0gMzsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5xdWFka2V5X3RvX3RpbGVfeHl6KHF1YWRfa2V5ICsgaS50b1N0cmluZygpKSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgICAgIGIgPSB0aGlzLmdldF90aWxlX21ldGVyX2JvdW5kcyh4LCB5LCB6KTtcbiAgICAgICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZF90aWxlX3h5ei5wdXNoKFt4LCB5LCB6LCBiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkX3RpbGVfeHl6O1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5wYXJlbnRfYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgcGFyZW50X3F1YWRfa2V5LCBxdWFkX2tleTtcbiAgICAgICAgcXVhZF9rZXkgPSB0aGlzLnRpbGVfeHl6X3RvX3F1YWRrZXkoeCwgeSwgeik7XG4gICAgICAgIHBhcmVudF9xdWFkX2tleSA9IHF1YWRfa2V5LnN1YnN0cmluZygwLCBxdWFkX2tleS5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZGtleV90b190aWxlX3h5eihwYXJlbnRfcXVhZF9rZXkpO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfY2xvc2VzdF9wYXJlbnRfYnlfdGlsZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgcXVhZF9rZXksIHJlZiwgcmVmMSwgcmVmMiwgd29ybGRfeDtcbiAgICAgICAgd29ybGRfeCA9IHRoaXMuY2FsY3VsYXRlX3dvcmxkX3hfYnlfdGlsZV94eXooeCwgeSwgeik7XG4gICAgICAgIHJlZiA9IHRoaXMubm9ybWFsaXplX3h5eih4LCB5LCB6KSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgcXVhZF9rZXkgPSB0aGlzLnRpbGVfeHl6X3RvX3F1YWRrZXkoeCwgeSwgeik7XG4gICAgICAgIHdoaWxlIChxdWFkX2tleS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWFkX2tleSA9IHF1YWRfa2V5LnN1YnN0cmluZygwLCBxdWFkX2tleS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLnF1YWRrZXlfdG9fdGlsZV94eXoocXVhZF9rZXkpLCB4ID0gcmVmMVswXSwgeSA9IHJlZjFbMV0sIHogPSByZWYxWzJdO1xuICAgICAgICAgICAgcmVmMiA9IHRoaXMuZGVub3JtYWxpemVfeHl6KHgsIHksIHosIHdvcmxkX3gpLCB4ID0gcmVmMlswXSwgeSA9IHJlZjJbMV0sIHogPSByZWYyWzJdO1xuICAgICAgICAgICAgaWYgKHRoaXMudGlsZV94eXpfdG9fa2V5KHgsIHksIHopIGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfTtcbiAgICBNZXJjYXRvclRpbGVTb3VyY2UucHJvdG90eXBlLm5vcm1hbGl6ZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgdGlsZV9jb3VudDtcbiAgICAgICAgaWYgKHRoaXMud3JhcF9hcm91bmQpIHtcbiAgICAgICAgICAgIHRpbGVfY291bnQgPSBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgICAgIHJldHVybiBbKCh4ICUgdGlsZV9jb3VudCkgKyB0aWxlX2NvdW50KSAlIHRpbGVfY291bnQsIHksIHpdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5kZW5vcm1hbGl6ZV94eXogPSBmdW5jdGlvbiAoeCwgeSwgeiwgd29ybGRfeCkge1xuICAgICAgICByZXR1cm4gW3ggKyB3b3JsZF94ICogTWF0aC5wb3coMiwgeiksIHksIHpdO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5kZW5vcm1hbGl6ZV9tZXRlcnMgPSBmdW5jdGlvbiAobWV0ZXJzX3gsIG1ldGVyc195LCBsZXZlbCwgd29ybGRfeCkge1xuICAgICAgICByZXR1cm4gW21ldGVyc194ICsgd29ybGRfeCAqIDIgKiBNYXRoLlBJICogNjM3ODEzNywgbWV0ZXJzX3ldO1xuICAgIH07XG4gICAgTWVyY2F0b3JUaWxlU291cmNlLnByb3RvdHlwZS5jYWxjdWxhdGVfd29ybGRfeF9ieV90aWxlX3h5eiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHggLyBNYXRoLnBvdygyLCB6KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyY2F0b3JUaWxlU291cmNlO1xufSkodGlsZV9zb3VyY2VfMS5UaWxlU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtZXJjYXRvcl90aWxlX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vbWVyY2F0b3JfdGlsZV9zb3VyY2VcIik7XG5leHBvcnRzLlFVQURLRVlUaWxlU291cmNlID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFFVQURLRVlUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBRVUFES0VZVGlsZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIFFVQURLRVlUaWxlU291cmNlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBRVUFES0VZVGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdRVUFES0VZVGlsZVNvdXJjZSc7XG4gICAgUVVBREtFWVRpbGVTb3VyY2UucHJvdG90eXBlLmdldF9pbWFnZV91cmwgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIgaW1hZ2VfdXJsLCBxdWFkS2V5LCByZWY7XG4gICAgICAgIGltYWdlX3VybCA9IHRoaXMuc3RyaW5nX2xvb2t1cF9yZXBsYWNlKHRoaXMudXJsLCB0aGlzLmV4dHJhX3VybF92YXJzKTtcbiAgICAgICAgcmVmID0gdGhpcy50bXNfdG9fd210cyh4LCB5LCB6KSwgeCA9IHJlZlswXSwgeSA9IHJlZlsxXSwgeiA9IHJlZlsyXTtcbiAgICAgICAgcXVhZEtleSA9IHRoaXMudGlsZV94eXpfdG9fcXVhZGtleSh4LCB5LCB6KTtcbiAgICAgICAgcmV0dXJuIGltYWdlX3VybC5yZXBsYWNlKFwie1F9XCIsIHF1YWRLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIFFVQURLRVlUaWxlU291cmNlO1xufSkobWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xufSByZXR1cm4gLTE7IH07XG52YXIgaW1hZ2VfcG9vbF8xID0gcmVxdWlyZShcIi4vaW1hZ2VfcG9vbFwiKTtcbnZhciB3bXRzX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi93bXRzX3RpbGVfc291cmNlXCIpO1xudmFyIHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXJzL3JlbmRlcmVyXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5UaWxlUmVuZGVyZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRpbGVSZW5kZXJlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRpbGVSZW5kZXJlclZpZXcoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSA9IGJpbmQodGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJlZmV0Y2hfdGlsZXMgPSBiaW5kKHRoaXMuX3ByZWZldGNoX3RpbGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fb25fdGlsZV9lcnJvciA9IGJpbmQodGhpcy5fb25fdGlsZV9lcnJvciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX29uX3RpbGVfY2FjaGVfbG9hZCA9IGJpbmQodGhpcy5fb25fdGlsZV9jYWNoZV9sb2FkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fb25fdGlsZV9sb2FkID0gYmluZCh0aGlzLl9vbl90aWxlX2xvYWQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRfYXR0cmlidXRpb24gPSBiaW5kKHRoaXMuX2FkZF9hdHRyaWJ1dGlvbiwgdGhpcyk7XG4gICAgICAgIHJldHVybiBUaWxlUmVuZGVyZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGlvbkVsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFRpbGVSZW5kZXJlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZXF1ZXN0X3JlbmRlcik7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5nZXRfZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMueF9yYW5nZS5zdGFydCwgdGhpcy55X3JhbmdlLnN0YXJ0LCB0aGlzLnhfcmFuZ2UuZW5kLCB0aGlzLnlfcmFuZ2UuZW5kXTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9zZXRfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb29sID0gbmV3IGltYWdlX3Bvb2xfMS5JbWFnZVBvb2woKTtcbiAgICAgICAgdGhpcy5tYXBfcGxvdCA9IHRoaXMucGxvdF9tb2RlbC5wbG90O1xuICAgICAgICB0aGlzLm1hcF9jYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXNfdmlldy5jdHg7XG4gICAgICAgIHRoaXMubWFwX2ZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICB0aGlzLnhfcmFuZ2UgPSB0aGlzLm1hcF9wbG90LnhfcmFuZ2U7XG4gICAgICAgIHRoaXMueF9tYXBwZXIgPSB0aGlzLm1hcF9mcmFtZS54X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgdGhpcy55X3JhbmdlID0gdGhpcy5tYXBfcGxvdC55X3JhbmdlO1xuICAgICAgICB0aGlzLnlfbWFwcGVyID0gdGhpcy5tYXBfZnJhbWUueV9tYXBwZXJzWydkZWZhdWx0J107XG4gICAgICAgIHRoaXMuZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgICAgIHRoaXMuX2xhc3RfaGVpZ2h0ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdF93aWR0aCA9IHZvaWQgMDtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9hZGRfYXR0cmlidXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGlvbiwgYm9yZGVyX3dpZHRoLCBib3R0b21fb2Zmc2V0LCBtYXhfd2lkdGgsIG92ZXJsYXlzLCByaWdodF9vZmZzZXQ7XG4gICAgICAgIGF0dHJpYnV0aW9uID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5hdHRyaWJ1dGlvbjtcbiAgICAgICAgaWYgKHR5cGVzXzEuaXNTdHJpbmcoYXR0cmlidXRpb24pICYmIGF0dHJpYnV0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0aW9uRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvcmRlcl93aWR0aCA9IHRoaXMubWFwX3Bsb3Qub3V0bGluZV9saW5lX3dpZHRoO1xuICAgICAgICAgICAgICAgIGJvdHRvbV9vZmZzZXQgPSB0aGlzLm1hcF9wbG90Lm1pbl9ib3JkZXJfYm90dG9tICsgYm9yZGVyX3dpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0X29mZnNldCA9IHRoaXMubWFwX2ZyYW1lLnJpZ2h0IC0gdGhpcy5tYXBfZnJhbWUud2lkdGg7XG4gICAgICAgICAgICAgICAgbWF4X3dpZHRoID0gdGhpcy5tYXBfZnJhbWUud2lkdGggLSBib3JkZXJfd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGlvbkVsID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiAnYmstdGlsZS1hdHRyaWJ1dGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tX29mZnNldCArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodF9vZmZzZXQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4LXdpZHRoJzogbWF4X3dpZHRoICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncmdiYSgyNTUsMjU1LDI1NSwwLjgpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiAnOXB0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdzYW5zLXNlcmlmJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMgPSB0aGlzLnBsb3Rfdmlldy5lbC5xdWVyeVNlbGVjdG9yKCdkaXYuYmstY2FudmFzLWV2ZW50cycpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzLmFwcGVuZENoaWxkKHRoaXMuYXR0cmlidXRpb25FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbkVsLmlubmVySFRNTCA9IGF0dHJpYnV0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fbWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdfZXh0ZW50LCB6b29tX2xldmVsO1xuICAgICAgICB0aGlzLmluaXRpYWxfZXh0ZW50ID0gdGhpcy5nZXRfZXh0ZW50KCk7XG4gICAgICAgIHpvb21fbGV2ZWwgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlLmdldF9sZXZlbF9ieV9leHRlbnQodGhpcy5pbml0aWFsX2V4dGVudCwgdGhpcy5tYXBfZnJhbWUuaGVpZ2h0LCB0aGlzLm1hcF9mcmFtZS53aWR0aCk7XG4gICAgICAgIG5ld19leHRlbnQgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlLnNuYXBfdG9fem9vbSh0aGlzLmluaXRpYWxfZXh0ZW50LCB0aGlzLm1hcF9mcmFtZS5oZWlnaHQsIHRoaXMubWFwX2ZyYW1lLndpZHRoLCB6b29tX2xldmVsKTtcbiAgICAgICAgdGhpcy54X3JhbmdlLnN0YXJ0ID0gbmV3X2V4dGVudFswXTtcbiAgICAgICAgdGhpcy55X3JhbmdlLnN0YXJ0ID0gbmV3X2V4dGVudFsxXTtcbiAgICAgICAgdGhpcy54X3JhbmdlLmVuZCA9IG5ld19leHRlbnRbMl07XG4gICAgICAgIHRoaXMueV9yYW5nZS5lbmQgPSBuZXdfZXh0ZW50WzNdO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkX2F0dHJpYnV0aW9uKCk7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fb25fdGlsZV9sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YTtcbiAgICAgICAgdGlsZV9kYXRhID0gZS50YXJnZXQudGlsZV9kYXRhO1xuICAgICAgICB0aWxlX2RhdGEuaW1nID0gZS50YXJnZXQ7XG4gICAgICAgIHRpbGVfZGF0YS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdGlsZV9kYXRhLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RfcmVuZGVyKCk7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fb25fdGlsZV9jYWNoZV9sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YTtcbiAgICAgICAgdGlsZV9kYXRhID0gZS50YXJnZXQudGlsZV9kYXRhO1xuICAgICAgICB0aWxlX2RhdGEuaW1nID0gZS50YXJnZXQ7XG4gICAgICAgIHJldHVybiB0aWxlX2RhdGEubG9hZGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9vbl90aWxlX2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX2NyZWF0ZV90aWxlID0gZnVuY3Rpb24gKHgsIHksIHosIGJvdW5kcywgY2FjaGVfb25seSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZF9jb29yZHMsIHJlZiwgdGlsZTtcbiAgICAgICAgaWYgKGNhY2hlX29ubHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2FjaGVfb25seSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZWRfY29vcmRzID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5ub3JtYWxpemVfeHl6KHgsIHksIHopO1xuICAgICAgICB0aWxlID0gdGhpcy5wb29sLnBvcCgpO1xuICAgICAgICBpZiAoY2FjaGVfb25seSkge1xuICAgICAgICAgICAgdGlsZS5vbmxvYWQgPSB0aGlzLl9vbl90aWxlX2NhY2hlX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aWxlLm9ubG9hZCA9IHRoaXMuX29uX3RpbGVfbG9hZDtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLm9uZXJyb3IgPSB0aGlzLl9vbl90aWxlX2Vycm9yO1xuICAgICAgICB0aWxlLmFsdCA9ICcnO1xuICAgICAgICB0aWxlLnRpbGVfZGF0YSA9IHtcbiAgICAgICAgICAgIHRpbGVfY29vcmRzOiBbeCwgeSwgel0sXG4gICAgICAgICAgICBub3JtYWxpemVkX2Nvb3Jkczogbm9ybWFsaXplZF9jb29yZHMsXG4gICAgICAgICAgICBxdWFka2V5OiB0aGlzLm1vZGVsLnRpbGVfc291cmNlLnRpbGVfeHl6X3RvX3F1YWRrZXkoeCwgeSwgeiksXG4gICAgICAgICAgICBjYWNoZV9rZXk6IHRoaXMubW9kZWwudGlsZV9zb3VyY2UudGlsZV94eXpfdG9fa2V5KHgsIHksIHopLFxuICAgICAgICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgeF9jb29yZDogYm91bmRzWzBdLFxuICAgICAgICAgICAgeV9jb29yZDogYm91bmRzWzNdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kZWwudGlsZV9zb3VyY2UudGlsZXNbdGlsZS50aWxlX2RhdGEuY2FjaGVfa2V5XSA9IHRpbGUudGlsZV9kYXRhO1xuICAgICAgICB0aWxlLnNyYyA9IChyZWYgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlKS5nZXRfaW1hZ2VfdXJsLmFwcGx5KHJlZiwgbm9ybWFsaXplZF9jb29yZHMpO1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9lbmZvcmNlX2FzcGVjdF9yYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dGVudCwgbmV3X2V4dGVudCwgem9vbV9sZXZlbDtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RfaGVpZ2h0ICE9PSB0aGlzLm1hcF9mcmFtZS5oZWlnaHQgfHwgdGhpcy5fbGFzdF93aWR0aCAhPT0gdGhpcy5tYXBfZnJhbWUud2lkdGgpIHtcbiAgICAgICAgICAgIGV4dGVudCA9IHRoaXMuZ2V0X2V4dGVudCgpO1xuICAgICAgICAgICAgem9vbV9sZXZlbCA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2UuZ2V0X2xldmVsX2J5X2V4dGVudChleHRlbnQsIHRoaXMubWFwX2ZyYW1lLmhlaWdodCwgdGhpcy5tYXBfZnJhbWUud2lkdGgpO1xuICAgICAgICAgICAgbmV3X2V4dGVudCA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2Uuc25hcF90b196b29tKGV4dGVudCwgdGhpcy5tYXBfZnJhbWUuaGVpZ2h0LCB0aGlzLm1hcF9mcmFtZS53aWR0aCwgem9vbV9sZXZlbCk7XG4gICAgICAgICAgICB0aGlzLnhfcmFuZ2Uuc2V0dih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5ld19leHRlbnRbMF0sXG4gICAgICAgICAgICAgICAgZW5kOiBuZXdfZXh0ZW50WzJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMueV9yYW5nZS5zZXR2KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbmV3X2V4dGVudFsxXSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld19leHRlbnRbM11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5leHRlbnQgPSBuZXdfZXh0ZW50O1xuICAgICAgICAgICAgdGhpcy5fbGFzdF9oZWlnaHQgPSB0aGlzLm1hcF9mcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9sYXN0X3dpZHRoID0gdGhpcy5tYXBfZnJhbWUud2lkdGg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY3R4LCBpbmRpY2VzLCBhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcF9pbml0aWFsaXplZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRfZGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5fbWFwX2RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMubWFwX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5mb3JjZV9hc3BlY3RfcmF0aW8oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5wcmVmZXRjaF90aW1lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wcmVmZXRjaF90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZmV0Y2hfdGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX3ByZWZldGNoX3RpbGVzLCA1MDApO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX2RyYXdfdGlsZSA9IGZ1bmN0aW9uICh0aWxlX2tleSkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCBzaCwgc3csIHN4LCBzeG1heCwgc3htaW4sIHN5LCBzeW1heCwgc3ltaW4sIHRpbGVfb2JqO1xuICAgICAgICB0aWxlX29iaiA9IHRoaXMubW9kZWwudGlsZV9zb3VyY2UudGlsZXNbdGlsZV9rZXldO1xuICAgICAgICBpZiAodGlsZV9vYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5wbG90X3ZpZXcuZnJhbWUubWFwX3RvX3NjcmVlbihbdGlsZV9vYmouYm91bmRzWzBdXSwgW3RpbGVfb2JqLmJvdW5kc1szXV0sIHRoaXMucGxvdF92aWV3LmNhbnZhcyksIHN4bWluID0gcmVmWzBdLCBzeW1pbiA9IHJlZlsxXTtcbiAgICAgICAgICAgIHJlZjEgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS5tYXBfdG9fc2NyZWVuKFt0aWxlX29iai5ib3VuZHNbMl1dLCBbdGlsZV9vYmouYm91bmRzWzFdXSwgdGhpcy5wbG90X3ZpZXcuY2FudmFzKSwgc3htYXggPSByZWYxWzBdLCBzeW1heCA9IHJlZjFbMV07XG4gICAgICAgICAgICBzeG1pbiA9IHN4bWluWzBdO1xuICAgICAgICAgICAgc3ltaW4gPSBzeW1pblswXTtcbiAgICAgICAgICAgIHN4bWF4ID0gc3htYXhbMF07XG4gICAgICAgICAgICBzeW1heCA9IHN5bWF4WzBdO1xuICAgICAgICAgICAgc3cgPSBzeG1heCAtIHN4bWluO1xuICAgICAgICAgICAgc2ggPSBzeW1heCAtIHN5bWluO1xuICAgICAgICAgICAgc3ggPSBzeG1pbjtcbiAgICAgICAgICAgIHN5ID0gc3ltaW47XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBfY2FudmFzLmRyYXdJbWFnZSh0aWxlX29iai5pbWcsIHN4LCBzeSwgc3csIHNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX3NldF9yZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaCwgbCwgb3V0bGluZV93aWR0aCwgdCwgdztcbiAgICAgICAgb3V0bGluZV93aWR0aCA9IHRoaXMucGxvdF9tb2RlbC5wbG90LnByb3BlcnRpZXMub3V0bGluZV9saW5lX3dpZHRoLnZhbHVlKCk7XG4gICAgICAgIGwgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXMudnhfdG9fc3godGhpcy5tYXBfZnJhbWUubGVmdCkgKyAob3V0bGluZV93aWR0aCAvIDIpO1xuICAgICAgICB0ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnZ5X3RvX3N5KHRoaXMubWFwX2ZyYW1lLnRvcCkgKyAob3V0bGluZV93aWR0aCAvIDIpO1xuICAgICAgICB3ID0gdGhpcy5tYXBfZnJhbWUud2lkdGggLSBvdXRsaW5lX3dpZHRoO1xuICAgICAgICBoID0gdGhpcy5tYXBfZnJhbWUuaGVpZ2h0IC0gb3V0bGluZV93aWR0aDtcbiAgICAgICAgdGhpcy5tYXBfY2FudmFzLnJlY3QobCwgdCwgdywgaCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9jYW52YXMuY2xpcCgpO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX3JlbmRlcl90aWxlcyA9IGZ1bmN0aW9uICh0aWxlX2tleXMpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgdGlsZV9rZXk7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5zYXZlKCk7XG4gICAgICAgIHRoaXMuX3NldF9yZWN0KCk7XG4gICAgICAgIHRoaXMubWFwX2NhbnZhcy5nbG9iYWxBbHBoYSA9IHRoaXMubW9kZWwuYWxwaGE7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRpbGVfa2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGlsZV9rZXkgPSB0aWxlX2tleXNbaV07XG4gICAgICAgICAgICB0aGlzLl9kcmF3X3RpbGUodGlsZV9rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF9jYW52YXMucmVzdG9yZSgpO1xuICAgIH07XG4gICAgVGlsZVJlbmRlcmVyVmlldy5wcm90b3R5cGUuX3ByZWZldGNoX3RpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzLCBjLCBjYm91bmRzLCBjaGlsZHJlbiwgY3gsIGN5LCBjeiwgZXh0ZW50LCBoLCBpLCByZWYsIHJlc3VsdHMsIHQsIHRpbGVfc291cmNlLCB0aWxlcywgdywgeCwgeSwgeiwgem9vbV9sZXZlbDtcbiAgICAgICAgdGlsZV9zb3VyY2UgPSB0aGlzLm1vZGVsLnRpbGVfc291cmNlO1xuICAgICAgICBleHRlbnQgPSB0aGlzLmdldF9leHRlbnQoKTtcbiAgICAgICAgaCA9IHRoaXMubWFwX2ZyYW1lLmhlaWdodDtcbiAgICAgICAgdyA9IHRoaXMubWFwX2ZyYW1lLndpZHRoO1xuICAgICAgICB6b29tX2xldmVsID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5nZXRfbGV2ZWxfYnlfZXh0ZW50KGV4dGVudCwgaCwgdyk7XG4gICAgICAgIHRpbGVzID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5nZXRfdGlsZXNfYnlfZXh0ZW50KGV4dGVudCwgem9vbV9sZXZlbCk7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh0ID0gaSA9IDAsIHJlZiA9IE1hdGgubWluKDEwLCB0aWxlcy5sZW5ndGgpOyBpIDw9IHJlZjsgdCA9IGkgKz0gMSkge1xuICAgICAgICAgICAgeCA9IHRbMF0sIHkgPSB0WzFdLCB6ID0gdFsyXSwgYm91bmRzID0gdFszXTtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZS5jaGlsZHJlbl9ieV90aWxlX3h5eih4LCB5LCB6KTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlc3VsdHMxO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMxID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBjeCA9IGNbMF0sIGN5ID0gY1sxXSwgY3ogPSBjWzJdLCBjYm91bmRzID0gY1szXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGVfc291cmNlLnRpbGVfeHl6X3RvX2tleShjeCwgY3ksIGN6KSBpbiB0aWxlX3NvdXJjZS50aWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKHRoaXMuX2NyZWF0ZV90aWxlKGN4LCBjeSwgY3osIGNib3VuZHMsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRpbGVSZW5kZXJlclZpZXcucHJvdG90eXBlLl9mZXRjaF90aWxlcyA9IGZ1bmN0aW9uICh0aWxlcykge1xuICAgICAgICB2YXIgYm91bmRzLCBpLCBsZW4sIHJlc3VsdHMsIHQsIHgsIHksIHo7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSB0aWxlc1tpXTtcbiAgICAgICAgICAgIHggPSB0WzBdLCB5ID0gdFsxXSwgeiA9IHRbMl0sIGJvdW5kcyA9IHRbM107XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fY3JlYXRlX3RpbGUoeCwgeSwgeiwgYm91bmRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUaWxlUmVuZGVyZXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzLCBjLCBjYWNoZWQsIGNib3VuZHMsIGNoaWxkX2tleSwgY2hpbGRyZW4sIGN4LCBjeSwgY3osIGV4dGVudCwgaCwgaSwgaiwgaywga2V5LCBsZW4sIGxlbjEsIGxlbjIsIG1heF96b29tLCBtaW5fem9vbSwgbmVlZF9sb2FkLCBwYXJlbnRfa2V5LCBwYXJlbnRfdGlsZSwgcGFyZW50cywgcHgsIHB5LCBweiwgcmVmLCBzbmFwX2JhY2ssIHQsIHRpbGUsIHRpbGVfc291cmNlLCB0aWxlcywgdywgeCwgeSwgeiwgem9vbV9sZXZlbCwgem9vbWluZ19vdXQ7XG4gICAgICAgIHRpbGVfc291cmNlID0gdGhpcy5tb2RlbC50aWxlX3NvdXJjZTtcbiAgICAgICAgbWluX3pvb20gPSB0aWxlX3NvdXJjZS5taW5fem9vbTtcbiAgICAgICAgbWF4X3pvb20gPSB0aWxlX3NvdXJjZS5tYXhfem9vbTtcbiAgICAgICAgdGlsZV9zb3VyY2UudXBkYXRlKCk7XG4gICAgICAgIGV4dGVudCA9IHRoaXMuZ2V0X2V4dGVudCgpO1xuICAgICAgICB6b29taW5nX291dCA9IHRoaXMuZXh0ZW50WzJdIC0gdGhpcy5leHRlbnRbMF0gPCBleHRlbnRbMl0gLSBleHRlbnRbMF07XG4gICAgICAgIGggPSB0aGlzLm1hcF9mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHcgPSB0aGlzLm1hcF9mcmFtZS53aWR0aDtcbiAgICAgICAgem9vbV9sZXZlbCA9IHRpbGVfc291cmNlLmdldF9sZXZlbF9ieV9leHRlbnQoZXh0ZW50LCBoLCB3KTtcbiAgICAgICAgc25hcF9iYWNrID0gZmFsc2U7XG4gICAgICAgIGlmICh6b29tX2xldmVsIDwgbWluX3pvb20pIHtcbiAgICAgICAgICAgIGV4dGVudCA9IHRoaXMuZXh0ZW50O1xuICAgICAgICAgICAgem9vbV9sZXZlbCA9IG1pbl96b29tO1xuICAgICAgICAgICAgc25hcF9iYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh6b29tX2xldmVsID4gbWF4X3pvb20pIHtcbiAgICAgICAgICAgIGV4dGVudCA9IHRoaXMuZXh0ZW50O1xuICAgICAgICAgICAgem9vbV9sZXZlbCA9IG1heF96b29tO1xuICAgICAgICAgICAgc25hcF9iYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc25hcF9iYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnhfcmFuZ2Uuc2V0dih7XG4gICAgICAgICAgICAgICAgeF9yYW5nZToge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZXh0ZW50WzBdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGV4dGVudFsyXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy55X3JhbmdlLnNldHYoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBleHRlbnRbMV0sXG4gICAgICAgICAgICAgICAgZW5kOiBleHRlbnRbM11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgICAgIHRpbGVzID0gdGlsZV9zb3VyY2UuZ2V0X3RpbGVzX2J5X2V4dGVudChleHRlbnQsIHpvb21fbGV2ZWwpO1xuICAgICAgICBwYXJlbnRzID0gW107XG4gICAgICAgIG5lZWRfbG9hZCA9IFtdO1xuICAgICAgICBjYWNoZWQgPSBbXTtcbiAgICAgICAgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSB0aWxlc1tpXTtcbiAgICAgICAgICAgIHggPSB0WzBdLCB5ID0gdFsxXSwgeiA9IHRbMl0sIGJvdW5kcyA9IHRbM107XG4gICAgICAgICAgICBrZXkgPSB0aWxlX3NvdXJjZS50aWxlX3h5el90b19rZXkoeCwgeSwgeik7XG4gICAgICAgICAgICB0aWxlID0gdGlsZV9zb3VyY2UudGlsZXNba2V5XTtcbiAgICAgICAgICAgIGlmICgodGlsZSAhPSBudWxsKSAmJiB0aWxlLmxvYWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5yZW5kZXJfcGFyZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZWYgPSB0aWxlX3NvdXJjZS5nZXRfY2xvc2VzdF9wYXJlbnRfYnlfdGlsZV94eXooeCwgeSwgeiksIHB4ID0gcmVmWzBdLCBweSA9IHJlZlsxXSwgcHogPSByZWZbMl07XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF9rZXkgPSB0aWxlX3NvdXJjZS50aWxlX3h5el90b19rZXkocHgsIHB5LCBweik7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF90aWxlID0gdGlsZV9zb3VyY2UudGlsZXNbcGFyZW50X2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgocGFyZW50X3RpbGUgIT0gbnVsbCkgJiYgcGFyZW50X3RpbGUubG9hZGVkICYmIGluZGV4T2YuY2FsbChwYXJlbnRzLCBwYXJlbnRfa2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoem9vbWluZ19vdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGlsZV9zb3VyY2UuY2hpbGRyZW5fYnlfdGlsZV94eXooeCwgeSwgeik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gY1swXSwgY3kgPSBjWzFdLCBjeiA9IGNbMl0sIGNib3VuZHMgPSBjWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkX2tleSA9IHRpbGVfc291cmNlLnRpbGVfeHl6X3RvX2tleShjeCwgY3ksIGN6KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRfa2V5IGluIHRpbGVfc291cmNlLnRpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmVlZF9sb2FkLnB1c2godCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyX3RpbGVzKHBhcmVudHMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJfdGlsZXMoY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLl9yZW5kZXJfdGlsZXMoY2FjaGVkKTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuMiA9IGNhY2hlZC5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgIHQgPSBjYWNoZWRba107XG4gICAgICAgICAgICB0aWxlX3NvdXJjZS50aWxlc1t0XS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfdGltZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVuZGVyX3RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJfdGltZXIgPSBzZXRUaW1lb3V0KCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmV0Y2hfdGlsZXMobmVlZF9sb2FkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKSwgNjUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbGVSZW5kZXJlclZpZXc7XG59KShyZW5kZXJlcl8xLlJlbmRlcmVyVmlldyk7XG5leHBvcnRzLlRpbGVSZW5kZXJlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUaWxlUmVuZGVyZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRpbGVSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIFRpbGVSZW5kZXJlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGlsZVJlbmRlcmVyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRpbGVSZW5kZXJlclZpZXc7XG4gICAgVGlsZVJlbmRlcmVyLnByb3RvdHlwZS50eXBlID0gJ1RpbGVSZW5kZXJlcic7XG4gICAgVGlsZVJlbmRlcmVyLmRlZmluZSh7XG4gICAgICAgIGFscGhhOiBbcC5OdW1iZXIsIDEuMF0sXG4gICAgICAgIHhfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCBcImRlZmF1bHRcIl0sXG4gICAgICAgIHlfcmFuZ2VfbmFtZTogW3AuU3RyaW5nLCBcImRlZmF1bHRcIl0sXG4gICAgICAgIHRpbGVfc291cmNlOiBbXG4gICAgICAgICAgICBwLkluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3bXRzX3RpbGVfc291cmNlXzEuV01UU1RpbGVTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmVuZGVyX3BhcmVudHM6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgVGlsZVJlbmRlcmVyLm92ZXJyaWRlKHtcbiAgICAgICAgbGV2ZWw6ICd1bmRlcmxheSdcbiAgICB9KTtcbiAgICByZXR1cm4gVGlsZVJlbmRlcmVyO1xufSkocmVuZGVyZXJfMS5SZW5kZXJlcik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaW1hZ2VfcG9vbF8xID0gcmVxdWlyZShcIi4vaW1hZ2VfcG9vbFwiKTtcbnZhciB0aWxlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi90aWxlX3V0aWxzXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuVGlsZVNvdXJjZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS50eXBlID0gJ1RpbGVTb3VyY2UnO1xuICAgIFRpbGVTb3VyY2UuZGVmaW5lKHtcbiAgICAgICAgdXJsOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgdGlsZV9zaXplOiBbcC5OdW1iZXIsIDI1Nl0sXG4gICAgICAgIG1heF96b29tOiBbcC5OdW1iZXIsIDMwXSxcbiAgICAgICAgbWluX3pvb206IFtwLk51bWJlciwgMF0sXG4gICAgICAgIGV4dHJhX3VybF92YXJzOiBbcC5BbnksIHt9XSxcbiAgICAgICAgYXR0cmlidXRpb246IFtwLlN0cmluZywgJyddLFxuICAgICAgICB4X29yaWdpbl9vZmZzZXQ6IFtwLk51bWJlcl0sXG4gICAgICAgIHlfb3JpZ2luX29mZnNldDogW3AuTnVtYmVyXSxcbiAgICAgICAgaW5pdGlhbF9yZXNvbHV0aW9uOiBbcC5OdW1iZXJdXG4gICAgfSk7XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFRpbGVTb3VyY2UuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplX2Nhc2UoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgVGlsZVNvdXJjZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51dGlscyA9IG5ldyB0aWxlX3V0aWxzXzEuUHJvamVjdGlvblV0aWxzKCk7XG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBpbWFnZV9wb29sXzEuSW1hZ2VQb29sKCk7XG4gICAgICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVfY2FzZSgpO1xuICAgIH1cbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5zdHJpbmdfbG9va3VwX3JlcGxhY2UgPSBmdW5jdGlvbiAoc3RyLCBsb29rdXApIHtcbiAgICAgICAgdmFyIGtleSwgcmVzdWx0X3N0ciwgdmFsdWU7XG4gICAgICAgIHJlc3VsdF9zdHIgPSBzdHI7XG4gICAgICAgIGZvciAoa2V5IGluIGxvb2t1cCkge1xuICAgICAgICAgICAgdmFsdWUgPSBsb29rdXBba2V5XTtcbiAgICAgICAgICAgIHJlc3VsdF9zdHIgPSByZXN1bHRfc3RyLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0X3N0cjtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLm5vcm1hbGl6ZV9jYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAnTm90ZTogc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgaW50byBzdWJjbGFzc2VzLic7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3h9JywgJ3tYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3l9JywgJ3tZfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3p9JywgJ3tafScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3F9JywgJ3tRfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htaW59JywgJ3tYTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltaW59JywgJ3tZTUlOfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3htYXh9JywgJ3tYTUFYfScpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ltYXh9JywgJ3tZTUFYfScpO1xuICAgICAgICByZXR1cm4gdGhpcy51cmwgPSB1cmw7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXksIHJlZiwgcmVzdWx0cywgdGlsZTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlRpbGVTb3VyY2U6IHRpbGUgY2FjaGUgY291bnQ6IFwiICsgKE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aCkpO1xuICAgICAgICByZWYgPSB0aGlzLnRpbGVzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgdGlsZSA9IHJlZltrZXldO1xuICAgICAgICAgICAgdGlsZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGlsZS5yZXRhaW4gPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS50aWxlX3h5el90b19rZXkgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBrZXkgPSB4ICsgXCI6XCIgKyB5ICsgXCI6XCIgKyB6O1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUua2V5X3RvX3RpbGVfeHl6ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZWYgPSBrZXkuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGMgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50KGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUuc29ydF90aWxlc19mcm9tX2NlbnRlciA9IGZ1bmN0aW9uICh0aWxlcywgdGlsZV9leHRlbnQpIHtcbiAgICAgICAgdmFyIGNlbnRlcl94LCBjZW50ZXJfeSwgdHhtYXgsIHR4bWluLCB0eW1heCwgdHltaW47XG4gICAgICAgIHR4bWluID0gdGlsZV9leHRlbnRbMF0sIHR5bWluID0gdGlsZV9leHRlbnRbMV0sIHR4bWF4ID0gdGlsZV9leHRlbnRbMl0sIHR5bWF4ID0gdGlsZV9leHRlbnRbM107XG4gICAgICAgIGNlbnRlcl94ID0gKHR4bWF4IC0gdHhtaW4pIC8gMiArIHR4bWluO1xuICAgICAgICBjZW50ZXJfeSA9ICh0eW1heCAtIHR5bWluKSAvIDIgKyB0eW1pbjtcbiAgICAgICAgdGlsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGFfZGlzdGFuY2UsIGJfZGlzdGFuY2U7XG4gICAgICAgICAgICBhX2Rpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNlbnRlcl94IC0gYVswXSwgMikgKyBNYXRoLnBvdyhjZW50ZXJfeSAtIGFbMV0sIDIpKTtcbiAgICAgICAgICAgIGJfZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY2VudGVyX3ggLSBiWzBdLCAyKSArIE1hdGgucG93KGNlbnRlcl95IC0gYlsxXSwgMikpO1xuICAgICAgICAgICAgcmV0dXJuIGFfZGlzdGFuY2UgLSBiX2Rpc3RhbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRpbGVzO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUucHJ1bmVfdGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXksIHJlZiwgcmVmMSwgcmVzdWx0cywgdGlsZTtcbiAgICAgICAgcmVmID0gdGhpcy50aWxlcztcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmW2tleV07XG4gICAgICAgICAgICB0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudCB8fCB0aWxlLnRpbGVfY29vcmRzWzJdIDwgMztcbiAgICAgICAgICAgIGlmICh0aWxlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldGFpbl9uZWlnaGJvcnModGlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRhaW5fY2hpbGRyZW4odGlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRhaW5fcGFyZW50cyh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWYxID0gdGhpcy50aWxlcztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiByZWYxKSB7XG4gICAgICAgICAgICB0aWxlID0gcmVmMVtrZXldO1xuICAgICAgICAgICAgaWYgKCF0aWxlLnJldGFpbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnJlbW92ZV90aWxlKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5yZW1vdmVfdGlsZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRpbGU7XG4gICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgIGlmICh0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKHRpbGUuaW1nKTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfaW1hZ2VfdXJsID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGltYWdlX3VybDtcbiAgICAgICAgaW1hZ2VfdXJsID0gdGhpcy5zdHJpbmdfbG9va3VwX3JlcGxhY2UodGhpcy51cmwsIHRoaXMuZXh0cmFfdXJsX3ZhcnMpO1xuICAgICAgICByZXR1cm4gaW1hZ2VfdXJsLnJlcGxhY2UoXCJ7WH1cIiwgeCkucmVwbGFjZSgne1l9JywgeSkucmVwbGFjZShcIntafVwiLCB6KTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnJldGFpbl9uZWlnaGJvcnMgPSBmdW5jdGlvbiAocmVmZXJlbmNlX3RpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX3BhcmVudHMgPSBmdW5jdGlvbiAocmVmZXJlbmNlX3RpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH07XG4gICAgVGlsZVNvdXJjZS5wcm90b3R5cGUucmV0YWluX2NoaWxkcmVuID0gZnVuY3Rpb24gKHJlZmVyZW5jZV90aWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIFRpbGVTb3VyY2UucHJvdG90eXBlLnRpbGVfeHl6X3RvX3F1YWRrZXkgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbiAgICBUaWxlU291cmNlLnByb3RvdHlwZS5xdWFka2V5X3RvX3RpbGVfeHl6ID0gZnVuY3Rpb24gKHF1YWRrZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbGVTb3VyY2U7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByb2o0XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3Byb2o0XCIpO1xuZXhwb3J0cy5Qcm9qZWN0aW9uVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2plY3Rpb25VdGlscygpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5fc2hpZnQgPSAyICogTWF0aC5QSSAqIDYzNzgxMzcgLyAyLjA7XG4gICAgfVxuICAgIFByb2plY3Rpb25VdGlscy5wcm90b3R5cGUuZ2VvZ3JhcGhpY190b19tZXRlcnMgPSBmdW5jdGlvbiAoeExvbiwgeUxhdCkge1xuICAgICAgICByZXR1cm4gcHJvajRfMS5wcm9qNChwcm9qNF8xLndnczg0LCBwcm9qNF8xLm1lcmNhdG9yLCBbeExvbiwgeUxhdF0pO1xuICAgIH07XG4gICAgUHJvamVjdGlvblV0aWxzLnByb3RvdHlwZS5tZXRlcnNfdG9fZ2VvZ3JhcGhpYyA9IGZ1bmN0aW9uIChteCwgbXkpIHtcbiAgICAgICAgcmV0dXJuIHByb2o0XzEucHJvajQocHJvajRfMS5tZXJjYXRvciwgcHJvajRfMS53Z3M4NCwgW214LCBteV0pO1xuICAgIH07XG4gICAgUHJvamVjdGlvblV0aWxzLnByb3RvdHlwZS5nZW9ncmFwaGljX2V4dGVudF90b19tZXRlcnMgPSBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgICAgIHZhciByZWYsIHJlZjEsIHhtYXgsIHhtaW4sIHltYXgsIHltaW47XG4gICAgICAgIHhtaW4gPSBleHRlbnRbMF0sIHltaW4gPSBleHRlbnRbMV0sIHhtYXggPSBleHRlbnRbMl0sIHltYXggPSBleHRlbnRbM107XG4gICAgICAgIHJlZiA9IHRoaXMuZ2VvZ3JhcGhpY190b19tZXRlcnMoeG1pbiwgeW1pbiksIHhtaW4gPSByZWZbMF0sIHltaW4gPSByZWZbMV07XG4gICAgICAgIHJlZjEgPSB0aGlzLmdlb2dyYXBoaWNfdG9fbWV0ZXJzKHhtYXgsIHltYXgpLCB4bWF4ID0gcmVmMVswXSwgeW1heCA9IHJlZjFbMV07XG4gICAgICAgIHJldHVybiBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF07XG4gICAgfTtcbiAgICBQcm9qZWN0aW9uVXRpbHMucHJvdG90eXBlLm1ldGVyc19leHRlbnRfdG9fZ2VvZ3JhcGhpYyA9IGZ1bmN0aW9uIChleHRlbnQpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmMSwgeG1heCwgeG1pbiwgeW1heCwgeW1pbjtcbiAgICAgICAgeG1pbiA9IGV4dGVudFswXSwgeW1pbiA9IGV4dGVudFsxXSwgeG1heCA9IGV4dGVudFsyXSwgeW1heCA9IGV4dGVudFszXTtcbiAgICAgICAgcmVmID0gdGhpcy5tZXRlcnNfdG9fZ2VvZ3JhcGhpYyh4bWluLCB5bWluKSwgeG1pbiA9IHJlZlswXSwgeW1pbiA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMubWV0ZXJzX3RvX2dlb2dyYXBoaWMoeG1heCwgeW1heCksIHhtYXggPSByZWYxWzBdLCB5bWF4ID0gcmVmMVsxXTtcbiAgICAgICAgcmV0dXJuIFt4bWluLCB5bWluLCB4bWF4LCB5bWF4XTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9qZWN0aW9uVXRpbHM7XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1lcmNhdG9yX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tZXJjYXRvcl90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuVE1TVGlsZVNvdXJjZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUTVNUaWxlU291cmNlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUTVNUaWxlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gVE1TVGlsZVNvdXJjZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVE1TVGlsZVNvdXJjZS5wcm90b3R5cGUudHlwZSA9ICdUTVNUaWxlU291cmNlJztcbiAgICBUTVNUaWxlU291cmNlLnByb3RvdHlwZS5nZXRfaW1hZ2VfdXJsID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGltYWdlX3VybDtcbiAgICAgICAgaW1hZ2VfdXJsID0gdGhpcy5zdHJpbmdfbG9va3VwX3JlcGxhY2UodGhpcy51cmwsIHRoaXMuZXh0cmFfdXJsX3ZhcnMpO1xuICAgICAgICByZXR1cm4gaW1hZ2VfdXJsLnJlcGxhY2UoXCJ7WH1cIiwgeCkucmVwbGFjZSgne1l9JywgeSkucmVwbGFjZShcIntafVwiLCB6KTtcbiAgICB9O1xuICAgIHJldHVybiBUTVNUaWxlU291cmNlO1xufSkobWVyY2F0b3JfdGlsZV9zb3VyY2VfMS5NZXJjYXRvclRpbGVTb3VyY2UpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1lcmNhdG9yX3RpbGVfc291cmNlXzEgPSByZXF1aXJlKFwiLi9tZXJjYXRvcl90aWxlX3NvdXJjZVwiKTtcbmV4cG9ydHMuV01UU1RpbGVTb3VyY2UgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV01UU1RpbGVTb3VyY2UsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdNVFNUaWxlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gV01UU1RpbGVTb3VyY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdNVFNUaWxlU291cmNlLnByb3RvdHlwZS50eXBlID0gJ1dNVFNUaWxlU291cmNlJztcbiAgICBXTVRTVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0X2ltYWdlX3VybCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBpbWFnZV91cmwsIHJlZjtcbiAgICAgICAgaW1hZ2VfdXJsID0gdGhpcy5zdHJpbmdfbG9va3VwX3JlcGxhY2UodGhpcy51cmwsIHRoaXMuZXh0cmFfdXJsX3ZhcnMpO1xuICAgICAgICByZWYgPSB0aGlzLnRtc190b193bXRzKHgsIHksIHopLCB4ID0gcmVmWzBdLCB5ID0gcmVmWzFdLCB6ID0gcmVmWzJdO1xuICAgICAgICByZXR1cm4gaW1hZ2VfdXJsLnJlcGxhY2UoXCJ7WH1cIiwgeCkucmVwbGFjZSgne1l9JywgeSkucmVwbGFjZShcIntafVwiLCB6KTtcbiAgICB9O1xuICAgIHJldHVybiBXTVRTVGlsZVNvdXJjZTtcbn0pKG1lcmNhdG9yX3RpbGVfc291cmNlXzEuTWVyY2F0b3JUaWxlU291cmNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBidXR0b25fdG9vbF8xID0gcmVxdWlyZShcIi4uL2J1dHRvbl90b29sXCIpO1xuZXhwb3J0cy5BY3Rpb25Ub29sQnV0dG9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBY3Rpb25Ub29sQnV0dG9uVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQWN0aW9uVG9vbEJ1dHRvblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBBY3Rpb25Ub29sQnV0dG9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWN0aW9uVG9vbEJ1dHRvblZpZXcucHJvdG90eXBlLl9jbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmlnZ2VyKCdkbycpO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvblRvb2xCdXR0b25WaWV3O1xufSkoYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sQnV0dG9uVmlldyk7XG5leHBvcnRzLkFjdGlvblRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFjdGlvblRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFjdGlvblRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY3Rpb25Ub29sVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIEFjdGlvblRvb2xWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdkbycsIHRoaXNbXCJkb1wiXSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uVG9vbFZpZXc7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2xWaWV3KTtcbmV4cG9ydHMuQWN0aW9uVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBY3Rpb25Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25Ub29sKCkge1xuICAgICAgICByZXR1cm4gQWN0aW9uVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEFjdGlvblRvb2w7XG59KShidXR0b25fdG9vbF8xLkJ1dHRvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuSGVscFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhlbHBUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSGVscFRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gSGVscFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIZWxwVG9vbFZpZXcucHJvdG90eXBlW1wiZG9cIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cub3Blbih0aGlzLm1vZGVsLnJlZGlyZWN0KTtcbiAgICB9O1xuICAgIHJldHVybiBIZWxwVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuSGVscFRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSGVscFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEhlbHBUb29sKCkge1xuICAgICAgICByZXR1cm4gSGVscFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEhlbHBUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkhlbHBUb29sVmlldztcbiAgICBIZWxwVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiSGVscFRvb2xcIjtcbiAgICBIZWxwVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJIZWxwXCI7XG4gICAgSGVscFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1oZWxwXCI7XG4gICAgSGVscFRvb2wuZGVmaW5lKHtcbiAgICAgICAgaGVscF90b29sdGlwOiBbcC5TdHJpbmcsICdDbGljayB0aGUgcXVlc3Rpb24gbWFyayB0byBsZWFybiBtb3JlIGFib3V0IEJva2VoIHBsb3QgdG9vbHMuJ10sXG4gICAgICAgIHJlZGlyZWN0OiBbcC5TdHJpbmcsICdodHRwOi8vYm9rZWgucHlkYXRhLm9yZy9lbi9sYXRlc3QvZG9jcy91c2VyX2d1aWRlL3Rvb2xzLmh0bWwnXVxuICAgIH0pO1xuICAgIEhlbHBUb29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwX3Rvb2x0aXA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gSGVscFRvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbmV4cG9ydHMuUmVkb1Rvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlZG9Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVkb1Rvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmVkb1Rvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWRvVG9vbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBSZWRvVG9vbFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuVG8odGhpcy5wbG90X3ZpZXcsIFwic3RhdGVfY2hhbmdlZFwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tb2RlbC5kaXNhYmxlZCA9ICFfdGhpcy5wbG90X3ZpZXcuY2FuX3JlZG8oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuICAgIFJlZG9Ub29sVmlldy5wcm90b3R5cGVbXCJkb1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlZG8oKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWRvVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuUmVkb1Rvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVkb1Rvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlZG9Ub29sKCkge1xuICAgICAgICByZXR1cm4gUmVkb1Rvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlZG9Ub29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlJlZG9Ub29sVmlldztcbiAgICBSZWRvVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiUmVkb1Rvb2xcIjtcbiAgICBSZWRvVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJSZWRvXCI7XG4gICAgUmVkb1Rvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1yZWRvXCI7XG4gICAgUmVkb1Rvb2wub3ZlcnJpZGUoe1xuICAgICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZWRvVG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbl90b29sXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5SZXNldFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2V0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJlc2V0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBSZXNldFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNldFRvb2xWaWV3LnByb3RvdHlwZVtcImRvXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5jbGVhcl9zdGF0ZSgpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5yZXNldF9yYW5nZSgpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5yZXNldF9zZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVzZXRfc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnJlc2V0X2RpbWVuc2lvbnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlc2V0VG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuUmVzZXRUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2V0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVzZXRUb29sKCkge1xuICAgICAgICByZXR1cm4gUmVzZXRUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNldFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmVzZXRUb29sVmlldztcbiAgICBSZXNldFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlJlc2V0VG9vbFwiO1xuICAgIFJlc2V0VG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJSZXNldFwiO1xuICAgIFJlc2V0VG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXJlc2V0XCI7XG4gICAgUmVzZXRUb29sLmRlZmluZSh7XG4gICAgICAgIHJlc2V0X3NpemU6IFtwLkJvb2wsIHRydWVdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc2V0VG9vbDtcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbl90b29sXCIpO1xuZXhwb3J0cy5TYXZlVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2F2ZVRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTYXZlVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTYXZlVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNhdmVUb29sVmlldy5wcm90b3R5cGVbXCJkb1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnNhdmUoXCJib2tlaF9wbG90LnBuZ1wiKTtcbiAgICB9O1xuICAgIHJldHVybiBTYXZlVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuU2F2ZVRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2F2ZVRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNhdmVUb29sKCkge1xuICAgICAgICByZXR1cm4gU2F2ZVRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNhdmVUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlNhdmVUb29sVmlldztcbiAgICBTYXZlVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiU2F2ZVRvb2xcIjtcbiAgICBTYXZlVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJTYXZlXCI7XG4gICAgU2F2ZVRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1zYXZlXCI7XG4gICAgcmV0dXJuIFNhdmVUb29sO1xufSkoYWN0aW9uX3Rvb2xfMS5BY3Rpb25Ub29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhY3Rpb25fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9uX3Rvb2xcIik7XG5leHBvcnRzLlVuZG9Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChVbmRvVG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFVuZG9Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFVuZG9Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVW5kb1Rvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVW5kb1Rvb2xWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMucGxvdF92aWV3LCBcInN0YXRlX2NoYW5nZWRcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubW9kZWwuZGlzYWJsZWQgPSAhX3RoaXMucGxvdF92aWV3LmNhbl91bmRvKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBVbmRvVG9vbFZpZXcucHJvdG90eXBlW1wiZG9cIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy51bmRvKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5kb1Rvb2xWaWV3O1xufSkoYWN0aW9uX3Rvb2xfMS5BY3Rpb25Ub29sVmlldyk7XG5leHBvcnRzLlVuZG9Ub29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFVuZG9Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBVbmRvVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFVuZG9Ub29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBVbmRvVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5VbmRvVG9vbFZpZXc7XG4gICAgVW5kb1Rvb2wucHJvdG90eXBlLnR5cGUgPSBcIlVuZG9Ub29sXCI7XG4gICAgVW5kb1Rvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiVW5kb1wiO1xuICAgIFVuZG9Ub29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24tdW5kb1wiO1xuICAgIFVuZG9Ub29sLm92ZXJyaWRlKHtcbiAgICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVW5kb1Rvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25fdG9vbFwiKTtcbnZhciB6b29tXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3pvb21cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlpvb21JblRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFpvb21JblRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBab29tSW5Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFpvb21JblRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBab29tSW5Ub29sVmlldy5wcm90b3R5cGVbXCJkb1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpbXMsIGZyYW1lLCBoX2F4aXMsIHZfYXhpcywgem9vbV9pbmZvO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaF9heGlzID0gZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCc7XG4gICAgICAgIHZfYXhpcyA9IGRpbXMgPT09ICdoZWlnaHQnIHx8IGRpbXMgPT09ICdib3RoJztcbiAgICAgICAgem9vbV9pbmZvID0gem9vbV8xLnNjYWxlX3JhbmdlKGZyYW1lLCB0aGlzLm1vZGVsLmZhY3RvciwgaF9heGlzLCB2X2F4aXMpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCd6b29tX291dCcsIHtcbiAgICAgICAgICAgIHJhbmdlOiB6b29tX2luZm9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnVwZGF0ZV9yYW5nZSh6b29tX2luZm8sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcuaW50ZXJhY3RpdmVfdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gWm9vbUluVG9vbFZpZXc7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2xWaWV3KTtcbmV4cG9ydHMuWm9vbUluVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChab29tSW5Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBab29tSW5Ub29sKCkge1xuICAgICAgICByZXR1cm4gWm9vbUluVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgWm9vbUluVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5ab29tSW5Ub29sVmlldztcbiAgICBab29tSW5Ub29sLnByb3RvdHlwZS50eXBlID0gXCJab29tSW5Ub29sXCI7XG4gICAgWm9vbUluVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJab29tIEluXCI7XG4gICAgWm9vbUluVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXpvb20taW5cIjtcbiAgICBab29tSW5Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKHRoaXMudG9vbF9uYW1lLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgWm9vbUluVG9vbC5kZWZpbmUoe1xuICAgICAgICBmYWN0b3I6IFtwLlBlcmNlbnQsIDAuMV0sXG4gICAgICAgIGRpbWVuc2lvbnM6IFtwLkRpbWVuc2lvbnMsIFwiYm90aFwiXVxuICAgIH0pO1xuICAgIHJldHVybiBab29tSW5Ub29sO1xufSkoYWN0aW9uX3Rvb2xfMS5BY3Rpb25Ub29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBhY3Rpb25fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9uX3Rvb2xcIik7XG52YXIgem9vbV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC96b29tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5ab29tT3V0VG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWm9vbU91dFRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBab29tT3V0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBab29tT3V0VG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFpvb21PdXRUb29sVmlldy5wcm90b3R5cGVbXCJkb1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpbXMsIGZyYW1lLCBoX2F4aXMsIHZfYXhpcywgem9vbV9pbmZvO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaF9heGlzID0gZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCc7XG4gICAgICAgIHZfYXhpcyA9IGRpbXMgPT09ICdoZWlnaHQnIHx8IGRpbXMgPT09ICdib3RoJztcbiAgICAgICAgem9vbV9pbmZvID0gem9vbV8xLnNjYWxlX3JhbmdlKGZyYW1lLCAtdGhpcy5tb2RlbC5mYWN0b3IsIGhfYXhpcywgdl9heGlzKTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZSgnem9vbV9vdXQnLCB7XG4gICAgICAgICAgICByYW5nZTogem9vbV9pbmZvXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy51cGRhdGVfcmFuZ2Uoem9vbV9pbmZvLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFpvb21PdXRUb29sVmlldztcbn0pKGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbFZpZXcpO1xuZXhwb3J0cy5ab29tT3V0VG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChab29tT3V0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gWm9vbU91dFRvb2woKSB7XG4gICAgICAgIHJldHVybiBab29tT3V0VG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgWm9vbU91dFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuWm9vbU91dFRvb2xWaWV3O1xuICAgIFpvb21PdXRUb29sLnByb3RvdHlwZS50eXBlID0gXCJab29tT3V0VG9vbFwiO1xuICAgIFpvb21PdXRUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIlpvb20gT3V0XCI7XG4gICAgWm9vbU91dFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi16b29tLW91dFwiO1xuICAgIFpvb21PdXRUb29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKHRoaXMudG9vbF9uYW1lLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgWm9vbU91dFRvb2wuZGVmaW5lKHtcbiAgICAgICAgZmFjdG9yOiBbcC5QZXJjZW50LCAwLjFdLFxuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl1cbiAgICB9KTtcbiAgICByZXR1cm4gWm9vbU91dFRvb2w7XG59KShhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGJva2VoX3ZpZXdfMSA9IHJlcXVpcmUoXCJjb3JlL2Jva2VoX3ZpZXdcIik7XG52YXIgdG9vbF8xID0gcmVxdWlyZShcIi4vdG9vbFwiKTtcbnZhciBkb21fMSA9IHJlcXVpcmUoXCJjb3JlL2RvbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQnV0dG9uVG9vbEJ1dHRvblZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQnV0dG9uVG9vbEJ1dHRvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblRvb2xCdXR0b25WaWV3KCkge1xuICAgICAgICByZXR1cm4gQnV0dG9uVG9vbEJ1dHRvblZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLXRvb2xiYXItYnV0dG9uXCI7XG4gICAgQnV0dG9uVG9vbEJ1dHRvblZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBCdXR0b25Ub29sQnV0dG9uVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jbGlja2VkKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpY29uLCB0aXA7XG4gICAgICAgIGRvbV8xLmVtcHR5KHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmVsLmRpc2FibGVkID0gdGhpcy5tb2RlbC5kaXNhYmxlZDtcbiAgICAgICAgaWNvbiA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFsnYmstYnRuLWljb24nLCB0aGlzLm1vZGVsLmljb25dXG4gICAgICAgIH0pO1xuICAgICAgICB0aXAgPSBkb21fMS5zcGFuKHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLXRpcCdcbiAgICAgICAgfSwgdGhpcy5tb2RlbC50b29sdGlwKTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChpY29uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGlwKTtcbiAgICB9O1xuICAgIEJ1dHRvblRvb2xCdXR0b25WaWV3LnByb3RvdHlwZS5fY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7IH07XG4gICAgcmV0dXJuIEJ1dHRvblRvb2xCdXR0b25WaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLkJ1dHRvblRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJ1dHRvblRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCdXR0b25Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEJ1dHRvblRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uVG9vbFZpZXc7XG59KSh0b29sXzEuVG9vbFZpZXcpO1xuZXhwb3J0cy5CdXR0b25Ub29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJ1dHRvblRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEJ1dHRvblRvb2woKSB7XG4gICAgICAgIHJldHVybiBCdXR0b25Ub29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdXR0b25Ub29sLnByb3RvdHlwZS5pY29uID0gbnVsbDtcbiAgICBCdXR0b25Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b29sX25hbWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBCdXR0b25Ub29sLmludGVybmFsKHtcbiAgICAgICAgZGlzYWJsZWQ6IFtwLkJvb2xlYW4sIGZhbHNlXVxuICAgIH0pO1xuICAgIHJldHVybiBCdXR0b25Ub29sO1xufSkodG9vbF8xLlRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVGQVVMVF9CT1hfT1ZFUkxBWSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RfdG9vbFwiKTtcbnZhciBib3hfYW5ub3RhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2Fubm90YXRpb25zL2JveF9hbm5vdGF0aW9uXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5Cb3hTZWxlY3RUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb3hTZWxlY3RUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94U2VsZWN0VG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBCb3hTZWxlY3RUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm94U2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHRoaXMuX2Jhc2Vib2ludCA9IFtjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCksIGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQm94U2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9wYW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYXBwZW5kLCBjYW52YXMsIGN1cnBvaW50LCBkaW1zLCBmcmFtZSwgcmVmLCByZWYxLCB2eGxpbSwgdnlsaW07XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgY3VycG9pbnQgPSBbY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpLCBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSldO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fZ2V0X2RpbV9saW1pdHModGhpcy5fYmFzZWJvaW50LCBjdXJwb2ludCwgZnJhbWUsIGRpbXMpLCB2eGxpbSA9IHJlZlswXSwgdnlsaW0gPSByZWZbMV07XG4gICAgICAgIHRoaXMubW9kZWwub3ZlcmxheS51cGRhdGUoe1xuICAgICAgICAgICAgbGVmdDogdnhsaW1bMF0sXG4gICAgICAgICAgICByaWdodDogdnhsaW1bMV0sXG4gICAgICAgICAgICB0b3A6IHZ5bGltWzFdLFxuICAgICAgICAgICAgYm90dG9tOiB2eWxpbVswXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2VsZWN0X2V2ZXJ5X21vdXNlbW92ZSkge1xuICAgICAgICAgICAgYXBwZW5kID0gKHJlZjEgPSBlLnNyY0V2ZW50LnNoaWZ0S2V5KSAhPSBudWxsID8gcmVmMSA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0KHZ4bGltLCB2eWxpbSwgZmFsc2UsIGFwcGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCb3hTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3Bhbl9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYXBwZW5kLCBjYW52YXMsIGN1cnBvaW50LCBkaW1zLCBmcmFtZSwgcmVmLCByZWYxLCB2eGxpbSwgdnlsaW07XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgY3VycG9pbnQgPSBbY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpLCBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSldO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5fZ2V0X2RpbV9saW1pdHModGhpcy5fYmFzZWJvaW50LCBjdXJwb2ludCwgZnJhbWUsIGRpbXMpLCB2eGxpbSA9IHJlZlswXSwgdnlsaW0gPSByZWZbMV07XG4gICAgICAgIGFwcGVuZCA9IChyZWYxID0gZS5zcmNFdmVudC5zaGlmdEtleSkgIT0gbnVsbCA/IHJlZjEgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0KHZ4bGltLCB2eWxpbSwgdHJ1ZSwgYXBwZW5kKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vdmVybGF5LnVwZGF0ZSh7XG4gICAgICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgICAgICBib3R0b206IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Jhc2Vib2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoJ2JveF9zZWxlY3QnLCB7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMucGxvdF92aWV3LmdldF9zZWxlY3Rpb24oKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCb3hTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3NlbGVjdCA9IGZ1bmN0aW9uIChhcmcsIGFyZzEsIGZpbmFsLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGRzLCBnZW9tZXRyeSwgaSwgbGVuLCByLCByZWYsIHNtLCB2eDAsIHZ4MSwgdnkwLCB2eTE7XG4gICAgICAgIHZ4MCA9IGFyZ1swXSwgdngxID0gYXJnWzFdO1xuICAgICAgICB2eTAgPSBhcmcxWzBdLCB2eTEgPSBhcmcxWzFdO1xuICAgICAgICBpZiAoYXBwZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGVuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5ID0ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgdngwOiB2eDAsXG4gICAgICAgICAgICB2eDE6IHZ4MSxcbiAgICAgICAgICAgIHZ5MDogdnkwLFxuICAgICAgICAgICAgdnkxOiB2eTFcbiAgICAgICAgfTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5jb21wdXRlZF9yZW5kZXJlcnM7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgciA9IHJlZltpXTtcbiAgICAgICAgICAgIGRzID0gci5kYXRhX3NvdXJjZTtcbiAgICAgICAgICAgIHNtID0gZHMuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICBzbS5zZWxlY3QodGhpcywgdGhpcy5wbG90X3ZpZXcucmVuZGVyZXJfdmlld3Nbci5pZF0sIGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5jYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0X2NhbGxiYWNrKGdlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYXZlX2dlb21ldHJ5KGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCb3hTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2VtaXRfY2FsbGJhY2sgPSBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgZnJhbWUsIHIsIHhtYXBwZXIsIHltYXBwZXI7XG4gICAgICAgIHIgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVyc1swXTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIGdlb21ldHJ5WydzeDAnXSA9IGNhbnZhcy52eF90b19zeChnZW9tZXRyeS52eDApO1xuICAgICAgICBnZW9tZXRyeVsnc3gxJ10gPSBjYW52YXMudnhfdG9fc3goZ2VvbWV0cnkudngxKTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N5MCddID0gY2FudmFzLnZ5X3RvX3N5KGdlb21ldHJ5LnZ5MCk7XG4gICAgICAgIGdlb21ldHJ5WydzeTEnXSA9IGNhbnZhcy52eV90b19zeShnZW9tZXRyeS52eTEpO1xuICAgICAgICB4bWFwcGVyID0gZnJhbWUueF9tYXBwZXJzW3IueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgeW1hcHBlciA9IGZyYW1lLnlfbWFwcGVyc1tyLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIGdlb21ldHJ5Wyd4MCddID0geG1hcHBlci5tYXBfZnJvbV90YXJnZXQoZ2VvbWV0cnkudngwKTtcbiAgICAgICAgZ2VvbWV0cnlbJ3gxJ10gPSB4bWFwcGVyLm1hcF9mcm9tX3RhcmdldChnZW9tZXRyeS52eDEpO1xuICAgICAgICBnZW9tZXRyeVsneTAnXSA9IHltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KGdlb21ldHJ5LnZ5MCk7XG4gICAgICAgIGdlb21ldHJ5Wyd5MSddID0geW1hcHBlci5tYXBfZnJvbV90YXJnZXQoZ2VvbWV0cnkudnkxKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jYWxsYmFjay5leGVjdXRlKHRoaXMubW9kZWwsIHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3hTZWxlY3RUb29sVmlldztcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbFZpZXcpO1xuREVGQVVMVF9CT1hfT1ZFUkxBWSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IGJveF9hbm5vdGF0aW9uXzEuQm94QW5ub3RhdGlvbih7XG4gICAgICAgIGxldmVsOiBcIm92ZXJsYXlcIixcbiAgICAgICAgcmVuZGVyX21vZGU6IFwiY3NzXCIsXG4gICAgICAgIHRvcF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgbGVmdF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgYm90dG9tX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICByaWdodF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgZmlsbF9jb2xvcjogXCJsaWdodGdyZXlcIixcbiAgICAgICAgZmlsbF9hbHBoYTogMC41LFxuICAgICAgICBsaW5lX2NvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVfYWxwaGE6IDEuMCxcbiAgICAgICAgbGluZV93aWR0aDogMixcbiAgICAgICAgbGluZV9kYXNoOiBbNCwgNF1cbiAgICB9KTtcbn07XG5leHBvcnRzLkJveFNlbGVjdFRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQm94U2VsZWN0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94U2VsZWN0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIEJveFNlbGVjdFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQm94U2VsZWN0VG9vbFZpZXc7XG4gICAgQm94U2VsZWN0VG9vbC5wcm90b3R5cGUudHlwZSA9IFwiQm94U2VsZWN0VG9vbFwiO1xuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiQm94IFNlbGVjdFwiO1xuICAgIEJveFNlbGVjdFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1ib3gtc2VsZWN0XCI7XG4gICAgQm94U2VsZWN0VG9vbC5wcm90b3R5cGUuZXZlbnRfdHlwZSA9IFwicGFuXCI7XG4gICAgQm94U2VsZWN0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF9vcmRlciA9IDMwO1xuICAgIEJveFNlbGVjdFRvb2wuZGVmaW5lKHtcbiAgICAgICAgZGltZW5zaW9uczogW3AuRGltZW5zaW9ucywgXCJib3RoXCJdLFxuICAgICAgICBzZWxlY3RfZXZlcnlfbW91c2Vtb3ZlOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIGNhbGxiYWNrOiBbcC5JbnN0YW5jZV0sXG4gICAgICAgIG92ZXJsYXk6IFtwLkluc3RhbmNlLCBERUZBVUxUX0JPWF9PVkVSTEFZXVxuICAgIH0pO1xuICAgIEJveFNlbGVjdFRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfZGltX3Rvb2x0aXAodGhpcy50b29sX25hbWUsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQm94U2VsZWN0VG9vbDtcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX0JPWF9PVkVSTEFZLCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgYm94X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9hbm5vdGF0aW9ucy9ib3hfYW5ub3RhdGlvblwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmV4cG9ydHMuQm94Wm9vbVRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveFpvb21Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQm94Wm9vbVRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gQm94Wm9vbVRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hab29tVG9vbFZpZXcucHJvdG90eXBlLl9tYXRjaF9hc3BlY3QgPSBmdW5jdGlvbiAoYmFzZXBvaW50LCBjdXJwb2ludCwgZnJhbWUpIHtcbiAgICAgICAgdmFyIGEsIGJvdHRvbSwgaCwgaGVuZCwgaHN0YXJ0LCBsZWZ0LCByZWYsIHJlZjEsIHJpZ2h0LCB0b3AsIHZhLCB2ZW5kLCB2aCwgdnN0YXJ0LCB2dywgdywgeG1vZCwgeW1vZDtcbiAgICAgICAgaGVuZCA9IGZyYW1lLmhfcmFuZ2UuZW5kO1xuICAgICAgICBoc3RhcnQgPSBmcmFtZS5oX3JhbmdlLnN0YXJ0O1xuICAgICAgICB2ZW5kID0gZnJhbWUudl9yYW5nZS5lbmQ7XG4gICAgICAgIHZzdGFydCA9IGZyYW1lLnZfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHcgPSBoZW5kIC0gaHN0YXJ0O1xuICAgICAgICBoID0gdmVuZCAtIHZzdGFydDtcbiAgICAgICAgYSA9IHcgLyBoO1xuICAgICAgICB2dyA9IE1hdGguYWJzKGJhc2Vwb2ludFswXSAtIGN1cnBvaW50WzBdKTtcbiAgICAgICAgdmggPSBNYXRoLmFicyhiYXNlcG9pbnRbMV0gLSBjdXJwb2ludFsxXSk7XG4gICAgICAgIGlmICh2aCA9PT0gMCkge1xuICAgICAgICAgICAgdmEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmEgPSB2dyAvIHZoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YSA+PSBhKSB7XG4gICAgICAgICAgICByZWYgPSBbMSwgdmEgLyBhXSwgeG1vZCA9IHJlZlswXSwgeW1vZCA9IHJlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZjEgPSBbYSAvIHZhLCAxXSwgeG1vZCA9IHJlZjFbMF0sIHltb2QgPSByZWYxWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlcG9pbnRbMF0gPD0gY3VycG9pbnRbMF0pIHtcbiAgICAgICAgICAgIGxlZnQgPSBiYXNlcG9pbnRbMF07XG4gICAgICAgICAgICByaWdodCA9IGJhc2Vwb2ludFswXSArIHZ3ICogeG1vZDtcbiAgICAgICAgICAgIGlmIChyaWdodCA+IGhlbmQpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IGhlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByaWdodCA9IGJhc2Vwb2ludFswXTtcbiAgICAgICAgICAgIGxlZnQgPSBiYXNlcG9pbnRbMF0gLSB2dyAqIHhtb2Q7XG4gICAgICAgICAgICBpZiAobGVmdCA8IGhzdGFydCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBoc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdncgPSBNYXRoLmFicyhyaWdodCAtIGxlZnQpO1xuICAgICAgICBpZiAoYmFzZXBvaW50WzFdIDw9IGN1cnBvaW50WzFdKSB7XG4gICAgICAgICAgICBib3R0b20gPSBiYXNlcG9pbnRbMV07XG4gICAgICAgICAgICB0b3AgPSBiYXNlcG9pbnRbMV0gKyB2dyAvIGE7XG4gICAgICAgICAgICBpZiAodG9wID4gdmVuZCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHZlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSBiYXNlcG9pbnRbMV07XG4gICAgICAgICAgICBib3R0b20gPSBiYXNlcG9pbnRbMV0gLSB2dyAvIGE7XG4gICAgICAgICAgICBpZiAoYm90dG9tIDwgdnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gdnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZoID0gTWF0aC5hYnModG9wIC0gYm90dG9tKTtcbiAgICAgICAgaWYgKGJhc2Vwb2ludFswXSA8PSBjdXJwb2ludFswXSkge1xuICAgICAgICAgICAgcmlnaHQgPSBiYXNlcG9pbnRbMF0gKyBhICogdmg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gYmFzZXBvaW50WzBdIC0gYSAqIHZoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW2xlZnQsIHJpZ2h0XSwgW2JvdHRvbSwgdG9wXV07XG4gICAgfTtcbiAgICBCb3hab29tVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHRoaXMuX2Jhc2Vib2ludCA9IFtjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCksIGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQm94Wm9vbVRvb2xWaWV3LnByb3RvdHlwZS5fcGFuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgY3VycG9pbnQsIGRpbXMsIGZyYW1lLCByZWYsIHJlZjEsIHZ4LCB2eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICBjdXJwb2ludCA9IFtjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCksIGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KV07XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBkaW1zID0gdGhpcy5tb2RlbC5kaW1lbnNpb25zO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5tYXRjaF9hc3BlY3QgJiYgZGltcyA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLl9tYXRjaF9hc3BlY3QodGhpcy5fYmFzZWJvaW50LCBjdXJwb2ludCwgZnJhbWUpLCB2eCA9IHJlZlswXSwgdnkgPSByZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5tb2RlbC5fZ2V0X2RpbV9saW1pdHModGhpcy5fYmFzZWJvaW50LCBjdXJwb2ludCwgZnJhbWUsIGRpbXMpLCB2eCA9IHJlZjFbMF0sIHZ5ID0gcmVmMVsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLm92ZXJsYXkudXBkYXRlKHtcbiAgICAgICAgICAgIGxlZnQ6IHZ4WzBdLFxuICAgICAgICAgICAgcmlnaHQ6IHZ4WzFdLFxuICAgICAgICAgICAgdG9wOiB2eVsxXSxcbiAgICAgICAgICAgIGJvdHRvbTogdnlbMF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQm94Wm9vbVRvb2xWaWV3LnByb3RvdHlwZS5fcGFuX2VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGN1cnBvaW50LCBkaW1zLCBmcmFtZSwgcmVmLCByZWYxLCB2eCwgdnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgY3VycG9pbnQgPSBbY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpLCBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSldO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaWYgKHRoaXMubW9kZWwubWF0Y2hfYXNwZWN0ICYmIGRpbXMgPT09ICdib3RoJykge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5fbWF0Y2hfYXNwZWN0KHRoaXMuX2Jhc2Vib2ludCwgY3VycG9pbnQsIGZyYW1lKSwgdnggPSByZWZbMF0sIHZ5ID0gcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmMSA9IHRoaXMubW9kZWwuX2dldF9kaW1fbGltaXRzKHRoaXMuX2Jhc2Vib2ludCwgY3VycG9pbnQsIGZyYW1lLCBkaW1zKSwgdnggPSByZWYxWzBdLCB2eSA9IHJlZjFbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlKHZ4LCB2eSk7XG4gICAgICAgIHRoaXMubW9kZWwub3ZlcmxheS51cGRhdGUoe1xuICAgICAgICAgICAgbGVmdDogbnVsbCxcbiAgICAgICAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICAgICAgYm90dG9tOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iYXNlYm9pbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJveFpvb21Ub29sVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2eCwgdnkpIHtcbiAgICAgICAgdmFyIGVuZCwgbWFwcGVyLCBuYW1lLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHN0YXJ0LCB4cnMsIHlycywgem9vbV9pbmZvO1xuICAgICAgICBpZiAoTWF0aC5hYnModnhbMV0gLSB2eFswXSkgPD0gNSB8fCBNYXRoLmFicyh2eVsxXSAtIHZ5WzBdKSA8PSA1KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeHJzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMucGxvdF92aWV3LmZyYW1lLnhfbWFwcGVycztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgICAgbWFwcGVyID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgcmVmMSA9IG1hcHBlci52X21hcF9mcm9tX3RhcmdldCh2eCwgdHJ1ZSksIHN0YXJ0ID0gcmVmMVswXSwgZW5kID0gcmVmMVsxXTtcbiAgICAgICAgICAgIHhyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgeXJzID0ge307XG4gICAgICAgIHJlZjIgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS55X21hcHBlcnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBtYXBwZXIgPSByZWYyW25hbWVdO1xuICAgICAgICAgICAgcmVmMyA9IG1hcHBlci52X21hcF9mcm9tX3RhcmdldCh2eSwgdHJ1ZSksIHN0YXJ0ID0gcmVmM1swXSwgZW5kID0gcmVmM1sxXTtcbiAgICAgICAgICAgIHlyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgem9vbV9pbmZvID0ge1xuICAgICAgICAgICAgeHJzOiB4cnMsXG4gICAgICAgICAgICB5cnM6IHlyc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdib3hfem9vbScsIHtcbiAgICAgICAgICAgIHJhbmdlOiB6b29tX2luZm9cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy51cGRhdGVfcmFuZ2Uoem9vbV9pbmZvKTtcbiAgICB9O1xuICAgIHJldHVybiBCb3hab29tVG9vbFZpZXc7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbFZpZXcpO1xuREVGQVVMVF9CT1hfT1ZFUkxBWSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IGJveF9hbm5vdGF0aW9uXzEuQm94QW5ub3RhdGlvbih7XG4gICAgICAgIGxldmVsOiBcIm92ZXJsYXlcIixcbiAgICAgICAgcmVuZGVyX21vZGU6IFwiY3NzXCIsXG4gICAgICAgIHRvcF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgbGVmdF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgYm90dG9tX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICByaWdodF91bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgZmlsbF9jb2xvcjogXCJsaWdodGdyZXlcIixcbiAgICAgICAgZmlsbF9hbHBoYTogMC41LFxuICAgICAgICBsaW5lX2NvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVfYWxwaGE6IDEuMCxcbiAgICAgICAgbGluZV93aWR0aDogMixcbiAgICAgICAgbGluZV9kYXNoOiBbNCwgNF1cbiAgICB9KTtcbn07XG5leHBvcnRzLkJveFpvb21Ub29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEJveFpvb21Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb3hab29tVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIEJveFpvb21Ub29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCb3hab29tVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Cb3hab29tVG9vbFZpZXc7XG4gICAgQm94Wm9vbVRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkJveFpvb21Ub29sXCI7XG4gICAgQm94Wm9vbVRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiQm94IFpvb21cIjtcbiAgICBCb3hab29tVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLWJveC16b29tXCI7XG4gICAgQm94Wm9vbVRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInBhblwiO1xuICAgIEJveFpvb21Ub29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMjA7XG4gICAgQm94Wm9vbVRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfZGltX3Rvb2x0aXAodGhpcy50b29sX25hbWUsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBCb3hab29tVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl0sXG4gICAgICAgIG92ZXJsYXk6IFtwLkluc3RhbmNlLCBERUZBVUxUX0JPWF9PVkVSTEFZXSxcbiAgICAgICAgbWF0Y2hfYXNwZWN0OiBbcC5Cb29sLCBmYWxzZV1cbiAgICB9KTtcbiAgICByZXR1cm4gQm94Wm9vbVRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYnV0dG9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuLi9idXR0b25fdG9vbFwiKTtcbmV4cG9ydHMuR2VzdHVyZVRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdlc3R1cmVUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gR2VzdHVyZVRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gR2VzdHVyZVRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gR2VzdHVyZVRvb2xWaWV3O1xufSkoYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sVmlldyk7XG5leHBvcnRzLkdlc3R1cmVUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEdlc3R1cmVUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBHZXN0dXJlVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIEdlc3R1cmVUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHZXN0dXJlVG9vbC5wcm90b3R5cGUuZXZlbnRfdHlwZSA9IG51bGw7XG4gICAgR2VzdHVyZVRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSBudWxsO1xuICAgIHJldHVybiBHZXN0dXJlVG9vbDtcbn0pKGJ1dHRvbl90b29sXzEuQnV0dG9uVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX1BPTFlfT1ZFUkxBWSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RfdG9vbFwiKTtcbnZhciBwb2x5X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9hbm5vdGF0aW9ucy9wb2x5X2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkxhc3NvU2VsZWN0VG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGFzc29TZWxlY3RUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFzc29TZWxlY3RUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIExhc3NvU2VsZWN0VG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExhc3NvU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBMYXNzb1NlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTphY3RpdmUnLCB0aGlzLl9hY3RpdmVfY2hhbmdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fYWN0aXZlX2NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyX292ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzc29TZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2tleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGVhcl9vdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhc3NvU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzLCB2eCwgdnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICB2eDogW3Z4XSxcbiAgICAgICAgICAgIHZ5OiBbdnldXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGFzc29TZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3BhbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcHBlbmQsIGNhbnZhcywgaF9yYW5nZSwgb3ZlcmxheSwgcmVmLCB2X3JhbmdlLCB2eCwgdnk7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICBoX3JhbmdlID0gdGhpcy5wbG90X21vZGVsLmZyYW1lLmhfcmFuZ2U7XG4gICAgICAgIHZfcmFuZ2UgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWUudl9yYW5nZTtcbiAgICAgICAgaWYgKHZ4ID4gaF9yYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHZ4ID0gaF9yYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZ4IDwgaF9yYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgdnggPSBoX3JhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2eSA+IHZfcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICB2eSA9IHZfcmFuZ2UuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2eSA8IHZfcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIHZ5ID0gdl9yYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEudngucHVzaCh2eCk7XG4gICAgICAgIHRoaXMuZGF0YS52eS5wdXNoKHZ5KTtcbiAgICAgICAgb3ZlcmxheSA9IHRoaXMubW9kZWwub3ZlcmxheTtcbiAgICAgICAgb3ZlcmxheS51cGRhdGUoe1xuICAgICAgICAgICAgeHM6IHRoaXMuZGF0YS52eCxcbiAgICAgICAgICAgIHlzOiB0aGlzLmRhdGEudnlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNlbGVjdF9ldmVyeV9tb3VzZW1vdmUpIHtcbiAgICAgICAgICAgIGFwcGVuZCA9IChyZWYgPSBlLnNyY0V2ZW50LnNoaWZ0S2V5KSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0KHRoaXMuZGF0YS52eCwgdGhpcy5kYXRhLnZ5LCBmYWxzZSwgYXBwZW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzc29TZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3Bhbl9lbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYXBwZW5kLCByZWY7XG4gICAgICAgIHRoaXMuX2NsZWFyX292ZXJsYXkoKTtcbiAgICAgICAgYXBwZW5kID0gKHJlZiA9IGUuc3JjRXZlbnQuc2hpZnRLZXkpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0KHRoaXMuZGF0YS52eCwgdGhpcy5kYXRhLnZ5LCB0cnVlLCBhcHBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcucHVzaF9zdGF0ZSgnbGFzc29fc2VsZWN0Jywge1xuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnBsb3Rfdmlldy5nZXRfc2VsZWN0aW9uKClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMYXNzb1NlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fY2xlYXJfb3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3ZlcmxheS51cGRhdGUoe1xuICAgICAgICAgICAgeHM6IFtdLFxuICAgICAgICAgICAgeXM6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGFzc29TZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3NlbGVjdCA9IGZ1bmN0aW9uICh2eCwgdnksIGZpbmFsLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGRzLCBnZW9tZXRyeSwgaSwgbGVuLCByLCByZWYsIHNtO1xuICAgICAgICBnZW9tZXRyeSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2x5JyxcbiAgICAgICAgICAgIHZ4OiB2eCxcbiAgICAgICAgICAgIHZ5OiB2eVxuICAgICAgICB9O1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByID0gcmVmW2ldO1xuICAgICAgICAgICAgZHMgPSByLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgc20gPSBkcy5zZWxlY3Rpb25fbWFuYWdlcjtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0aGlzLCB0aGlzLnBsb3Rfdmlldy5yZW5kZXJlcl92aWV3c1tyLmlkXSwgZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRfY2FsbGJhY2soZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVfZ2VvbWV0cnkoZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExhc3NvU2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9lbWl0X2NhbGxiYWNrID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYW52YXMsIGZyYW1lLCByLCB4bWFwcGVyLCB5bWFwcGVyO1xuICAgICAgICByID0gdGhpcy5tb2RlbC5jb21wdXRlZF9yZW5kZXJlcnNbMF07XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF9tb2RlbC5jYW52YXM7XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBnZW9tZXRyeVsnc3gnXSA9IGNhbnZhcy52X3Z4X3RvX3N4KGdlb21ldHJ5LnZ4KTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N5J10gPSBjYW52YXMudl92eV90b19zeShnZW9tZXRyeS52eSk7XG4gICAgICAgIHhtYXBwZXIgPSBmcmFtZS54X21hcHBlcnNbci54X3JhbmdlX25hbWVdO1xuICAgICAgICB5bWFwcGVyID0gZnJhbWUueV9tYXBwZXJzW3IueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgZ2VvbWV0cnlbJ3gnXSA9IHhtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoZ2VvbWV0cnkudngpO1xuICAgICAgICBnZW9tZXRyeVsneSddID0geW1hcHBlci52X21hcF9mcm9tX3RhcmdldChnZW9tZXRyeS52eSk7XG4gICAgICAgIHRoaXMubW9kZWwuY2FsbGJhY2suZXhlY3V0ZSh0aGlzLm1vZGVsLCB7XG4gICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzc29TZWxlY3RUb29sVmlldztcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbFZpZXcpO1xuREVGQVVMVF9QT0xZX09WRVJMQVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBwb2x5X2Fubm90YXRpb25fMS5Qb2x5QW5ub3RhdGlvbih7XG4gICAgICAgIGxldmVsOiBcIm92ZXJsYXlcIixcbiAgICAgICAgeHNfdW5pdHM6IFwic2NyZWVuXCIsXG4gICAgICAgIHlzX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICBmaWxsX2NvbG9yOiBcImxpZ2h0Z3JleVwiLFxuICAgICAgICBmaWxsX2FscGhhOiAwLjUsXG4gICAgICAgIGxpbmVfY29sb3I6IFwiYmxhY2tcIixcbiAgICAgICAgbGluZV9hbHBoYTogMS4wLFxuICAgICAgICBsaW5lX3dpZHRoOiAyLFxuICAgICAgICBsaW5lX2Rhc2g6IFs0LCA0XVxuICAgIH0pO1xufTtcbmV4cG9ydHMuTGFzc29TZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExhc3NvU2VsZWN0VG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTGFzc29TZWxlY3RUb29sKCkge1xuICAgICAgICByZXR1cm4gTGFzc29TZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuTGFzc29TZWxlY3RUb29sVmlldztcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkxhc3NvU2VsZWN0VG9vbFwiO1xuICAgIExhc3NvU2VsZWN0VG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJMYXNzbyBTZWxlY3RcIjtcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1sYXNzby1zZWxlY3RcIjtcbiAgICBMYXNzb1NlbGVjdFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInBhblwiO1xuICAgIExhc3NvU2VsZWN0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF9vcmRlciA9IDEyO1xuICAgIExhc3NvU2VsZWN0VG9vbC5kZWZpbmUoe1xuICAgICAgICBzZWxlY3RfZXZlcnlfbW91c2Vtb3ZlOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgb3ZlcmxheTogW3AuSW5zdGFuY2UsIERFRkFVTFRfUE9MWV9PVkVSTEFZXVxuICAgIH0pO1xuICAgIHJldHVybiBMYXNzb1NlbGVjdFRvb2w7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2wpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZV90b29sXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5QYW5Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGFuVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBQYW5Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzLCBmcmFtZSwgaHIsIHZyLCB2eCwgdnk7XG4gICAgICAgIHRoaXMubGFzdF9keCA9IDA7XG4gICAgICAgIHRoaXMubGFzdF9keSA9IDA7XG4gICAgICAgIGNhbnZhcyA9IHRoaXMucGxvdF92aWV3LmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3Rfdmlldy5mcmFtZTtcbiAgICAgICAgdnggPSBjYW52YXMuc3hfdG9fdngoZS5ib2tlaC5zeCk7XG4gICAgICAgIHZ5ID0gY2FudmFzLnN5X3RvX3Z5KGUuYm9rZWguc3kpO1xuICAgICAgICBpZiAoIWZyYW1lLmNvbnRhaW5zKHZ4LCB2eSkpIHtcbiAgICAgICAgICAgIGhyID0gZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgICAgIHZyID0gZnJhbWUudl9yYW5nZTtcbiAgICAgICAgICAgIGlmICh2eCA8IGhyLnN0YXJ0IHx8IHZ4ID4gaHIuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52X2F4aXNfb25seSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnkgPCB2ci5zdGFydCB8fCB2eSA+IHZyLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaF9heGlzX29ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoZS5kZWx0YVgsIC1lLmRlbHRhWSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH07XG4gICAgUGFuVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5oX2F4aXNfb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZfYXhpc19vbmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhbl9pbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdwYW4nLCB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMucGFuX2luZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYW5Ub29sVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgdmFyIGRpbXMsIGVuZCwgZnJhbWUsIGhyLCBpc19wYW5uaW5nLCBtYXBwZXIsIG5hbWUsIG5ld19keCwgbmV3X2R5LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHNkeCwgc2R5LCBzdGFydCwgc3gwLCBzeDEsIHN4X2hpZ2gsIHN4X2xvdywgc3kwLCBzeTEsIHN5X2hpZ2gsIHN5X2xvdywgdnIsIHhycywgeXJzO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICBuZXdfZHggPSBkeCAtIHRoaXMubGFzdF9keDtcbiAgICAgICAgbmV3X2R5ID0gZHkgLSB0aGlzLmxhc3RfZHk7XG4gICAgICAgIGhyID0gZnJhbWUuaF9yYW5nZTtcbiAgICAgICAgc3hfbG93ID0gaHIuc3RhcnQgLSBuZXdfZHg7XG4gICAgICAgIHN4X2hpZ2ggPSBoci5lbmQgLSBuZXdfZHg7XG4gICAgICAgIHZyID0gZnJhbWUudl9yYW5nZTtcbiAgICAgICAgc3lfbG93ID0gdnIuc3RhcnQgLSBuZXdfZHk7XG4gICAgICAgIHN5X2hpZ2ggPSB2ci5lbmQgLSBuZXdfZHk7XG4gICAgICAgIGRpbXMgPSB0aGlzLm1vZGVsLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmICgoZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCcpICYmICF0aGlzLnZfYXhpc19vbmx5KSB7XG4gICAgICAgICAgICBzeDAgPSBzeF9sb3c7XG4gICAgICAgICAgICBzeDEgPSBzeF9oaWdoO1xuICAgICAgICAgICAgc2R4ID0gLW5ld19keDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN4MCA9IGhyLnN0YXJ0O1xuICAgICAgICAgICAgc3gxID0gaHIuZW5kO1xuICAgICAgICAgICAgc2R4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGRpbXMgPT09ICdoZWlnaHQnIHx8IGRpbXMgPT09ICdib3RoJykgJiYgIXRoaXMuaF9heGlzX29ubHkpIHtcbiAgICAgICAgICAgIHN5MCA9IHN5X2xvdztcbiAgICAgICAgICAgIHN5MSA9IHN5X2hpZ2g7XG4gICAgICAgICAgICBzZHkgPSBuZXdfZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeTAgPSB2ci5zdGFydDtcbiAgICAgICAgICAgIHN5MSA9IHZyLmVuZDtcbiAgICAgICAgICAgIHNkeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X2R4ID0gZHg7XG4gICAgICAgIHRoaXMubGFzdF9keSA9IGR5O1xuICAgICAgICB4cnMgPSB7fTtcbiAgICAgICAgcmVmID0gZnJhbWUueF9tYXBwZXJzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBtYXBwZXIgPSByZWZbbmFtZV07XG4gICAgICAgICAgICByZWYxID0gbWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFtzeDAsIHN4MV0sIHRydWUpLCBzdGFydCA9IHJlZjFbMF0sIGVuZCA9IHJlZjFbMV07XG4gICAgICAgICAgICB4cnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHlycyA9IHt9O1xuICAgICAgICByZWYyID0gZnJhbWUueV9tYXBwZXJzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMikge1xuICAgICAgICAgICAgbWFwcGVyID0gcmVmMltuYW1lXTtcbiAgICAgICAgICAgIHJlZjMgPSBtYXBwZXIudl9tYXBfZnJvbV90YXJnZXQoW3N5MCwgc3kxXSwgdHJ1ZSksIHN0YXJ0ID0gcmVmM1swXSwgZW5kID0gcmVmM1sxXTtcbiAgICAgICAgICAgIHlyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5faW5mbyA9IHtcbiAgICAgICAgICAgIHhyczogeHJzLFxuICAgICAgICAgICAgeXJzOiB5cnMsXG4gICAgICAgICAgICBzZHg6IHNkeCxcbiAgICAgICAgICAgIHNkeTogc2R5XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnVwZGF0ZV9yYW5nZSh0aGlzLnBhbl9pbmZvLCBpc19wYW5uaW5nID0gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBhblRvb2xWaWV3O1xufSkoZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2xWaWV3KTtcbmV4cG9ydHMuUGFuVG9vbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQYW5Ub29sKCkge1xuICAgICAgICByZXR1cm4gUGFuVG9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5QYW5Ub29sVmlldztcbiAgICBQYW5Ub29sLnByb3RvdHlwZS50eXBlID0gXCJQYW5Ub29sXCI7XG4gICAgUGFuVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJQYW5cIjtcbiAgICBQYW5Ub29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJwYW5cIjtcbiAgICBQYW5Ub29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTA7XG4gICAgUGFuVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl1cbiAgICB9KTtcbiAgICBQYW5Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKFwiUGFuXCIsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGljb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdWZmaXg7XG4gICAgICAgICAgICBzdWZmaXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib3RoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYW5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ4cGFuXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInlwYW5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIFwiYmstdG9vbC1pY29uLVwiICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFBhblRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUZBVUxUX1BPTFlfT1ZFUkxBWSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHNlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9zZWxlY3RfdG9vbFwiKTtcbnZhciBwb2x5X2Fubm90YXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9hbm5vdGF0aW9ucy9wb2x5X2Fubm90YXRpb25cIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvYXJyYXlcIik7XG5leHBvcnRzLlBvbHlTZWxlY3RUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQb2x5U2VsZWN0VG9vbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBvbHlTZWxlY3RUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBvbHlTZWxlY3RUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgUG9seVNlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTphY3RpdmUnLCB0aGlzLl9hY3RpdmVfY2hhbmdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIHZ4OiBbXSxcbiAgICAgICAgICAgIHZ5OiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fYWN0aXZlX2NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyX2RhdGEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fa2V5dXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyX2RhdGEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fZG91YmxldGFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGFwcGVuZCwgcmVmO1xuICAgICAgICBhcHBlbmQgPSAocmVmID0gZS5zcmNFdmVudC5zaGlmdEtleSkgIT0gbnVsbCA/IHJlZiA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZWxlY3QodGhpcy5kYXRhLnZ4LCB0aGlzLmRhdGEudnksIHRydWUsIGFwcGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGVhcl9kYXRhKCk7XG4gICAgfTtcbiAgICBQb2x5U2VsZWN0VG9vbFZpZXcucHJvdG90eXBlLl9jbGVhcl9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICB2eDogW10sXG4gICAgICAgICAgICB2eTogW11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3ZlcmxheS51cGRhdGUoe1xuICAgICAgICAgICAgeHM6IFtdLFxuICAgICAgICAgICAgeXM6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seVNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fdGFwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgdngsIHZ5O1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHZ4ID0gY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpO1xuICAgICAgICB2eSA9IGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KTtcbiAgICAgICAgdGhpcy5kYXRhLnZ4LnB1c2godngpO1xuICAgICAgICB0aGlzLmRhdGEudnkucHVzaCh2eSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm92ZXJsYXkudXBkYXRlKHtcbiAgICAgICAgICAgIHhzOiBhcnJheV8xLmNvcHkodGhpcy5kYXRhLnZ4KSxcbiAgICAgICAgICAgIHlzOiBhcnJheV8xLmNvcHkodGhpcy5kYXRhLnZ5KVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX3NlbGVjdCA9IGZ1bmN0aW9uICh2eCwgdnksIGZpbmFsLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGRzLCBnZW9tZXRyeSwgaSwgbGVuLCByLCByZWYsIHNtO1xuICAgICAgICBnZW9tZXRyeSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2x5JyxcbiAgICAgICAgICAgIHZ4OiB2eCxcbiAgICAgICAgICAgIHZ5OiB2eVxuICAgICAgICB9O1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByID0gcmVmW2ldO1xuICAgICAgICAgICAgZHMgPSByLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgc20gPSBkcy5zZWxlY3Rpb25fbWFuYWdlcjtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0aGlzLCB0aGlzLnBsb3Rfdmlldy5yZW5kZXJlcl92aWV3c1tyLmlkXSwgZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVfZ2VvbWV0cnkoZ2VvbWV0cnksIGZpbmFsLCBhcHBlbmQpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCdwb2x5X3NlbGVjdCcsIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5wbG90X3ZpZXcuZ2V0X3NlbGVjdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQb2x5U2VsZWN0VG9vbFZpZXc7XG59KShzZWxlY3RfdG9vbF8xLlNlbGVjdFRvb2xWaWV3KTtcbkRFRkFVTFRfUE9MWV9PVkVSTEFZID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgcG9seV9hbm5vdGF0aW9uXzEuUG9seUFubm90YXRpb24oe1xuICAgICAgICBsZXZlbDogXCJvdmVybGF5XCIsXG4gICAgICAgIHhzX3VuaXRzOiBcInNjcmVlblwiLFxuICAgICAgICB5c191bml0czogXCJzY3JlZW5cIixcbiAgICAgICAgZmlsbF9jb2xvcjogXCJsaWdodGdyZXlcIixcbiAgICAgICAgZmlsbF9hbHBoYTogMC41LFxuICAgICAgICBsaW5lX2NvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgIGxpbmVfYWxwaGE6IDEuMCxcbiAgICAgICAgbGluZV93aWR0aDogMixcbiAgICAgICAgbGluZV9kYXNoOiBbNCwgNF1cbiAgICB9KTtcbn07XG5leHBvcnRzLlBvbHlTZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBvbHlTZWxlY3RUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQb2x5U2VsZWN0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFBvbHlTZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQb2x5U2VsZWN0VG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Qb2x5U2VsZWN0VG9vbFZpZXc7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLnR5cGUgPSBcIlBvbHlTZWxlY3RUb29sXCI7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiUG9seSBTZWxlY3RcIjtcbiAgICBQb2x5U2VsZWN0VG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXBvbHlnb24tc2VsZWN0XCI7XG4gICAgUG9seVNlbGVjdFRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInRhcFwiO1xuICAgIFBvbHlTZWxlY3RUb29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTE7XG4gICAgUG9seVNlbGVjdFRvb2wuZGVmaW5lKHtcbiAgICAgICAgb3ZlcmxheTogW3AuSW5zdGFuY2UsIERFRkFVTFRfUE9MWV9PVkVSTEFZXVxuICAgIH0pO1xuICAgIHJldHVybiBQb2x5U2VsZWN0VG9vbDtcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgZG9tXzEgPSByZXF1aXJlKFwiY29yZS9kb21cIik7XG5leHBvcnRzLlJlc2l6ZVRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJlc2l6ZVRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSZXNpemVUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFJlc2l6ZVRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay1yZXNpemUtcG9wdXBcIjtcbiAgICBSZXNpemVUb29sVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciB3cmFwcGVyO1xuICAgICAgICBSZXNpemVUb29sVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB3cmFwcGVyID0gdGhpcy5wbG90X3ZpZXcuZWwucXVlcnlTZWxlY3RvcignZGl2LmJrLWNhbnZhcy13cmFwcGVyJyk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIGRvbV8xLmhpZGUodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgZnJhbWUsIGxlZnQsIHRvcDtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF92aWV3LmZyYW1lO1xuICAgICAgICAgICAgbGVmdCA9IGNhbnZhcy52eF90b19zeChmcmFtZS5oX3JhbmdlLmVuZCAtIDQwKTtcbiAgICAgICAgICAgIHRvcCA9IGNhbnZhcy52eV90b19zeShmcmFtZS52X3JhbmdlLnN0YXJ0ICsgNDApO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIGRvbV8xLnNob3codGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21fMS5oaWRlKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHRoaXMuY2ggPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmN3ID0gY2FudmFzLndpZHRoO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlc2l6ZVRvb2xWaWV3LnByb3RvdHlwZS5fcGFuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGUuZGVsdGFYLCBlLmRlbHRhWSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLl9wYW5fZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoXCJyZXNpemVcIiwge1xuICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnBsb3Rfdmlldy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnBsb3Rfdmlldy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzaXplVG9vbFZpZXcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgIHZhciBuZXdfaGVpZ2h0LCBuZXdfd2lkdGg7XG4gICAgICAgIG5ld193aWR0aCA9IHRoaXMuY3cgKyBkeDtcbiAgICAgICAgbmV3X2hlaWdodCA9IHRoaXMuY2ggKyBkeTtcbiAgICAgICAgaWYgKG5ld193aWR0aCA8IDEwMCB8fCBuZXdfaGVpZ2h0IDwgMTAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbG90X3ZpZXcudXBkYXRlX2RpbWVuc2lvbnMobmV3X3dpZHRoLCBuZXdfaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVUb29sVmlldztcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sVmlldyk7XG5leHBvcnRzLlJlc2l6ZVRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVzaXplVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUmVzaXplVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc2l6ZVRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmVzaXplVG9vbFZpZXc7XG4gICAgUmVzaXplVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiUmVzaXplVG9vbFwiO1xuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiUmVzaXplXCI7XG4gICAgUmVzaXplVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXJlc2l6ZVwiO1xuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSBcInBhblwiO1xuICAgIFJlc2l6ZVRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSA0MDtcbiAgICByZXR1cm4gUmVzaXplVG9vbDtcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBnZXN0dXJlX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVfdG9vbFwiKTtcbnZhciBnbHlwaF9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVycy9nbHlwaF9yZW5kZXJlclwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG5leHBvcnRzLlNlbGVjdFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNlbGVjdFRvb2xWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWxlY3RUb29sVmlldy5wcm90b3R5cGUuX2tleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRzLCBqLCBsZW4sIHIsIHJlZiwgcmVzdWx0cywgc207XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHIgPSByZWZbal07XG4gICAgICAgICAgICAgICAgZHMgPSByLmRhdGFfc291cmNlO1xuICAgICAgICAgICAgICAgIHNtID0gZHMuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNtLmNsZWFyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlbGVjdFRvb2xWaWV3LnByb3RvdHlwZS5fc2F2ZV9nZW9tZXRyeSA9IGZ1bmN0aW9uIChnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCkge1xuICAgICAgICB2YXIgZywgZ2VvbXMsIGksIGosIHJlZiwgdG9vbF9ldmVudHMsIHhtLCB5bTtcbiAgICAgICAgZyA9IG9iamVjdF8xLmNsb25lKGdlb21ldHJ5KTtcbiAgICAgICAgeG0gPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS54X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgeW0gPSB0aGlzLnBsb3Rfdmlldy5mcmFtZS55X21hcHBlcnNbJ2RlZmF1bHQnXTtcbiAgICAgICAgc3dpdGNoIChnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgICAgICAgICBnLnggPSB4bS5tYXBfZnJvbV90YXJnZXQoZy52eCk7XG4gICAgICAgICAgICAgICAgZy55ID0geW0ubWFwX2Zyb21fdGFyZ2V0KGcudnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjdCc6XG4gICAgICAgICAgICAgICAgZy54MCA9IHhtLm1hcF9mcm9tX3RhcmdldChnLnZ4MCk7XG4gICAgICAgICAgICAgICAgZy55MCA9IHltLm1hcF9mcm9tX3RhcmdldChnLnZ5MCk7XG4gICAgICAgICAgICAgICAgZy54MSA9IHhtLm1hcF9mcm9tX3RhcmdldChnLnZ4MSk7XG4gICAgICAgICAgICAgICAgZy55MSA9IHltLm1hcF9mcm9tX3RhcmdldChnLnZ5MSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb2x5JzpcbiAgICAgICAgICAgICAgICBnLnggPSBuZXcgQXJyYXkoZy52eC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGcueSA9IG5ldyBBcnJheShnLnZ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGcudngubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgZy54W2ldID0geG0ubWFwX2Zyb21fdGFyZ2V0KGcudnhbaV0pO1xuICAgICAgICAgICAgICAgICAgICBnLnlbaV0gPSB5bS5tYXBfZnJvbV90YXJnZXQoZy52eVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwiVW5yZWNvZ25pemVkIHNlbGVjdGlvbiBnZW9tZXRyeSB0eXBlOiAnXCIgKyBnLnR5cGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICB0b29sX2V2ZW50cyA9IHRoaXMucGxvdF9tb2RlbC5wbG90LnRvb2xfZXZlbnRzO1xuICAgICAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgICAgIGdlb21zID0gdG9vbF9ldmVudHMuZ2VvbWV0cmllcztcbiAgICAgICAgICAgICAgICBnZW9tcy5wdXNoKGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VvbXMgPSBbZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sX2V2ZW50cy5nZW9tZXRyaWVzID0gZ2VvbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0VG9vbFZpZXc7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbFZpZXcpO1xuZXhwb3J0cy5TZWxlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNlbGVjdFRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdFRvb2woKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWxlY3RUb29sLmRlZmluZSh7XG4gICAgICAgIHJlbmRlcmVyczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgbmFtZXM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBTZWxlY3RUb29sLmludGVybmFsKHtcbiAgICAgICAgbXVsdGlfc2VsZWN0X21vZGlmaWVyOiBbcC5TdHJpbmcsIFwic2hpZnRcIl1cbiAgICB9KTtcbiAgICBTZWxlY3RUb29sLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIFNlbGVjdFRvb2wuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGVmaW5lX2NvbXB1dGVkX3Byb3BlcnR5KCdjb21wdXRlZF9yZW5kZXJlcnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWxsX3JlbmRlcmVycywgbmFtZXMsIHIsIHJlbmRlcmVycztcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xuICAgICAgICAgICAgbmFtZXMgPSB0aGlzLm5hbWVzO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbGxfcmVuZGVyZXJzID0gdGhpcy5wbG90LnJlbmRlcmVycztcbiAgICAgICAgICAgICAgICByZW5kZXJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGFsbF9yZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhbGxfcmVuZGVyZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZW5kZXJlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByZW5kZXJlcnNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihyLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLmFkZF9kZXBlbmRlbmNpZXMoJ2NvbXB1dGVkX3JlbmRlcmVycycsIHRoaXMsIFsncmVuZGVyZXJzJywgJ25hbWVzJywgJ3Bsb3QnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9kZXBlbmRlbmNpZXMoJ2NvbXB1dGVkX3JlbmRlcmVycycsIHRoaXMucGxvdCwgWydyZW5kZXJlcnMnXSk7XG4gICAgfTtcbiAgICBTZWxlY3RUb29sLmdldHRlcnMoe1xuICAgICAgICBjb21wdXRlZF9yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29tcHV0ZWQoJ2NvbXB1dGVkX3JlbmRlcmVycycpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFNlbGVjdFRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgc2VsZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdF90b29sXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiY29yZS91dGlsL3R5cGVzXCIpO1xuZXhwb3J0cy5UYXBUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUYXBUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGFwVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUYXBUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFwVG9vbFZpZXcucHJvdG90eXBlLl90YXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYXBwZW5kLCBjYW52YXMsIHJlZiwgdngsIHZ5O1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3Rfdmlldy5jYW52YXM7XG4gICAgICAgIHZ4ID0gY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpO1xuICAgICAgICB2eSA9IGNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KTtcbiAgICAgICAgYXBwZW5kID0gKHJlZiA9IGUuc3JjRXZlbnQuc2hpZnRLZXkpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdCh2eCwgdnksIHRydWUsIGFwcGVuZCk7XG4gICAgfTtcbiAgICBUYXBUb29sVmlldy5wcm90b3R5cGUuX3NlbGVjdCA9IGZ1bmN0aW9uICh2eCwgdnksIGZpbmFsLCBhcHBlbmQpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrLCBjYl9kYXRhLCBkaWRfaGl0LCBkcywgZ2VvbWV0cnksIGksIGxlbiwgciwgcmVmLCBzbSwgdmlldztcbiAgICAgICAgZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgdnk6IHZ5XG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5tb2RlbC5jYWxsYmFjaztcbiAgICAgICAgdGhpcy5fc2F2ZV9nZW9tZXRyeShnZW9tZXRyeSwgZmluYWwsIGFwcGVuZCk7XG4gICAgICAgIGNiX2RhdGEgPSB7XG4gICAgICAgICAgICBnZW9tZXRyaWVzOiB0aGlzLnBsb3RfbW9kZWwucGxvdC50b29sX2V2ZW50cy5nZW9tZXRyaWVzXG4gICAgICAgIH07XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZbaV07XG4gICAgICAgICAgICBkcyA9IHIuZGF0YV9zb3VyY2U7XG4gICAgICAgICAgICBzbSA9IGRzLnNlbGVjdGlvbl9tYW5hZ2VyO1xuICAgICAgICAgICAgdmlldyA9IHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuYmVoYXZpb3IgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBkaWRfaGl0ID0gc20uc2VsZWN0KHRoaXMsIHZpZXcsIGdlb21ldHJ5LCBmaW5hbCwgYXBwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZF9oaXQgPSBzbS5pbnNwZWN0KHRoaXMsIHZpZXcsIGdlb21ldHJ5LCB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZF9oaXQgJiYgKGNhbGxiYWNrICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzXzEuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZHMsIGNiX2RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suZXhlY3V0ZShkcywgY2JfZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmJlaGF2aW9yID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCd0YXAnLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnBsb3Rfdmlldy5nZXRfc2VsZWN0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRhcFRvb2xWaWV3O1xufSkoc2VsZWN0X3Rvb2xfMS5TZWxlY3RUb29sVmlldyk7XG5leHBvcnRzLlRhcFRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGFwVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGFwVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFRhcFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRhcFRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuVGFwVG9vbFZpZXc7XG4gICAgVGFwVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiVGFwVG9vbFwiO1xuICAgIFRhcFRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiVGFwXCI7XG4gICAgVGFwVG9vbC5wcm90b3R5cGUuaWNvbiA9IFwiYmstdG9vbC1pY29uLXRhcC1zZWxlY3RcIjtcbiAgICBUYXBUb29sLnByb3RvdHlwZS5ldmVudF90eXBlID0gXCJ0YXBcIjtcbiAgICBUYXBUb29sLnByb3RvdHlwZS5kZWZhdWx0X29yZGVyID0gMTA7XG4gICAgVGFwVG9vbC5kZWZpbmUoe1xuICAgICAgICBiZWhhdmlvcjogW3AuU3RyaW5nLCBcInNlbGVjdFwiXSxcbiAgICAgICAgY2FsbGJhY2s6IFtwLkFueV1cbiAgICB9KTtcbiAgICByZXR1cm4gVGFwVG9vbDtcbn0pKHNlbGVjdF90b29sXzEuU2VsZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlX3Rvb2xcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLldoZWVsUGFuVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2hlZWxQYW5Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2hlZWxQYW5Ub29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFdoZWVsUGFuVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdoZWVsUGFuVG9vbFZpZXcucHJvdG90eXBlLl9zY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZmFjdG9yO1xuICAgICAgICBmYWN0b3IgPSB0aGlzLm1vZGVsLnNwZWVkICogZS5ib2tlaC5kZWx0YTtcbiAgICAgICAgaWYgKGZhY3RvciA+IDAuOSkge1xuICAgICAgICAgICAgZmFjdG9yID0gMC45O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZhY3RvciA8IC0wLjkpIHtcbiAgICAgICAgICAgIGZhY3RvciA9IC0wLjk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9yYW5nZXMoZmFjdG9yKTtcbiAgICB9O1xuICAgIFdoZWVsUGFuVG9vbFZpZXcucHJvdG90eXBlLl91cGRhdGVfcmFuZ2VzID0gZnVuY3Rpb24gKGZhY3Rvcikge1xuICAgICAgICB2YXIgZW5kLCBmcmFtZSwgaHIsIG1hcHBlciwgbmFtZSwgcGFuX2luZm8sIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgc3RhcnQsIHN4MCwgc3gxLCBzeTAsIHN5MSwgdnIsIHZ4X2hpZ2gsIHZ4X2xvdywgdnhfcmFuZ2UsIHZ5X2hpZ2gsIHZ5X2xvdywgdnlfcmFuZ2UsIHhycywgeXJzO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgaHIgPSBmcmFtZS5oX3JhbmdlO1xuICAgICAgICB2ciA9IGZyYW1lLnZfcmFuZ2U7XG4gICAgICAgIHJlZiA9IFtoci5zdGFydCwgaHIuZW5kXSwgdnhfbG93ID0gcmVmWzBdLCB2eF9oaWdoID0gcmVmWzFdO1xuICAgICAgICByZWYxID0gW3ZyLnN0YXJ0LCB2ci5lbmRdLCB2eV9sb3cgPSByZWYxWzBdLCB2eV9oaWdoID0gcmVmMVsxXTtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLmRpbWVuc2lvbikge1xuICAgICAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgICAgICAgIHZ5X3JhbmdlID0gTWF0aC5hYnModnlfaGlnaCAtIHZ5X2xvdyk7XG4gICAgICAgICAgICAgICAgc3gwID0gdnhfbG93O1xuICAgICAgICAgICAgICAgIHN4MSA9IHZ4X2hpZ2g7XG4gICAgICAgICAgICAgICAgc3kwID0gdnlfbG93ICsgdnlfcmFuZ2UgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgc3kxID0gdnlfaGlnaCArIHZ5X3JhbmdlICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgICAgdnhfcmFuZ2UgPSBNYXRoLmFicyh2eF9oaWdoIC0gdnhfbG93KTtcbiAgICAgICAgICAgICAgICBzeDAgPSB2eF9sb3cgLSB2eF9yYW5nZSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBzeDEgPSB2eF9oaWdoIC0gdnhfcmFuZ2UgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgc3kwID0gdnlfbG93O1xuICAgICAgICAgICAgICAgIHN5MSA9IHZ5X2hpZ2g7XG4gICAgICAgIH1cbiAgICAgICAgeHJzID0ge307XG4gICAgICAgIHJlZjIgPSBmcmFtZS54X21hcHBlcnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBtYXBwZXIgPSByZWYyW25hbWVdO1xuICAgICAgICAgICAgcmVmMyA9IG1hcHBlci52X21hcF9mcm9tX3RhcmdldChbc3gwLCBzeDFdLCB0cnVlKSwgc3RhcnQgPSByZWYzWzBdLCBlbmQgPSByZWYzWzFdO1xuICAgICAgICAgICAgeHJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB5cnMgPSB7fTtcbiAgICAgICAgcmVmNCA9IGZyYW1lLnlfbWFwcGVycztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZjQpIHtcbiAgICAgICAgICAgIG1hcHBlciA9IHJlZjRbbmFtZV07XG4gICAgICAgICAgICByZWY1ID0gbWFwcGVyLnZfbWFwX2Zyb21fdGFyZ2V0KFtzeTAsIHN5MV0sIHRydWUpLCBzdGFydCA9IHJlZjVbMF0sIGVuZCA9IHJlZjVbMV07XG4gICAgICAgICAgICB5cnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHBhbl9pbmZvID0ge1xuICAgICAgICAgICAgeHJzOiB4cnMsXG4gICAgICAgICAgICB5cnM6IHlycyxcbiAgICAgICAgICAgIGZhY3RvcjogZmFjdG9yXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGxvdF92aWV3LnB1c2hfc3RhdGUoJ3doZWVsX3BhbicsIHtcbiAgICAgICAgICAgIHJhbmdlOiBwYW5faW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcudXBkYXRlX3JhbmdlKHBhbl9pbmZvLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucGxvdF92aWV3LmludGVyYWN0aXZlX3RpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFdoZWVsUGFuVG9vbFZpZXc7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbFZpZXcpO1xuZXhwb3J0cy5XaGVlbFBhblRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2hlZWxQYW5Ub29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBXaGVlbFBhblRvb2woKSB7XG4gICAgICAgIHJldHVybiBXaGVlbFBhblRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUudHlwZSA9ICdXaGVlbFBhblRvb2wnO1xuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5XaGVlbFBhblRvb2xWaWV3O1xuICAgIFdoZWVsUGFuVG9vbC5wcm90b3R5cGUudG9vbF9uYW1lID0gXCJXaGVlbCBQYW5cIjtcbiAgICBXaGVlbFBhblRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi13aGVlbC1wYW5cIjtcbiAgICBXaGVlbFBhblRvb2wucHJvdG90eXBlLmV2ZW50X3R5cGUgPSAnc2Nyb2xsJztcbiAgICBXaGVlbFBhblRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSAxMjtcbiAgICBXaGVlbFBhblRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfZGltX3Rvb2x0aXAodGhpcy50b29sX25hbWUsIHRoaXMuZGltZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFdoZWVsUGFuVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb246IFtwLkRpbWVuc2lvbiwgXCJ3aWR0aFwiXVxuICAgIH0pO1xuICAgIFdoZWVsUGFuVG9vbC5pbnRlcm5hbCh7XG4gICAgICAgIHNwZWVkOiBbcC5OdW1iZXIsIDEgLyAxMDAwXVxuICAgIH0pO1xuICAgIHJldHVybiBXaGVlbFBhblRvb2w7XG59KShnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2N1bWVudCwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZV90b29sXCIpO1xudmFyIHpvb21fMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvem9vbVwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICBkb2N1bWVudCA9IHt9O1xufVxuZXhwb3J0cy5XaGVlbFpvb21Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChXaGVlbFpvb21Ub29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2hlZWxab29tVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBXaGVlbFpvb21Ub29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgV2hlZWxab29tVG9vbFZpZXcucHJvdG90eXBlLl9waW5jaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgaWYgKGUuc2NhbGUgPj0gMSkge1xuICAgICAgICAgICAgZGVsdGEgPSAoZS5zY2FsZSAtIDEpICogMjAuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gLTIwLjAgLyBlLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGUuYm9rZWguZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbChlKTtcbiAgICB9O1xuICAgIFdoZWVsWm9vbVRvb2xWaWV3LnByb3RvdHlwZS5fc2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRpbXMsIGZhY3RvciwgZnJhbWUsIGhfYXhpcywgaHIsIHZfYXhpcywgdnIsIHZ4LCB2eSwgem9vbV9pbmZvO1xuICAgICAgICBmcmFtZSA9IHRoaXMucGxvdF9tb2RlbC5mcmFtZTtcbiAgICAgICAgaHIgPSBmcmFtZS5oX3JhbmdlO1xuICAgICAgICB2ciA9IGZyYW1lLnZfcmFuZ2U7XG4gICAgICAgIHZ4ID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzLnN4X3RvX3Z4KGUuYm9rZWguc3gpO1xuICAgICAgICB2eSA9IHRoaXMucGxvdF92aWV3LmNhbnZhcy5zeV90b192eShlLmJva2VoLnN5KTtcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaF9heGlzID0gKGRpbXMgPT09ICd3aWR0aCcgfHwgZGltcyA9PT0gJ2JvdGgnKSAmJiAoaHIubWluIDwgdnggJiYgdnggPCBoci5tYXgpO1xuICAgICAgICB2X2F4aXMgPSAoZGltcyA9PT0gJ2hlaWdodCcgfHwgZGltcyA9PT0gJ2JvdGgnKSAmJiAodnIubWluIDwgdnkgJiYgdnkgPCB2ci5tYXgpO1xuICAgICAgICBmYWN0b3IgPSB0aGlzLm1vZGVsLnNwZWVkICogZS5ib2tlaC5kZWx0YTtcbiAgICAgICAgem9vbV9pbmZvID0gem9vbV8xLnNjYWxlX3JhbmdlKGZyYW1lLCBmYWN0b3IsIGhfYXhpcywgdl9heGlzLCB7XG4gICAgICAgICAgICB4OiB2eCxcbiAgICAgICAgICAgIHk6IHZ5XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5wdXNoX3N0YXRlKCd3aGVlbF96b29tJywge1xuICAgICAgICAgICAgcmFuZ2U6IHpvb21faW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbG90X3ZpZXcudXBkYXRlX3JhbmdlKHpvb21faW5mbywgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLnBsb3Rfdmlldy5pbnRlcmFjdGl2ZV90aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBXaGVlbFpvb21Ub29sVmlldztcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sVmlldyk7XG5leHBvcnRzLldoZWVsWm9vbVRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2hlZWxab29tVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2hlZWxab29tVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFdoZWVsWm9vbVRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdoZWVsWm9vbVRvb2wucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuV2hlZWxab29tVG9vbFZpZXc7XG4gICAgV2hlZWxab29tVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiV2hlZWxab29tVG9vbFwiO1xuICAgIFdoZWVsWm9vbVRvb2wucHJvdG90eXBlLnRvb2xfbmFtZSA9IFwiV2hlZWwgWm9vbVwiO1xuICAgIFdoZWVsWm9vbVRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi13aGVlbC16b29tXCI7XG4gICAgV2hlZWxab29tVG9vbC5wcm90b3R5cGUuZXZlbnRfdHlwZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwID8gJ3BpbmNoJyA6ICdzY3JvbGwnO1xuICAgIFdoZWVsWm9vbVRvb2wucHJvdG90eXBlLmRlZmF1bHRfb3JkZXIgPSAxMDtcbiAgICBXaGVlbFpvb21Ub29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKHRoaXMudG9vbF9uYW1lLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgV2hlZWxab29tVG9vbC5kZWZpbmUoe1xuICAgICAgICBkaW1lbnNpb25zOiBbcC5EaW1lbnNpb25zLCBcImJvdGhcIl1cbiAgICB9KTtcbiAgICBXaGVlbFpvb21Ub29sLmludGVybmFsKHtcbiAgICAgICAgc3BlZWQ6IFtwLk51bWJlciwgMSAvIDYwMF1cbiAgICB9KTtcbiAgICByZXR1cm4gV2hlZWxab29tVG9vbDtcbn0pKGdlc3R1cmVfdG9vbF8xLkdlc3R1cmVUb29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL2FjdGlvbl90b29sXCIpO1xuZXhwb3J0cy5BY3Rpb25Ub29sID0gYWN0aW9uX3Rvb2xfMS5BY3Rpb25Ub29sO1xudmFyIGhlbHBfdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9oZWxwX3Rvb2xcIik7XG5leHBvcnRzLkhlbHBUb29sID0gaGVscF90b29sXzEuSGVscFRvb2w7XG52YXIgcmVkb190b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL3JlZG9fdG9vbFwiKTtcbmV4cG9ydHMuUmVkb1Rvb2wgPSByZWRvX3Rvb2xfMS5SZWRvVG9vbDtcbnZhciByZXNldF90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL3Jlc2V0X3Rvb2xcIik7XG5leHBvcnRzLlJlc2V0VG9vbCA9IHJlc2V0X3Rvb2xfMS5SZXNldFRvb2w7XG52YXIgc2F2ZV90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL3NhdmVfdG9vbFwiKTtcbmV4cG9ydHMuU2F2ZVRvb2wgPSBzYXZlX3Rvb2xfMS5TYXZlVG9vbDtcbnZhciB1bmRvX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvdW5kb190b29sXCIpO1xuZXhwb3J0cy5VbmRvVG9vbCA9IHVuZG9fdG9vbF8xLlVuZG9Ub29sO1xudmFyIHpvb21faW5fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy96b29tX2luX3Rvb2xcIik7XG5leHBvcnRzLlpvb21JblRvb2wgPSB6b29tX2luX3Rvb2xfMS5ab29tSW5Ub29sO1xudmFyIHpvb21fb3V0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvem9vbV9vdXRfdG9vbFwiKTtcbmV4cG9ydHMuWm9vbU91dFRvb2wgPSB6b29tX291dF90b29sXzEuWm9vbU91dFRvb2w7XG52YXIgYnV0dG9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2J1dHRvbl90b29sXCIpO1xuZXhwb3J0cy5CdXR0b25Ub29sID0gYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sO1xudmFyIGJveF9zZWxlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvYm94X3NlbGVjdF90b29sXCIpO1xuZXhwb3J0cy5Cb3hTZWxlY3RUb29sID0gYm94X3NlbGVjdF90b29sXzEuQm94U2VsZWN0VG9vbDtcbnZhciBib3hfem9vbV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9ib3hfem9vbV90b29sXCIpO1xuZXhwb3J0cy5Cb3hab29tVG9vbCA9IGJveF96b29tX3Rvb2xfMS5Cb3hab29tVG9vbDtcbnZhciBnZXN0dXJlX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL2dlc3R1cmVfdG9vbFwiKTtcbmV4cG9ydHMuR2VzdHVyZVRvb2wgPSBnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbDtcbnZhciBsYXNzb19zZWxlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvbGFzc29fc2VsZWN0X3Rvb2xcIik7XG5leHBvcnRzLkxhc3NvU2VsZWN0VG9vbCA9IGxhc3NvX3NlbGVjdF90b29sXzEuTGFzc29TZWxlY3RUb29sO1xudmFyIHBhbl90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9wYW5fdG9vbFwiKTtcbmV4cG9ydHMuUGFuVG9vbCA9IHBhbl90b29sXzEuUGFuVG9vbDtcbnZhciBwb2x5X3NlbGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9wb2x5X3NlbGVjdF90b29sXCIpO1xuZXhwb3J0cy5Qb2x5U2VsZWN0VG9vbCA9IHBvbHlfc2VsZWN0X3Rvb2xfMS5Qb2x5U2VsZWN0VG9vbDtcbnZhciByZXNpemVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvcmVzaXplX3Rvb2xcIik7XG5leHBvcnRzLlJlc2l6ZVRvb2wgPSByZXNpemVfdG9vbF8xLlJlc2l6ZVRvb2w7XG52YXIgc2VsZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2dlc3R1cmVzL3NlbGVjdF90b29sXCIpO1xuZXhwb3J0cy5TZWxlY3RUb29sID0gc2VsZWN0X3Rvb2xfMS5TZWxlY3RUb29sO1xudmFyIHRhcF90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy90YXBfdG9vbFwiKTtcbmV4cG9ydHMuVGFwVG9vbCA9IHRhcF90b29sXzEuVGFwVG9vbDtcbnZhciB3aGVlbF9wYW5fdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvd2hlZWxfcGFuX3Rvb2xcIik7XG5leHBvcnRzLldoZWVsUGFuVG9vbCA9IHdoZWVsX3Bhbl90b29sXzEuV2hlZWxQYW5Ub29sO1xudmFyIHdoZWVsX3pvb21fdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvd2hlZWxfem9vbV90b29sXCIpO1xuZXhwb3J0cy5XaGVlbFpvb21Ub29sID0gd2hlZWxfem9vbV90b29sXzEuV2hlZWxab29tVG9vbDtcbnZhciBjcm9zc2hhaXJfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdG9ycy9jcm9zc2hhaXJfdG9vbFwiKTtcbmV4cG9ydHMuQ3Jvc3NoYWlyVG9vbCA9IGNyb3NzaGFpcl90b29sXzEuQ3Jvc3NoYWlyVG9vbDtcbnZhciBob3Zlcl90b29sXzEgPSByZXF1aXJlKFwiLi9pbnNwZWN0b3JzL2hvdmVyX3Rvb2xcIik7XG5leHBvcnRzLkhvdmVyVG9vbCA9IGhvdmVyX3Rvb2xfMS5Ib3ZlclRvb2w7XG52YXIgaW5zcGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9pbnNwZWN0b3JzL2luc3BlY3RfdG9vbFwiKTtcbmV4cG9ydHMuSW5zcGVjdFRvb2wgPSBpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbDtcbnZhciB0b29sXzEgPSByZXF1aXJlKFwiLi90b29sXCIpO1xuZXhwb3J0cy5Ub29sID0gdG9vbF8xLlRvb2w7XG52YXIgdG9vbF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3Rvb2xfZXZlbnRzXCIpO1xuZXhwb3J0cy5Ub29sRXZlbnRzID0gdG9vbF9ldmVudHNfMS5Ub29sRXZlbnRzO1xudmFyIHRvb2xfcHJveHlfMSA9IHJlcXVpcmUoXCIuL3Rvb2xfcHJveHlcIik7XG5leHBvcnRzLlRvb2xQcm94eSA9IHRvb2xfcHJveHlfMS5Ub29sUHJveHk7XG52YXIgdG9vbGJhcl8xID0gcmVxdWlyZShcIi4vdG9vbGJhclwiKTtcbmV4cG9ydHMuVG9vbGJhciA9IHRvb2xiYXJfMS5Ub29sYmFyO1xudmFyIHRvb2xiYXJfYmFzZV8xID0gcmVxdWlyZShcIi4vdG9vbGJhcl9iYXNlXCIpO1xuZXhwb3J0cy5Ub29sYmFyQmFzZSA9IHRvb2xiYXJfYmFzZV8xLlRvb2xiYXJCYXNlO1xudmFyIHRvb2xiYXJfYm94XzEgPSByZXF1aXJlKFwiLi90b29sYmFyX2JveFwiKTtcbmV4cG9ydHMuVG9vbGJhckJveFRvb2xiYXIgPSB0b29sYmFyX2JveF8xLlRvb2xiYXJCb3hUb29sYmFyO1xudmFyIHRvb2xiYXJfYm94XzIgPSByZXF1aXJlKFwiLi90b29sYmFyX2JveFwiKTtcbmV4cG9ydHMuVG9vbGJhckJveCA9IHRvb2xiYXJfYm94XzIuVG9vbGJhckJveDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbnNwZWN0X3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2luc3BlY3RfdG9vbFwiKTtcbnZhciBzcGFuXzEgPSByZXF1aXJlKFwiLi4vLi4vYW5ub3RhdGlvbnMvc3BhblwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvb2JqZWN0XCIpO1xuZXhwb3J0cy5Dcm9zc2hhaXJUb29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDcm9zc2hhaXJUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ3Jvc3NoYWlyVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDcm9zc2hhaXJUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ3Jvc3NoYWlyVG9vbFZpZXcucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgZnJhbWUsIHZ4LCB2eTtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lID0gdGhpcy5wbG90X21vZGVsLmZyYW1lO1xuICAgICAgICBjYW52YXMgPSB0aGlzLnBsb3RfbW9kZWwuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIGlmICghZnJhbWUuY29udGFpbnModngsIHZ5KSkge1xuICAgICAgICAgICAgdnggPSB2eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZV9zcGFucyh2eCwgdnkpO1xuICAgIH07XG4gICAgQ3Jvc3NoYWlyVG9vbFZpZXcucHJvdG90eXBlLl9tb3ZlX2V4aXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlX3NwYW5zKG51bGwsIG51bGwpO1xuICAgIH07XG4gICAgQ3Jvc3NoYWlyVG9vbFZpZXcucHJvdG90eXBlLl91cGRhdGVfc3BhbnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgZGltcztcbiAgICAgICAgZGltcyA9IHRoaXMubW9kZWwuZGltZW5zaW9ucztcbiAgICAgICAgaWYgKGRpbXMgPT09ICd3aWR0aCcgfHwgZGltcyA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNwYW5zLndpZHRoLmNvbXB1dGVkX2xvY2F0aW9uID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltcyA9PT0gJ2hlaWdodCcgfHwgZGltcyA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zcGFucy5oZWlnaHQuY29tcHV0ZWRfbG9jYXRpb24gPSB4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ3Jvc3NoYWlyVG9vbFZpZXc7XG59KShpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbFZpZXcpO1xuZXhwb3J0cy5Dcm9zc2hhaXJUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENyb3NzaGFpclRvb2wsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENyb3NzaGFpclRvb2woKSB7XG4gICAgICAgIHJldHVybiBDcm9zc2hhaXJUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDcm9zc2hhaXJUb29sLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkNyb3NzaGFpclRvb2xWaWV3O1xuICAgIENyb3NzaGFpclRvb2wucHJvdG90eXBlLnR5cGUgPSBcIkNyb3NzaGFpclRvb2xcIjtcbiAgICBDcm9zc2hhaXJUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIkNyb3NzaGFpclwiO1xuICAgIENyb3NzaGFpclRvb2wucHJvdG90eXBlLmljb24gPSBcImJrLXRvb2wtaWNvbi1jcm9zc2hhaXJcIjtcbiAgICBDcm9zc2hhaXJUb29sLmRlZmluZSh7XG4gICAgICAgIGRpbWVuc2lvbnM6IFtwLkRpbWVuc2lvbnMsIFwiYm90aFwiXSxcbiAgICAgICAgbGluZV9jb2xvcjogW3AuQ29sb3IsICdibGFjayddLFxuICAgICAgICBsaW5lX3dpZHRoOiBbcC5OdW1iZXIsIDFdLFxuICAgICAgICBsaW5lX2FscGhhOiBbcC5OdW1iZXIsIDEuMF1cbiAgICB9KTtcbiAgICBDcm9zc2hhaXJUb29sLmludGVybmFsKHtcbiAgICAgICAgbG9jYXRpb25fdW5pdHM6IFtwLlNwYXRpYWxVbml0cywgXCJzY3JlZW5cIl0sXG4gICAgICAgIHJlbmRlcl9tb2RlOiBbcC5SZW5kZXJNb2RlLCBcImNzc1wiXSxcbiAgICAgICAgc3BhbnM6IFtwLkFueV1cbiAgICB9KTtcbiAgICBDcm9zc2hhaXJUb29sLmdldHRlcnMoe1xuICAgICAgICB0b29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2RpbV90b29sdGlwKFwiQ3Jvc3NoYWlyXCIsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN5bnRoZXRpY19yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RfMS52YWx1ZXModGhpcy5zcGFucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDcm9zc2hhaXJUb29sLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIENyb3NzaGFpclRvb2wuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW5zID0ge1xuICAgICAgICAgICAgd2lkdGg6IG5ldyBzcGFuXzEuU3Bhbih7XG4gICAgICAgICAgICAgICAgZm9yX2hvdmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogXCJ3aWR0aFwiLFxuICAgICAgICAgICAgICAgIHJlbmRlcl9tb2RlOiB0aGlzLnJlbmRlcl9tb2RlLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uX3VuaXRzOiB0aGlzLmxvY2F0aW9uX3VuaXRzLFxuICAgICAgICAgICAgICAgIGxpbmVfY29sb3I6IHRoaXMubGluZV9jb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lX3dpZHRoOiB0aGlzLmxpbmVfd2lkdGgsXG4gICAgICAgICAgICAgICAgbGluZV9hbHBoYTogdGhpcy5saW5lX2FscGhhXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGhlaWdodDogbmV3IHNwYW5fMS5TcGFuKHtcbiAgICAgICAgICAgICAgICBmb3JfaG92ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiBcImhlaWdodFwiLFxuICAgICAgICAgICAgICAgIHJlbmRlcl9tb2RlOiB0aGlzLnJlbmRlcl9tb2RlLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uX3VuaXRzOiB0aGlzLmxvY2F0aW9uX3VuaXRzLFxuICAgICAgICAgICAgICAgIGxpbmVfY29sb3I6IHRoaXMubGluZV9jb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lX3dpZHRoOiB0aGlzLmxpbmVfd2lkdGgsXG4gICAgICAgICAgICAgICAgbGluZV9hbHBoYTogdGhpcy5saW5lX2FscGhhXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENyb3NzaGFpclRvb2w7XG59KShpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfY29sb3JfdG9faGV4LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgaW5zcGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9pbnNwZWN0X3Rvb2xcIik7XG52YXIgdG9vbHRpcF8xID0gcmVxdWlyZShcIi4uLy4uL2Fubm90YXRpb25zL3Rvb2x0aXBcIik7XG52YXIgZ2x5cGhfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlcnMvZ2x5cGhfcmVuZGVyZXJcIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCJjb3JlL2hpdHRlc3RcIik7XG52YXIgdGVtcGxhdGluZ18xID0gcmVxdWlyZShcImNvcmUvdXRpbC90ZW1wbGF0aW5nXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJjb3JlL3V0aWwvdHlwZXNcIik7XG5fY29sb3JfdG9faGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGJsdWUsIGRpZ2l0cywgZ3JlZW4sIHJlZCwgcmdiO1xuICAgIGlmIChjb2xvci5zdWJzdHIoMCwgMSkgPT09ICcjJykge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGRpZ2l0cyA9IC8oLio/KXJnYlxcKChcXGQrKSwgKFxcZCspLCAoXFxkKylcXCkvLmV4ZWMoY29sb3IpO1xuICAgIHJlZCA9IHBhcnNlSW50KGRpZ2l0c1syXSk7XG4gICAgZ3JlZW4gPSBwYXJzZUludChkaWdpdHNbM10pO1xuICAgIGJsdWUgPSBwYXJzZUludChkaWdpdHNbNF0pO1xuICAgIHJnYiA9IGJsdWUgfCAoZ3JlZW4gPDwgOCkgfCAocmVkIDw8IDE2KTtcbiAgICByZXR1cm4gZGlnaXRzWzFdICsgJyMnICsgcmdiLnRvU3RyaW5nKDE2KTtcbn07XG5leHBvcnRzLkhvdmVyVG9vbFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSG92ZXJUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSG92ZXJUb29sVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEhvdmVyVG9vbFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLmJpbmRfYm9rZWhfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaywgbGVuLCByLCByZWY7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZba107XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHIuZGF0YV9zb3VyY2UsICdpbnNwZWN0JywgdGhpcy5fdXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcuY2FudmFzX3ZpZXcuZWwuc3R5bGUuY3Vyc29yID0gXCJjcm9zc2hhaXJcIjtcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVzdWx0cywgcmlkLCB0dDtcbiAgICAgICAgdGhpcy5faW5zcGVjdCgyZTMwOCwgMmUzMDgpO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLnR0bW9kZWxzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAocmlkIGluIHJlZikge1xuICAgICAgICAgICAgdHQgPSByZWZbcmlkXTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0dC5jbGVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNhbnZhcywgdngsIHZ5O1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X3ZpZXcuY2FudmFzO1xuICAgICAgICB2eCA9IGNhbnZhcy5zeF90b192eChlLmJva2VoLnN4KTtcbiAgICAgICAgdnkgPSBjYW52YXMuc3lfdG9fdnkoZS5ib2tlaC5zeSk7XG4gICAgICAgIGlmICghdGhpcy5wbG90X3ZpZXcuZnJhbWUuY29udGFpbnModngsIHZ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zcGVjdCh2eCwgdnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fbW92ZV9leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXIoKTtcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9pbnNwZWN0ID0gZnVuY3Rpb24gKHZ4LCB2eSwgZSkge1xuICAgICAgICB2YXIgZ2VvbWV0cnksIGhvdmVyZWRfaW5kZXhlcywgaG92ZXJlZF9yZW5kZXJlcnMsIGssIGxlbiwgciwgcmVmLCBzbTtcbiAgICAgICAgZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgdng6IHZ4LFxuICAgICAgICAgICAgdnk6IHZ5XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm1vZGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5Wyd0eXBlJ10gPSAncG9pbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VvbWV0cnlbJ3R5cGUnXSA9ICdzcGFuJztcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm1vZGUgPT09ICd2bGluZScpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5kaXJlY3Rpb24gPSAnaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5kaXJlY3Rpb24gPSAndic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaG92ZXJlZF9pbmRleGVzID0gW107XG4gICAgICAgIGhvdmVyZWRfcmVuZGVyZXJzID0gW107XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwuY29tcHV0ZWRfcmVuZGVyZXJzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHIgPSByZWZba107XG4gICAgICAgICAgICBzbSA9IHIuZGF0YV9zb3VyY2Uuc2VsZWN0aW9uX21hbmFnZXI7XG4gICAgICAgICAgICBzbS5pbnNwZWN0KHRoaXMsIHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdLCBnZW9tZXRyeSwge1xuICAgICAgICAgICAgICAgIFwiZ2VvbWV0cnlcIjogZ2VvbWV0cnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRfY2FsbGJhY2soZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIb3ZlclRvb2xWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGluZGljZXMsIHRvb2wsIHJlbmRlcmVyLCBkcywgYXJnKSB7XG4gICAgICAgIHZhciBjYW52YXMsIGQxeCwgZDF5LCBkMngsIGQyeSwgZGF0YV94LCBkYXRhX3ksIGRpc3QxLCBkaXN0MiwgZnJhbWUsIGdlb21ldHJ5LCBpLCBqLCBrLCBsLCBsZW4sIGxlbjEsIHB0LCByZWYsIHJlZjEsIHJlZjEwLCByZWYxMSwgcmVmMTIsIHJlZjEzLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3LCByZWY4LCByZWY5LCByeCwgcnksIHNkYXRheCwgc2RhdGF5LCBzeCwgc3ksIHRvb2x0aXAsIHZhcnMsIHZ4LCB2eSwgeCwgeG1hcHBlciwgeSwgeW1hcHBlcjtcbiAgICAgICAgZ2VvbWV0cnkgPSBhcmcuZ2VvbWV0cnk7XG4gICAgICAgIHRvb2x0aXAgPSAocmVmID0gdGhpcy5tb2RlbC50dG1vZGVsc1tyZW5kZXJlci5tb2RlbC5pZF0pICE9IG51bGwgPyByZWYgOiBudWxsO1xuICAgICAgICBpZiAodG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcC5jbGVhcigpO1xuICAgICAgICBpZiAoaW5kaWNlc1snMGQnXS5nbHlwaCA9PT0gbnVsbCAmJiBpbmRpY2VzWycxZCddLmluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdnggPSBnZW9tZXRyeS52eDtcbiAgICAgICAgdnkgPSBnZW9tZXRyeS52eTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIHN4ID0gY2FudmFzLnZ4X3RvX3N4KHZ4KTtcbiAgICAgICAgc3kgPSBjYW52YXMudnlfdG9fc3kodnkpO1xuICAgICAgICB4bWFwcGVyID0gZnJhbWUueF9tYXBwZXJzW3JlbmRlcmVyLm1vZGVsLnhfcmFuZ2VfbmFtZV07XG4gICAgICAgIHltYXBwZXIgPSBmcmFtZS55X21hcHBlcnNbcmVuZGVyZXIubW9kZWwueV9yYW5nZV9uYW1lXTtcbiAgICAgICAgeCA9IHhtYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ4KTtcbiAgICAgICAgeSA9IHltYXBwZXIubWFwX2Zyb21fdGFyZ2V0KHZ5KTtcbiAgICAgICAgcmVmMSA9IGluZGljZXNbJzBkJ10uaW5kaWNlcztcbiAgICAgICAgZm9yIChrID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaSA9IHJlZjFba107XG4gICAgICAgICAgICBkYXRhX3ggPSByZW5kZXJlci5nbHlwaC5feFtpICsgMV07XG4gICAgICAgICAgICBkYXRhX3kgPSByZW5kZXJlci5nbHlwaC5feVtpICsgMV07XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwubGluZV9wb2xpY3kpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlZjIgPSByZW5kZXJlci5nbHlwaC5nZXRfaW50ZXJwb2xhdGlvbl9oaXQoaSwgZ2VvbWV0cnkpLCBkYXRhX3ggPSByZWYyWzBdLCBkYXRhX3kgPSByZWYyWzFdO1xuICAgICAgICAgICAgICAgICAgICByeCA9IHhtYXBwZXIubWFwX3RvX3RhcmdldChkYXRhX3gpO1xuICAgICAgICAgICAgICAgICAgICByeSA9IHltYXBwZXIubWFwX3RvX3RhcmdldChkYXRhX3kpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJldlwiOlxuICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChyZW5kZXJlci5nbHlwaC5zeFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gY2FudmFzLnN5X3RvX3Z5KHJlbmRlcmVyLmdseXBoLnN5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcnggPSBjYW52YXMuc3hfdG9fdngocmVuZGVyZXIuZ2x5cGguc3hbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBjYW52YXMuc3lfdG9fdnkocmVuZGVyZXIuZ2x5cGguc3lbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZDF4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaV07XG4gICAgICAgICAgICAgICAgICAgIGQxeSA9IHJlbmRlcmVyLmdseXBoLnN5W2ldO1xuICAgICAgICAgICAgICAgICAgICBkaXN0MSA9IGhpdHRlc3QuZGlzdF8yX3B0cyhkMXgsIGQxeSwgc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgZDJ4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBkMnkgPSByZW5kZXJlci5nbHlwaC5zeVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGRpc3QyID0gaGl0dGVzdC5kaXN0XzJfcHRzKGQyeCwgZDJ5LCBzeCwgc3kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdDEgPCBkaXN0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmMyA9IFtkMXgsIGQxeV0sIHNkYXRheCA9IHJlZjNbMF0sIHNkYXRheSA9IHJlZjNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY0ID0gW2QyeCwgZDJ5XSwgc2RhdGF4ID0gcmVmNFswXSwgc2RhdGF5ID0gcmVmNFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhX3ggPSByZW5kZXJlci5nbHlwaC5feFtpXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV95ID0gcmVuZGVyZXIuZ2x5cGguX3lbaV07XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gY2FudmFzLnN4X3RvX3Z4KHNkYXRheCk7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gY2FudmFzLnN5X3RvX3Z5KHNkYXRheSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlZjUgPSBbdngsIHZ5XSwgcnggPSByZWY1WzBdLCByeSA9IHJlZjVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJzID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB2eDogdngsXG4gICAgICAgICAgICAgICAgdnk6IHZ5LFxuICAgICAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICAgICAgZGF0YV94OiBkYXRhX3gsXG4gICAgICAgICAgICAgICAgZGF0YV95OiBkYXRhX3ksXG4gICAgICAgICAgICAgICAgcng6IHJ4LFxuICAgICAgICAgICAgICAgIHJ5OiByeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRvb2x0aXAuYWRkKHJ4LCByeSwgdGhpcy5fcmVuZGVyX3Rvb2x0aXBzKGRzLCBpLCB2YXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmNiA9IGluZGljZXNbJzFkJ10uaW5kaWNlcztcbiAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHJlZjYubGVuZ3RoOyBsIDwgbGVuMTsgbCsrKSB7XG4gICAgICAgICAgICBpID0gcmVmNltsXTtcbiAgICAgICAgICAgIGlmICghb2JqZWN0XzEuaXNFbXB0eShpbmRpY2VzWycyZCddLmluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVmNyA9IGluZGljZXNbJzJkJ10uaW5kaWNlcztcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcmVmNykge1xuICAgICAgICAgICAgICAgICAgICBqID0gcmVmN1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV94ID0gcmVuZGVyZXIuZ2x5cGguX3hzW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhX3kgPSByZW5kZXJlci5nbHlwaC5feXNbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5saW5lX3BvbGljeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVycFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjggPSByZW5kZXJlci5nbHlwaC5nZXRfaW50ZXJwb2xhdGlvbl9oaXQoaSwgaiwgZ2VvbWV0cnkpLCBkYXRhX3ggPSByZWY4WzBdLCBkYXRhX3kgPSByZWY4WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0geG1hcHBlci5tYXBfdG9fdGFyZ2V0KGRhdGFfeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSB5bWFwcGVyLm1hcF90b190YXJnZXQoZGF0YV95KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmV2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBjYW52YXMuc3hfdG9fdngocmVuZGVyZXIuZ2x5cGguc3hzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShyZW5kZXJlci5nbHlwaC5zeXNbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeCA9IGNhbnZhcy5zeF90b192eChyZW5kZXJlci5nbHlwaC5zeHNbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShyZW5kZXJlci5nbHlwaC5zeXNbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDF4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDF5ID0gcmVuZGVyZXIuZ2x5cGguc3lbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdDEgPSBoaXR0ZXN0LmRpc3RfMl9wdHMoZDF4LCBkMXksIHN4LCBzeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDJ4ID0gcmVuZGVyZXIuZ2x5cGguc3hbaV1baiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyeSA9IHJlbmRlcmVyLmdseXBoLnN5W2ldW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0MiA9IGhpdHRlc3QuZGlzdF8yX3B0cyhkMngsIGQyeSwgc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdDEgPCBkaXN0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY5ID0gW2QxeCwgZDF5XSwgc2RhdGF4ID0gcmVmOVswXSwgc2RhdGF5ID0gcmVmOVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjEwID0gW2QyeCwgZDJ5XSwgc2RhdGF4ID0gcmVmMTBbMF0sIHNkYXRheSA9IHJlZjEwWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfeCA9IHJlbmRlcmVyLmdseXBoLl94W2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfeSA9IHJlbmRlcmVyLmdseXBoLl95W2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gY2FudmFzLnN4X3RvX3Z4KHNkYXRheCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBjYW52YXMuc3lfdG9fdnkoc2RhdGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50X2luZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICB2eDogdngsXG4gICAgICAgICAgICAgICAgICAgICAgICB2eTogdnksXG4gICAgICAgICAgICAgICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3g6IGRhdGFfeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfeTogZGF0YV95XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkKHJ4LCByeSwgdGhpcy5fcmVuZGVyX3Rvb2x0aXBzKGRzLCBpLCB2YXJzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YV94ID0gKHJlZjExID0gcmVuZGVyZXIuZ2x5cGguX3gpICE9IG51bGwgPyByZWYxMVtpXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkYXRhX3kgPSAocmVmMTIgPSByZW5kZXJlci5nbHlwaC5feSkgIT0gbnVsbCA/IHJlZjEyW2ldIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnBvaW50X3BvbGljeSA9PT0gJ3NuYXBfdG9fZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHQgPSByZW5kZXJlci5nbHlwaC5nZXRfYW5jaG9yX3BvaW50KHRoaXMubW9kZWwuYW5jaG9yLCBpLCBbc3gsIHN5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdCA9IHJlbmRlcmVyLmdseXBoLmdldF9hbmNob3JfcG9pbnQoXCJjZW50ZXJcIiwgaSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gY2FudmFzLnN4X3RvX3Z4KHB0LngpO1xuICAgICAgICAgICAgICAgICAgICByeSA9IGNhbnZhcy5zeV90b192eShwdC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjEzID0gW3Z4LCB2eV0sIHJ4ID0gcmVmMTNbMF0sIHJ5ID0gcmVmMTNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICB2eDogdngsXG4gICAgICAgICAgICAgICAgICAgIHZ5OiB2eSxcbiAgICAgICAgICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgICAgICAgICBzeTogc3ksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFfeDogZGF0YV94LFxuICAgICAgICAgICAgICAgICAgICBkYXRhX3k6IGRhdGFfeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5hZGQocngsIHJ5LCB0aGlzLl9yZW5kZXJfdG9vbHRpcHMoZHMsIGksIHZhcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEhvdmVyVG9vbFZpZXcucHJvdG90eXBlLl9lbWl0X2NhbGxiYWNrID0gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIHZhciBjYWxsYmFjaywgY2FudmFzLCBkYXRhLCBmcmFtZSwgaW5kaWNlcywgb2JqLCByLCByZWYsIHhtYXBwZXIsIHltYXBwZXI7XG4gICAgICAgIHIgPSB0aGlzLm1vZGVsLmNvbXB1dGVkX3JlbmRlcmVyc1swXTtcbiAgICAgICAgaW5kaWNlcyA9IHRoaXMucGxvdF92aWV3LnJlbmRlcmVyX3ZpZXdzW3IuaWRdLmhpdF90ZXN0KGdlb21ldHJ5KTtcbiAgICAgICAgY2FudmFzID0gdGhpcy5wbG90X21vZGVsLmNhbnZhcztcbiAgICAgICAgZnJhbWUgPSB0aGlzLnBsb3RfbW9kZWwuZnJhbWU7XG4gICAgICAgIGdlb21ldHJ5WydzeCddID0gY2FudmFzLnZ4X3RvX3N4KGdlb21ldHJ5LnZ4KTtcbiAgICAgICAgZ2VvbWV0cnlbJ3N5J10gPSBjYW52YXMudnlfdG9fc3koZ2VvbWV0cnkudnkpO1xuICAgICAgICB4bWFwcGVyID0gZnJhbWUueF9tYXBwZXJzW3IueF9yYW5nZV9uYW1lXTtcbiAgICAgICAgeW1hcHBlciA9IGZyYW1lLnlfbWFwcGVyc1tyLnlfcmFuZ2VfbmFtZV07XG4gICAgICAgIGdlb21ldHJ5Wyd4J10gPSB4bWFwcGVyLm1hcF9mcm9tX3RhcmdldChnZW9tZXRyeS52eCk7XG4gICAgICAgIGdlb21ldHJ5Wyd5J10gPSB5bWFwcGVyLm1hcF9mcm9tX3RhcmdldChnZW9tZXRyeS52eSk7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5tb2RlbC5jYWxsYmFjaztcbiAgICAgICAgcmVmID0gW1xuICAgICAgICAgICAgY2FsbGJhY2ssIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kaWNlcyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSwgb2JqID0gcmVmWzBdLCBkYXRhID0gcmVmWzFdO1xuICAgICAgICBpZiAodHlwZXNfMS5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sob2JqLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmV4ZWN1dGUob2JqLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSG92ZXJUb29sVmlldy5wcm90b3R5cGUuX3JlbmRlcl90b29sdGlwcyA9IGZ1bmN0aW9uIChkcywgaSwgdmFycykge1xuICAgICAgICB2YXIgY2VsbCwgY29sbmFtZSwgY29sb3IsIGNvbHVtbiwgZWwsIGhleCwgaywgbGFiZWwsIGxlbiwgbWF0Y2gsIG9wdHMsIHJlZiwgcmVmMSwgcm93LCByb3dzLCBzd2F0Y2gsIHRvb2x0aXBzLCB2YWx1ZTtcbiAgICAgICAgdG9vbHRpcHMgPSB0aGlzLm1vZGVsLnRvb2x0aXBzO1xuICAgICAgICBpZiAodHlwZXNfMS5pc1N0cmluZyh0b29sdGlwcykpIHtcbiAgICAgICAgICAgIGVsID0gZG9tXzEuZGl2KCk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB0ZW1wbGF0aW5nXzEucmVwbGFjZV9wbGFjZWhvbGRlcnModG9vbHRpcHMsIGRzLCBpLCB2YXJzKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlc18xLmlzRnVuY3Rpb24odG9vbHRpcHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9vbHRpcHMoZHMsIHZhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93cyA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJ0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJTcGFjaW5nOiBcIjJweFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSB0b29sdGlwcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHJlZiA9IHRvb2x0aXBzW2tdLCBsYWJlbCA9IHJlZlswXSwgdmFsdWUgPSByZWZbMV07XG4gICAgICAgICAgICAgICAgcm93ID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGUtcm93XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvd3MuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICAgICBjZWxsID0gZG9tXzEuZGl2KHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwidGFibGUtY2VsbFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogJ2JrLXRvb2x0aXAtcm93LWxhYmVsJ1xuICAgICAgICAgICAgICAgIH0sIGxhYmVsICsgXCI6IFwiKTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgICAgICAgICAgY2VsbCA9IGRvbV8xLmRpdih7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcInRhYmxlLWNlbGxcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6ICdiay10b29sdGlwLXJvdy12YWx1ZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCIkY29sb3JcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWYxID0gdmFsdWUubWF0Y2goL1xcJGNvbG9yKFxcWy4qXFxdKT86KFxcdyopLyksIG1hdGNoID0gcmVmMVswXSwgb3B0cyA9IHJlZjFbMV0sIGNvbG5hbWUgPSByZWYxWzJdO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBkcy5nZXRfY29sdW1uKGNvbG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9tXzEuc3Bhbih7fSwgY29sbmFtZSArIFwiIHVua25vd25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhleCA9IChvcHRzICE9IG51bGwgPyBvcHRzLmluZGV4T2YoXCJoZXhcIikgOiB2b2lkIDApID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHN3YXRjaCA9IChvcHRzICE9IG51bGwgPyBvcHRzLmluZGV4T2YoXCJzd2F0Y2hcIikgOiB2b2lkIDApID49IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sdW1uW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb21fMS5zcGFuKHt9LCBcIihudWxsKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfY29sb3JfdG9faGV4KGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbCA9IGRvbV8xLnNwYW4oe30sIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9tXzEuc3Bhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiAnYmstdG9vbHRpcC1jb2xvci1ibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCIkflwiLCBcIiRkYXRhX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBkb21fMS5zcGFuKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHRlbXBsYXRpbmdfMS5yZXBsYWNlX3BsYWNlaG9sZGVycyh2YWx1ZSwgZHMsIGksIHZhcnMpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEhvdmVyVG9vbFZpZXc7XG59KShpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbFZpZXcpO1xuZXhwb3J0cy5Ib3ZlclRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSG92ZXJUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBIb3ZlclRvb2woKSB7XG4gICAgICAgIHJldHVybiBIb3ZlclRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEhvdmVyVG9vbC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Ib3ZlclRvb2xWaWV3O1xuICAgIEhvdmVyVG9vbC5wcm90b3R5cGUudHlwZSA9IFwiSG92ZXJUb29sXCI7XG4gICAgSG92ZXJUb29sLnByb3RvdHlwZS50b29sX25hbWUgPSBcIkhvdmVyXCI7XG4gICAgSG92ZXJUb29sLnByb3RvdHlwZS5pY29uID0gXCJiay10b29sLWljb24taG92ZXJcIjtcbiAgICBIb3ZlclRvb2wuZGVmaW5lKHtcbiAgICAgICAgdG9vbHRpcHM6IFtwLkFueSwgW1tcImluZGV4XCIsIFwiJGluZGV4XCJdLCBbXCJkYXRhICh4LCB5KVwiLCBcIigkeCwgJHkpXCJdLCBbXCJjYW52YXMgKHgsIHkpXCIsIFwiKCRzeCwgJHN5KVwiXV1dLFxuICAgICAgICByZW5kZXJlcnM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIG5hbWVzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBtb2RlOiBbcC5TdHJpbmcsICdtb3VzZSddLFxuICAgICAgICBwb2ludF9wb2xpY3k6IFtwLlN0cmluZywgJ3NuYXBfdG9fZGF0YSddLFxuICAgICAgICBsaW5lX3BvbGljeTogW3AuU3RyaW5nLCAnbmVhcmVzdCddLFxuICAgICAgICBzaG93X2Fycm93OiBbcC5Cb29sZWFuLCB0cnVlXSxcbiAgICAgICAgYW5jaG9yOiBbcC5TdHJpbmcsICdjZW50ZXInXSxcbiAgICAgICAgYXR0YWNobWVudDogW3AuU3RyaW5nLCAnaG9yaXpvbnRhbCddLFxuICAgICAgICBjYWxsYmFjazogW3AuQW55XVxuICAgIH0pO1xuICAgIEhvdmVyVG9vbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBIb3ZlclRvb2wuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGVmaW5lX2NvbXB1dGVkX3Byb3BlcnR5KCdjb21wdXRlZF9yZW5kZXJlcnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWxsX3JlbmRlcmVycywgbmFtZXMsIHIsIHJlbmRlcmVycztcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHRoaXMucmVuZGVyZXJzO1xuICAgICAgICAgICAgbmFtZXMgPSB0aGlzLm5hbWVzO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbGxfcmVuZGVyZXJzID0gdGhpcy5wbG90LnJlbmRlcmVycztcbiAgICAgICAgICAgICAgICByZW5kZXJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaywgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbiA9IGFsbF9yZW5kZXJlcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhbGxfcmVuZGVyZXJzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBnbHlwaF9yZW5kZXJlcl8xLkdseXBoUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGssIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZW5kZXJlcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByZW5kZXJlcnNba107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihyLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLmFkZF9kZXBlbmRlbmNpZXMoJ2NvbXB1dGVkX3JlbmRlcmVycycsIHRoaXMsIFsncmVuZGVyZXJzJywgJ25hbWVzJywgJ3Bsb3QnXSk7XG4gICAgICAgIHRoaXMuYWRkX2RlcGVuZGVuY2llcygnY29tcHV0ZWRfcmVuZGVyZXJzJywgdGhpcy5wbG90LCBbJ3JlbmRlcmVycyddKTtcbiAgICAgICAgdGhpcy5kZWZpbmVfY29tcHV0ZWRfcHJvcGVydHkoJ3R0bW9kZWxzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGssIGxlbiwgciwgcmVmLCB0b29sdGlwLCB0b29sdGlwcywgdHRtb2RlbHM7XG4gICAgICAgICAgICB0dG1vZGVscyA9IHt9O1xuICAgICAgICAgICAgdG9vbHRpcHMgPSB0aGlzLnRvb2x0aXBzO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLmNvbXB1dGVkX3JlbmRlcmVycztcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJlZltrXTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9IG5ldyB0b29sdGlwXzEuVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b206IHR5cGVzXzEuaXNTdHJpbmcodG9vbHRpcHMpIHx8IHR5cGVzXzEuaXNGdW5jdGlvbih0b29sdGlwcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50OiB0aGlzLmF0dGFjaG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93X2Fycm93OiB0aGlzLnNob3dfYXJyb3dcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHR0bW9kZWxzW3IuaWRdID0gdG9vbHRpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHRtb2RlbHM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfZGVwZW5kZW5jaWVzKCd0dG1vZGVscycsIHRoaXMsIFsnY29tcHV0ZWRfcmVuZGVyZXJzJywgJ3Rvb2x0aXBzJ10pO1xuICAgIH07XG4gICAgSG92ZXJUb29sLmdldHRlcnMoe1xuICAgICAgICBjb21wdXRlZF9yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29tcHV0ZWQoJ2NvbXB1dGVkX3JlbmRlcmVycycpO1xuICAgICAgICB9LFxuICAgICAgICB0dG1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb21wdXRlZCgndHRtb2RlbHMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3ludGhldGljX3JlbmRlcmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF8xLnZhbHVlcyh0aGlzLnR0bW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBIb3ZlclRvb2w7XG59KShpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgYnV0dG9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuLi9idXR0b25fdG9vbFwiKTtcbmV4cG9ydHMuSW5zcGVjdFRvb2xWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEluc3BlY3RUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW5zcGVjdFRvb2xWaWV3KCkge1xuICAgICAgICByZXR1cm4gSW5zcGVjdFRvb2xWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gSW5zcGVjdFRvb2xWaWV3O1xufSkoYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sVmlldyk7XG5leHBvcnRzLkluc3BlY3RUb29sID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEluc3BlY3RUb29sLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbnNwZWN0VG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIEluc3BlY3RUb29sLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbnNwZWN0VG9vbC5wcm90b3R5cGUuZXZlbnRfdHlwZSA9IFwibW92ZVwiO1xuICAgIEluc3BlY3RUb29sLm92ZXJyaWRlKHtcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEluc3BlY3RUb29sO1xufSkoYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBidXR0b25fdG9vbF8xID0gcmVxdWlyZShcIi4vYnV0dG9uX3Rvb2xcIik7XG5leHBvcnRzLk9uT2ZmQnV0dG9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChPbk9mZkJ1dHRvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE9uT2ZmQnV0dG9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIE9uT2ZmQnV0dG9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgT25PZmZCdXR0b25WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9uT2ZmQnV0dG9uVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnYmstYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdiay1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT25PZmZCdXR0b25WaWV3LnByb3RvdHlwZS5fY2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZTtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFjdGl2ZSA9ICFhY3RpdmU7XG4gICAgfTtcbiAgICByZXR1cm4gT25PZmZCdXR0b25WaWV3O1xufSkoYnV0dG9uX3Rvb2xfMS5CdXR0b25Ub29sQnV0dG9uVmlldyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYm9rZWhfdmlld18xID0gcmVxdWlyZShcImNvcmUvYm9rZWhfdmlld1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5Ub29sVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUb29sVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9vbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBUb29sVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcgPSBvcHRpb25zLnBsb3RfdmlldztcbiAgICB9O1xuICAgIFRvb2xWaWV3LmdldHRlcnMoe1xuICAgICAgICBwbG90X21vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbG90X3ZpZXcubW9kZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBUb29sVmlldy5wcm90b3R5cGUuYmluZF9ib2tlaF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6YWN0aXZlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgfTtcbiAgICBUb29sVmlldy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVG9vbFZpZXcucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFRvb2xWaWV3O1xufSkoYm9rZWhfdmlld18xLkJva2VoVmlldyk7XG5leHBvcnRzLlRvb2wgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbCgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2wuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2wuZ2V0dGVycyh7XG4gICAgICAgIHN5bnRoZXRpY19yZW5kZXJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFRvb2wuZGVmaW5lKHtcbiAgICAgICAgcGxvdDogW3AuSW5zdGFuY2VdXG4gICAgfSk7XG4gICAgVG9vbC5pbnRlcm5hbCh7XG4gICAgICAgIGFjdGl2ZTogW3AuQm9vbGVhbiwgZmFsc2VdXG4gICAgfSk7XG4gICAgVG9vbC5wcm90b3R5cGUuX2dldF9kaW1fdG9vbHRpcCA9IGZ1bmN0aW9uIChuYW1lLCBkaW1zKSB7XG4gICAgICAgIHN3aXRjaCAoZGltcykge1xuICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCIgKHgtYXhpcylcIjtcbiAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiAoeS1heGlzKVwiO1xuICAgICAgICAgICAgY2FzZSAnYm90aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2wucHJvdG90eXBlLl9nZXRfZGltX2xpbWl0cyA9IGZ1bmN0aW9uIChhcmcsIGFyZzEsIGZyYW1lLCBkaW1zKSB7XG4gICAgICAgIHZhciBociwgdnIsIHZ4MCwgdngxLCB2eGxpbSwgdnkwLCB2eTEsIHZ5bGltO1xuICAgICAgICB2eDAgPSBhcmdbMF0sIHZ5MCA9IGFyZ1sxXTtcbiAgICAgICAgdngxID0gYXJnMVswXSwgdnkxID0gYXJnMVsxXTtcbiAgICAgICAgaHIgPSBmcmFtZS5oX3JhbmdlO1xuICAgICAgICBpZiAoZGltcyA9PT0gJ3dpZHRoJyB8fCBkaW1zID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHZ4bGltID0gW2FycmF5XzEubWluKFt2eDAsIHZ4MV0pLCBhcnJheV8xLm1heChbdngwLCB2eDFdKV07XG4gICAgICAgICAgICB2eGxpbSA9IFthcnJheV8xLm1heChbdnhsaW1bMF0sIGhyLm1pbl0pLCBhcnJheV8xLm1pbihbdnhsaW1bMV0sIGhyLm1heF0pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ4bGltID0gW2hyLm1pbiwgaHIubWF4XTtcbiAgICAgICAgfVxuICAgICAgICB2ciA9IGZyYW1lLnZfcmFuZ2U7XG4gICAgICAgIGlmIChkaW1zID09PSAnaGVpZ2h0JyB8fCBkaW1zID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHZ5bGltID0gW2FycmF5XzEubWluKFt2eTAsIHZ5MV0pLCBhcnJheV8xLm1heChbdnkwLCB2eTFdKV07XG4gICAgICAgICAgICB2eWxpbSA9IFthcnJheV8xLm1heChbdnlsaW1bMF0sIHZyLm1pbl0pLCBhcnJheV8xLm1pbihbdnlsaW1bMV0sIHZyLm1heF0pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZ5bGltID0gW3ZyLm1pbiwgdnIubWF4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Z4bGltLCB2eWxpbV07XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbDtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG52YXIgcCA9IHJlcXVpcmUoXCJjb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLlRvb2xFdmVudHMgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbEV2ZW50cywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbEV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIFRvb2xFdmVudHMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xFdmVudHMucHJvdG90eXBlLnR5cGUgPSAnVG9vbEV2ZW50cyc7XG4gICAgVG9vbEV2ZW50cy5kZWZpbmUoe1xuICAgICAgICBnZW9tZXRyaWVzOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIFRvb2xFdmVudHM7XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5Ub29sUHJveHkgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbFByb3h5LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sUHJveHkoKSB7XG4gICAgICAgIHJldHVybiBUb29sUHJveHkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xQcm94eS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFRvb2xQcm94eS5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdkbycsIHRoaXNbXCJkb1wiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6YWN0aXZlJywgdGhpcy5zZXRfYWN0aXZlKTtcbiAgICB9O1xuICAgIFRvb2xQcm94eS5wcm90b3R5cGVbXCJkb1wiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgcmVmLCB0b29sO1xuICAgICAgICByZWYgPSB0aGlzLnRvb2xzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICB0b29sLnRyaWdnZXIoJ2RvJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUb29sUHJveHkucHJvdG90eXBlLnNldF9hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHJlZiwgdG9vbDtcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgdG9vbC5hY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRvb2xQcm94eS5kZWZpbmUoe1xuICAgICAgICB0b29sczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYWN0aXZlOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIHRvb2x0aXA6IFtwLlN0cmluZ10sXG4gICAgICAgIHRvb2xfbmFtZTogW3AuU3RyaW5nXSxcbiAgICAgICAgZGlzYWJsZWQ6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgZXZlbnRfdHlwZTogW3AuU3RyaW5nXSxcbiAgICAgICAgaWNvbjogW3AuU3RyaW5nXVxuICAgIH0pO1xuICAgIFRvb2xQcm94eS5wcm90b3R5cGUuX2NsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmU7XG4gICAgICAgIGFjdGl2ZSA9IHRoaXMubW9kZWwuYWN0aXZlO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hY3RpdmUgPSAhYWN0aXZlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xQcm94eTtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGFjdGlvbl90b29sXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25zL2FjdGlvbl90b29sXCIpO1xudmFyIGhlbHBfdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9oZWxwX3Rvb2xcIik7XG52YXIgZ2VzdHVyZV90b29sXzEgPSByZXF1aXJlKFwiLi9nZXN0dXJlcy9nZXN0dXJlX3Rvb2xcIik7XG52YXIgaW5zcGVjdF90b29sXzEgPSByZXF1aXJlKFwiLi9pbnNwZWN0b3JzL2luc3BlY3RfdG9vbFwiKTtcbnZhciB0b29sYmFyX2Jhc2VfMSA9IHJlcXVpcmUoXCIuL3Rvb2xiYXJfYmFzZVwiKTtcbmV4cG9ydHMuVG9vbGJhciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sYmFyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gVG9vbGJhci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9vbGJhci5wcm90b3R5cGUudHlwZSA9ICdUb29sYmFyJztcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSB0b29sYmFyX2Jhc2VfMS5Ub29sYmFyQmFzZVZpZXc7XG4gICAgVG9vbGJhci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBUb29sYmFyLl9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6dG9vbHMnLCB0aGlzLl9pbml0X3Rvb2xzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRfdG9vbHMoKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLl9pbml0X3Rvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXQsIGksIGxlbiwgcmVmLCByZXN1bHRzLCB0b29sLCB0b29scztcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b29sID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKHRvb2wgaW5zdGFuY2VvZiBpbnNwZWN0X3Rvb2xfMS5JbnNwZWN0VG9vbCkge1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5pbnNwZWN0b3JzLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaWQgPT09IHRvb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zcGVjdG9ycyA9IHRoaXMuaW5zcGVjdG9ycy5jb25jYXQoW3Rvb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgaGVscF90b29sXzEuSGVscFRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuaGVscCwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlbHAgPSB0aGlzLmhlbHAuY29uY2F0KFt0b29sXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9vbCBpbnN0YW5jZW9mIGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbCkge1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5hY3Rpb25zLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaWQgPT09IHRvb2wuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHRoaXMuYWN0aW9ucy5jb25jYXQoW3Rvb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgZ2VzdHVyZV90b29sXzEuR2VzdHVyZVRvb2wpIHtcbiAgICAgICAgICAgICAgICBldCA9IHRvb2wuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoIShldCBpbiB0aGlzLmdlc3R1cmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlRvb2xiYXI6IHVua25vd24gZXZlbnQgdHlwZSAnXCIgKyBldCArIFwiJyBmb3IgdG9vbDogXCIgKyB0b29sLnR5cGUgKyBcIiAoXCIgKyB0b29sLmlkICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheV8xLmFueSh0aGlzLmdlc3R1cmVzW2V0XS50b29scywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlc3R1cmVzW2V0XS50b29scyA9IHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzLmNvbmNhdChbdG9vbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRvb2wsICdjaGFuZ2U6YWN0aXZlJywgdGhpcy5fYWN0aXZlX2NoYW5nZS5iaW5kKHRvb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoZXQgaW4gdGhpcy5nZXN0dXJlcykge1xuICAgICAgICAgICAgdG9vbHMgPSB0aGlzLmdlc3R1cmVzW2V0XS50b29scztcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzID0gYXJyYXlfMS5zb3J0QnkodG9vbHMsIGZ1bmN0aW9uICh0b29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2wuZGVmYXVsdF9vcmRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV0ID09PSAndGFwJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV90YXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV90YXAgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlc3R1cmVzW2V0XS50b29sc1swXS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVfdGFwLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV0ID09PSAncGFuJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV9kcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVfZHJhZyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzWzBdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZV9kcmFnLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV0ID09PSAncGluY2gnIHx8IGV0ID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZV9zY3JvbGwgPT09IG51bGwgfHwgdGhpcy5hY3RpdmVfc2Nyb2xsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmFjdGl2ZV9zY3JvbGwuYWN0aXZlID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRvb2xiYXIuZGVmaW5lKHtcbiAgICAgICAgYWN0aXZlX2RyYWc6IFtwLkFueSwgJ2F1dG8nXSxcbiAgICAgICAgYWN0aXZlX3Njcm9sbDogW3AuQW55LCAnYXV0byddLFxuICAgICAgICBhY3RpdmVfdGFwOiBbcC5BbnksICdhdXRvJ11cbiAgICB9KTtcbiAgICByZXR1cm4gVG9vbGJhcjtcbn0pKHRvb2xiYXJfYmFzZV8xLlRvb2xiYXJCYXNlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCJjb3JlL2xvZ2dpbmdcIik7XG52YXIgc29sdmVyXzEgPSByZXF1aXJlKFwiY29yZS9sYXlvdXQvc29sdmVyXCIpO1xudmFyIGRvbV8xID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG52YXIgYWN0aW9uX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvYWN0aW9uX3Rvb2xcIik7XG52YXIgb25fb2ZmX2J1dHRvbl8xID0gcmVxdWlyZShcIi4vb25fb2ZmX2J1dHRvblwiKTtcbnZhciB0b29sYmFyX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi90b29sYmFyX3RlbXBsYXRlXCIpO1xuZXhwb3J0cy5Ub29sYmFyQmFzZVZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJhc2VWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyQmFzZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBUb29sYmFyQmFzZVZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCYXNlVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay10b29sYmFyLXdyYXBwZXJcIjtcbiAgICBUb29sYmFyQmFzZVZpZXcucHJvdG90eXBlLnRlbXBsYXRlID0gdG9vbGJhcl90ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgVG9vbGJhckJhc2VWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zLCBldCwgZ2VzdHVyZXMsIGksIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgb2JqLCByZWYsIHJlZjEsIHJlZjIsIHJlZjM7XG4gICAgICAgIGRvbV8xLmVtcHR5KHRoaXMuZWwpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zaXppbmdfbW9kZSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gdGhpcy5tb2RlbC5fZG9tX2xlZnQuX3ZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSB0aGlzLm1vZGVsLl9kb21fdG9wLl92YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSB0aGlzLm1vZGVsLl93aWR0aC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMubW9kZWwuX2hlaWdodC5fdmFsdWUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnRlbXBsYXRlKHtcbiAgICAgICAgICAgIGxvZ286IHRoaXMubW9kZWwubG9nbyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLm1vZGVsLnRvb2xiYXJfbG9jYXRpb24sXG4gICAgICAgICAgICBzdGlja3k6IHRoaXMubW9kZWwudG9vbGJhcl9zdGlja3kgPyAnc3RpY2t5JyA6ICdub3Qtc3RpY2t5J1xuICAgICAgICB9KSk7XG4gICAgICAgIGJ1dHRvbnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuYmstYnV0dG9uLWJhci1saXN0W3R5cGU9J2luc3BlY3RvcnMnXVwiKTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5pbnNwZWN0b3JzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9iaiA9IHJlZltpXTtcbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQobmV3IG9uX29mZl9idXR0b25fMS5Pbk9mZkJ1dHRvblZpZXcoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiBvYmpcbiAgICAgICAgICAgIH0pLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBidXR0b25zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmJrLWJ1dHRvbi1iYXItbGlzdFt0eXBlPSdoZWxwJ11cIik7XG4gICAgICAgIHJlZjEgPSB0aGlzLm1vZGVsLmhlbHA7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgICAgb2JqID0gcmVmMVtqXTtcbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQobmV3IGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbEJ1dHRvblZpZXcoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiBvYmpcbiAgICAgICAgICAgIH0pLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBidXR0b25zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmJrLWJ1dHRvbi1iYXItbGlzdFt0eXBlPSdhY3Rpb25zJ11cIik7XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLmFjdGlvbnM7XG4gICAgICAgIGZvciAoayA9IDAsIGxlbjIgPSByZWYyLmxlbmd0aDsgayA8IGxlbjI7IGsrKykge1xuICAgICAgICAgICAgb2JqID0gcmVmMltrXTtcbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQobmV3IGFjdGlvbl90b29sXzEuQWN0aW9uVG9vbEJ1dHRvblZpZXcoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiBvYmpcbiAgICAgICAgICAgIH0pLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBnZXN0dXJlcyA9IHRoaXMubW9kZWwuZ2VzdHVyZXM7XG4gICAgICAgIGZvciAoZXQgaW4gZ2VzdHVyZXMpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuYmstYnV0dG9uLWJhci1saXN0W3R5cGU9J1wiICsgZXQgKyBcIiddXCIpO1xuICAgICAgICAgICAgcmVmMyA9IGdlc3R1cmVzW2V0XS50b29scztcbiAgICAgICAgICAgIGZvciAobCA9IDAsIGxlbjMgPSByZWYzLmxlbmd0aDsgbCA8IGxlbjM7IGwrKykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHJlZjNbbF07XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5hcHBlbmRDaGlsZChuZXcgb25fb2ZmX2J1dHRvbl8xLk9uT2ZmQnV0dG9uVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBvYmpcbiAgICAgICAgICAgICAgICB9KS5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhckJhc2VWaWV3O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTVZpZXcpO1xuZXhwb3J0cy5Ub29sYmFyQmFzZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sYmFyQmFzZSwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVG9vbGJhckJhc2UoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZV9jaGFuZ2UgPSBiaW5kKHRoaXMuX2FjdGl2ZV9jaGFuZ2UsIHRoaXMpO1xuICAgICAgICByZXR1cm4gVG9vbGJhckJhc2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCYXNlLnByb3RvdHlwZS50eXBlID0gJ1Rvb2xiYXJCYXNlJztcbiAgICBUb29sYmFyQmFzZS5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Ub29sYmFyQmFzZVZpZXc7XG4gICAgVG9vbGJhckJhc2UucHJvdG90eXBlLl9hY3RpdmVfY2hhbmdlID0gZnVuY3Rpb24gKHRvb2wpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRseV9hY3RpdmVfdG9vbCwgZXZlbnRfdHlwZSwgZ2VzdHVyZXM7XG4gICAgICAgIGV2ZW50X3R5cGUgPSB0b29sLmV2ZW50X3R5cGU7XG4gICAgICAgIGdlc3R1cmVzID0gdGhpcy5nZXN0dXJlcztcbiAgICAgICAgY3VycmVudGx5X2FjdGl2ZV90b29sID0gZ2VzdHVyZXNbZXZlbnRfdHlwZV0uYWN0aXZlO1xuICAgICAgICBpZiAoKGN1cnJlbnRseV9hY3RpdmVfdG9vbCAhPSBudWxsKSAmJiBjdXJyZW50bHlfYWN0aXZlX3Rvb2wgIT09IHRvb2wpIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJUb29sYmFyOiBkZWFjdGl2YXRpbmcgdG9vbDogXCIgKyBjdXJyZW50bHlfYWN0aXZlX3Rvb2wudHlwZSArIFwiIChcIiArIGN1cnJlbnRseV9hY3RpdmVfdG9vbC5pZCArIFwiKSBmb3IgZXZlbnQgdHlwZSAnXCIgKyBldmVudF90eXBlICsgXCInXCIpO1xuICAgICAgICAgICAgY3VycmVudGx5X2FjdGl2ZV90b29sLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGdlc3R1cmVzW2V2ZW50X3R5cGVdLmFjdGl2ZSA9IHRvb2w7XG4gICAgICAgIHRoaXMuZ2VzdHVyZXMgPSBnZXN0dXJlcztcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIlRvb2xiYXI6IGFjdGl2YXRpbmcgdG9vbDogXCIgKyB0b29sLnR5cGUgKyBcIiAoXCIgKyB0b29sLmlkICsgXCIpIGZvciBldmVudCB0eXBlICdcIiArIGV2ZW50X3R5cGUgKyBcIidcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVG9vbGJhckJhc2UucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdHJhaW50cyA9IFRvb2xiYXJCYXNlLl9fc3VwZXJfXy5nZXRfY29uc3RyYWludHMuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChzb2x2ZXJfMS5FUSh0aGlzLl9zaXplYWJsZSwgLTMwKSk7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9O1xuICAgIFRvb2xiYXJCYXNlLmRlZmluZSh7XG4gICAgICAgIHRvb2xzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBsb2dvOiBbcC5TdHJpbmcsICdub3JtYWwnXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCYXNlLmludGVybmFsKHtcbiAgICAgICAgZ2VzdHVyZXM6IFtcbiAgICAgICAgICAgIHAuQW55LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZG91YmxldGFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGluY2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcmVzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhY3Rpb25zOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBpbnNwZWN0b3JzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBoZWxwOiBbcC5BcnJheSwgW11dLFxuICAgICAgICB0b29sYmFyX2xvY2F0aW9uOiBbcC5Mb2NhdGlvbiwgJ3JpZ2h0J10sXG4gICAgICAgIHRvb2xiYXJfc3RpY2t5OiBbcC5Cb29sXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCYXNlLm92ZXJyaWRlKHtcbiAgICAgICAgc2l6aW5nX21vZGU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gVG9vbGJhckJhc2U7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbnZhciBhY3Rpb25fdG9vbF8xID0gcmVxdWlyZShcIi4vYWN0aW9ucy9hY3Rpb25fdG9vbFwiKTtcbnZhciBoZWxwX3Rvb2xfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbnMvaGVscF90b29sXCIpO1xudmFyIGdlc3R1cmVfdG9vbF8xID0gcmVxdWlyZShcIi4vZ2VzdHVyZXMvZ2VzdHVyZV90b29sXCIpO1xudmFyIGluc3BlY3RfdG9vbF8xID0gcmVxdWlyZShcIi4vaW5zcGVjdG9ycy9pbnNwZWN0X3Rvb2xcIik7XG52YXIgdG9vbGJhcl9iYXNlXzEgPSByZXF1aXJlKFwiLi90b29sYmFyX2Jhc2VcIik7XG52YXIgdG9vbF9wcm94eV8xID0gcmVxdWlyZShcIi4vdG9vbF9wcm94eVwiKTtcbnZhciBib3hfMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2JveFwiKTtcbmV4cG9ydHMuVG9vbGJhckJveFRvb2xiYXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9vbGJhckJveFRvb2xiYXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJCb3hUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gVG9vbGJhckJveFRvb2xiYXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS50eXBlID0gJ1Rvb2xiYXJCb3hUb29sYmFyJztcbiAgICBUb29sYmFyQm94VG9vbGJhci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gdG9vbGJhcl9iYXNlXzEuVG9vbGJhckJhc2VWaWV3O1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVG9vbGJhckJveFRvb2xiYXIuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdF90b29scygpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZV90b29scyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlX3Rvb2xzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLmRlZmluZSh7XG4gICAgICAgIG1lcmdlX3Rvb2xzOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIFRvb2xiYXJCb3hUb29sYmFyLnByb3RvdHlwZS5faW5pdF90b29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV0LCBpLCBsZW4sIHJlZiwgcmVzdWx0cywgdG9vbDtcbiAgICAgICAgcmVmID0gdGhpcy50b29scztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAodG9vbCBpbnN0YW5jZW9mIGluc3BlY3RfdG9vbF8xLkluc3BlY3RUb29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheV8xLmFueSh0aGlzLmluc3BlY3RvcnMsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5pZCA9PT0gdG9vbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuaW5zcGVjdG9ycyA9IHRoaXMuaW5zcGVjdG9ycy5jb25jYXQoW3Rvb2xdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29sIGluc3RhbmNlb2YgaGVscF90b29sXzEuSGVscFRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuaGVscCwgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5oZWxwID0gdGhpcy5oZWxwLmNvbmNhdChbdG9vbF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvb2wgaW5zdGFuY2VvZiBhY3Rpb25fdG9vbF8xLkFjdGlvblRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5XzEuYW55KHRoaXMuYWN0aW9ucywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0b29sLmlkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5hY3Rpb25zID0gdGhpcy5hY3Rpb25zLmNvbmNhdChbdG9vbF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvb2wgaW5zdGFuY2VvZiBnZXN0dXJlX3Rvb2xfMS5HZXN0dXJlVG9vbCkge1xuICAgICAgICAgICAgICAgIGV0ID0gdG9vbC5ldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGlmICghYXJyYXlfMS5hbnkodGhpcy5nZXN0dXJlc1tldF0udG9vbHMsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5pZCA9PT0gdG9vbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzID0gdGhpcy5nZXN0dXJlc1tldF0udG9vbHMuY29uY2F0KFt0b29sXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBUb29sYmFyQm94VG9vbGJhci5wcm90b3R5cGUuX21lcmdlX3Rvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aW9ucywgYWN0aXZlLCBldCwgZXZlbnRfdHlwZSwgZ2VzdHVyZXMsIGhlbHB0b29sLCBpLCBpbmZvLCBpbnNwZWN0b3JzLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIGxlbjMsIG1ha2VfcHJveHksIG5ld19oZWxwX3Rvb2xzLCBuZXdfaGVscF91cmxzLCBwcm94eSwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZXN1bHRzLCB0b29sLCB0b29sX3R5cGUsIHRvb2xzO1xuICAgICAgICBpbnNwZWN0b3JzID0ge307XG4gICAgICAgIGFjdGlvbnMgPSB7fTtcbiAgICAgICAgZ2VzdHVyZXMgPSB7fTtcbiAgICAgICAgbmV3X2hlbHBfdG9vbHMgPSBbXTtcbiAgICAgICAgbmV3X2hlbHBfdXJscyA9IFtdO1xuICAgICAgICByZWYgPSB0aGlzLmhlbHA7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaGVscHRvb2wgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAocmVmMSA9IGhlbHB0b29sLnJlZGlyZWN0LCBpbmRleE9mLmNhbGwobmV3X2hlbHBfdXJscywgcmVmMSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV3X2hlbHBfdG9vbHMucHVzaChoZWxwdG9vbCk7XG4gICAgICAgICAgICAgICAgbmV3X2hlbHBfdXJscy5wdXNoKGhlbHB0b29sLnJlZGlyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlbHAgPSBuZXdfaGVscF90b29scztcbiAgICAgICAgcmVmMiA9IHRoaXMuZ2VzdHVyZXM7XG4gICAgICAgIGZvciAoZXZlbnRfdHlwZSBpbiByZWYyKSB7XG4gICAgICAgICAgICBpbmZvID0gcmVmMltldmVudF90eXBlXTtcbiAgICAgICAgICAgIGlmICghKGV2ZW50X3R5cGUgaW4gZ2VzdHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZXNbZXZlbnRfdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZjMgPSBpbmZvLnRvb2xzO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG9vbCA9IHJlZjNbal07XG4gICAgICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGdlc3R1cmVzW2V2ZW50X3R5cGVdKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXN0dXJlc1tldmVudF90eXBlXVt0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlc3R1cmVzW2V2ZW50X3R5cGVdW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWY0ID0gdGhpcy5pbnNwZWN0b3JzO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmNC5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWY0W2tdO1xuICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGluc3BlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdG9yc1t0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNwZWN0b3JzW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICByZWY1ID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4zID0gcmVmNS5sZW5ndGg7IGwgPCBsZW4zOyBsKyspIHtcbiAgICAgICAgICAgIHRvb2wgPSByZWY1W2xdO1xuICAgICAgICAgICAgaWYgKCEodG9vbC50eXBlIGluIGFjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1t0b29sLnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb25zW3Rvb2wudHlwZV0ucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlX3Byb3h5ID0gZnVuY3Rpb24gKHRvb2xzLCBhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX3Byb3h5XzEuVG9vbFByb3h5KHtcbiAgICAgICAgICAgICAgICB0b29sczogdG9vbHMsXG4gICAgICAgICAgICAgICAgZXZlbnRfdHlwZTogdG9vbHNbMF0uZXZlbnRfdHlwZSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB0b29sc1swXS50b29sX25hbWUsXG4gICAgICAgICAgICAgICAgdG9vbF9uYW1lOiB0b29sc1swXS50b29sX25hbWUsXG4gICAgICAgICAgICAgICAgaWNvbjogdG9vbHNbMF0uaWNvbixcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoZXZlbnRfdHlwZSBpbiBnZXN0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5nZXN0dXJlc1tldmVudF90eXBlXS50b29scyA9IFtdO1xuICAgICAgICAgICAgcmVmNiA9IGdlc3R1cmVzW2V2ZW50X3R5cGVdO1xuICAgICAgICAgICAgZm9yICh0b29sX3R5cGUgaW4gcmVmNikge1xuICAgICAgICAgICAgICAgIHRvb2xzID0gcmVmNlt0b29sX3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gbWFrZV9wcm94eSh0b29scyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXNbZXZlbnRfdHlwZV0udG9vbHMucHVzaChwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8ocHJveHksICdjaGFuZ2U6YWN0aXZlJywgdGhpcy5fYWN0aXZlX2NoYW5nZS5iaW5kKHByb3h5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHRvb2xfdHlwZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICB0b29scyA9IGFjdGlvbnNbdG9vbF90eXBlXTtcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2gobWFrZV9wcm94eSh0b29scykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zcGVjdG9ycyA9IFtdO1xuICAgICAgICBmb3IgKHRvb2xfdHlwZSBpbiBpbnNwZWN0b3JzKSB7XG4gICAgICAgICAgICB0b29scyA9IGluc3BlY3RvcnNbdG9vbF90eXBlXTtcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNwZWN0b3JzLnB1c2gobWFrZV9wcm94eSh0b29scywgYWN0aXZlID0gdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChldCBpbiB0aGlzLmdlc3R1cmVzKSB7XG4gICAgICAgICAgICB0b29scyA9IHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzO1xuICAgICAgICAgICAgaWYgKHRvb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlc1tldF0udG9vbHMgPSBhcnJheV8xLnNvcnRCeSh0b29scywgZnVuY3Rpb24gKHRvb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbC5kZWZhdWx0X29yZGVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXQgIT09ICdwaW5jaCcgJiYgZXQgIT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2VzdHVyZXNbZXRdLnRvb2xzWzBdLmFjdGl2ZSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhckJveFRvb2xiYXI7XG59KSh0b29sYmFyX2Jhc2VfMS5Ub29sYmFyQmFzZSk7XG5leHBvcnRzLlRvb2xiYXJCb3hWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRvb2xiYXJCb3hWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyQm94VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRvb2xiYXJCb3hWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUb29sYmFyQm94Vmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ2JrLXRvb2xiYXItYm94JztcbiAgICBUb29sYmFyQm94Vmlldy5wcm90b3R5cGUuZ2V0X3dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5faG9yaXpvbnRhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCb3hWaWV3LnByb3RvdHlwZS5nZXRfaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhckJveFZpZXc7XG59KShib3hfMS5Cb3hWaWV3KTtcbmV4cG9ydHMuVG9vbGJhckJveCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb29sYmFyQm94LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyQm94KCkge1xuICAgICAgICByZXR1cm4gVG9vbGJhckJveC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9vbGJhckJveC5wcm90b3R5cGUudHlwZSA9ICdUb29sYmFyQm94JztcbiAgICBUb29sYmFyQm94LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRvb2xiYXJCb3hWaWV3O1xuICAgIFRvb2xiYXJCb3gucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBUb29sYmFyQm94Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIgPSBuZXcgZXhwb3J0cy5Ub29sYmFyQm94VG9vbGJhcihvcHRpb25zKTtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLnRvb2xiYXJfbG9jYXRpb24pID09PSAnbGVmdCcgfHwgcmVmID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b29sYmFyLl9zaXplYWJsZSA9IHRoaXMuX3Rvb2xiYXIuX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rvb2xiYXIuX3NpemVhYmxlID0gdGhpcy5fdG9vbGJhci5faGVpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyQm94LnByb3RvdHlwZS5fZG9jX2F0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9vbGJhci5hdHRhY2hfZG9jdW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgfTtcbiAgICBUb29sYmFyQm94LnByb3RvdHlwZS5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl90b29sYmFyXTtcbiAgICB9O1xuICAgIFRvb2xiYXJCb3guZGVmaW5lKHtcbiAgICAgICAgdG9vbGJhcl9sb2NhdGlvbjogW3AuTG9jYXRpb24sIFwicmlnaHRcIl0sXG4gICAgICAgIG1lcmdlX3Rvb2xzOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgdG9vbHM6IFtwLkFueSwgW11dLFxuICAgICAgICBsb2dvOiBbcC5TdHJpbmcsIFwibm9ybWFsXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuIFRvb2xiYXJCb3g7XG59KShib3hfMS5Cb3gpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRE9NID0gcmVxdWlyZShcImNvcmUvZG9tXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGxvZ287XG4gICAgaWYgKHByb3BzLmxvZ28gIT0gbnVsbCkge1xuICAgICAgICB2YXIgY2xzID0gcHJvcHMubG9nbyA9PT0gXCJncmV5XCIgPyBcImJrLWdyZXlcIiA6IG51bGw7XG4gICAgICAgIGxvZ28gPSBET00uY3JlYXRlRWxlbWVudChcImFcIiwgeyBocmVmOiBcImh0dHA6Ly9ib2tlaC5weWRhdGEub3JnL1wiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIGNsYXNzOiBbXCJiay1sb2dvXCIsIFwiYmstbG9nby1zbWFsbFwiLCBjbHNdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6IFtcImJrLXRvb2xiYXItXCIgKyBwcm9wcy5sb2NhdGlvbiwgXCJiay10b29sYmFyLVwiICsgcHJvcHMuc3RpY2t5XSB9LFxuICAgICAgICBsb2dvLFxuICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhcicgfSxcbiAgICAgICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6ICdiay1idXR0b24tYmFyLWxpc3QnLCB0eXBlOiBcInBhblwiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwic2Nyb2xsXCIgfSksXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJwaW5jaFwiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwidGFwXCIgfSksXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJwcmVzc1wiIH0pLFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogJ2JrLWJ1dHRvbi1iYXItbGlzdCcsIHR5cGU6IFwicm90YXRlXCIgfSksXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJhY3Rpb25zXCIgfSksXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJpbnNwZWN0b3JzXCIgfSksXG4gICAgICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiAnYmstYnV0dG9uLWJhci1saXN0JywgdHlwZTogXCJoZWxwXCIgfSkpKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBzbGljZSA9IFtdLnNsaWNlO1xudmFyIHRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG9iamVjdF8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9vYmplY3RcIik7XG5leHBvcnRzLkN1c3RvbUpTVHJhbnNmb3JtID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEN1c3RvbUpTVHJhbnNmb3JtLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDdXN0b21KU1RyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIEN1c3RvbUpTVHJhbnNmb3JtLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDdXN0b21KU1RyYW5zZm9ybS5wcm90b3R5cGUudHlwZSA9ICdDdXN0b21KU1RyYW5zZm9ybSc7XG4gICAgQ3VzdG9tSlNUcmFuc2Zvcm0uZGVmaW5lKHtcbiAgICAgICAgYXJnczogW3AuQW55LCB7fV0sXG4gICAgICAgIGZ1bmM6IFtwLlN0cmluZywgXCJcIl0sXG4gICAgICAgIHZfZnVuYzogW3AuU3RyaW5nLCBcIlwiXVxuICAgIH0pO1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLmdldHRlcnMoe1xuICAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlX3ZhbHVlcygpO1xuICAgICAgICB9LFxuICAgICAgICBzY2FsYXJfdHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZV90cmFuc2Zvcm0oXCJ4XCIsIHRoaXMuZnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZlY3Rvcl90cmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlX3RyYW5zZm9ybShcInhzXCIsIHRoaXMudl9mdW5jKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEN1c3RvbUpTVHJhbnNmb3JtLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGFyX3RyYW5zZm9ybS5hcHBseSh0aGlzLCBzbGljZS5jYWxsKHRoaXMudmFsdWVzKS5jb25jYXQoW3hdLCBbcmVxdWlyZV0sIFtleHBvcnRzXSkpO1xuICAgIH07XG4gICAgQ3VzdG9tSlNUcmFuc2Zvcm0ucHJvdG90eXBlLnZfY29tcHV0ZSA9IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JfdHJhbnNmb3JtLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwodGhpcy52YWx1ZXMpLmNvbmNhdChbeHNdLCBbcmVxdWlyZV0sIFtleHBvcnRzXSkpO1xuICAgIH07XG4gICAgQ3VzdG9tSlNUcmFuc2Zvcm0ucHJvdG90eXBlLl9tYWtlX3RyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWwsIGZuKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGZ1bmMsIGFyZ3MsIGN0b3IpIHtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBuZXcgY3RvciwgcmVzdWx0ID0gZnVuYy5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCA/IHJlc3VsdCA6IGNoaWxkO1xuICAgICAgICB9KShGdW5jdGlvbiwgc2xpY2UuY2FsbChPYmplY3Qua2V5cyh0aGlzLmFyZ3MpKS5jb25jYXQoW3ZhbF0sIFtcInJlcXVpcmVcIl0sIFtcImV4cG9ydHNcIl0sIFtmbl0pLCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgIH07XG4gICAgQ3VzdG9tSlNUcmFuc2Zvcm0ucHJvdG90eXBlLl9tYWtlX3ZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLnZhbHVlcyh0aGlzLmFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUpTVHJhbnNmb3JtO1xufSkodHJhbnNmb3JtXzEuVHJhbnNmb3JtKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGN1c3RvbWpzX3RyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vY3VzdG9tanNfdHJhbnNmb3JtXCIpO1xuZXhwb3J0cy5DdXN0b21KU1RyYW5zZm9ybSA9IGN1c3RvbWpzX3RyYW5zZm9ybV8xLkN1c3RvbUpTVHJhbnNmb3JtO1xudmFyIGludGVycG9sYXRvcl8xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdG9yXCIpO1xuZXhwb3J0cy5JbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0b3JfMS5JbnRlcnBvbGF0b3I7XG52YXIgaml0dGVyXzEgPSByZXF1aXJlKFwiLi9qaXR0ZXJcIik7XG5leHBvcnRzLkppdHRlciA9IGppdHRlcl8xLkppdHRlcjtcbnZhciBsaW5lYXJfaW50ZXJwb2xhdG9yXzEgPSByZXF1aXJlKFwiLi9saW5lYXJfaW50ZXJwb2xhdG9yXCIpO1xuZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGF0b3IgPSBsaW5lYXJfaW50ZXJwb2xhdG9yXzEuTGluZWFySW50ZXJwb2xhdG9yO1xudmFyIHN0ZXBfaW50ZXJwb2xhdG9yXzEgPSByZXF1aXJlKFwiLi9zdGVwX2ludGVycG9sYXRvclwiKTtcbmV4cG9ydHMuU3RlcEludGVycG9sYXRvciA9IHN0ZXBfaW50ZXJwb2xhdG9yXzEuU3RlcEludGVycG9sYXRvcjtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gdHJhbnNmb3JtXzEuVHJhbnNmb3JtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyIHRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5JbnRlcnBvbGF0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW50ZXJwb2xhdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0b3IoKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnBvbGF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEludGVycG9sYXRvci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICBJbnRlcnBvbGF0b3IuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3hfc29ydGVkID0gW107XG4gICAgICAgIHRoaXMuX3lfc29ydGVkID0gW107XG4gICAgICAgIHRoaXMuX3NvcnRlZF9kaXJ0eSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc29ydGVkX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbnRlcnBvbGF0b3IuZGVmaW5lKHtcbiAgICAgICAgeDogW3AuQW55XSxcbiAgICAgICAgeTogW3AuQW55XSxcbiAgICAgICAgZGF0YTogW3AuQW55XSxcbiAgICAgICAgY2xpcDogW3AuQm9vbCwgdHJ1ZV1cbiAgICB9KTtcbiAgICBJbnRlcnBvbGF0b3IucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGVzY2VuZGluZykge1xuICAgICAgICB2YXIgY29sdW1uX25hbWVzLCBkYXRhLCBpLCBqLCBrLCBsaXN0LCByZWYsIHJlZjEsIHJlZjIsIHRzeCwgdHN5O1xuICAgICAgICBpZiAoZGVzY2VuZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnggIT09IHR5cGVvZiB0aGlzLnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmFtZXRlcnMgZm9yIHggYW5kIHkgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlLCBlaXRoZXIgYm90aCBzdHJpbmdzIHdoaWNoIGRlZmluZSBhIGNvbHVtbiBpbiB0aGUgZGF0YSBzb3VyY2Ugb3IgYm90aCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3N0cmluZycgJiYgdGhpcy5kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB0aGUgeCBhbmQgeSBwYXJhbWV0ZXJzIGFyZSBub3Qgc3BlY2lmaWVkIGFzIGFuIGFycmF5LCB0aGUgZGF0YSBwYXJhbWV0ZXIgaXMgcmVxaXJlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NvcnRlZF9kaXJ0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0c3ggPSBbXTtcbiAgICAgICAgdHN5ID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy54ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGNvbHVtbl9uYW1lcyA9IGRhdGEuY29sdW1ucygpO1xuICAgICAgICAgICAgaWYgKHJlZiA9IHRoaXMueCwgaW5kZXhPZi5jYWxsKGNvbHVtbl9uYW1lcywgcmVmKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB4IHBhcmFtZXRlciBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgdmFsaWQgY29sdW1uIG5hbWUgZGVmaW5lZCBpbiB0aGUgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWYxID0gdGhpcy55LCBpbmRleE9mLmNhbGwoY29sdW1uX25hbWVzLCByZWYxKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB4IHBhcmFtZXRlciBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgdmFsaWQgY29sdW1uIG5hbWUgZGVmaW5lZCBpbiB0aGUgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRzeCA9IGRhdGEuZ2V0X2NvbHVtbih0aGlzLngpO1xuICAgICAgICAgICAgdHN5ID0gZGF0YS5nZXRfY29sdW1uKHRoaXMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0c3ggPSB0aGlzLng7XG4gICAgICAgICAgICB0c3kgPSB0aGlzLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzeC5sZW5ndGggIT09IHRzeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlbmd0aCBmb3IgeCBhbmQgeSBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHN4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzIHRvIHN1cHBvcnQgaW50ZXJwb2xhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChqIGluIHRzeCkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAneCc6IHRzeFtqXSxcbiAgICAgICAgICAgICAgICAneSc6IHRzeVtqXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NlbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmMiA9IGEueCA8IGIueCkgIT0gbnVsbCA/IHJlZjIgOiAte1xuICAgICAgICAgICAgICAgICAgICAxOiAocmVmMyA9IGEueCA9PT0gYi54KSAhPSBudWxsID8gcmVmMyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDA6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmMiA9IGEueCA+IGIueCkgIT0gbnVsbCA/IHJlZjIgOiAte1xuICAgICAgICAgICAgICAgICAgICAxOiAocmVmMyA9IGEueCA9PT0gYi54KSAhPSBudWxsID8gcmVmMyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIDA6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgPSBpID0gMCwgcmVmMiA9IGxpc3QubGVuZ3RoOyAwIDw9IHJlZjIgPyBpIDwgcmVmMiA6IGkgPiByZWYyOyBrID0gMCA8PSByZWYyID8gKytpIDogLS1pKSB7XG4gICAgICAgICAgICB0aGlzLl94X3NvcnRlZFtrXSA9IGxpc3Rba10ueDtcbiAgICAgICAgICAgIHRoaXMuX3lfc29ydGVkW2tdID0gbGlzdFtrXS55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0ZWRfZGlydHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0b3I7XG59KSh0cmFuc2Zvcm1fMS5UcmFuc2Zvcm0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGJva2VoX21hdGggPSByZXF1aXJlKFwiY29yZS91dGlsL21hdGhcIik7XG5leHBvcnRzLkppdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChKaXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEppdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIEppdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSml0dGVyLmRlZmluZSh7XG4gICAgICAgIG1lYW46IFtwLk51bWJlciwgMF0sXG4gICAgICAgIHdpZHRoOiBbcC5OdW1iZXIsIDFdLFxuICAgICAgICBkaXN0cmlidXRpb246IFtwLkRpc3RyaWJ1dGlvbiwgJ3VuaWZvcm0nXVxuICAgIH0pO1xuICAgIEppdHRlci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICByZXR1cm4geCArIHRoaXMubWVhbiArICgoYm9rZWhfbWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4geCArIGJva2VoX21hdGgucm5vcm0odGhpcy5tZWFuLCB0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSml0dGVyLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGksIGlkeCwgbGVuLCByZXN1bHQsIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpZHggPSBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHggPSB4c1tpZHhdO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0aGlzLmNvbXB1dGUoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBKaXR0ZXI7XG59KSh0cmFuc2Zvcm1fMS5UcmFuc2Zvcm0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiY29yZS91dGlsL2FycmF5XCIpO1xudmFyIGludGVycG9sYXRvcl8xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdG9yXCIpO1xuZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGF0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTGluZWFySW50ZXJwb2xhdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGF0b3IoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJJbnRlcnBvbGF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmVhckludGVycG9sYXRvci5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBkZXNjZW5kaW5nLCBpbmQsIHJldCwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIHRoaXMuc29ydChkZXNjZW5kaW5nID0gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jbGlwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeCA8IHRoaXMuX3hfc29ydGVkWzBdIHx8IHggPiB0aGlzLl94X3NvcnRlZFt0aGlzLl94X3NvcnRlZC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHggPCB0aGlzLl94X3NvcnRlZFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95X3NvcnRlZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy5feF9zb3J0ZWRbdGhpcy5feF9zb3J0ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbdGhpcy5feV9zb3J0ZWQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IHRoaXMuX3hfc29ydGVkWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kTGFzdEluZGV4KHRoaXMuX3hfc29ydGVkLCBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtIDwgeDtcbiAgICAgICAgfSk7XG4gICAgICAgIHgxID0gdGhpcy5feF9zb3J0ZWRbaW5kXTtcbiAgICAgICAgeDIgPSB0aGlzLl94X3NvcnRlZFtpbmQgKyAxXTtcbiAgICAgICAgeTEgPSB0aGlzLl95X3NvcnRlZFtpbmRdO1xuICAgICAgICB5MiA9IHRoaXMuX3lfc29ydGVkW2luZCArIDFdO1xuICAgICAgICByZXQgPSB5MSArICgoKHggLSB4MSkgLyAoeDIgLSB4MSkpICogKHkyIC0geTEpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIExpbmVhckludGVycG9sYXRvci5wcm90b3R5cGUudl9jb21wdXRlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHZhciBpLCBpZHgsIGxlbiwgcmVzdWx0LCB4O1xuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KHhzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaWR4ID0gaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaWR4ID0gKytpKSB7XG4gICAgICAgICAgICB4ID0geHNbaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gdGhpcy5jb21wdXRlKHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFySW50ZXJwb2xhdG9yO1xufSkoaW50ZXJwb2xhdG9yXzEuSW50ZXJwb2xhdG9yKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbnRlcnBvbGF0b3JfMSA9IHJlcXVpcmUoXCIuL2ludGVycG9sYXRvclwiKTtcbnZhciBwID0gcmVxdWlyZShcImNvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9hcnJheVwiKTtcbmV4cG9ydHMuU3RlcEludGVycG9sYXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdGVwSW50ZXJwb2xhdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTdGVwSW50ZXJwb2xhdG9yKCkge1xuICAgICAgICByZXR1cm4gU3RlcEludGVycG9sYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RlcEludGVycG9sYXRvci5kZWZpbmUoe1xuICAgICAgICBtb2RlOiBbcC5UcmFuc2Zvcm1TdGVwTW9kZSwgXCJhZnRlclwiXVxuICAgIH0pO1xuICAgIFN0ZXBJbnRlcnBvbGF0b3IucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZGVzY2VuZGluZywgZGlmZnMsIGluZCwgbWRpZmYsIHJldCwgdHg7XG4gICAgICAgIHRoaXMuc29ydChkZXNjZW5kaW5nID0gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jbGlwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeCA8IHRoaXMuX3hfc29ydGVkWzBdIHx8IHggPiB0aGlzLl94X3NvcnRlZFt0aGlzLl94X3NvcnRlZC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHggPCB0aGlzLl94X3NvcnRlZFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95X3NvcnRlZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy5feF9zb3J0ZWRbdGhpcy5feF9zb3J0ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feV9zb3J0ZWRbdGhpcy5feV9zb3J0ZWQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kTGFzdEluZGV4KHRoaXMuX3hfc29ydGVkLCBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPj0gbnVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgaW5kID0gYXJyYXlfMS5maW5kSW5kZXgodGhpcy5feF9zb3J0ZWQsIGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCA8PSBudW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICBkaWZmcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMuX3hfc29ydGVkO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHggPSByZWZbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChNYXRoLmFicyh0eCAtIHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgbWRpZmYgPSBhcnJheV8xLm1pbihkaWZmcyk7XG4gICAgICAgICAgICBpbmQgPSBhcnJheV8xLmZpbmRJbmRleChkaWZmcywgZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZGlmZiA9PT0gbnVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX3lfc29ydGVkW2luZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBTdGVwSW50ZXJwb2xhdG9yLnByb3RvdHlwZS52X2NvbXB1dGUgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGksIGlkeCwgbGVuLCByZXN1bHQsIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoeHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpZHggPSBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpZHggPSArK2kpIHtcbiAgICAgICAgICAgIHggPSB4c1tpZHhdO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0aGlzLmNvbXB1dGUoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTdGVwSW50ZXJwb2xhdG9yO1xufSkoaW50ZXJwb2xhdG9yXzEuSW50ZXJwb2xhdG9yKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVHJhbnNmb3JtLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm0uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm07XG59KShtb2RlbF8xLk1vZGVsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9idXJzdF9pbnRvX2ZsYW1lcztcbl9idXJzdF9pbnRvX2ZsYW1lcyA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBib2R5LCBib3gsIGJ1dHRvbiwgbWVzc2FnZSwgcmVmLCB0aXRsZTtcbiAgICBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJveC5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcIiNmMmRlZGVcIjtcbiAgICBib3guc3R5bGVbXCJib3JkZXJcIl0gPSBcIjFweCBzb2xpZCAjYTk0NDQyXCI7XG4gICAgYm94LnN0eWxlW1wiYm9yZGVyLXJhZGl1c1wiXSA9IFwiNHB4XCI7XG4gICAgYm94LnN0eWxlW1wiZGlzcGxheVwiXSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgYm94LnN0eWxlW1wiZm9udC1mYW1pbHlcIl0gPSBcInNhbnMtc2VyaWZcIjtcbiAgICBib3guc3R5bGVbXCJtYXJnaW4tdG9wXCJdID0gXCI1cHhcIjtcbiAgICBib3guc3R5bGVbXCJtaW4td2lkdGhcIl0gPSBcIjIwMHB4XCI7XG4gICAgYm94LnN0eWxlW1wicGFkZGluZ1wiXSA9IFwiNXB4IDVweCA1cHggMTBweFwiO1xuICAgIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5zdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl0gPSBcIiNhOTQ0NDJcIjtcbiAgICBidXR0b24uc3R5bGVbXCJib3JkZXItcmFkaXVzXCJdID0gXCIwcHggNHB4IDBweCAwcHhcIjtcbiAgICBidXR0b24uc3R5bGVbXCJjb2xvclwiXSA9IFwid2hpdGVcIjtcbiAgICBidXR0b24uc3R5bGVbXCJjdXJzb3JcIl0gPSBcInBvaW50ZXJcIjtcbiAgICBidXR0b24uc3R5bGVbXCJmbG9hdFwiXSA9IFwicmlnaHRcIjtcbiAgICBidXR0b24uc3R5bGVbXCJmb250LXNpemVcIl0gPSBcIjAuOGVtXCI7XG4gICAgYnV0dG9uLnN0eWxlW1wibWFyZ2luXCJdID0gXCItNnB4IC02cHggMHB4IDBweFwiO1xuICAgIGJ1dHRvbi5zdHlsZVtcInBhZGRpbmdcIl0gPSBcIjJweCA1cHggNHB4IDVweFwiO1xuICAgIGJ1dHRvbi50aXRsZSA9IFwiY2xvc2VcIjtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcImNsb3NlXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYm9keS5yZW1vdmVDaGlsZChib3gpO1xuICAgIH0pO1xuICAgIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpO1xuICAgIHRpdGxlLnN0eWxlW1wiY29sb3JcIl0gPSBcIiNhOTQ0NDJcIjtcbiAgICB0aXRsZS5zdHlsZVtcIm1hcmdpblwiXSA9IFwiOHB4IDBweCAwcHggMHB4XCI7XG4gICAgdGl0bGUuc3R5bGVbXCJwYWRkaW5nXCJdID0gXCIwcHhcIjtcbiAgICB0aXRsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkJva2VoIEVycm9yXCIpKTtcbiAgICBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICBtZXNzYWdlLnN0eWxlW1wid2hpdGUtc3BhY2VcIl0gPSBcInVuc2V0XCI7XG4gICAgbWVzc2FnZS5zdHlsZVtcIm92ZXJmbG93LXhcIl0gPSBcImF1dG9cIjtcbiAgICBtZXNzYWdlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKChyZWYgPSBlcnJvci5tZXNzYWdlKSAhPSBudWxsID8gcmVmIDogZXJyb3IpKTtcbiAgICBib3guYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICBib3guYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIGJveC5hcHBlbmRDaGlsZChtZXNzYWdlKTtcbiAgICBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgIHJldHVybiBib2R5Lmluc2VydEJlZm9yZShib3gsIGJvZHkuZmlyc3RDaGlsZCk7XG59O1xuZXhwb3J0cy5zYWZlbHkgPSBmdW5jdGlvbiAoZm4sIHNpbGVudCkge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgc2lsZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3IxO1xuICAgICAgICBfYnVyc3RfaW50b19mbGFtZXMoZXJyb3IpO1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4xMi41JztcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMC4yXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheSA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICsgMV0gPSBhcmc7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXAoYXNhcEZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGFzYXBGbjtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogdW5kZWZpbmVkO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93IHx8IHt9O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4gICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpIHtcbiAgICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdmVydHhcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2ViIHdvcmtlclxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByID0gcmVxdWlyZTtcbiAgICAgICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaDtcbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgICA9IHZvaWQgMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEID0gMTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpIHtcbiAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKG1heWJlVGhlbmFibGUpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQ7XG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKSB7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHZhciBoYXNDYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSl7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgZW51bWVyYXRvci5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgICAgZW51bWVyYXRvci5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoZW51bWVyYXRvci5fdmFsaWRhdGVJbnB1dChpbnB1dCkpIHtcbiAgICAgICAgZW51bWVyYXRvci5faW5wdXQgICAgID0gaW5wdXQ7XG4gICAgICAgIGVudW1lcmF0b3IubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICAgIGVudW1lcmF0b3IuX2luaXQoKTtcblxuICAgICAgICBpZiAoZW51bWVyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLmxlbmd0aCA9IGVudW1lcmF0b3IubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgZW51bWVyYXRvci5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl92YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpO1xuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgbGVuZ3RoICA9IGVudW1lcmF0b3IubGVuZ3RoO1xuICAgICAgdmFyIHByb21pc2UgPSBlbnVtZXJhdG9yLnByb21pc2U7XG4gICAgICB2YXIgaW5wdXQgICA9IGVudW1lcmF0b3IuX2lucHV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcbiAgICAgIHZhciBjID0gZW51bWVyYXRvci5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKGVudHJ5KSkge1xuICAgICAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgZW50cnkuX29uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IuX3dpbGxTZXR0bGVBdChjLnJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nLS07XG4gICAgICAgIGVudW1lcmF0b3IuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBlbnVtZXJhdG9yLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsKGVudHJpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQodGhpcywgZW50cmllcykucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2UoZW50cmllcykge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsbWVudCh2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmU7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3QocmVhc29uKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0O1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzLl9pZCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyKys7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yYWNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZXNvbHZlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldFNjaGVkdWxlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXI7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldEFzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fYXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLFxuXG4gICAgLyoqXG4gICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQ2hhaW5pbmdcbiAgICAgIC0tLS0tLS0tXG5cbiAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgICAgfSk7XG5cbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICAgIH0pO1xuICAgICAgYGBgXG4gICAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBc3NpbWlsYXRpb25cbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgYXV0aG9yLCBib29rcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG5cbiAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXG4gICAgICB9XG5cbiAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIHRoZW5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICB0aGVuOiBmdW5jdGlvbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCAmJiAhb25GdWxmaWxsbWVudCB8fCBzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgJiYgIW9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcmVudC5fcmVzdWx0O1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbCgpIHtcbiAgICAgIHZhciBsb2NhbDtcblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgICAgaWYgKFAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKSA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbC5Qcm9taXNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2UgPSB7XG4gICAgICAnUHJvbWlzZSc6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ3BvbHlmaWxsJzogbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0XG4gICAgfTtcblxuICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVsnZXhwb3J0cyddKSB7XG4gICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbJ0VTNlByb21pc2UnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0KCk7XG59KS5jYWxsKHRoaXMpO1xuXG4iLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG59XG5cbi8qKlxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0RFUFJFQ0FURUQgTUVUSE9EOiAnICsgbmFtZSArICdcXG4nICsgbWVzc2FnZSArICcgQVQgXFxuJztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIG1lcmdlID0gZGVwcmVjYXRlKGZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcblxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWwxXG4gKiBAcGFyYW0geyp9IHZhbDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XG59XG5cbi8qKlxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuXG4vKipcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59XG5cbi8qKlxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuXG4vKipcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbn1cblxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxudmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcblxudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG5cbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG59XG5cbklucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gICAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gICAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuXG4vKipcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICAgICAgICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgICB9O1xuXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXG4gICAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xuICAgICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5mdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuLyoqXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuXG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbn1cblxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKSxcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcblxuICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgICAgICB2YXIgbGFzdFRvdWNoID0ge3g6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFl9O1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFgsIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KSwgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcbiAgICAgICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbi8qKlxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xufVxuXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgICAgdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG4vKipcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xufVxuXG5SZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB9XG59O1xuXG4vKipcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICAgIHJldHVybiAnZG93bic7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAqL1xuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuXG4gICAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbn1cblxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH0sXG5cbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbn1cblxuaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuSGFtbWVyLlZFUlNJT04gPSAnMi4wLjcnO1xuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgKi9cbiAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHByZXNldDogW1xuICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfV0sXG4gICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfV0sXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHtldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDJ9LCBbJ3RhcCddXSxcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAqL1xuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgfVxufTtcblxudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcblxuLyoqXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB9XG59XG5cbi8qKlxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cbmFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuXG4gICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxuICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXG4gICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxufSk7XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbnZhciBmcmVlR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmZyZWVHbG9iYWwuSGFtbWVyID0gSGFtbWVyO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gZGVmaW5pbmcgdGhlIGxpbmVhciBjb25zdHJhaW50IG9wZXJhdG9ycy5cbiAgICAgKi9cbiAgICB2YXIgT3BlcmF0b3I7XG4gICAgKGZ1bmN0aW9uIChPcGVyYXRvcikge1xuICAgICAgICBPcGVyYXRvcltPcGVyYXRvcltcIkxlXCJdID0gMF0gPSBcIkxlXCI7XG4gICAgICAgIE9wZXJhdG9yW09wZXJhdG9yW1wiR2VcIl0gPSAxXSA9IFwiR2VcIjtcbiAgICAgICAgT3BlcmF0b3JbT3BlcmF0b3JbXCJFcVwiXSA9IDJdID0gXCJFcVwiOyAvLyA9PVxuICAgIH0pKE9wZXJhdG9yID0ga2l3aS5PcGVyYXRvciB8fCAoa2l3aS5PcGVyYXRvciA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogQSBsaW5lYXIgY29uc3RyYWludCBlcXVhdGlvbi5cbiAgICAgKlxuICAgICAqIEEgY29uc3RyYWludCBlcXVhdGlvbiBpcyBjb21wb3NlZCBvZiBhbiBleHByZXNzaW9uLCBhbiBvcGVyYXRvcixcbiAgICAgKiBhbmQgYSBzdHJlbmd0aC4gVGhlIFJIUyBvZiB0aGUgZXF1YXRpb24gaXMgaW1wbGljaXRseSB6ZXJvLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICovXG4gICAgdmFyIENvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IENvbnN0cmFpbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBjb25zdHJhaW50IGV4cHJlc3Npb24uXG4gICAgICAgICAqIEBwYXJhbSBvcGVyYXRvciBUaGUgZXF1YXRpb24gb3BlcmF0b3IuXG4gICAgICAgICAqIEBwYXJhbSBzdHJlbmd0aCBUaGUgc3RyZW5ndGggb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb25zdHJhaW50KGV4cHJlc3Npb24sIG9wZXJhdG9yLCBzdHJlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0cmVuZ3RoID09PSB2b2lkIDApIHsgc3RyZW5ndGggPSBraXdpLlN0cmVuZ3RoLnJlcXVpcmVkOyB9XG4gICAgICAgICAgICB0aGlzLl9pZCA9IENuSWQrKztcbiAgICAgICAgICAgIHRoaXMuX29wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLl9leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX3N0cmVuZ3RoID0ga2l3aS5TdHJlbmd0aC5jbGlwKHN0cmVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdGF0aWMgY29uc3RyYWludCBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29uc3RyYWludC5Db21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmlkKCkgLSBiLmlkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgbnVtYmVyIG9mIHRoZSBjb25zdHJhaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29uc3RyYWludC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBleHByZXNzaW9uIG9mIHRoZSBjb25zdHJhaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29uc3RyYWludC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByZXNzaW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVsYXRpb25hbCBvcGVyYXRvciBvZiB0aGUgY29uc3RyYWludC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnN0cmFpbnQucHJvdG90eXBlLm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZXJhdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2YgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAqL1xuICAgICAgICBDb25zdHJhaW50LnByb3RvdHlwZS5zdHJlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnN0cmFpbnQ7XG4gICAgfSgpKTtcbiAgICBraXdpLkNvbnN0cmFpbnQgPSBDb25zdHJhaW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBjb25zdHJhaW50IGlkIGNvdW50ZXIuXG4gICAgICovXG4gICAgdmFyIENuSWQgPSAwO1xufSkoa2l3aSB8fCAoa2l3aSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIC8qKlxuICAgICAqIEFuIGV4cHJlc3Npb24gb2YgdmFyaWFibGUgdGVybXMgYW5kIGEgY29uc3RhbnQuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICB2YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VBcmdzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLl90ZXJtcyA9IHBhcnNlZC50ZXJtcztcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50ID0gcGFyc2VkLmNvbnN0YW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXBwaW5nIG9mIHRlcm1zIGluIHRoZSBleHByZXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzICptdXN0KiBiZSB0cmVhdGVkIGFzIGNvbnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUudGVybXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVybXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb25zdGFudCBvZiB0aGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0YW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgICAgICAqL1xuICAgICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jb25zdGFudDtcbiAgICAgICAgICAgIHRzdS5mb3JFYWNoKHRoaXMuX3Rlcm1zLCBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwYWlyLmZpcnN0LnZhbHVlKCkgKiBwYWlyLnNlY29uZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb247XG4gICAgfSgpKTtcbiAgICBraXdpLkV4cHJlc3Npb24gPSBFeHByZXNzaW9uO1xuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGFyZ3VtZW50IHBhcnNpbmcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VBcmdzKGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbnN0YW50ID0gMC4wO1xuICAgICAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDsgfTtcbiAgICAgICAgdmFyIHRlcm1zID0ga2l3aS5jcmVhdGVNYXAoa2l3aS5WYXJpYWJsZS5Db21wYXJlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3RhbnQgKz0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBraXdpLlZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGVybXMuc2V0RGVmYXVsdChpdGVtLCBmYWN0b3J5KS5zZWNvbmQgKz0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IG11c3QgaGF2ZSBsZW5ndGggMlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBpdGVtWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXRlbSAwIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHZhcmlhYmxlIGluc3RhbmNlb2Yga2l3aS5WYXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXRlbSAxIG11c3QgYmUgYSB2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVybXMuc2V0RGVmYXVsdCh2YXJpYWJsZSwgZmFjdG9yeSkuc2Vjb25kICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBFeHByZXNzaW9uIGFyZ3VtZW50OiBcIiArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRlcm1zOiB0ZXJtcywgY29uc3RhbnQ6IGNvbnN0YW50IH07XG4gICAgfVxufSkoa2l3aSB8fCAoa2l3aSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcChjb21wYXJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHN1LkFzc29jaWF0aXZlQXJyYXkoY29tcGFyZSk7XG4gICAgfVxuICAgIGtpd2kuY3JlYXRlTWFwID0gY3JlYXRlTWFwO1xufSkoa2l3aSB8fCAoa2l3aSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJhaW50IHNvbHZlciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqL1xuICAgIHZhciBTb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IFNvbHZlci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFNvbHZlcigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NuTWFwID0gY3JlYXRlQ25NYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvd01hcCA9IGNyZWF0ZVJvd01hcCgpO1xuICAgICAgICAgICAgdGhpcy5fdmFyTWFwID0gY3JlYXRlVmFyTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9lZGl0TWFwID0gY3JlYXRlRWRpdE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5faW5mZWFzaWJsZVJvd3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdGl2ZSA9IG5ldyBSb3coKTtcbiAgICAgICAgICAgIHRoaXMuX2FydGlmaWNpYWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faWRUaWNrID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgc29sdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHZhciBjblBhaXIgPSB0aGlzLl9jbk1hcC5maW5kKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgaWYgKGNuUGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGNvbnN0cmFpbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGluZyBhIHJvdyBjYXVzZXMgc3ltYm9scyB0byBiZSByZXNlcnZlZCBmb3IgdGhlIHZhcmlhYmxlc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGNvbnN0cmFpbnQuIElmIHRoaXMgbWV0aG9kIGV4aXRzIHdpdGggYW4gZXhjZXB0aW9uLFxuICAgICAgICAgICAgLy8gdGhlbiBpdHMgcG9zc2libGUgdGhvc2UgdmFyaWFibGVzIHdpbGwgbGluZ2VyIGluIHRoZSB2YXIgbWFwLlxuICAgICAgICAgICAgLy8gU2luY2UgaXRzIGxpa2VseSB0aGF0IHRob3NlIHZhcmlhYmxlcyB3aWxsIGJlIHVzZWQgaW4gb3RoZXJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnRzIGFuZCBzaW5jZSBleGNlcHRpb25hbCBjb25kaXRpb25zIGFyZSB1bmNvbW1vbixcbiAgICAgICAgICAgIC8vIGknbSBub3QgdG9vIHdvcnJpZWQgYWJvdXQgYWdncmVzc2l2ZSBjbGVhbnVwIG9mIHRoZSB2YXIgbWFwLlxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jcmVhdGVSb3coY29uc3RyYWludCk7XG4gICAgICAgICAgICB2YXIgcm93ID0gZGF0YS5yb3c7XG4gICAgICAgICAgICB2YXIgdGFnID0gZGF0YS50YWc7XG4gICAgICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX2Nob29zZVN1YmplY3Qocm93LCB0YWcpO1xuICAgICAgICAgICAgLy8gSWYgY2hvb3NlU3ViamVjdCBjb3VsZG50IGZpbmQgYSB2YWxpZCBlbnRlcmluZyBzeW1ib2wsIG9uZVxuICAgICAgICAgICAgLy8gbGFzdCBvcHRpb24gaXMgYXZhaWxhYmxlIGlmIHRoZSBlbnRpcmUgcm93IGlzIGNvbXBvc2VkIG9mXG4gICAgICAgICAgICAvLyBkdW1teSB2YXJpYWJsZXMuIElmIHRoZSBjb25zdGFudCBvZiB0aGUgcm93IGlzIHplcm8sIHRoZW5cbiAgICAgICAgICAgIC8vIHRoaXMgcmVwcmVzZW50cyByZWR1bmRhbnQgY29uc3RyYWludHMgYW5kIHRoZSBuZXcgZHVtbXlcbiAgICAgICAgICAgIC8vIG1hcmtlciBjYW4gZW50ZXIgdGhlIGJhc2lzLiBJZiB0aGUgY29uc3RhbnQgaXMgbm9uLXplcm8sXG4gICAgICAgICAgICAvLyB0aGVuIGl0IHJlcHJlc2VudHMgYW4gdW5zYXRpc2ZpYWJsZSBjb25zdHJhaW50LlxuICAgICAgICAgICAgaWYgKHN1YmplY3QudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQgJiYgcm93LmFsbER1bW1pZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICghbmVhclplcm8ocm93LmNvbnN0YW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29uc3RyYWludC5leHByZXNzaW9uKCkudGVybXMoKS5fYXJyYXk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goaXRlbS5maXJzdC5uYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IFsnTEUnLCAnR0UnLCAnRVEnXVtjb25zdHJhaW50Lm9wKCldO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNhdGlzZmlhYmxlIGNvbnN0cmFpbnQgW1wiICsgbmFtZXMuam9pbihcIixcIikgKyBcIl0gb3BlcmF0b3I6IFwiICsgb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdCA9IHRhZy5tYXJrZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYW4gZW50ZXJpbmcgc3ltYm9sIHN0aWxsIGlzbid0IGZvdW5kLCB0aGVuIHRoZSByb3cgbXVzdFxuICAgICAgICAgICAgLy8gYmUgYWRkZWQgdXNpbmcgYW4gYXJ0aWZpY2lhbCB2YXJpYWJsZS4gSWYgdGhhdCBmYWlscywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIHJvdyByZXByZXNlbnRzIGFuIHVuc2F0aXNmaWFibGUgY29uc3RyYWludC5cbiAgICAgICAgICAgIGlmIChzdWJqZWN0LnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5JbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hZGRXaXRoQXJ0aWZpY2lhbFZhcmlhYmxlKHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zYXRpc2ZpYWJsZSBjb25zdHJhaW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5zb2x2ZUZvcihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzdGl0dXRlKHN1YmplY3QsIHJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93TWFwLmluc2VydChzdWJqZWN0LCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY25NYXAuaW5zZXJ0KGNvbnN0cmFpbnQsIHRhZyk7XG4gICAgICAgICAgICAvLyBPcHRpbWl6aW5nIGFmdGVyIGVhY2ggY29uc3RyYWludCBpcyBhZGRlZCBwZXJmb3JtcyBsZXNzXG4gICAgICAgICAgICAvLyBhZ2dyZWdhdGUgd29yayBkdWUgdG8gYSBzbWFsbGVyIGF2ZXJhZ2Ugc3lzdGVtIHNpemUuIEl0XG4gICAgICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhlIHNvbHZlciByZW1haW5zIGluIGEgY29uc2lzdGVudCBzdGF0ZS5cbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplKHRoaXMuX29iamVjdGl2ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBjb25zdHJhaW50IGZyb20gdGhlIHNvbHZlci5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50LCBzaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChzaWxlbnQgPT09IHZvaWQgMCkgeyBzaWxlbnQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGNuUGFpciA9IHRoaXMuX2NuTWFwLmVyYXNlKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgaWYgKGNuUGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbGVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjb25zdHJhaW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBlcnJvciBlZmZlY3RzIGZyb20gdGhlIG9iamVjdGl2ZSBmdW5jdGlvblxuICAgICAgICAgICAgLy8gKmJlZm9yZSogcGl2b3RpbmcsIG9yIHN1YnN0aXR1dGlvbnMgaW50byB0aGUgb2JqZWN0aXZlXG4gICAgICAgICAgICAvLyB3aWxsIGxlYWQgdG8gaW5jb3JyZWN0IHNvbHZlciByZXN1bHRzLlxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ29uc3RyYWludEVmZmVjdHMoY29uc3RyYWludCwgY25QYWlyLnNlY29uZCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbWFya2VyIGlzIGJhc2ljLCBzaW1wbHkgZHJvcCB0aGUgcm93LiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyBwaXZvdCB0aGUgbWFya2VyIGludG8gdGhlIGJhc2lzIGFuZCB0aGVuIGRyb3AgdGhlIHJvdy5cbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBjblBhaXIuc2Vjb25kLm1hcmtlcjtcbiAgICAgICAgICAgIHZhciByb3dQYWlyID0gdGhpcy5fcm93TWFwLmVyYXNlKG1hcmtlcik7XG4gICAgICAgICAgICBpZiAocm93UGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYXZpbmcgPSB0aGlzLl9nZXRNYXJrZXJMZWF2aW5nU3ltYm9sKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmcudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGZpbmQgbGVhdmluZyByb3dcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd1BhaXIgPSB0aGlzLl9yb3dNYXAuZXJhc2UobGVhdmluZyk7XG4gICAgICAgICAgICAgICAgcm93UGFpci5zZWNvbmQuc29sdmVGb3JFeChsZWF2aW5nLCBtYXJrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGUobWFya2VyLCByb3dQYWlyLnNlY29uZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6aW5nIGFmdGVyIGVhY2ggY29uc3RyYWludCBpcyByZW1vdmVkIGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIHNvbHZlciByZW1haW5zIGNvbnNpc3RlbnQuIEl0IG1ha2VzIHRoZSBzb2x2ZXIgYXBpIGVhc2llciB0b1xuICAgICAgICAgICAgLy8gdXNlIGF0IGEgc21hbGwgdHJhZGVvZmYgZm9yIHNwZWVkLlxuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemUodGhpcy5fb2JqZWN0aXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgc29sdmVyIGNvbnRhaW5zIHRoZSBjb25zdHJhaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5oYXNDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbk1hcC5jb250YWlucyhjb25zdHJhaW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbiBlZGl0IHZhcmlhYmxlIHRvIHRoZSBzb2x2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLmFkZEVkaXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSwgc3RyZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlZGl0UGFpciA9IHRoaXMuX2VkaXRNYXAuZmluZCh2YXJpYWJsZSk7XG4gICAgICAgICAgICBpZiAoZWRpdFBhaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSBlZGl0IHZhcmlhYmxlOiBcIiArIHZhcmlhYmxlLm5hbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlbmd0aCA9IGtpd2kuU3RyZW5ndGguY2xpcChzdHJlbmd0aCk7XG4gICAgICAgICAgICBpZiAoc3RyZW5ndGggPT09IGtpd2kuU3RyZW5ndGgucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVxdWlyZWQgc3RyZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwciA9IG5ldyBraXdpLkV4cHJlc3Npb24odmFyaWFibGUpO1xuICAgICAgICAgICAgdmFyIGNuID0gbmV3IGtpd2kuQ29uc3RyYWludChleHByLCBraXdpLk9wZXJhdG9yLkVxLCBzdHJlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmFkZENvbnN0cmFpbnQoY24pO1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX2NuTWFwLmZpbmQoY24pLnNlY29uZDtcbiAgICAgICAgICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgY29uc3RyYWludDogY24sIGNvbnN0YW50OiAwLjAgfTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRNYXAuaW5zZXJ0KHZhcmlhYmxlLCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBlZGl0IHZhcmlhYmxlIGZyb20gdGhlIHNvbHZlci5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlRWRpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCBzaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChzaWxlbnQgPT09IHZvaWQgMCkgeyBzaWxlbnQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGVkaXRQYWlyID0gdGhpcy5fZWRpdE1hcC5lcmFzZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICBpZiAoZWRpdFBhaXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzaWxlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZWRpdCB2YXJpYWJsZTogXCIgKyB2YXJpYWJsZS5uYW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25zdHJhaW50KGVkaXRQYWlyLnNlY29uZC5jb25zdHJhaW50LCBzaWxlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBzb2x2ZXIgY29udGFpbnMgdGhlIGVkaXQgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLmhhc0VkaXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRNYXAuY29udGFpbnModmFyaWFibGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VnZ2VzdCB0aGUgdmFsdWUgb2YgYW4gZWRpdCB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuc3VnZ2VzdFZhbHVlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGVkaXRQYWlyID0gdGhpcy5fZWRpdE1hcC5maW5kKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChlZGl0UGFpciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlZGl0IHZhcmlhYmxlOiBcIiArIHZhcmlhYmxlLm5hbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuX3Jvd01hcDtcbiAgICAgICAgICAgIHZhciBpbmZvID0gZWRpdFBhaXIuc2Vjb25kO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdmFsdWUgLSBpbmZvLmNvbnN0YW50O1xuICAgICAgICAgICAgaW5mby5jb25zdGFudCA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgaWYgdGhlIHBvc2l0aXZlIGVycm9yIHZhcmlhYmxlIGlzIGJhc2ljLlxuICAgICAgICAgICAgdmFyIG1hcmtlciA9IGluZm8udGFnLm1hcmtlcjtcbiAgICAgICAgICAgIHZhciByb3dQYWlyID0gcm93cy5maW5kKG1hcmtlcik7XG4gICAgICAgICAgICBpZiAocm93UGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1BhaXIuc2Vjb25kLmFkZCgtZGVsdGEpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZmVhc2libGVSb3dzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZHVhbE9wdGltaXplKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgbmV4dCBpZiB0aGUgbmVnYXRpdmUgZXJyb3IgdmFyaWFibGUgaXMgYmFzaWMuXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBpbmZvLnRhZy5vdGhlcjtcbiAgICAgICAgICAgIHZhciByb3dQYWlyID0gcm93cy5maW5kKG90aGVyKTtcbiAgICAgICAgICAgIGlmIChyb3dQYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93UGFpci5zZWNvbmQuYWRkKGRlbHRhKSA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmZlYXNpYmxlUm93cy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZHVhbE9wdGltaXplKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHVwZGF0ZSBlYWNoIHJvdyB3aGVyZSB0aGUgZXJyb3IgdmFyaWFibGVzIGV4aXN0LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByb3dzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dQYWlyID0gcm93cy5pdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHJvd1BhaXIuc2Vjb25kO1xuICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IHJvdy5jb2VmZmljaWVudEZvcihtYXJrZXIpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VmZiAhPT0gMC4wICYmIHJvdy5hZGQoZGVsdGEgKiBjb2VmZikgPCAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgcm93UGFpci5maXJzdC50eXBlKCkgIT09IFN5bWJvbFR5cGUuRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5mZWFzaWJsZVJvd3MucHVzaChyb3dQYWlyLmZpcnN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kdWFsT3B0aW1pemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSB2YXJpYWJsZXMuXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnVwZGF0ZVZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YXJzID0gdGhpcy5fdmFyTWFwO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZhcnMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSB2YXJzLml0ZW1BdChpKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93UGFpciA9IHJvd3MuZmluZChwYWlyLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1BhaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYWlyLmZpcnN0LnNldFZhbHVlKHJvd1BhaXIuc2Vjb25kLmNvbnN0YW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpci5maXJzdC5zZXRWYWx1ZSgwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3ltYm9sIGZvciB0aGUgZ2l2ZW4gdmFyaWFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgc3ltYm9sIGRvZXMgbm90IGV4aXN0IGZvciB0aGUgdmFyaWFibGUsIG9uZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLl9nZXRWYXJTeW1ib2wgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9tYWtlU3ltYm9sKFN5bWJvbFR5cGUuRXh0ZXJuYWwpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zhck1hcC5zZXREZWZhdWx0KHZhcmlhYmxlLCBmYWN0b3J5KS5zZWNvbmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgUm93IG9iamVjdCBmb3IgdGhlIGdpdmVuIGNvbnN0cmFpbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0ZXJtcyBpbiB0aGUgY29uc3RyYWludCB3aWxsIGJlIGNvbnZlcnRlZCB0byBjZWxscyBpbiB0aGUgcm93LlxuICAgICAgICAgKiBBbnkgdGVybSBpbiB0aGUgY29uc3RyYWludCB3aXRoIGEgY29lZmZpY2llbnQgb2YgemVybyBpcyBpZ25vcmVkLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBgX2dldFZhclN5bWJvbGAgbWV0aG9kIHRvIGdldCB0aGUgc3ltYm9sIGZvclxuICAgICAgICAgKiB0aGUgdmFyaWFibGVzIGFkZGVkIHRvIHRoZSByb3cuIElmIHRoZSBzeW1ib2wgZm9yIGEgZ2l2ZW4gY2VsbFxuICAgICAgICAgKiB2YXJpYWJsZSBpcyBiYXNpYywgdGhlIGNlbGwgdmFyaWFibGUgd2lsbCBiZSBzdWJzdGl0dXRlZCB3aXRoIHRoZVxuICAgICAgICAgKiBiYXNpYyByb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBuZWNlc3Nhcnkgc2xhY2sgYW5kIGVycm9yIHZhcmlhYmxlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSByb3cuXG4gICAgICAgICAqIElmIHRoZSBjb25zdGFudCBmb3IgdGhlIHJvdyBpcyBuZWdhdGl2ZSwgdGhlIHNpZ24gZm9yIHRoZSByb3dcbiAgICAgICAgICogd2lsbCBiZSBpbnZlcnRlZCBzbyB0aGUgY29uc3RhbnQgYmVjb21lcyBwb3NpdGl2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3JlYXRlZCBSb3cgYW5kIHRoZSB0YWcgZm9yIHRyYWNraW5nIHRoZSBjb25zdHJhaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fY3JlYXRlUm93ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHZhciBleHByID0gY29uc3RyYWludC5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICB2YXIgcm93ID0gbmV3IFJvdyhleHByLmNvbnN0YW50KCkpO1xuICAgICAgICAgICAgLy8gU3Vic3RpdHV0ZSB0aGUgY3VycmVudCBiYXNpYyB2YXJpYWJsZXMgaW50byB0aGUgcm93LlxuICAgICAgICAgICAgdmFyIHRlcm1zID0gZXhwci50ZXJtcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0ZXJtcy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybVBhaXIgPSB0ZXJtcy5pdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWFyWmVybyh0ZXJtUGFpci5zZWNvbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLl9nZXRWYXJTeW1ib2wodGVybVBhaXIuZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzaWNQYWlyID0gdGhpcy5fcm93TWFwLmZpbmQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2ljUGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0Um93KGJhc2ljUGFpci5zZWNvbmQsIHRlcm1QYWlyLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0U3ltYm9sKHN5bWJvbCwgdGVybVBhaXIuc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmVjZXNzYXJ5IHNsYWNrLCBlcnJvciwgYW5kIGR1bW15IHZhcmlhYmxlcy5cbiAgICAgICAgICAgIHZhciBvYmplY3RpdmUgPSB0aGlzLl9vYmplY3RpdmU7XG4gICAgICAgICAgICB2YXIgc3RyZW5ndGggPSBjb25zdHJhaW50LnN0cmVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgdGFnID0geyBtYXJrZXI6IElOVkFMSURfU1lNQk9MLCBvdGhlcjogSU5WQUxJRF9TWU1CT0wgfTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29uc3RyYWludC5vcCgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBraXdpLk9wZXJhdG9yLkxlOlxuICAgICAgICAgICAgICAgIGNhc2Uga2l3aS5PcGVyYXRvci5HZTpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gY29uc3RyYWludC5vcCgpID09PSBraXdpLk9wZXJhdG9yLkxlID8gMS4wIDogLTEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGFjayA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5TbGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcubWFya2VyID0gc2xhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0U3ltYm9sKHNsYWNrLCBjb2VmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZW5ndGggPCBraXdpLlN0cmVuZ3RoLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fbWFrZVN5bWJvbChTeW1ib2xUeXBlLkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcub3RoZXIgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0U3ltYm9sKGVycm9yLCAtY29lZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdGl2ZS5pbnNlcnRTeW1ib2woZXJyb3IsIHN0cmVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBraXdpLk9wZXJhdG9yLkVxOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZW5ndGggPCBraXdpLlN0cmVuZ3RoLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycnBsdXMgPSB0aGlzLl9tYWtlU3ltYm9sKFN5bWJvbFR5cGUuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJtaW51cyA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm1hcmtlciA9IGVycnBsdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm90aGVyID0gZXJybWludXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Lmluc2VydFN5bWJvbChlcnJwbHVzLCAtMS4wKTsgLy8gdiA9IGVwbHVzIC0gZW1pbnVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Lmluc2VydFN5bWJvbChlcnJtaW51cywgMS4wKTsgLy8gdiAtIGVwbHVzICsgZW1pbnVzID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdGl2ZS5pbnNlcnRTeW1ib2woZXJycGx1cywgc3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdGl2ZS5pbnNlcnRTeW1ib2woZXJybWludXMsIHN0cmVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teSA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5EdW1teSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLm1hcmtlciA9IGR1bW15O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pbnNlcnRTeW1ib2woZHVtbXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgcm93IGhhcyBhIHBvc2l0aXZlIGNvbnN0YW50LlxuICAgICAgICAgICAgaWYgKHJvdy5jb25zdGFudCgpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgcm93LnJldmVyc2VTaWduKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByb3c6IHJvdywgdGFnOiB0YWcgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENob29zZSB0aGUgc3ViamVjdCBmb3Igc29sdmluZyBmb3IgdGhlIHJvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjaG9vc2UgdGhlIGJlc3Qgc3ViamVjdCBmb3IgdXNpbmcgYXMgdGhlIHNvbHZlXG4gICAgICAgICAqIHRhcmdldCBmb3IgdGhlIHJvdy4gQW4gaW52YWxpZCBzeW1ib2wgd2lsbCBiZSByZXR1cm5lZCBpZiB0aGVyZVxuICAgICAgICAgKiBpcyBubyB2YWxpZCB0YXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzeW1ib2xzIGFyZSBjaG9zZW4gYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcHJlY2VkZW5jZTpcbiAgICAgICAgICpcbiAgICAgICAgICogMSkgVGhlIGZpcnN0IHN5bWJvbCByZXByZXNlbnRpbmcgYW4gZXh0ZXJuYWwgdmFyaWFibGUuXG4gICAgICAgICAqIDIpIEEgbmVnYXRpdmUgc2xhY2sgb3IgZXJyb3IgdGFnIHZhcmlhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHN1YmplY3QgY2Fubm90IGJlIGZvdW5kLCBhbiBpbnZhbGlkIHN5bWJvbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fY2hvb3NlU3ViamVjdCA9IGZ1bmN0aW9uIChyb3csIHRhZykge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gcm93LmNlbGxzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChwYWlyLmZpcnN0LnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci5maXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRhZy5tYXJrZXIudHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFN5bWJvbFR5cGUuU2xhY2sgfHwgdHlwZSA9PT0gU3ltYm9sVHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuY29lZmZpY2llbnRGb3IodGFnLm1hcmtlcikgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZy5tYXJrZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHRhZy5vdGhlci50eXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gU3ltYm9sVHlwZS5TbGFjayB8fCB0eXBlID09PSBTeW1ib2xUeXBlLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5jb2VmZmljaWVudEZvcih0YWcub3RoZXIpIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWcub3RoZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSURfU1lNQk9MO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHRoZSByb3cgdG8gdGhlIHRhYmxlYXUgdXNpbmcgYW4gYXJ0aWZpY2lhbCB2YXJpYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIHJldHVybiBmYWxzZSBpZiB0aGUgY29uc3RyYWludCBjYW5ub3QgYmUgc2F0aXNmaWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fYWRkV2l0aEFydGlmaWNpYWxWYXJpYWJsZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBhcnRpZmljaWFsIHZhcmlhYmxlIHRvIHRoZSB0YWJsZWF1LlxuICAgICAgICAgICAgdmFyIGFydCA9IHRoaXMuX21ha2VTeW1ib2woU3ltYm9sVHlwZS5TbGFjayk7XG4gICAgICAgICAgICB0aGlzLl9yb3dNYXAuaW5zZXJ0KGFydCwgcm93LmNvcHkoKSk7XG4gICAgICAgICAgICB0aGlzLl9hcnRpZmljaWFsID0gcm93LmNvcHkoKTtcbiAgICAgICAgICAgIC8vIE9wdGltaXplIHRoZSBhcnRpZmljaWFsIG9iamVjdGl2ZS4gVGhpcyBpcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICAvLyBvbmx5IGlmIHRoZSBhcnRpZmljaWFsIG9iamVjdGl2ZSBpcyBvcHRpbWl6ZWQgdG8gemVyby5cbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplKHRoaXMuX2FydGlmaWNpYWwpO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBuZWFyWmVybyh0aGlzLl9hcnRpZmljaWFsLmNvbnN0YW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fYXJ0aWZpY2lhbCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYXJ0aWZpY2lhbCB2YXJpYWJsZSBpcyBiYXNpYywgcGl2b3QgdGhlIHJvdyBzbyB0aGF0XG4gICAgICAgICAgICAvLyBpdCBiZWNvbWVzIG5vbi1iYXNpYy4gSWYgdGhlIHJvdyBpcyBjb25zdGFudCwgZXhpdCBlYXJseS5cbiAgICAgICAgICAgIHZhciBwYWlyID0gdGhpcy5fcm93TWFwLmVyYXNlKGFydCk7XG4gICAgICAgICAgICBpZiAocGFpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2ljUm93ID0gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2ljUm93LmlzQ29uc3RhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gdGhpcy5fYW55UGl2b3RhYmxlU3ltYm9sKGJhc2ljUm93KTtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJpbmcudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB1bnNhdGlzZmlhYmxlICh3aWxsIHRoaXMgZXZlciBoYXBwZW4/KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXNpY1Jvdy5zb2x2ZUZvckV4KGFydCwgZW50ZXJpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGUoZW50ZXJpbmcsIGJhc2ljUm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dNYXAuaW5zZXJ0KGVudGVyaW5nLCBiYXNpY1Jvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGFydGlmaWNpYWwgdmFyaWFibGUgZnJvbSB0aGUgdGFibGVhdS5cbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5fcm93TWFwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByb3dzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHJvd3MuaXRlbUF0KGkpLnNlY29uZC5yZW1vdmVTeW1ib2woYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29iamVjdGl2ZS5yZW1vdmVTeW1ib2woYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic3RpdHV0ZSB0aGUgcGFyYW1ldHJpYyBzeW1ib2wgd2l0aCB0aGUgZ2l2ZW4gcm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHN1YnN0aXR1dGUgYWxsIGluc3RhbmNlcyBvZiB0aGUgcGFyYW1ldHJpYyBzeW1ib2xcbiAgICAgICAgICogaW4gdGhlIHRhYmxlYXUgYW5kIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fc3Vic3RpdHV0ZSA9IGZ1bmN0aW9uIChzeW1ib2wsIHJvdykge1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJvd3Muc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSByb3dzLml0ZW1BdChpKTtcbiAgICAgICAgICAgICAgICBwYWlyLnNlY29uZC5zdWJzdGl0dXRlKHN5bWJvbCwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAocGFpci5zZWNvbmQuY29uc3RhbnQoKSA8IDAuMCAmJlxuICAgICAgICAgICAgICAgICAgICBwYWlyLmZpcnN0LnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmZlYXNpYmxlUm93cy5wdXNoKHBhaXIuZmlyc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29iamVjdGl2ZS5zdWJzdGl0dXRlKHN5bWJvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hcnRpZmljaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJ0aWZpY2lhbC5zdWJzdGl0dXRlKHN5bWJvbCwgcm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGltaXplIHRoZSBzeXN0ZW0gZm9yIHRoZSBnaXZlbiBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGl0ZXJhdGlvbnMgb2YgUGhhc2UgMiBvZiB0aGUgc2ltcGxleCBtZXRob2RcbiAgICAgICAgICogdW50aWwgdGhlIG9iamVjdGl2ZSBmdW5jdGlvbiByZWFjaGVzIGEgbWluaW11bS5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuX29wdGltaXplID0gZnVuY3Rpb24gKG9iamVjdGl2ZSkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLl9nZXRFbnRlcmluZ1N5bWJvbChvYmplY3RpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmluZy50eXBlKCkgPT09IFN5bWJvbFR5cGUuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZWF2aW5nID0gdGhpcy5fZ2V0TGVhdmluZ1N5bWJvbChlbnRlcmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmcudHlwZSgpID09PSBTeW1ib2xUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIG9iamVjdGl2ZSBpcyB1bmJvdW5kZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBpdm90IHRoZSBlbnRlcmluZyBzeW1ib2wgaW50byB0aGUgYmFzaXNcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5fcm93TWFwLmVyYXNlKGxlYXZpbmcpLnNlY29uZDtcbiAgICAgICAgICAgICAgICByb3cuc29sdmVGb3JFeChsZWF2aW5nLCBlbnRlcmluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic3RpdHV0ZShlbnRlcmluZywgcm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dNYXAuaW5zZXJ0KGVudGVyaW5nLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW1pemUgdGhlIHN5c3RlbSB1c2luZyB0aGUgZHVhbCBvZiB0aGUgc2ltcGxleCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzeXN0ZW0gc2hvdWxkIGJlIHN1Y2ggdGhhdCB0aGUgb2JqZWN0aXZlXG4gICAgICAgICAqIGZ1bmN0aW9uIGlzIG9wdGltYWwsIGJ1dCBub3QgZmVhc2libGUuIFRoaXMgbWV0aG9kIHdpbGwgcGVyZm9ybVxuICAgICAgICAgKiBhbiBpdGVyYXRpb24gb2YgdGhlIGR1YWwgc2ltcGxleCBtZXRob2QgdG8gbWFrZSB0aGUgc29sdXRpb24gYm90aFxuICAgICAgICAgKiBvcHRpbWFsIGFuZCBmZWFzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuX2R1YWxPcHRpbWl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5fcm93TWFwO1xuICAgICAgICAgICAgdmFyIGluZmVhc2libGUgPSB0aGlzLl9pbmZlYXNpYmxlUm93cztcbiAgICAgICAgICAgIHdoaWxlIChpbmZlYXNpYmxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWF2aW5nID0gaW5mZWFzaWJsZS5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHJvd3MuZmluZChsZWF2aW5nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFpciAhPT0gdW5kZWZpbmVkICYmIHBhaXIuc2Vjb25kLmNvbnN0YW50KCkgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGVyaW5nID0gdGhpcy5fZ2V0RHVhbEVudGVyaW5nU3ltYm9sKHBhaXIuc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGVyaW5nLnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5JbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdWFsIG9wdGltaXplIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBwaXZvdCB0aGUgZW50ZXJpbmcgc3ltYm9sIGludG8gdGhlIGJhc2lzXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBwYWlyLnNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgcm93cy5lcmFzZShsZWF2aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LnNvbHZlRm9yRXgobGVhdmluZywgZW50ZXJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzdGl0dXRlKGVudGVyaW5nLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICByb3dzLmluc2VydChlbnRlcmluZywgcm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBlbnRlcmluZyB2YXJpYWJsZSBmb3IgYSBwaXZvdCBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGZpcnN0IHN5bWJvbCBpbiB0aGUgb2JqZWN0aXZlIGZ1bmN0aW9uIHdoaWNoXG4gICAgICAgICAqIGlzIG5vbi1kdW1teSBhbmQgaGFzIGEgY29lZmZpY2llbnQgbGVzcyB0aGFuIHplcm8uIElmIG5vIHN5bWJvbCBtZWV0c1xuICAgICAgICAgKiB0aGUgY3JpdGVyaWEsIGl0IG1lYW5zIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24gaXMgYXQgYSBtaW5pbXVtLCBhbmQgYW5cbiAgICAgICAgICogaW52YWxpZCBzeW1ib2wgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRlcmluZ1N5bWJvbCA9IGZ1bmN0aW9uIChvYmplY3RpdmUpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IG9iamVjdGl2ZS5jZWxscygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGNlbGxzLml0ZW1BdChpKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gcGFpci5maXJzdDtcbiAgICAgICAgICAgICAgICBpZiAocGFpci5zZWNvbmQgPCAwLjAgJiYgc3ltYm9sLnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5EdW1teSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEX1NZTUJPTDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGUgdGhlIGVudGVyaW5nIHN5bWJvbCBmb3IgdGhlIGR1YWwgb3B0aW1pemUgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc3ltYm9sIGluIHRoZSByb3cgd2hpY2ggaGFzIGEgcG9zaXRpdmVcbiAgICAgICAgICogY29lZmZpY2llbnQgYW5kIHlpZWxkcyB0aGUgbWluaW11bSByYXRpbyBmb3IgaXRzIHJlc3BlY3RpdmUgc3ltYm9sXG4gICAgICAgICAqIGluIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24uIFRoZSBwcm92aWRlZCByb3cgKm11c3QqIGJlIGluZmVhc2libGUuXG4gICAgICAgICAqIElmIG5vIHN5bWJvbCBpcyBmb3VuZCB3aGljaCBtZWF0cyB0aGUgY3JpdGVyaWEsIGFuIGludmFsaWQgc3ltYm9sXG4gICAgICAgICAqIGlzIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fZ2V0RHVhbEVudGVyaW5nU3ltYm9sID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IElOVkFMSURfU1lNQk9MO1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gcm93LmNlbGxzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBwYWlyLmZpcnN0O1xuICAgICAgICAgICAgICAgIHZhciBjID0gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiAwLjAgJiYgc3ltYm9sLnR5cGUoKSAhPT0gU3ltYm9sVHlwZS5EdW1teSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29lZmYgPSB0aGlzLl9vYmplY3RpdmUuY29lZmZpY2llbnRGb3Ioc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjb2VmZiAvIGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIDwgcmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyaW5nID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudGVyaW5nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZSB0aGUgc3ltYm9sIGZvciBwaXZvdCBleGl0IHJvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHN5bWJvbCBmb3IgdGhlIGV4aXQgcm93IGluIHRoZSByb3dcbiAgICAgICAgICogbWFwLiBJZiBubyBhcHByb3ByaWF0ZSBleGl0IHN5bWJvbCBpcyBmb3VuZCwgYW4gaW52YWxpZCBzeW1ib2xcbiAgICAgICAgICogd2lsbCBiZSByZXR1cm5lZC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgb2JqZWN0aXZlIGZ1bmN0aW9uIGlzXG4gICAgICAgICAqIHVuYm91bmRlZC5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuX2dldExlYXZpbmdTeW1ib2wgPSBmdW5jdGlvbiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBJTlZBTElEX1NZTUJPTDtcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5fcm93TWFwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByb3dzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcm93cy5pdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHBhaXIuZmlyc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbC50eXBlKCkgIT09IFN5bWJvbFR5cGUuRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHBhaXIuc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHJvdy5jb2VmZmljaWVudEZvcihlbnRlcmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcF9yYXRpbyA9IC1yb3cuY29uc3RhbnQoKSAvIHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcF9yYXRpbyA8IHJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW8gPSB0ZW1wX3JhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZSB0aGUgbGVhdmluZyBzeW1ib2wgZm9yIGEgbWFya2VyIHZhcmlhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIHN5bWJvbCBjb3JyZXNwb25kaW5nIHRvIGEgYmFzaWMgcm93XG4gICAgICAgICAqIHdoaWNoIGhvbGRzIHRoZSBnaXZlbiBtYXJrZXIgdmFyaWFibGUuIFRoZSByb3cgd2lsbCBiZSBjaG9zZW5cbiAgICAgICAgICogYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcHJlY2VkZW5jZTpcbiAgICAgICAgICpcbiAgICAgICAgICogMSkgVGhlIHJvdyB3aXRoIGEgcmVzdHJpY3RlZCBiYXNpYyB2YXJpYmxlIGFuZCBhIG5lZ2F0aXZlIGNvZWZmaWNpZW50XG4gICAgICAgICAqICAgIGZvciB0aGUgbWFya2VyIHdpdGggdGhlIHNtYWxsZXN0IHJhdGlvIG9mIC1jb25zdGFudCAvIGNvZWZmaWNpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAyKSBUaGUgcm93IHdpdGggYSByZXN0cmljdGVkIGJhc2ljIHZhcmlhYmxlIGFuZCB0aGUgc21hbGxlc3QgcmF0aW9cbiAgICAgICAgICogICAgb2YgY29uc3RhbnQgLyBjb2VmZmljaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogMykgVGhlIGxhc3QgdW5yZXN0cmljdGVkIHJvdyB3aGljaCBjb250YWlucyB0aGUgbWFya2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgbWFya2VyIGRvZXMgbm90IGV4aXN0IGluIGFueSByb3csIGFuIGludmFsaWQgc3ltYm9sIHdpbGwgYmVcbiAgICAgICAgICogcmV0dXJuZWQuIFRoaXMgaW5kaWNhdGVzIGFuIGludGVybmFsIHNvbHZlciBlcnJvciBzaW5jZSB0aGUgbWFya2VyXG4gICAgICAgICAqICpzaG91bGQqIGV4aXN0IHNvbWV3aGVyZSBpbiB0aGUgdGFibGVhdS5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuX2dldE1hcmtlckxlYXZpbmdTeW1ib2wgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICB2YXIgZG1heCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB2YXIgcjEgPSBkbWF4O1xuICAgICAgICAgICAgdmFyIHIyID0gZG1heDtcbiAgICAgICAgICAgIHZhciBpbnZhbGlkID0gSU5WQUxJRF9TWU1CT0w7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBpbnZhbGlkO1xuICAgICAgICAgICAgdmFyIHNlY29uZCA9IGludmFsaWQ7XG4gICAgICAgICAgICB2YXIgdGhpcmQgPSBpbnZhbGlkO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dNYXA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJvd3Muc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSByb3dzLml0ZW1BdChpKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSByb3cuY29lZmZpY2llbnRGb3IobWFya2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gcGFpci5maXJzdDtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sLnR5cGUoKSA9PT0gU3ltYm9sVHlwZS5FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlyZCA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IC1yb3cuY29uc3RhbnQoKSAvIGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIDwgcjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIxID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHJvdy5jb25zdGFudCgpIC8gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCByMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcjIgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0ICE9PSBpbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlY29uZCAhPT0gaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGVmZmVjdHMgb2YgYSBjb25zdHJhaW50IG9uIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLl9yZW1vdmVDb25zdHJhaW50RWZmZWN0cyA9IGZ1bmN0aW9uIChjbiwgdGFnKSB7XG4gICAgICAgICAgICBpZiAodGFnLm1hcmtlci50eXBlKCkgPT09IFN5bWJvbFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVNYXJrZXJFZmZlY3RzKHRhZy5tYXJrZXIsIGNuLnN0cmVuZ3RoKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZy5vdGhlci50eXBlKCkgPT09IFN5bWJvbFR5cGUuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVNYXJrZXJFZmZlY3RzKHRhZy5vdGhlciwgY24uc3RyZW5ndGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGVmZmVjdHMgb2YgYW4gZXJyb3IgbWFya2VyIG9uIHRoZSBvYmplY3RpdmUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLl9yZW1vdmVNYXJrZXJFZmZlY3RzID0gZnVuY3Rpb24gKG1hcmtlciwgc3RyZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gdGhpcy5fcm93TWFwLmZpbmQobWFya2VyKTtcbiAgICAgICAgICAgIGlmIChwYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RpdmUuaW5zZXJ0Um93KHBhaXIuc2Vjb25kLCAtc3RyZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0aXZlLmluc2VydFN5bWJvbChtYXJrZXIsIC1zdHJlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZpcnN0IFNsYWNrIG9yIEVycm9yIHN5bWJvbCBpbiB0aGUgcm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBzdWNoIHN5bWJvbCBpcyBwcmVzZW50LCBhbiBpbnZhbGlkIHN5bWJvbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5fYW55UGl2b3RhYmxlU3ltYm9sID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gcm93LmNlbGxzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLnNpemUoKTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gY2VsbHMuaXRlbUF0KGkpO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcGFpci5maXJzdC50eXBlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFN5bWJvbFR5cGUuU2xhY2sgfHwgdHlwZSA9PT0gU3ltYm9sVHlwZS5FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci5maXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRF9TWU1CT0w7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IFN5bWJvbCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuX21ha2VTeW1ib2wgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2wodHlwZSwgdGhpcy5faWRUaWNrKyspO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU29sdmVyO1xuICAgIH0oKSk7XG4gICAga2l3aS5Tb2x2ZXIgPSBTb2x2ZXI7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYXBwcm94aW1hdGVseSB6ZXJvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lYXJaZXJvKHZhbHVlKSB7XG4gICAgICAgIHZhciBlcHMgPSAxLjBlLTg7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAuMCA/IC12YWx1ZSA8IGVwcyA6IHZhbHVlIDwgZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBjb25zdHJhaW50IG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDbk1hcCgpIHtcbiAgICAgICAgcmV0dXJuIGtpd2kuY3JlYXRlTWFwKGtpd2kuQ29uc3RyYWludC5Db21wYXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcm93IG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3dNYXAoKSB7XG4gICAgICAgIHJldHVybiBraXdpLmNyZWF0ZU1hcChTeW1ib2wuQ29tcGFyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHZhcmlhYmxlIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVWYXJNYXAoKSB7XG4gICAgICAgIHJldHVybiBraXdpLmNyZWF0ZU1hcChraXdpLlZhcmlhYmxlLkNvbXBhcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW4gZWRpdCBtYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRWRpdE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIGtpd2kuY3JlYXRlTWFwKGtpd2kuVmFyaWFibGUuQ29tcGFyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGVudW0gZGVmaW5pbmcgdGhlIGF2YWlsYWJsZSBzeW1ib2wgdHlwZXMuXG4gICAgICovXG4gICAgdmFyIFN5bWJvbFR5cGU7XG4gICAgKGZ1bmN0aW9uIChTeW1ib2xUeXBlKSB7XG4gICAgICAgIFN5bWJvbFR5cGVbU3ltYm9sVHlwZVtcIkludmFsaWRcIl0gPSAwXSA9IFwiSW52YWxpZFwiO1xuICAgICAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJFeHRlcm5hbFwiXSA9IDFdID0gXCJFeHRlcm5hbFwiO1xuICAgICAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJTbGFja1wiXSA9IDJdID0gXCJTbGFja1wiO1xuICAgICAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xuICAgICAgICBTeW1ib2xUeXBlW1N5bWJvbFR5cGVbXCJEdW1teVwiXSA9IDRdID0gXCJEdW1teVwiO1xuICAgIH0pKFN5bWJvbFR5cGUgfHwgKFN5bWJvbFR5cGUgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHN5bWJvbCBpbiB0aGUgc29sdmVyLlxuICAgICAqL1xuICAgIHZhciBTeW1ib2wgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IFN5bWJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gW3R5cGVdIFRoZSB0eXBlIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqIEBwYXJhbSBbaWRdIFRoZSB1bmlxdWUgaWQgbnVtYmVyIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTeW1ib2wodHlwZSwgaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRpYyBTeW1ib2wgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFN5bWJvbC5Db21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmlkKCkgLSBiLmlkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgbnVtYmVyIG9mIHRoZSBzeW1ib2wuXG4gICAgICAgICAqL1xuICAgICAgICBTeW1ib2wucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgc3ltYm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgU3ltYm9sLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTeW1ib2w7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBpbnZhbGlkIHN5bWJvbFxuICAgICAqL1xuICAgIHZhciBJTlZBTElEX1NZTUJPTCA9IG5ldyBTeW1ib2woU3ltYm9sVHlwZS5JbnZhbGlkLCAtMSk7XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcm93IGNsYXNzIHVzZWQgYnkgdGhlIHNvbHZlci5cbiAgICAgKi9cbiAgICB2YXIgUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBSb3cuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSb3coY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGlmIChjb25zdGFudCA9PT0gdm9pZCAwKSB7IGNvbnN0YW50ID0gMC4wOyB9XG4gICAgICAgICAgICB0aGlzLl9jZWxsTWFwID0ga2l3aS5jcmVhdGVNYXAoU3ltYm9sLkNvbXBhcmUpO1xuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbWFwcGluZyBvZiBzeW1ib2xzIHRvIGNvZWZmaWNpZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIFJvdy5wcm90b3R5cGUuY2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE1hcDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbnN0YW50IGZvciB0aGUgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5jb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25zdGFudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm93IGlzIGEgY29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE1hcC5lbXB0eSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBSb3cgaGFzIGFsbCBkdW1teSBzeW1ib2xzLlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5hbGxEdW1taWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5fY2VsbE1hcDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBjZWxscy5pdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXIuZmlyc3QudHlwZSgpICE9PSBTeW1ib2xUeXBlLkR1bW15KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHJvdy5cbiAgICAgICAgICovXG4gICAgICAgIFJvdy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGVDb3B5ID0gbmV3IFJvdyh0aGlzLl9jb25zdGFudCk7XG4gICAgICAgICAgICB0aGVDb3B5Ll9jZWxsTWFwID0gdGhpcy5fY2VsbE1hcC5jb3B5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhlQ29weTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGNvbnN0YW50IHZhbHVlIHRvIHRoZSByb3cgY29uc3RhbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY29uc3RhbnQuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0YW50ICs9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IHRoZSBzeW1ib2wgaW50byB0aGUgcm93IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgc3ltYm9sIGFscmVhZHkgZXhpc3RzIGluIHRoZSByb3csIHRoZSBjb2VmZmljaWVudFxuICAgICAgICAgKiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBleGlzdGluZyBjb2VmZmljaWVudC4gSWYgdGhlIHJlc3VsdGluZ1xuICAgICAgICAgKiBjb2VmZmljaWVudCBpcyB6ZXJvLCB0aGUgc3ltYm9sIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSByb3cuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLmluc2VydFN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IHZvaWQgMCkgeyBjb2VmZmljaWVudCA9IDEuMDsgfVxuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLl9jZWxsTWFwLnNldERlZmF1bHQoc3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjA7IH0pO1xuICAgICAgICAgICAgaWYgKG5lYXJaZXJvKHBhaXIuc2Vjb25kICs9IGNvZWZmaWNpZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NlbGxNYXAuZXJhc2Uoc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIHJvdyBpbnRvIHRoaXMgcm93IHdpdGggYSBnaXZlbiBjb2VmZmljaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNvbnN0YW50IGFuZCB0aGUgY2VsbHMgb2YgdGhlIG90aGVyIHJvdyB3aWxsIGJlXG4gICAgICAgICAqIG11bHRpcGxpZWQgYnkgdGhlIGNvZWZmaWNpZW50IGFuZCBhZGRlZCB0byB0aGlzIHJvdy4gQW55XG4gICAgICAgICAqIGNlbGwgd2l0aCBhIHJlc3VsdGluZyBjb2VmZmljaWVudCBvZiB6ZXJvIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICAgKiBmcm9tIHRoZSByb3cuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLmluc2VydFJvdyA9IGZ1bmN0aW9uIChvdGhlciwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gdm9pZCAwKSB7IGNvZWZmaWNpZW50ID0gMS4wOyB9XG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudCArPSBvdGhlci5fY29uc3RhbnQgKiBjb2VmZmljaWVudDtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IG90aGVyLl9jZWxsTWFwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5zaXplKCk7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGNlbGxzLml0ZW1BdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydFN5bWJvbChwYWlyLmZpcnN0LCBwYWlyLnNlY29uZCAqIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHN5bWJvbCBmcm9tIHRoZSByb3cuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLnJlbW92ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxNYXAuZXJhc2Uoc3ltYm9sKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldmVyc2UgdGhlIHNpZ24gb2YgdGhlIGNvbnN0YW50IGFuZCBjZWxscyBpbiB0aGUgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5yZXZlcnNlU2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50ID0gLXRoaXMuX2NvbnN0YW50O1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5fY2VsbE1hcDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBjZWxscy5pdGVtQXQoaSk7XG4gICAgICAgICAgICAgICAgcGFpci5zZWNvbmQgPSAtcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb2x2ZSB0aGUgcm93IGZvciB0aGUgZ2l2ZW4gc3ltYm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoZSByb3cgaXMgb2YgdGhlIGZvcm1cbiAgICAgICAgICogYSAqIHggKyBiICogeSArIGMgPSAwIGFuZCAoYXNzdW1pbmcgc29sdmUgZm9yIHgpIHdpbGwgbW9kaWZ5XG4gICAgICAgICAqIHRoZSByb3cgdG8gcmVwcmVzZW50IHRoZSByaWdodCBoYW5kIHNpZGUgb2ZcbiAgICAgICAgICogeCA9IC1iL2EgKiB5IC0gYyAvIGEuIFRoZSB0YXJnZXQgc3ltYm9sIHdpbGwgYmUgcmVtb3ZlZCBmcm9tXG4gICAgICAgICAqIHRoZSByb3csIGFuZCB0aGUgY29uc3RhbnQgYW5kIG90aGVyIGNlbGxzIHdpbGwgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBieSB0aGUgbmVnYXRpdmUgaW52ZXJzZSBvZiB0aGUgdGFyZ2V0IGNvZWZmaWNpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZ2l2ZW4gc3ltYm9sICptdXN0KiBleGlzdCBpbiB0aGUgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5zb2x2ZUZvciA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuX2NlbGxNYXA7XG4gICAgICAgICAgICB2YXIgcGFpciA9IGNlbGxzLmVyYXNlKHN5bWJvbCk7XG4gICAgICAgICAgICB2YXIgY29lZmYgPSAtMS4wIC8gcGFpci5zZWNvbmQ7XG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudCAqPSBjb2VmZjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMuc2l6ZSgpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMuaXRlbUF0KGkpLnNlY29uZCAqPSBjb2VmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbHZlIHRoZSByb3cgZm9yIHRoZSBnaXZlbiBzeW1ib2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoZSByb3cgaXMgb2YgdGhlIGZvcm1cbiAgICAgICAgICogeCA9IGIgKiB5ICsgYyBhbmQgd2lsbCBzb2x2ZSB0aGUgcm93IHN1Y2ggdGhhdFxuICAgICAgICAgKiB5ID0geCAvIGIgLSBjIC8gYi4gVGhlIHJocyBzeW1ib2wgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgICAqIHJvdywgdGhlIGxocyBhZGRlZCwgYW5kIHRoZSByZXN1bHQgZGl2aWRlZCBieSB0aGUgbmVnYXRpdmVcbiAgICAgICAgICogaW52ZXJzZSBvZiB0aGUgcmhzIGNvZWZmaWNpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbGhzIHN5bWJvbCAqbXVzdCBub3QqIGV4aXN0IGluIHRoZSByb3csIGFuZCB0aGUgcmhzXG4gICAgICAgICAqIHN5bWJvbCBtdXN0KiBleGlzdCBpbiB0aGUgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5zb2x2ZUZvckV4ID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydFN5bWJvbChsaHMsIC0xLjApO1xuICAgICAgICAgICAgdGhpcy5zb2x2ZUZvcihyaHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29lZmZpY2llbnQgZm9yIHRoZSBnaXZlbiBzeW1ib2wuXG4gICAgICAgICAqL1xuICAgICAgICBSb3cucHJvdG90eXBlLmNvZWZmaWNpZW50Rm9yID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLl9jZWxsTWFwLmZpbmQoc3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiBwYWlyICE9PSB1bmRlZmluZWQgPyBwYWlyLnNlY29uZCA6IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnN0aXR1dGUgYSBzeW1ib2wgd2l0aCB0aGUgZGF0YSBmcm9tIGFub3RoZXIgcm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBHaXZlbiBhIHJvdyBvZiB0aGUgZm9ybSBhICogeCArIGIgYW5kIGEgc3Vic3RpdHV0aW9uIG9mIHRoZVxuICAgICAgICAgKiBmb3JtIHggPSAzICogeSArIGMgdGhlIHJvdyB3aWxsIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGVcbiAgICAgICAgICogZXhwcmVzc2lvbiAzICogYSAqIHkgKyBhICogYyArIGIuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBzeW1ib2wgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJvdywgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAgICAgKi9cbiAgICAgICAgUm93LnByb3RvdHlwZS5zdWJzdGl0dXRlID0gZnVuY3Rpb24gKHN5bWJvbCwgcm93KSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHRoaXMuX2NlbGxNYXAuZXJhc2Uoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChwYWlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydFJvdyhyb3csIHBhaXIuc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJvdztcbiAgICB9KCkpO1xufSkoa2l3aSB8fCAoa2l3aSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIHZhciBTdHJlbmd0aDtcbiAgICAoZnVuY3Rpb24gKFN0cmVuZ3RoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc3ltYm9saWMgc3RyZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGUoYSwgYiwgYywgdykge1xuICAgICAgICAgICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMS4wOyB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMC4wO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMTAwMC4wLCBhICogdykpICogMTAwMDAwMC4wO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMTAwMC4wLCBiICogdykpICogMTAwMC4wO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMTAwMC4wLCBjICogdykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBTdHJlbmd0aC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ3JlcXVpcmVkJyBzeW1ib2xpYyBzdHJlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIFN0cmVuZ3RoLnJlcXVpcmVkID0gY3JlYXRlKDEwMDAuMCwgMTAwMC4wLCAxMDAwLjApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdzdHJvbmcnIHN5bWJvbGljIHN0cmVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RyZW5ndGguc3Ryb25nID0gY3JlYXRlKDEuMCwgMC4wLCAwLjApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdtZWRpdW0nIHN5bWJvbGljIHN0cmVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RyZW5ndGgubWVkaXVtID0gY3JlYXRlKDAuMCwgMS4wLCAwLjApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICd3ZWFrJyBzeW1ib2xpYyBzdHJlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIFN0cmVuZ3RoLndlYWsgPSBjcmVhdGUoMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGlwIGEgc3ltYm9saWMgc3RyZW5ndGggdG8gdGhlIGFsbG93ZWQgbWluIGFuZCBtYXguXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjbGlwKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbihTdHJlbmd0aC5yZXF1aXJlZCwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBTdHJlbmd0aC5jbGlwID0gY2xpcDtcbiAgICB9KShTdHJlbmd0aCA9IGtpd2kuU3RyZW5ndGggfHwgKGtpd2kuU3RyZW5ndGggPSB7fSkpO1xufSkoa2l3aSB8fCAoa2l3aSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIga2l3aTtcbihmdW5jdGlvbiAoa2l3aSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHVzZXIgY29uc3RyYWludCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqL1xuICAgIHZhciBWYXJpYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgVmFyaWFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIFtuYW1lXSBUaGUgbmFtZSB0byBhc3NvY2lhdGVkIHdpdGggdGhlIHZhcmlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmFyaWFibGUobmFtZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJcIjsgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gVmFySWQrKztcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0YXRpYyB2YXJpYWJsZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFyaWFibGUuQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pZCgpIC0gYi5pZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkIG51bWJlciBvZiB0aGUgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBWYXJpYWJsZS5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhcmlhYmxlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFyaWFibGUucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1c2VyIGNvbnRleHQgb2JqZWN0IG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhcmlhYmxlLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHVzZXIgY29udGV4dCBvYmplY3Qgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFyaWFibGUucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBWYXJpYWJsZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhcmlhYmxlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZhcmlhYmxlO1xuICAgIH0oKSk7XG4gICAga2l3aS5WYXJpYWJsZSA9IFZhcmlhYmxlO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB2YXJpYWJsZSBpZCBjb3VudGVyLlxuICAgICAqL1xuICAgIHZhciBWYXJJZCA9IDA7XG59KShraXdpIHx8IChraXdpID0ge30pKTtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciB0c3U7XG4oZnVuY3Rpb24gKHRzdSkge1xuICAgIC8qKlxuICAgICogUGVyZm9ybSBhIGxvd2VyIGJvdW5kIHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAqXG4gICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IG9mIHNvcnRlZCBpdGVtcyB0byBzZWFyY2guXG4gICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGxvY2F0ZWQgaW4gdGhlIGFycmF5LlxuICAgICogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHdoaWNoXG4gICAgKiAgICAgICAgICBjb21wYXJlcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgICovXG4gICAgZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGJlZ2luID0gMDtcbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBoYWxmO1xuICAgICAgICB2YXIgbWlkZGxlO1xuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgIGhhbGYgPSBuID4+IDE7XG4gICAgICAgICAgICBtaWRkbGUgPSBiZWdpbiArIGhhbGY7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShhcnJheVttaWRkbGVdLCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgYmVnaW4gPSBtaWRkbGUgKyAxO1xuICAgICAgICAgICAgICAgIG4gLT0gaGFsZiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gaGFsZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVnaW47XG4gICAgfVxuICAgIHRzdS5sb3dlckJvdW5kID0gbG93ZXJCb3VuZDtcbiAgICAvKipcbiAgICAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICpcbiAgICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgb2Ygc29ydGVkIGl0ZW1zIHRvIHNlYXJjaC5cbiAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gbG9jYXRlZCBpbiB0aGUgYXJyYXkuXG4gICAgKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZm91bmQgaXRlbSwgb3IgLTEuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIHZhbHVlLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxvd2VyQm91bmQoYXJyYXksIHZhbHVlLCBjb21wYXJlKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICB0c3UuYmluYXJ5U2VhcmNoID0gYmluYXJ5U2VhcmNoO1xuICAgIC8qKlxuICAgICogUGVyZm9ybSBhIGJpbmFyeSBmaW5kIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICpcbiAgICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgb2Ygc29ydGVkIGl0ZW1zIHRvIHNlYXJjaC5cbiAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gbG9jYXRlZCBpbiB0aGUgYXJyYXkuXG4gICAgKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm5zIFRoZSBmb3VuZCBpdGVtIGluIHRoZSBhcnJheSwgb3IgdW5kZWZpbmVkLlxuICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5RmluZChhcnJheSwgdmFsdWUsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICB0c3UuYmluYXJ5RmluZCA9IGJpbmFyeUZpbmQ7XG4gICAgZnVuY3Rpb24gYXNTZXQoaXRlbXMsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gdHN1LmFzQXJyYXkoaXRlbXMpO1xuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGFycmF5LnNvcnQoY29tcGFyZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbYXJyYXlbMF1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgaiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY29tcGFyZShyZXN1bHRbal0sIGl0ZW0pICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRzdS5hc1NldCA9IGFzU2V0O1xuICAgIC8qKlxuICAgICogVGVzdCB3aGV0aGVyIGEgdHdvIHNvcnRlZCBhcnJheXMgc2V0cyBhcmUgZGlzam9pbnQuXG4gICAgKlxuICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBzb3J0ZWQgYXJyYXkgc2V0LlxuICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHNvcnRlZCBhcnJheSBzZXQuXG4gICAgKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNldHMgYXJlIGRpc2pvaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBzZXRJc0Rpc2pvaW50KGZpcnN0LCBzZWNvbmQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICAgICAgdmFyIGxlbjEgPSBmaXJzdC5sZW5ndGg7XG4gICAgICAgIHZhciBsZW4yID0gc2Vjb25kLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4xICYmIGogPCBsZW4yKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvbXBhcmUoZmlyc3RbaV0sIHNlY29uZFtqXSk7XG4gICAgICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHN1LnNldElzRGlzam9pbnQgPSBzZXRJc0Rpc2pvaW50O1xuICAgIC8qKlxuICAgICogVGVzdCB3aGV0aGVyIG9uZSBzb3J0ZWQgYXJyYXkgc2V0IGlzIHRoZSBzdWJzZXQgb2YgYW5vdGhlci5cbiAgICAqXG4gICAgKiBAcGFyYW0gZmlyc3QgVGhlIHBvdGVudGlhbCBzdWJzZXQuXG4gICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBwb3RlbnRpYWwgc3VwZXJzZXQuXG4gICAgKiBAcGFyYW0gY29tcGFyZSBUaGUgdmFsdWUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpcnN0IHNldCBpcyBhIHN1YnNldCBvZiB0aGUgc2Vjb25kLlxuICAgICovXG4gICAgZnVuY3Rpb24gc2V0SXNTdWJzZXQoZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGVuMSA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbjIgPSBzZWNvbmQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuMSA+IGxlbjIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbjEgJiYgaiA8IGxlbjIpIHtcbiAgICAgICAgICAgIHZhciB2ID0gY29tcGFyZShmaXJzdFtpXSwgc2Vjb25kW2pdKTtcbiAgICAgICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbjEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHN1LnNldElzU3Vic2V0ID0gc2V0SXNTdWJzZXQ7XG4gICAgLyoqXG4gICAgKiBDcmVhdGUgdGhlIHNldCB1bmlvbiBvZiB0d28gc29ydGVkIHNldCBhcnJheXMuXG4gICAgdmFyIGogPSAwO1xuICAgICpcbiAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3Qgc29ydGVkIGFycmF5IHNldC5cbiAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBzb3J0ZWQgYXJyYXkgc2V0LlxuICAgICogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgKiBAcmV0dXJucyBUaGUgc2V0IHVuaW9uIG9mIHRoZSB0d28gYXJyYXlzLlxuICAgICovXG4gICAgZnVuY3Rpb24gc2V0VW5pb24oZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgICAgICB2YXIgbGVuMSA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbjIgPSBzZWNvbmQubGVuZ3RoO1xuICAgICAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICAgICAgdmFyIGEgPSBmaXJzdFtpXTtcbiAgICAgICAgICAgIHZhciBiID0gc2Vjb25kW2pdO1xuICAgICAgICAgICAgdmFyIHYgPSBjb21wYXJlKGEsIGIpO1xuICAgICAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodiA+IDApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChiKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChhKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbGVuMSkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goZmlyc3RbaV0pO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChqIDwgbGVuMikge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goc2Vjb25kW2pdKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICB0c3Uuc2V0VW5pb24gPSBzZXRVbmlvbjtcbiAgICAvKipcbiAgICAqIENyZWF0ZSBhIHNldCBpbnRlcnNlY3Rpb24gb2YgdHdvIHNvcnRlZCBzZXQgYXJyYXlzLlxuICAgICpcbiAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3Qgc29ydGVkIGFycmF5IHNldC5cbiAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBzb3J0ZWQgYXJyYXkgc2V0LlxuICAgICogQHBhcmFtIGNvbXBhcmUgVGhlIHZhbHVlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgKiBAcmV0dXJucyBUaGUgc2V0IGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGFycmF5cy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEludGVyc2VjdGlvbihmaXJzdCwgc2Vjb25kLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgICAgIHZhciBsZW4xID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuMiA9IHNlY29uZC5sZW5ndGg7XG4gICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4xICYmIGogPCBsZW4yKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZpcnN0W2ldO1xuICAgICAgICAgICAgdmFyIGIgPSBzZWNvbmRbal07XG4gICAgICAgICAgICB2YXIgdiA9IGNvbXBhcmUoYSwgYik7XG4gICAgICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEpO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgdHN1LnNldEludGVyc2VjdGlvbiA9IHNldEludGVyc2VjdGlvbjtcbiAgICAvKipcbiAgICAqIENyZWF0ZSBhIHNldCBkaWZmZXJlbmNlIG9mIHR3byBzb3J0ZWQgc2V0IGFycmF5cy5cbiAgICAqXG4gICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IHNvcnRlZCBhcnJheSBzZXQuXG4gICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgc29ydGVkIGFycmF5IHNldC5cbiAgICAqIEBwYXJhbSBjb21wYXJlIFRoZSB2YWx1ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICogQHJldHVybnMgVGhlIHNldCBkaWZmZXJlbmNlIG9mIHRoZSB0d28gYXJyYXlzLlxuICAgICovXG4gICAgZnVuY3Rpb24gc2V0RGlmZmVyZW5jZShmaXJzdCwgc2Vjb25kLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgICAgIHZhciBsZW4xID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuMiA9IHNlY29uZC5sZW5ndGg7XG4gICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4xICYmIGogPCBsZW4yKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZpcnN0W2ldO1xuICAgICAgICAgICAgdmFyIGIgPSBzZWNvbmRbal07XG4gICAgICAgICAgICB2YXIgdiA9IGNvbXBhcmUoYSwgYik7XG4gICAgICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChhKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4xKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChmaXJzdFtpXSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgdHN1LnNldERpZmZlcmVuY2UgPSBzZXREaWZmZXJlbmNlO1xuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgc2V0IHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHR3byBzb3J0ZWQgc2V0IGFycmF5cy5cbiAgICAqXG4gICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IHNvcnRlZCBhcnJheSBzZXQuXG4gICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgc29ydGVkIGFycmF5IHNldC5cbiAgICAqIEBwYXJhbSBjb21wYXJlIFRoZSB2YWx1ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICogQHJldHVybnMgVGhlIHNldCBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgdHdvIGFycmF5cy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFN5bW1ldHJpY0RpZmZlcmVuY2UoZmlyc3QsIHNlY29uZCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgaSA9IDAsIGogPSAwO1xuICAgICAgICB2YXIgbGVuMSA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbjIgPSBzZWNvbmQubGVuZ3RoO1xuICAgICAgICB2YXIgbWVyZ2VkID0gW107XG4gICAgICAgIHdoaWxlIChpIDwgbGVuMSAmJiBqIDwgbGVuMikge1xuICAgICAgICAgICAgdmFyIGEgPSBmaXJzdFtpXTtcbiAgICAgICAgICAgIHZhciBiID0gc2Vjb25kW2pdO1xuICAgICAgICAgICAgdmFyIHYgPSBjb21wYXJlKGEsIGIpO1xuICAgICAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodiA+IDApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChiKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbGVuMSkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goZmlyc3RbaV0pO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChqIDwgbGVuMikge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goc2Vjb25kW2pdKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICB0c3Uuc2V0U3ltbWV0cmljRGlmZmVyZW5jZSA9IHNldFN5bW1ldHJpY0RpZmZlcmVuY2U7XG59KSh0c3UgfHwgKHRzdSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgdHN1O1xuKGZ1bmN0aW9uICh0c3UpIHtcbiAgICAvKipcbiAgICAqIEEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIGFycmF5LWJhc2VkIGRhdGEgc3RydWN0dXJlcy5cbiAgICAqXG4gICAgKiBAY2xhc3NcbiAgICAqL1xuICAgIHZhciBBcnJheUJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBcnJheUJhc2UoKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBUaGUgaW50ZXJuYWwgZGF0YSBhcnJheS5cbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXJyYXlCYXNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcnJheSBpcyBlbXB0eS5cbiAgICAgICAgKi9cbiAgICAgICAgQXJyYXlCYXNlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheS5sZW5ndGggPT09IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGFycmF5IGluZGV4LlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIGluZGV4IFRoZSBpbnRlZ2VyIGluZGV4IG9mIHRoZSBkZXNpcmVkIGl0ZW0uXG4gICAgICAgICovXG4gICAgICAgIEFycmF5QmFzZS5wcm90b3R5cGUuaXRlbUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW50ZWdlciBpbmRleCBvZiB0aGUgZGVzaXJlZCBpdGVtLlxuICAgICAgICAqL1xuICAgICAgICBBcnJheUJhc2UucHJvdG90eXBlLnRha2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5LnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIENsZWFyIHRoZSBpbnRlcm5hbCBjb250ZW50cyBvZiBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXJyYXlCYXNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFN3YXAgdGhpcyBhcnJheSdzIGNvbnRlbnRzIHdpdGggYW5vdGhlciBhcnJheS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBvdGhlciBUaGUgYXJyYXkgYmFzZSB0byB1c2UgZm9yIHRoZSBzd2FwLlxuICAgICAgICAqL1xuICAgICAgICBBcnJheUJhc2UucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBvdGhlci5fYXJyYXk7XG4gICAgICAgICAgICBvdGhlci5fYXJyYXkgPSBhcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAgKi9cbiAgICAgICAgQXJyYXlCYXNlLnByb3RvdHlwZS5fX2l0ZXJfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c3UuaXRlcih0aGlzLl9hcnJheSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYSByZXZlcnNlIGl0ZXJhdG9yIG92ZXIgdGhlIGFycmF5IG9mIGl0ZW1zLlxuICAgICAgICAqL1xuICAgICAgICBBcnJheUJhc2UucHJvdG90eXBlLl9fcmV2ZXJzZWRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c3UucmV2ZXJzZWQodGhpcy5fYXJyYXkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXJyYXlCYXNlO1xuICAgIH0oKSk7XG4gICAgdHN1LkFycmF5QmFzZSA9IEFycmF5QmFzZTtcbn0pKHRzdSB8fCAodHN1ID0ge30pKTtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciB0c3U7XG4oZnVuY3Rpb24gKHRzdSkge1xuICAgIC8qKlxuICAgICogQSBtYXBwaW5nIGNvbnRhaW5lciBidWlsZCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAqXG4gICAgKiBAY2xhc3NcbiAgICAqL1xuICAgIHZhciBBc3NvY2lhdGl2ZUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFzc29jaWF0aXZlQXJyYXksIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBBc3NvY2lhdGl2ZUFycmF5LlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIGNvbXBhcmUgVGhlIGtleSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBc3NvY2lhdGl2ZUFycmF5KGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5fY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgICAgICBfdGhpcy5fd3JhcHBlZCA9IHdyYXBDb21wYXJlKGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIGtleSBjb21wYXJpc29uIGZ1bmN0aW9uIHVzZWQgYnkgdGhpcyBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuY29tcGFyaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wYXJlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm4gdGhlIGFycmF5IGluZGV4IG9mIHRoZSBnaXZlbiBrZXksIG9yIC0xLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICAgICovXG4gICAgICAgIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHN1LmJpbmFyeVNlYXJjaCh0aGlzLl9hcnJheSwga2V5LCB0aGlzLl93cmFwcGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgaXMgaW4gdGhlIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHN1LmJpbmFyeVNlYXJjaCh0aGlzLl9hcnJheSwga2V5LCB0aGlzLl93cmFwcGVkKSA+PSAwO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBwYWlyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciB1bmRlZmluZWQuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0c3UuYmluYXJ5RmluZCh0aGlzLl9hcnJheSwga2V5LCB0aGlzLl93cmFwcGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0aGUgcGFpciBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpZiBpdCBleGlzdHMuXG4gICAgICAgICpcbiAgICAgICAgKiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCBhIG5ldyBwYWlyIHdpbGwgYmUgY3JlYXRlZCBhbmRcbiAgICAgICAgKiBpbnNlcnRlZCB1c2luZyB0aGUgdmFsdWUgY3JlYXRlZCBieSB0aGUgZ2l2ZW4gZmFjdG9yeS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICAgICAgICAqIEBwYXJhbSBmYWN0b3J5IFRoZSBmdW5jdGlvbiB3aGljaCBjcmVhdGVzIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAqL1xuICAgICAgICBBc3NvY2lhdGl2ZUFycmF5LnByb3RvdHlwZS5zZXREZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgZmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0c3UubG93ZXJCb3VuZChhcnJheSwga2V5LCB0aGlzLl93cmFwcGVkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgdHN1LlBhaXIoa2V5LCBmYWN0b3J5KCkpO1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyclBhaXIgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyZShjdXJyUGFpci5maXJzdCwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IHRzdS5QYWlyKGtleSwgZmFjdG9yeSgpKTtcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDAsIHBhaXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJQYWlyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBJbnNlcnQgdGhlIHBhaXIgaW50byB0aGUgYXJyYXkgYW5kIHJldHVybiB0aGUgcGFpci5cbiAgICAgICAgKlxuICAgICAgICAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBwb3J0aW9uIG9mIHRoZSBwYWlyLlxuICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgcG9ydGlvbiBvZiB0aGUgcGFpci5cbiAgICAgICAgKi9cbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdHN1Lmxvd2VyQm91bmQoYXJyYXksIGtleSwgdGhpcy5fd3JhcHBlZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IHRzdS5QYWlyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyclBhaXIgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyZShjdXJyUGFpci5maXJzdCwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IHRzdS5QYWlyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMCwgcGFpcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyUGFpci5zZWNvbmQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyUGFpcjtcbiAgICAgICAgfTtcbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBc3NvY2lhdGl2ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBtZXJnZSh0aGlzLl9hcnJheSwgb2JqZWN0Ll9hcnJheSwgdGhpcy5fY29tcGFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3UuZm9yRWFjaChvYmplY3QsIGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluc2VydChwYWlyLmZpcnN0LCBwYWlyLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHBhaXIgZm9yIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICAqL1xuICAgICAgICBBc3NvY2lhdGl2ZUFycmF5LnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdHN1LmJpbmFyeVNlYXJjaChhcnJheSwga2V5LCB0aGlzLl93cmFwcGVkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBhc3NvY2lhdGl2ZSBhcnJheS5cbiAgICAgICAgKi9cbiAgICAgICAgQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGVDb3B5ID0gbmV3IEFzc29jaWF0aXZlQXJyYXkodGhpcy5fY29tcGFyZSk7XG4gICAgICAgICAgICB2YXIgY29weUFycmF5ID0gdGhlQ29weS5fYXJyYXk7XG4gICAgICAgICAgICB2YXIgdGhpc0FycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXNBcnJheS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb3B5QXJyYXkucHVzaCh0aGlzQXJyYXlbaV0uY29weSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVDb3B5O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXNzb2NpYXRpdmVBcnJheTtcbiAgICB9KHRzdS5BcnJheUJhc2UpKTtcbiAgICB0c3UuQXNzb2NpYXRpdmVBcnJheSA9IEFzc29jaWF0aXZlQXJyYXk7XG4gICAgLyoqXG4gICAgKiBBbiBpbnRlcm5hbCB3aGljaCB3cmFwcyBhIGNvbXBhcmlzb24ga2V5IGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb24gd3JhcENvbXBhcmUoY21wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGFpciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbXAocGFpci5maXJzdCwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFuIGludGVybmFsIGZ1bmN0aW9uIHdoaWNoIG1lcmdlcyB0d28gb3JkZXJlZCBwYWlyIGFycmF5cy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKGZpcnN0LCBzZWNvbmQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICAgICAgdmFyIGxlbjEgPSBmaXJzdC5sZW5ndGg7XG4gICAgICAgIHZhciBsZW4yID0gc2Vjb25kLmxlbmd0aDtcbiAgICAgICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbjEgJiYgaiA8IGxlbjIpIHtcbiAgICAgICAgICAgIHZhciBhID0gZmlyc3RbaV07XG4gICAgICAgICAgICB2YXIgYiA9IHNlY29uZFtqXTtcbiAgICAgICAgICAgIHZhciB2ID0gY29tcGFyZShhLmZpcnN0LCBiLmZpcnN0KTtcbiAgICAgICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEuY29weSgpKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGIuY29weSgpKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChiLmNvcHkoKSk7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGxlbjEpIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGZpcnN0W2ldLmNvcHkoKSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGogPCBsZW4yKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChzZWNvbmRbal0uY29weSgpKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbn0pKHRzdSB8fCAodHN1ID0ge30pKTtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LCBOdWNsZWljIERldmVsb3BtZW50IFRlYW0uXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgQ09QWUlORy50eHQsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciB0c3U7XG4oZnVuY3Rpb24gKHRzdSkge1xuICAgIC8qKlxuICAgICogQW4gaXRlcmF0b3IgZm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgICovXG4gICAgdmFyIEFycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKlxuICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBBcnJheUl0ZXJhdG9yLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSBvZiBpdGVtcyB0byBpdGVyYXRlLlxuICAgICAgICAqIEBwYXJhbSBbaW5kZXhdIFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpdGVyYXRpb24uXG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYXJyYXksIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIG5leHQgaXRlbSBmcm9tIHRoZSBpdGVyYXRvciBvciB1bmRlZmluZWQuXG4gICAgICAgICovXG4gICAgICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLl9fbmV4dF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W3RoaXMuX2luZGV4KytdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoaXMgc2FtZSBpdGVyYXRvci5cbiAgICAgICAgKi9cbiAgICAgICAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuX19pdGVyX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICB0c3UuQXJyYXlJdGVyYXRvciA9IEFycmF5SXRlcmF0b3I7XG4gICAgLyoqXG4gICAgKiBBIHJldmVyc2UgaXRlcmF0b3IgZm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgICovXG4gICAgdmFyIFJldmVyc2VBcnJheUl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQ29uc3RydWN0IGEgbmV3IFJldmVyc2VBcnJheUl0ZXJhdG9yLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSBvZiBpdGVtcyB0byBpdGVyYXRlLlxuICAgICAgICAqIEBwYXJhbSBbaW5kZXhdIFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpdGVyYXRpb24uXG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJldmVyc2VBcnJheUl0ZXJhdG9yKGFycmF5LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIG5leHQgaXRlbSBmcm9tIHRoZSBpdGVyYXRvciBvciB1bmRlZmluZWQuXG4gICAgICAgICovXG4gICAgICAgIFJldmVyc2VBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5fX25leHRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheVstLXRoaXMuX2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0aGlzIHNhbWUgaXRlcmF0b3IuXG4gICAgICAgICovXG4gICAgICAgIFJldmVyc2VBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5fX2l0ZXJfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmV2ZXJzZUFycmF5SXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICB0c3UuUmV2ZXJzZUFycmF5SXRlcmF0b3IgPSBSZXZlcnNlQXJyYXlJdGVyYXRvcjtcbiAgICBmdW5jdGlvbiBpdGVyKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3QuX19pdGVyX18oKTtcbiAgICB9XG4gICAgdHN1Lml0ZXIgPSBpdGVyO1xuICAgIGZ1bmN0aW9uIHJldmVyc2VkKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmV2ZXJzZUFycmF5SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0Ll9fcmV2ZXJzZWRfXygpO1xuICAgIH1cbiAgICB0c3UucmV2ZXJzZWQgPSByZXZlcnNlZDtcbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIG5leHQgdmFsdWUgZnJvbSBhbiBpdGVyYXRvciwgb3IgdW5kZWZpbmVkLlxuICAgICovXG4gICAgZnVuY3Rpb24gbmV4dChpdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3IuX19uZXh0X18oKTtcbiAgICB9XG4gICAgdHN1Lm5leHQgPSBuZXh0O1xuICAgIGZ1bmN0aW9uIGFzQXJyYXkob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBpdCA9IG9iamVjdC5fX2l0ZXJfXygpO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gaXQuX19uZXh0X18oKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB0c3UuYXNBcnJheSA9IGFzQXJyYXk7XG4gICAgZnVuY3Rpb24gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmplY3QubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YXIgaXQgPSBvYmplY3QuX19pdGVyX18oKTtcbiAgICAgICAgICAgIHdoaWxlICgodmFsdWUgPSBpdC5fX25leHRfXygpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0c3UuZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgZnVuY3Rpb24gbWFwKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKG9iamVjdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIGl0ID0gb2JqZWN0Ll9faXRlcl9fKCk7XG4gICAgICAgICAgICB3aGlsZSAoKHZhbHVlID0gaXQuX19uZXh0X18oKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHN1Lm1hcCA9IG1hcDtcbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBvYmplY3QuX19pdGVyX18oKTtcbiAgICAgICAgICAgIHdoaWxlICgodmFsdWUgPSBpdC5fX25leHRfXygpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRzdS5maWx0ZXIgPSBmaWx0ZXI7XG59KSh0c3UgfHwgKHRzdSA9IHt9KSk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNCwgTnVjbGVpYyBEZXZlbG9wbWVudCBUZWFtLlxufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIENPUFlJTkcudHh0LCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgdHN1O1xuKGZ1bmN0aW9uICh0c3UpIHtcbiAgICAvKipcbiAgICAqIEEgY2xhc3Mgd2hpY2ggZGVmaW5lcyBhIGdlbmVyaWMgcGFpciBvYmplY3QuXG4gICAgKi9cbiAgICB2YXIgUGFpciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBQYWlyIG9iamVjdC5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgaXRlbSBvZiB0aGUgcGFpci5cbiAgICAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgaXRlbSBvZiB0aGUgcGFpci5cbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUGFpcihmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgICAgICAgICB0aGlzLnNlY29uZCA9IHNlY29uZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBwYWlyLlxuICAgICAgICAqL1xuICAgICAgICBQYWlyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWlyKHRoaXMuZmlyc3QsIHRoaXMuc2Vjb25kKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhaXI7XG4gICAgfSgpKTtcbiAgICB0c3UuUGFpciA9IFBhaXI7XG59KSh0c3UgfHwgKHRzdSA9IHt9KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGtpd2k7XG4iLCIvKiFcbiAqIG51bWJyby5qc1xuICogdmVyc2lvbiA6IDEuNi4yXG4gKiBhdXRob3IgOiBGw7ZyZXRhZ3NwbGF0c2VuIEFCXG4gKiBsaWNlbnNlIDogTUlUXG4gKiBodHRwOi8vd3d3LmZvcmV0YWdzcGxhdHNlbi5zZVxuICovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBudW1icm8sXG4gICAgICAgIFZFUlNJT04gPSAnMS42LjInLFxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGN1bHR1cmUgY29uZmlnIGZpbGVzXG4gICAgICAgIGN1bHR1cmVzID0ge30sXG4gICAgLy8gVG9kbzogUmVtb3ZlIGluIDIuMC4wXG4gICAgICAgIGxhbmd1YWdlcyA9IGN1bHR1cmVzLFxuICAgICAgICBjdXJyZW50Q3VsdHVyZSA9ICdlbi1VUycsXG4gICAgICAgIHplcm9Gb3JtYXQgPSBudWxsLFxuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gJzAsMCcsXG4gICAgICAgIGRlZmF1bHRDdXJyZW5jeUZvcm1hdCA9ICcwJCcsXG4gICAgICAgIC8vIGNoZWNrIGZvciBub2RlSlNcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSxcbiAgICAvLyBkZWZhdWx0IGN1bHR1cmVcbiAgICAgICAgZW5VUyA9IHtcbiAgICAgICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0aG91c2FuZHM6ICcsJyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYmJyZXZpYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICAgICAgYmlsbGlvbjogJ2InLFxuICAgICAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwO1xuICAgICAgICAgICAgICAgIHJldHVybiAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnJCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdwcmVmaXgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUZvcm1hdDogJywwMDAwIGEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0czoge1xuICAgICAgICAgICAgICAgIGZvdXJEaWdpdHM6ICcwMDAwIGEnLFxuICAgICAgICAgICAgICAgIGZ1bGxXaXRoVHdvRGVjaW1hbHM6ICckICwwLjAwJyxcbiAgICAgICAgICAgICAgICBmdWxsV2l0aFR3b0RlY2ltYWxzTm9DdXJyZW5jeTogJywwLjAwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIE51bWJybyBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtYnJvKG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bWJlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvZXMoY291bnQpIHtcbiAgICAgICAgdmFyIGksIHJldCA9ICcnO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXQgKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgdG9GaXhlZCgpIGZvciBudW1iZXJzIHdpdGggZXhwb25lbnQgPiAyMVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ZpeGVkTGFyZ2UodmFsdWUsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgbWFudGlzc2EsXG4gICAgICAgICAgICBiZWZvcmVEZWMsXG4gICAgICAgICAgICBhZnRlckRlYyxcbiAgICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgICAgc3RyO1xuXG4gICAgICAgIHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgbWFudGlzc2EgPSBzdHIuc3BsaXQoJ2UnKVswXTtcbiAgICAgICAgZXhwb25lbnQgID0gc3RyLnNwbGl0KCdlJylbMV07XG5cbiAgICAgICAgYmVmb3JlRGVjID0gbWFudGlzc2Euc3BsaXQoJy4nKVswXTtcbiAgICAgICAgYWZ0ZXJEZWMgPSBtYW50aXNzYS5zcGxpdCgnLicpWzFdIHx8ICcnO1xuXG4gICAgICAgIHN0ciA9IGJlZm9yZURlYyArIGFmdGVyRGVjICsgemVyb2VzKGV4cG9uZW50IC0gYWZ0ZXJEZWMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgICAgIHN0ciArPSAnLicgKyB6ZXJvZXMocHJlY2lzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgdG9GaXhlZCgpIHRoYXQgdHJlYXRzIGZsb2F0cyBtb3JlIGxpa2UgZGVjaW1hbHNcbiAgICAgKlxuICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICogcHJvYmxlbXMgZm9yIGFjY291bnRpbmctIGFuZCBmaW5hbmNlLXJlbGF0ZWQgc29mdHdhcmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiksXG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHZhbHVlLnRvRml4ZWQoMCkuc2VhcmNoKCdlJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gQWJvdmUgMWUyMSwgdG9GaXhlZCByZXR1cm5zIHNjaWVudGlmaWMgbm90YXRpb24sIHdoaWNoXG4gICAgICAgICAgICAvLyBpcyB1c2VsZXNzIGFuZCB1bmV4cGVjdGVkXG4gICAgICAgICAgICBvdXRwdXQgPSB0b0ZpeGVkTGFyZ2UodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSAqIHBvd2VyKSAvIHBvd2VyKS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9uYWxzKSB7XG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAgPSBuZXcgUmVnRXhwKCcwezEsJyArIG9wdGlvbmFscyArICd9JCcpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRm9ybWF0dGluZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIGRldGVybWluZSB3aGF0IHR5cGUgb2YgZm9ybWF0dGluZyB3ZSBuZWVkIHRvIGRvXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYnJvKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgLy8gVE9ETzogZG8gc29tZXRoaW5nIHdpdGggYGxhbmd1YWdlYFxuXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCBraW5kIG9mIGZvcm1hdCB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignJCcpID4gLTEpIHsgLy8gY3VycmVuY3khISEhIVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0Q3VycmVuY3kodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJzonKSA+IC0xKSB7IC8vIHRpbWVcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFRpbWUodmFsdWUpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KHZhbHVlLCBvcmlnaW5hbEZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgZm9ybWF0ID0gb3JpZ2luYWxGb3JtYXQsXG4gICAgICAgICAgICBzeW1ib2xJbmRleCA9IGZvcm1hdC5pbmRleE9mKCckJyksXG4gICAgICAgICAgICBvcGVuUGFyZW5JbmRleCA9IGZvcm1hdC5pbmRleE9mKCcoJyksXG4gICAgICAgICAgICBwbHVzU2lnbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJysnKSxcbiAgICAgICAgICAgIG1pbnVzU2lnbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJy0nKSxcbiAgICAgICAgICAgIHNwYWNlID0gJycsXG4gICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yID0gJycsXG4gICAgICAgICAgICBzcGxpY2VJbmRleCxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZihmb3JtYXQuaW5kZXhPZignJCcpID09PSAtMSl7XG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaW5zdGVhZCBvZiB0aGUgZm9ybWF0IHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnBvc2l0aW9uID09PSAnaW5maXgnKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9IGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgICAgICAgICAgaWYgKGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zcGFjZVNlcGFyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yID0gJyAnICsgZGVjaW1hbFNlcGFyYXRvciArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zcGFjZVNlcGFyYXRlZCkge1xuICAgICAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBvciBhZnRlciBjdXJyZW5jeVxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICQnLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJCAnLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCckJywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9ybWF0IFRoZSBOdW1iZXJcbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24sIGRlY2ltYWxTZXBhcmF0b3IpO1xuXG4gICAgICAgIGlmIChvcmlnaW5hbEZvcm1hdC5pbmRleE9mKCckJykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaW5zdGVhZCBvZiB0aGUgZm9ybWF0IHByb3ZpZGVkXG4gICAgICAgICAgICBzd2l0Y2ggKGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc3RmaXgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmZpeCc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZWZpeCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKCcpID4gLTEgfHwgb3V0cHV0LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSBNYXRoLm1heChvcGVuUGFyZW5JbmRleCwgbWludXNTaWduSW5kZXgpICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShzcGxpY2VJbmRleCwgMCwgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ3VycmVuY3kgcG9zaXRpb24gc2hvdWxkIGJlIGFtb25nIFtcInByZWZpeFwiLCBcImluZml4XCIsIFwicG9zdGZpeFwiXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICAgICAgaWYgKHN5bWJvbEluZGV4IDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJygnKSA+IC0xIHx8IG91dHB1dC5pbmRleE9mKCcrJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IHBsdXNTaWduSW5kZXggfHwgc3ltYm9sSW5kZXggPCBtaW51c1NpZ25JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIsIFwiK1wiIG9yIFwiLVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShzcGxpY2VJbmRleCwgMCwgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbCArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmNlbnRhZ2UodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEwMDtcblxuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlICVcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJScpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAlJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcpJykgPiAtMSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJyUnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRUaW1lKHZhbHVlKSB7XG4gICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IodmFsdWUgLyA2MCAvIDYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh2YWx1ZSAtIChob3VycyAqIDYwICogNjApKSAvIDYwKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG4gICAgICAgIHJldHVybiBob3VycyArICc6JyArXG4gICAgICAgICAgICAoKG1pbnV0ZXMgPCAxMCkgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgK1xuICAgICAgICAgICAgKChzZWNvbmRzIDwgMTApID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJlciAodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbiwgc2VwKSB7XG4gICAgICAgIHZhciBuZWdQID0gZmFsc2UsXG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFiYnJLID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0aG91c2FuZHNcbiAgICAgICAgICAgIGFiYnJNID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBtaWxsaW9uc1xuICAgICAgICAgICAgYWJickIgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIGJpbGxpb25zXG4gICAgICAgICAgICBhYmJyVCA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdHJpbGxpb25zXG4gICAgICAgICAgICBhYmJyRm9yY2UgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICBieXRlcyA9ICcnLFxuICAgICAgICAgICAgb3JkID0gJycsXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyh2YWx1ZSksXG4gICAgICAgICAgICBiaW5hcnlTdWZmaXhlcyA9IFsnQicsICdLaUInLCAnTWlCJywgJ0dpQicsICdUaUInLCAnUGlCJywgJ0VpQicsICdaaUInLCAnWWlCJ10sXG4gICAgICAgICAgICBkZWNpbWFsU3VmZml4ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgdG90YWxMZW5ndGgsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBtaW5pbXVtUHJlY2lzaW9uLFxuICAgICAgICAgICAgcG93LFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIGludFByZWNpc2lvbixcbiAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHBvc3RmaXgsXG4gICAgICAgICAgICB0aG91c2FuZHMsXG4gICAgICAgICAgICBkID0gJycsXG4gICAgICAgICAgICBmb3JjZWROZWcgPSBmYWxzZSxcbiAgICAgICAgICAgIG5lZyA9IGZhbHNlLFxuICAgICAgICAgICAgaW5kZXhPcGVuUCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBpbmRleE1pbnVzLFxuICAgICAgICAgICAgcGFyZW4gPSAnJyxcbiAgICAgICAgICAgIG1pbmxlbjtcblxuICAgICAgICAvLyBjaGVjayBpZiBudW1iZXIgaXMgemVybyBhbmQgYSBjdXN0b20gemVybyBmb3JtYXQgaGFzIGJlZW4gc2V0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB6ZXJvRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0Zvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZigneycpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gZm9ybWF0LmluZGV4T2YoJ30nKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Zvcm1hdCBzaG91bGQgYWxzbyBjb250YWluIGEgXCJ9XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZpeCA9IGZvcm1hdC5zbGljZSgxLCBlbmQpO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKGVuZCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlZml4ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ30nKSA9PT0gZm9ybWF0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGZvcm1hdC5pbmRleE9mKCd7Jyk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Zvcm1hdCBzaG91bGQgYWxzbyBjb250YWluIGEgXCJ7XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc3RmaXggPSBmb3JtYXQuc2xpY2Uoc3RhcnQgKyAxLCAtMSk7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMCwgc3RhcnQgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc3RmaXggPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaW4gbGVuZ3RoXG4gICAgICAgIHZhciBpbmZvO1xuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZm8gPSBmb3JtYXQubWF0Y2goLyhbMC05XSspLiovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZm8gPSBmb3JtYXQubWF0Y2goLyhbMC05XSspXFwuLiovKTtcbiAgICAgICAgfVxuICAgICAgICBtaW5sZW4gPSBpbmZvID09PSBudWxsID8gLTEgOiBpbmZvWzFdLmxlbmd0aDtcblxuICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgLy8gaWYgYm90aCBhcmUgcHJlc2VudCB3ZSBkZWZhdWx0IHRvIHBhcmVudGhlc2VzXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLScpICE9PSAtMSkge1xuICAgICAgICAgICAgZm9yY2VkTmVnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgxLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJysnKSA+IC0xKSB7XG4gICAgICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xcKy9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9uIGlzIHdhbnRlZFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2EnKSA+IC0xKSB7XG4gICAgICAgICAgICBpbnRQcmVjaXNpb24gPSBmb3JtYXQuc3BsaXQoJy4nKVswXS5tYXRjaCgvWzAtOV0rL2cpIHx8IFsnMCddO1xuICAgICAgICAgICAgaW50UHJlY2lzaW9uID0gcGFyc2VJbnQoaW50UHJlY2lzaW9uWzBdLCAxMCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFiYnJldmlhdGlvbiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGFiYnJLID0gZm9ybWF0LmluZGV4T2YoJ2FLJykgPj0gMDtcbiAgICAgICAgICAgIGFiYnJNID0gZm9ybWF0LmluZGV4T2YoJ2FNJykgPj0gMDtcbiAgICAgICAgICAgIGFiYnJCID0gZm9ybWF0LmluZGV4T2YoJ2FCJykgPj0gMDtcbiAgICAgICAgICAgIGFiYnJUID0gZm9ybWF0LmluZGV4T2YoJ2FUJykgPj0gMDtcbiAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJLIHx8IGFiYnJNIHx8IGFiYnJCIHx8IGFiYnJUO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBhYmJyID0gJyAnO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYScsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2EnLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gTWF0aC5mbG9vcihNYXRoLmxvZyhhYnMpIC8gTWF0aC5MTjEwKSArIDE7XG5cbiAgICAgICAgICAgIG1pbmltdW1QcmVjaXNpb24gPSB0b3RhbExlbmd0aCAlIDM7XG4gICAgICAgICAgICBtaW5pbXVtUHJlY2lzaW9uID0gbWluaW11bVByZWNpc2lvbiA9PT0gMCA/IDMgOiBtaW5pbXVtUHJlY2lzaW9uO1xuXG4gICAgICAgICAgICBpZiAoaW50UHJlY2lzaW9uICYmIGFicyAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC5mbG9vcihNYXRoLmxvZyhhYnMpIC8gTWF0aC5MTjEwKSArIDEgLSBpbnRQcmVjaXNpb247XG5cbiAgICAgICAgICAgICAgICBwb3cgPSAzICogfn4oKE1hdGgubWluKGludFByZWNpc2lvbiwgdG90YWxMZW5ndGgpIC0gbWluaW11bVByZWNpc2lvbikgLyAzKTtcblxuICAgICAgICAgICAgICAgIGFicyA9IGFicyAvIE1hdGgucG93KDEwLCBwb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IC0xICYmIGludFByZWNpc2lvbiA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ICs9ICdbLl0nO1xuXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBsZW5ndGggPT09IDAgPyAwIDogMyAqIH5+KGxlbmd0aCAvIDMpIC0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gc2l6ZSA8IDAgPyBzaXplICsgMyA6IHNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0ICs9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnModmFsdWUpKSAvIE1hdGguTE4xMCkgKyAxICE9PSBpbnRQcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IE1hdGgucG93KDEwLCAxMikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDEyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCAxMikgJiYgYWJzID49IE1hdGgucG93KDEwLCA5KSAmJiAhYWJickZvcmNlIHx8IGFiYnJCKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uYWJicmV2aWF0aW9ucy5iaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDkpICYmIGFicyA+PSBNYXRoLnBvdygxMCwgNikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyTSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA2KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDMpICYmICFhYmJyRm9yY2UgfHwgYWJickspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWUgaWYgd2UgYXJlIGZvcm1hdHRpbmcgYmluYXJ5IGJ5dGVzXG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYicpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSAnICc7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBiJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYicsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IGJpbmFyeVN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgucG93KDEwMjQsIHBvd2VyKTtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLnBvdygxMDI0LCBwb3dlciArIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzICsgYmluYXJ5U3VmZml4ZXNbcG93ZXJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWUgaWYgd2UgYXJlIGZvcm1hdHRpbmcgZGVjaW1hbCBieXRlc1xuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2QnKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBkJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgZCcsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2QnLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBkZWNpbWFsU3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coMTAwMCwgcG93ZXIpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KDEwMDAsIHBvd2VyICsgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgKyBkZWNpbWFsU3VmZml4ZXNbcG93ZXJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWUgaWYgb3JkaW5hbCBpcyB3YW50ZWRcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdvJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgbycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcmQgPSAnICc7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBvJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnbycsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1bHR1cmVzW2N1cnJlbnRDdWx0dXJlXS5vcmRpbmFsKSB7XG4gICAgICAgICAgICAgICAgb3JkID0gb3JkICsgY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLm9yZGluYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdbLl0nKSA+IC0xKSB7XG4gICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ1suXScsICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB3ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICBwcmVjaXNpb24gPSBmb3JtYXQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcblxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24uaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnJlcGxhY2UoJ10nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5zcGxpdCgnWycpO1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvblsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcgPSBkLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgIGlmIChkLnNwbGl0KCcuJylbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzZXAgPyBhYmJyICsgc2VwIDogY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdLmRlbGltaXRlcnMuZGVjaW1hbDtcbiAgICAgICAgICAgICAgICBkID0gcCArIGQuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0RGVjICYmIE51bWJlcihkLnNsaWNlKDEpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcgPSB0b0ZpeGVkKHZhbHVlLCBudWxsLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgaWYgKHcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHcgPSB3LnNsaWNlKDEpO1xuICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmxlbmd0aCA8IG1pbmxlbikge1xuICAgICAgICAgICAgdyA9IG5ldyBBcnJheShtaW5sZW4gLSB3Lmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgIHcgPSB3LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICtcbiAgICAgICAgICAgICAgICBjdWx0dXJlc1tjdXJyZW50Q3VsdHVyZV0uZGVsaW1pdGVycy50aG91c2FuZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgIHcgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4T3BlblAgPSBmb3JtYXQuaW5kZXhPZignKCcpO1xuICAgICAgICBpbmRleE1pbnVzID0gZm9ybWF0LmluZGV4T2YoJy0nKTtcblxuICAgICAgICBpZiAoaW5kZXhPcGVuUCA8IGluZGV4TWludXMpIHtcbiAgICAgICAgICAgIHBhcmVuID0gKChuZWdQICYmIG5lZykgPyAnKCcgOiAnJykgKyAoKChmb3JjZWROZWcgJiYgbmVnKSB8fCAoIW5lZ1AgJiYgbmVnKSkgPyAnLScgOiAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbiA9ICgoKGZvcmNlZE5lZyAmJiBuZWcpIHx8ICghbmVnUCAmJiBuZWcpKSA/ICctJyA6ICcnKSArICgobmVnUCAmJiBuZWcpID8gJygnIDogJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWZpeCArXG4gICAgICAgICAgICBwYXJlbiArICgoIW5lZyAmJiBzaWduZWQgJiYgdmFsdWUgIT09IDApID8gJysnIDogJycpICtcbiAgICAgICAgICAgIHcgKyBkICtcbiAgICAgICAgICAgICgob3JkKSA/IG9yZCA6ICcnKSArXG4gICAgICAgICAgICAoKGFiYnIgJiYgIXNlcCkgPyBhYmJyIDogJycpICtcbiAgICAgICAgICAgICgoYnl0ZXMpID8gYnl0ZXMgOiAnJykgK1xuICAgICAgICAgICAgKChuZWdQICYmIG5lZykgPyAnKScgOiAnJykgK1xuICAgICAgICAgICAgcG9zdGZpeDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1icm8gPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAobnVtYnJvLmlzTnVtYnJvKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBudW1icm8uZm4udW5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1icm8oTnVtYmVyKGlucHV0KSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtYnJvLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1icm8gb2JqZWN0XG4gICAgbnVtYnJvLmlzTnVtYnJvID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW1icm87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3cgdGhlIHVzZXIgdG8gc2V0IGEgbmV3IGxhbmd1YWdlIHdpdGggYSBmYWxsYmFjayBpZlxuICAgICAqIHRoZSBsYW5ndWFnZSBkb2VzIG5vdCBleGlzdC4gSWYgbm8gZmFsbGJhY2sgbGFuZ3VhZ2UgaXMgcHJvdmlkZWQsXG4gICAgICogaXQgZmFsbGJhY2tzIHRvIGVuZ2xpc2guXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSBpbiB2ZXJzaW9uIDEuNi4wLiBJdCB3aWxsIGJlIGRlbGV0ZWQgaW4gdmVyc2lvbiAyLjBcbiAgICAgKiBgc2V0Q3VsdHVyZWAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBudW1icm8uc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbihuZXdMYW5ndWFnZSwgZmFsbGJhY2tMYW5ndWFnZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2BzZXRMYW5ndWFnZWAgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuNi4wLiBVc2UgYHNldEN1bHR1cmVgIGluc3RlYWQnKTtcbiAgICAgICAgdmFyIGtleSA9IG5ld0xhbmd1YWdlLFxuICAgICAgICAgICAgcHJlZml4ID0gbmV3TGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXSxcbiAgICAgICAgICAgIG1hdGNoaW5nTGFuZ3VhZ2UgPSBudWxsO1xuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsYW5ndWFnZXMpLmZvckVhY2goZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoaW5nTGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXSA9PT0gcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nTGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGtleSA9IG1hdGNoaW5nTGFuZ3VhZ2UgfHwgZmFsbGJhY2tMYW5ndWFnZSB8fCAnZW4tVVMnO1xuICAgICAgICB9XG4gICAgICAgIGNob29zZUN1bHR1cmUoa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbGxvdyB0aGUgdXNlciB0byBzZXQgYSBuZXcgY3VsdHVyZSB3aXRoIGEgZmFsbGJhY2sgaWZcbiAgICAgKiB0aGUgY3VsdHVyZSBkb2VzIG5vdCBleGlzdC4gSWYgbm8gZmFsbGJhY2sgY3VsdHVyZSBpcyBwcm92aWRlZCxcbiAgICAgKiBpdCBmYWxsYmFja3MgdG8gXCJlbi1VU1wiLlxuICAgICAqL1xuICAgIG51bWJyby5zZXRDdWx0dXJlID0gZnVuY3Rpb24obmV3Q3VsdHVyZSwgZmFsbGJhY2tDdWx0dXJlKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdDdWx0dXJlLFxuICAgICAgICAgICAgc3VmZml4ID0gbmV3Q3VsdHVyZS5zcGxpdCgnLScpWzFdLFxuICAgICAgICAgICAgbWF0Y2hpbmdDdWx0dXJlID0gbnVsbDtcbiAgICAgICAgaWYgKCFjdWx0dXJlc1trZXldKSB7XG4gICAgICAgICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VsdHVyZXMpLmZvckVhY2goZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0N1bHR1cmUgJiYgbGFuZ3VhZ2Uuc3BsaXQoJy0nKVsxXSA9PT0gc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ0N1bHR1cmUgPSBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXkgPSBtYXRjaGluZ0N1bHR1cmUgfHwgZmFsbGJhY2tDdWx0dXJlIHx8ICdlbi1VUyc7XG4gICAgICAgIH1cbiAgICAgICAgY2hvb3NlQ3VsdHVyZShrZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsYW5ndWFnZXMgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbGFuZ3VhZ2UuICBJZlxuICAgICAqIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgICogbGFuZ3VhZ2Uga2V5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgaW4gdmVyc2lvbiAxLjYuMC4gSXQgd2lsbCBiZSBkZWxldGVkIGluIHZlcnNpb24gMi4wXG4gICAgICogYGN1bHR1cmVgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgbnVtYnJvLmxhbmd1YWdlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdgbGFuZ3VhZ2VgIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjYuMC4gVXNlIGBjdWx0dXJlYCBpbnN0ZWFkJyk7XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q3VsdHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgJiYgIXZhbHVlcykge1xuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZSA6ICcgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hvb3NlQ3VsdHVyZShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcyB8fCAhbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgIHNldEN1bHR1cmUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJybztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgY3VsdHVyZXMgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgY3VsdHVyZS4gIElmXG4gICAgICogbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAgKiBjdWx0dXJlIGNvZGUuXG4gICAgICovXG4gICAgbnVtYnJvLmN1bHR1cmUgPSBmdW5jdGlvbihjb2RlLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEN1bHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSAmJiAhdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIWN1bHR1cmVzW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGN1bHR1cmUgOiAnICsgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaG9vc2VDdWx0dXJlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcyB8fCAhY3VsdHVyZXNbY29kZV0pIHtcbiAgICAgICAgICAgIHNldEN1bHR1cmUoY29kZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1icm87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBsb2FkZWQgbGFuZ3VhZ2UgZGF0YS4gIElmXG4gICAgICogbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgICAqIGdsb2JhbCBsYW5ndWFnZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSBpbiB2ZXJzaW9uIDEuNi4wLiBJdCB3aWxsIGJlIGRlbGV0ZWQgaW4gdmVyc2lvbiAyLjBcbiAgICAgKiBgY3VsdHVyZWAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBudW1icm8ubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYGxhbmd1YWdlRGF0YWAgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuNi4wLiBVc2UgYGN1bHR1cmVEYXRhYCBpbnN0ZWFkJyk7XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXNbY3VycmVudEN1bHR1cmVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBsb2FkZWQgY3VsdHVyZSBkYXRhLiAgSWZcbiAgICAgKiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICogZ2xvYmFsIGN1bHR1cmUgb2JqZWN0LlxuICAgICAqL1xuICAgIG51bWJyby5jdWx0dXJlRGF0YSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VsdHVyZXNbY3VycmVudEN1bHR1cmVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdWx0dXJlc1tjb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGN1bHR1cmUgOiAnICsgY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VsdHVyZXNbY29kZV07XG4gICAgfTtcblxuICAgIG51bWJyby5jdWx0dXJlKCdlbi1VUycsIGVuVVMpO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgaW4gdmVyc2lvbiAxLjYuMC4gSXQgd2lsbCBiZSBkZWxldGVkIGluIHZlcnNpb24gMi4wXG4gICAgICogYGN1bHR1cmVzYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIG51bWJyby5sYW5ndWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdgbGFuZ3VhZ2VzYCBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS42LjAuIFVzZSBgY3VsdHVyZXNgIGluc3RlYWQnKTtcblxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzO1xuICAgIH07XG5cbiAgICBudW1icm8uY3VsdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1bHR1cmVzO1xuICAgIH07XG5cbiAgICBudW1icm8uemVyb0Zvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB6ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtYnJvLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICcwLjAnO1xuICAgIH07XG5cbiAgICBudW1icm8uZGVmYXVsdEN1cnJlbmN5Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBkZWZhdWx0Q3VycmVuY3lGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiAnMCQnO1xuICAgIH07XG5cbiAgICBudW1icm8udmFsaWRhdGUgPSBmdW5jdGlvbih2YWwsIGN1bHR1cmUpIHtcblxuICAgICAgICB2YXIgX2RlY2ltYWxTZXAsXG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAsXG4gICAgICAgICAgICBfY3VyclN5bWJvbCxcbiAgICAgICAgICAgIF92YWxBcnJheSxcbiAgICAgICAgICAgIF9hYmJyT2JqLFxuICAgICAgICAgICAgX3Rob3VzYW5kUmVnRXgsXG4gICAgICAgICAgICBjdWx0dXJlRGF0YSxcbiAgICAgICAgICAgIHRlbXA7XG5cbiAgICAgICAgLy9jb2VyY2UgdmFsIHRvIHN0cmluZ1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbCArPSAnJztcbiAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ051bWJyby5qczogVmFsdWUgaXMgbm90IHN0cmluZy4gSXQgaGFzIGJlZW4gY28tZXJjZWQgdG86ICcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RyaW0gd2hpdGVzcGFjZXMgZnJvbSBlaXRoZXIgc2lkZXNcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcblxuICAgICAgICAvL2lmIHZhbCBpcyBqdXN0IGRpZ2l0cyByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoICEhIHZhbC5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB2YWwgaXMgZW1wdHkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL2dldCB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmRzIHNlcGFyYXRvciBmcm9tIG51bWJyby5jdWx0dXJlRGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgY3VsdHVyZSBpcyB1bmRlcnN0b29kIGJ5IG51bWJyby4gaWYgbm90LCBkZWZhdWx0IGl0IHRvIGN1cnJlbnQgY3VsdHVyZVxuICAgICAgICAgICAgY3VsdHVyZURhdGEgPSBudW1icm8uY3VsdHVyZURhdGEoY3VsdHVyZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGN1bHR1cmVEYXRhID0gbnVtYnJvLmN1bHR1cmVEYXRhKG51bWJyby5jdWx0dXJlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zZXR1cCB0aGUgZGVsaW1pdGVycyBhbmQgY3VycmVuY3kgc3ltYm9sIGJhc2VkIG9uIGN1bHR1cmVcbiAgICAgICAgX2N1cnJTeW1ib2wgPSBjdWx0dXJlRGF0YS5jdXJyZW5jeS5zeW1ib2w7XG4gICAgICAgIF9hYmJyT2JqID0gY3VsdHVyZURhdGEuYWJicmV2aWF0aW9ucztcbiAgICAgICAgX2RlY2ltYWxTZXAgPSBjdWx0dXJlRGF0YS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgIGlmIChjdWx0dXJlRGF0YS5kZWxpbWl0ZXJzLnRob3VzYW5kcyA9PT0gJy4nKSB7XG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAgPSAnXFxcXC4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Rob3VzYW5kU2VwID0gY3VsdHVyZURhdGEuZGVsaW1pdGVycy50aG91c2FuZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0aW5nIGN1cnJlbmN5IHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9eW15cXGRdKy8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cigxKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfY3VyclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdmFsaWRhdGluZyBhYmJyZXZpYXRpb24gc3ltYm9sXG4gICAgICAgIHRlbXAgPSB2YWwubWF0Y2goL1teXFxkXSskLyk7XG4gICAgICAgIGlmICh0ZW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgaWYgKHRlbXBbMF0gIT09IF9hYmJyT2JqLnRob3VzYW5kICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLm1pbGxpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgdGVtcFswXSAhPT0gX2FiYnJPYmouYmlsbGlvbiAmJiB0ZW1wWzBdICE9PSBfYWJick9iai50cmlsbGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aG91c2FuZFJlZ0V4ID0gbmV3IFJlZ0V4cChfdGhvdXNhbmRTZXAgKyAnezJ9Jyk7XG5cbiAgICAgICAgaWYgKCF2YWwubWF0Y2goL1teXFxkLixdL2cpKSB7XG4gICAgICAgICAgICBfdmFsQXJyYXkgPSB2YWwuc3BsaXQoX2RlY2ltYWxTZXApO1xuICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3ZhbEFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKy4qXFxkJC8pICYmICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3ZhbEFycmF5WzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKyQvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhISBfdmFsQXJyYXlbMF0ubWF0Y2goL15cXGQrLipcXGQkLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhIF92YWxBcnJheVsxXS5tYXRjaCgvXlxcZCskLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBzZXRDdWx0dXJlKGNvZGUsIHZhbHVlcykge1xuICAgICAgICBjdWx0dXJlc1tjb2RlXSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaG9vc2VDdWx0dXJlKGNvZGUpIHtcbiAgICAgICAgY3VycmVudEN1bHR1cmUgPSBjb2RlO1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSBjdWx0dXJlc1tjb2RlXS5kZWZhdWx0cztcbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmZvcm1hdCkge1xuICAgICAgICAgICAgbnVtYnJvLmRlZmF1bHRGb3JtYXQoZGVmYXVsdHMuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMuY3VycmVuY3lGb3JtYXQpIHtcbiAgICAgICAgICAgIG51bWJyby5kZWZhdWx0Q3VycmVuY3lGb3JtYXQoZGVmYXVsdHMuY3VycmVuY3lGb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0KGlucHV0LCBmb3JtYXRTdHJpbmcsIGxhbmd1YWdlLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChsYW5ndWFnZSAhPSBudWxsICYmIGxhbmd1YWdlICE9PSBudW1icm8uY3VsdHVyZSgpKSB7XG4gICAgICAgICAgICBudW1icm8uc2V0Q3VsdHVyZShsYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJybyhcbiAgICAgICAgICAgIE51bWJlcihpbnB1dCksXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmcgIT0gbnVsbCAgICAgPyBmb3JtYXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0LFxuICAgICAgICAgICAgcm91bmRpbmdGdW5jdGlvbiA9PSBudWxsID8gTWF0aC5yb3VuZCAgIDogcm91bmRpbmdGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XCJmb3JtYXRcIjogZm9ybWF0fTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgcGFyc2VDb2RlID0gcmVxdWlyZSgnLi9wYXJzZUNvZGUnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xudmFyIHByb2plY3Rpb25zID0gcmVxdWlyZSgnLi9wcm9qZWN0aW9ucycpO1xudmFyIGRlcml2ZUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vZGVyaXZlQ29uc3RhbnRzJyk7XG52YXIgRGF0dW0gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9EYXR1bScpO1xudmFyIGRhdHVtID0gcmVxdWlyZSgnLi9kYXR1bScpO1xuXG5cbmZ1bmN0aW9uIFByb2plY3Rpb24oc3JzQ29kZSxjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oc3JzQ29kZSk7XG4gIH1cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnJvcil7XG4gICAgaWYoZXJyb3Ipe1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICB2YXIganNvbiA9IHBhcnNlQ29kZShzcnNDb2RlKTtcbiAgaWYodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG91clByb2ogPSBQcm9qZWN0aW9uLnByb2plY3Rpb25zLmdldChqc29uLnByb2pOYW1lKTtcbiAgaWYoIW91clByb2ope1xuICAgIGNhbGxiYWNrKHNyc0NvZGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoanNvbi5kYXR1bUNvZGUgJiYganNvbi5kYXR1bUNvZGUgIT09ICdub25lJykge1xuICAgIHZhciBkYXR1bURlZiA9IERhdHVtW2pzb24uZGF0dW1Db2RlXTtcbiAgICBpZiAoZGF0dW1EZWYpIHtcbiAgICAgIGpzb24uZGF0dW1fcGFyYW1zID0gZGF0dW1EZWYudG93Z3M4NCA/IGRhdHVtRGVmLnRvd2dzODQuc3BsaXQoJywnKSA6IG51bGw7XG4gICAgICBqc29uLmVsbHBzID0gZGF0dW1EZWYuZWxsaXBzZTtcbiAgICAgIGpzb24uZGF0dW1OYW1lID0gZGF0dW1EZWYuZGF0dW1OYW1lID8gZGF0dW1EZWYuZGF0dW1OYW1lIDoganNvbi5kYXR1bUNvZGU7XG4gICAgfVxuICB9XG4gIGpzb24uazAgPSBqc29uLmswIHx8IDEuMDtcbiAganNvbi5heGlzID0ganNvbi5heGlzIHx8ICdlbnUnO1xuXG4gIHZhciBzcGhlcmUgPSBkZXJpdmVDb25zdGFudHMuc3BoZXJlKGpzb24uYSwganNvbi5iLCBqc29uLnJmLCBqc29uLmVsbHBzLCBqc29uLnNwaGVyZSk7XG4gIHZhciBlY2MgPSBkZXJpdmVDb25zdGFudHMuZWNjZW50cmljaXR5KHNwaGVyZS5hLCBzcGhlcmUuYiwgc3BoZXJlLnJmLCBqc29uLlJfQSk7XG4gIHZhciBkYXR1bU9iaiA9IGpzb24uZGF0dW0gfHwgZGF0dW0oanNvbi5kYXR1bUNvZGUsIGpzb24uZGF0dW1fcGFyYW1zLCBzcGhlcmUuYSwgc3BoZXJlLmIsIGVjYy5lcywgZWNjLmVwMik7XG5cbiAgZXh0ZW5kKHRoaXMsIGpzb24pOyAvLyB0cmFuc2ZlciBldmVyeXRoaW5nIG92ZXIgZnJvbSB0aGUgcHJvamVjdGlvbiBiZWNhdXNlIHdlIGRvbid0IGtub3cgd2hhdCB3ZSdsbCBuZWVkXG4gIGV4dGVuZCh0aGlzLCBvdXJQcm9qKTsgLy8gdHJhbnNmZXIgYWxsIHRoZSBtZXRob2RzIGZyb20gdGhlIHByb2plY3Rpb25cblxuICAvLyBjb3B5IHRoZSA0IHRoaW5ncyBvdmVyIHdlIGNhbHVsYXRlZCBpbiBkZXJpdmVDb25zdGFudHMuc3BoZXJlXG4gIHRoaXMuYSA9IHNwaGVyZS5hO1xuICB0aGlzLmIgPSBzcGhlcmUuYjtcbiAgdGhpcy5yZiA9IHNwaGVyZS5yZjtcbiAgdGhpcy5zcGhlcmUgPSBzcGhlcmUuc3BoZXJlO1xuXG4gIC8vIGNvcHkgdGhlIDMgdGhpbmdzIHdlIGNhbGN1bGF0ZWQgaW4gZGVyaXZlQ29uc3RhbnRzLmVjY2VudHJpY2l0eVxuICB0aGlzLmVzID0gZWNjLmVzO1xuICB0aGlzLmUgPSBlY2MuZTtcbiAgdGhpcy5lcDIgPSBlY2MuZXAyO1xuXG4gIC8vIGFkZCBpbiB0aGUgZGF0dW0gb2JqZWN0XG4gIHRoaXMuZGF0dW0gPSBkYXR1bU9iajtcblxuICAvLyBpbml0IHRoZSBwcm9qZWN0aW9uXG4gIHRoaXMuaW5pdCgpO1xuXG4gIC8vIGxlZ2VjeSBjYWxsYmFjayBmcm9tIGJhY2sgaW4gdGhlIGRheSB3aGVuIGl0IHdlbnQgdG8gc3BhdGlhbHJlZmVyZW5jZS5vcmdcbiAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG5cbn1cblByb2plY3Rpb24ucHJvamVjdGlvbnMgPSBwcm9qZWN0aW9ucztcblByb2plY3Rpb24ucHJvamVjdGlvbnMuc3RhcnQoKTtcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdGlvbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3JzLCBkZW5vcm0sIHBvaW50KSB7XG4gIHZhciB4aW4gPSBwb2ludC54LFxuICAgIHlpbiA9IHBvaW50LnksXG4gICAgemluID0gcG9pbnQueiB8fCAwLjA7XG4gIHZhciB2LCB0LCBpO1xuICB2YXIgb3V0ID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAoZGVub3JtICYmIGkgPT09IDIgJiYgcG9pbnQueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHYgPSB4aW47XG4gICAgICB0ID0gJ3gnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpID09PSAxKSB7XG4gICAgICB2ID0geWluO1xuICAgICAgdCA9ICd5JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2ID0gemluO1xuICAgICAgdCA9ICd6JztcbiAgICB9XG4gICAgc3dpdGNoIChjcnMuYXhpc1tpXSkge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgb3V0W3RdID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3cnOlxuICAgICAgb3V0W3RdID0gLXY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduJzpcbiAgICAgIG91dFt0XSA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIG91dFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndSc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQueiA9IHY7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkJzpcbiAgICAgIGlmIChwb2ludFt0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dC56ID0gLXY7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy9jb25zb2xlLmxvZyhcIkVSUk9SOiB1bmtub3cgYXhpcyAoXCIrY3JzLmF4aXNbaV0rXCIpIC0gY2hlY2sgZGVmaW5pdGlvbiBvZiBcIitjcnMucHJvak5hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIFRXT19QSSA9IE1hdGguUEkgKiAyO1xuLy8gU1BJIGlzIHNsaWdodGx5IGdyZWF0ZXIgdGhhbiBNYXRoLlBJLCBzbyB2YWx1ZXMgdGhhdCBleGNlZWQgdGhlIC0xODAuLjE4MFxuLy8gZGVncmVlIHJhbmdlIGJ5IGEgdGlueSBhbW91bnQgZG9uJ3QgZ2V0IHdyYXBwZWQuIFRoaXMgcHJldmVudHMgcG9pbnRzIHRoYXRcbi8vIGhhdmUgZHJpZnRlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFsb25nIHRoZSAxODB0aCBtZXJpZGlhbiAoZHVlIHRvXG4vLyBmbG9hdGluZyBwb2ludCBlcnJvcikgZnJvbSBjaGFuZ2luZyB0aGVpciBzaWduLlxudmFyIFNQSSA9IDMuMTQxNTkyNjUzNTk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8PSBTUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBUV09fUEkpKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHNpbnBoaSwgY29zcGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHJldHVybiBjb3NwaGkgLyAoTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pKTtcbn07IiwidmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgdHMpIHtcbiAgdmFyIGVjY250aCA9IDAuNSAqIGVjY2VudDtcbiAgdmFyIGNvbiwgZHBoaTtcbiAgdmFyIHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTU7IGkrKykge1xuICAgIGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHBoaSk7XG4gICAgZHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzICogKE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBlY2NudGgpKSkgLSBwaGk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgLy9jb25zb2xlLmxvZyhcInBoaTJ6IGhhcyBOb0NvbnZlcmdlbmNlXCIpO1xuICByZXR1cm4gLTk5OTk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDwwID8gLTEgOiAxO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnJheSl7XG4gIHZhciBvdXQgPSB7XG4gICAgeDogYXJyYXlbMF0sXG4gICAgeTogYXJyYXlbMV1cbiAgfTtcbiAgaWYgKGFycmF5Lmxlbmd0aD4yKSB7XG4gICAgb3V0LnogPSBhcnJheVsyXTtcbiAgfVxuICBpZiAoYXJyYXkubGVuZ3RoPjMpIHtcbiAgICBvdXQubSA9IGFycmF5WzNdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59OyIsInZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgcGhpLCBzaW5waGkpIHtcbiAgdmFyIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgdmFyIGNvbSA9IDAuNSAqIGVjY2VudDtcbiAgY29uID0gTWF0aC5wb3coKCgxIC0gY29uKSAvICgxICsgY29uKSksIGNvbSk7XG4gIHJldHVybiAoTWF0aC50YW4oMC41ICogKEhBTEZfUEkgLSBwaGkpKSAvIGNvbik7XG59OyIsImV4cG9ydHMud2dzODQgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJXR1M4NFwiLFxuICBkYXR1bU5hbWU6IFwiV0dTODRcIlxufTtcbmV4cG9ydHMuY2gxOTAzID0ge1xuICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcInN3aXNzXCJcbn07XG5leHBvcnRzLmdncnM4NyA9IHtcbiAgdG93Z3M4NDogXCItMTk5Ljg3LDc0Ljc5LDI0Ni42MlwiLFxuICBlbGxpcHNlOiBcIkdSUzgwXCIsXG4gIGRhdHVtTmFtZTogXCJHcmVla19HZW9kZXRpY19SZWZlcmVuY2VfU3lzdGVtXzE5ODdcIlxufTtcbmV4cG9ydHMubmFkODMgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTk4M1wiXG59O1xuZXhwb3J0cy5uYWQyNyA9IHtcbiAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuICBlbGxpcHNlOiBcImNscms2NlwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTkyN1wiXG59O1xuZXhwb3J0cy5wb3RzZGFtID0ge1xuICB0b3dnczg0OiBcIjYwNi4wLDIzLjAsNDEzLjBcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG59O1xuZXhwb3J0cy5jYXJ0aGFnZSA9IHtcbiAgdG93Z3M4NDogXCItMjYzLjAsNi4wLDQzMS4wXCIsXG4gIGVsbGlwc2U6IFwiY2xhcms4MFwiLFxuICBkYXR1bU5hbWU6IFwiQ2FydGhhZ2UgMTkzNCBUdW5pc2lhXCJcbn07XG5leHBvcnRzLmhlcm1hbm5za29nZWwgPSB7XG4gIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5leHBvcnRzLmlyZTY1ID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwibW9kX2FpcnlcIixcbiAgZGF0dW1OYW1lOiBcIklyZWxhbmQgMTk2NVwiXG59O1xuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5leHBvcnRzLm56Z2Q0OSA9IHtcbiAgdG93Z3M4NDogXCI1OS40NywtNS4wNCwxODcuNDQsMC40NywtMC4xLDEuMDI0LC00LjU5OTNcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJOZXcgWmVhbGFuZCBHZW9kZXRpYyBEYXR1bSAxOTQ5XCJcbn07XG5leHBvcnRzLm9zZ2IzNiA9IHtcbiAgdG93Z3M4NDogXCI0NDYuNDQ4LC0xMjUuMTU3LDU0Mi4wNjAsMC4xNTAyLDAuMjQ3MCwwLjg0MjEsLTIwLjQ4OTRcIixcbiAgZWxsaXBzZTogXCJhaXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcbmV4cG9ydHMuYmVkdWFyYW0gPSB7XG4gIHRvd2dzODQ6ICctMTA2LC04NywxODgnLFxuICBlbGxpcHNlOiAnY2xyazgwJyxcbiAgZGF0dW1OYW1lOiAnQmVkdWFyYW0nXG59O1xuZXhwb3J0cy5ndW51bmdfc2VnYXJhID0ge1xuICB0b3dnczg0OiAnLTQwMyw2ODQsNDEnLFxuICBlbGxpcHNlOiAnYmVzc2VsJyxcbiAgZGF0dW1OYW1lOiAnR3VudW5nIFNlZ2FyYSBKYWthcnRhJ1xufTtcbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59OyIsImV4cG9ydHMuTUVSSVQgPSB7XG4gIGE6IDYzNzgxMzcuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIk1FUklUIDE5ODNcIlxufTtcbmV4cG9ydHMuU0dTODUgPSB7XG4gIGE6IDYzNzgxMzYuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIlNvdmlldCBHZW9kZXRpYyBTeXN0ZW0gODVcIlxufTtcbmV4cG9ydHMuR1JTODAgPSB7XG4gIGE6IDYzNzgxMzcuMCxcbiAgcmY6IDI5OC4yNTcyMjIxMDEsXG4gIGVsbGlwc2VOYW1lOiBcIkdSUyAxOTgwKElVR0csIDE5ODApXCJcbn07XG5leHBvcnRzLklBVTc2ID0ge1xuICBhOiA2Mzc4MTQwLjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJJQVUgMTk3NlwiXG59O1xuZXhwb3J0cy5haXJ5ID0ge1xuICBhOiA2Mzc3NTYzLjM5NixcbiAgYjogNjM1NjI1Ni45MTAsXG4gIGVsbGlwc2VOYW1lOiBcIkFpcnkgMTgzMFwiXG59O1xuZXhwb3J0cy5BUEw0ID0ge1xuICBhOiA2Mzc4MTM3LFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJBcHBsLiBQaHlzaWNzLiAxOTY1XCJcbn07XG5leHBvcnRzLk5XTDlEID0ge1xuICBhOiA2Mzc4MTQ1LjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIk5hdmFsIFdlYXBvbnMgTGFiLiwgMTk2NVwiXG59O1xuZXhwb3J0cy5tb2RfYWlyeSA9IHtcbiAgYTogNjM3NzM0MC4xODksXG4gIGI6IDYzNTYwMzQuNDQ2LFxuICBlbGxpcHNlTmFtZTogXCJNb2RpZmllZCBBaXJ5XCJcbn07XG5leHBvcnRzLmFuZHJhZSA9IHtcbiAgYTogNjM3NzEwNC40MyxcbiAgcmY6IDMwMC4wLFxuICBlbGxpcHNlTmFtZTogXCJBbmRyYWUgMTg3NiAoRGVuLiwgSWNsbmQuKVwiXG59O1xuZXhwb3J0cy5hdXN0X1NBID0ge1xuICBhOiA2Mzc4MTYwLjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIkF1c3RyYWxpYW4gTmF0bCAmIFMuIEFtZXIuIDE5NjlcIlxufTtcbmV4cG9ydHMuR1JTNjcgPSB7XG4gIGE6IDYzNzgxNjAuMCxcbiAgcmY6IDI5OC4yNDcxNjc0MjcwLFxuICBlbGxpcHNlTmFtZTogXCJHUlMgNjcoSVVHRyAxOTY3KVwiXG59O1xuZXhwb3J0cy5iZXNzZWwgPSB7XG4gIGE6IDYzNzczOTcuMTU1LFxuICByZjogMjk5LjE1MjgxMjgsXG4gIGVsbGlwc2VOYW1lOiBcIkJlc3NlbCAxODQxXCJcbn07XG5leHBvcnRzLmJlc3NfbmFtID0ge1xuICBhOiA2Mzc3NDgzLjg2NSxcbiAgcmY6IDI5OS4xNTI4MTI4LFxuICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MSAoTmFtaWJpYSlcIlxufTtcbmV4cG9ydHMuY2xyazY2ID0ge1xuICBhOiA2Mzc4MjA2LjQsXG4gIGI6IDYzNTY1ODMuOCxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4NjZcIlxufTtcbmV4cG9ydHMuY2xyazgwID0ge1xuICBhOiA2Mzc4MjQ5LjE0NSxcbiAgcmY6IDI5My40NjYzLFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg4MCBtb2QuXCJcbn07XG5leHBvcnRzLmNscms1OCA9IHtcbiAgYTogNjM3ODI5My42NDUyMDg3NTksXG4gIHJmOiAyOTQuMjYwNjc2MzY5MjY1NCxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4NThcIlxufTtcbmV4cG9ydHMuQ1BNID0ge1xuICBhOiA2Mzc1NzM4LjcsXG4gIHJmOiAzMzQuMjksXG4gIGVsbGlwc2VOYW1lOiBcIkNvbW0uIGRlcyBQb2lkcyBldCBNZXN1cmVzIDE3OTlcIlxufTtcbmV4cG9ydHMuZGVsbWJyID0ge1xuICBhOiA2Mzc2NDI4LjAsXG4gIHJmOiAzMTEuNSxcbiAgZWxsaXBzZU5hbWU6IFwiRGVsYW1icmUgMTgxMCAoQmVsZ2l1bSlcIlxufTtcbmV4cG9ydHMuZW5nZWxpcyA9IHtcbiAgYTogNjM3ODEzNi4wNSxcbiAgcmY6IDI5OC4yNTY2LFxuICBlbGxpcHNlTmFtZTogXCJFbmdlbGlzIDE5ODVcIlxufTtcbmV4cG9ydHMuZXZyc3QzMCA9IHtcbiAgYTogNjM3NzI3Ni4zNDUsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxODMwXCJcbn07XG5leHBvcnRzLmV2cnN0NDggPSB7XG4gIGE6IDYzNzczMDQuMDYzLFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTk0OFwiXG59O1xuZXhwb3J0cy5ldnJzdDU2ID0ge1xuICBhOiA2Mzc3MzAxLjI0MyxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NTZcIlxufTtcbmV4cG9ydHMuZXZyc3Q2OSA9IHtcbiAgYTogNjM3NzI5NS42NjQsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTY5XCJcbn07XG5leHBvcnRzLmV2cnN0U1MgPSB7XG4gIGE6IDYzNzcyOTguNTU2LFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgKFNhYmFoICYgU2FyYXdhaylcIlxufTtcbmV4cG9ydHMuZnNjaHI2MCA9IHtcbiAgYTogNjM3ODE2Ni4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgKE1lcmN1cnkgRGF0dW0pIDE5NjBcIlxufTtcbmV4cG9ydHMuZnNjaHI2MG0gPSB7XG4gIGE6IDYzNzgxNTUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjBcIlxufTtcbmV4cG9ydHMuZnNjaHI2OCA9IHtcbiAgYTogNjM3ODE1MC4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgMTk2OFwiXG59O1xuZXhwb3J0cy5oZWxtZXJ0ID0ge1xuICBhOiA2Mzc4MjAwLjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiSGVsbWVydCAxOTA2XCJcbn07XG5leHBvcnRzLmhvdWdoID0ge1xuICBhOiA2Mzc4MjcwLjAsXG4gIHJmOiAyOTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiSG91Z2hcIlxufTtcbmV4cG9ydHMuaW50bCA9IHtcbiAgYTogNjM3ODM4OC4wLFxuICByZjogMjk3LjAsXG4gIGVsbGlwc2VOYW1lOiBcIkludGVybmF0aW9uYWwgMTkwOSAoSGF5Zm9yZClcIlxufTtcbmV4cG9ydHMua2F1bGEgPSB7XG4gIGE6IDYzNzgxNjMuMCxcbiAgcmY6IDI5OC4yNCxcbiAgZWxsaXBzZU5hbWU6IFwiS2F1bGEgMTk2MVwiXG59O1xuZXhwb3J0cy5sZXJjaCA9IHtcbiAgYTogNjM3ODEzOS4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiTGVyY2ggMTk3OVwiXG59O1xuZXhwb3J0cy5tcHJ0cyA9IHtcbiAgYTogNjM5NzMwMC4wLFxuICByZjogMTkxLjAsXG4gIGVsbGlwc2VOYW1lOiBcIk1hdXBlcnRpdXMgMTczOFwiXG59O1xuZXhwb3J0cy5uZXdfaW50bCA9IHtcbiAgYTogNjM3ODE1Ny41LFxuICBiOiA2MzU2NzcyLjIsXG4gIGVsbGlwc2VOYW1lOiBcIk5ldyBJbnRlcm5hdGlvbmFsIDE5NjdcIlxufTtcbmV4cG9ydHMucGxlc3NpcyA9IHtcbiAgYTogNjM3NjUyMy4wLFxuICByZjogNjM1NTg2My4wLFxuICBlbGxpcHNlTmFtZTogXCJQbGVzc2lzIDE4MTcgKEZyYW5jZSlcIlxufTtcbmV4cG9ydHMua3Jhc3MgPSB7XG4gIGE6IDYzNzgyNDUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJLcmFzc292c2t5LCAxOTQyXCJcbn07XG5leHBvcnRzLlNFYXNpYSA9IHtcbiAgYTogNjM3ODE1NS4wLFxuICBiOiA2MzU2NzczLjMyMDUsXG4gIGVsbGlwc2VOYW1lOiBcIlNvdXRoZWFzdCBBc2lhXCJcbn07XG5leHBvcnRzLndhbGJlY2sgPSB7XG4gIGE6IDYzNzY4OTYuMCxcbiAgYjogNjM1NTgzNC44NDY3LFxuICBlbGxpcHNlTmFtZTogXCJXYWxiZWNrXCJcbn07XG5leHBvcnRzLldHUzYwID0ge1xuICBhOiA2Mzc4MTY1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDYwXCJcbn07XG5leHBvcnRzLldHUzY2ID0ge1xuICBhOiA2Mzc4MTQ1LjAsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA2NlwiXG59O1xuZXhwb3J0cy5XR1M3ID0ge1xuICBhOiA2Mzc4MTM1LjAsXG4gIHJmOiAyOTguMjYsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA3MlwiXG59O1xuZXhwb3J0cy5XR1M4NCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NzIyMzU2MyxcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDg0XCJcbn07XG5leHBvcnRzLnNwaGVyZSA9IHtcbiAgYTogNjM3MDk5Ny4wLFxuICBiOiA2MzcwOTk3LjAsXG4gIGVsbGlwc2VOYW1lOiBcIk5vcm1hbCBTcGhlcmUgKHI9NjM3MDk5NylcIlxufTsiLCJleHBvcnRzLmdyZWVud2ljaCA9IDAuMDsgLy9cIjBkRVwiLFxuZXhwb3J0cy5saXNib24gPSAtOS4xMzE5MDYxMTExMTE7IC8vXCI5ZDA3JzU0Ljg2MlxcXCJXXCIsXG5leHBvcnRzLnBhcmlzID0gMi4zMzcyMjkxNjY2Njc7IC8vXCIyZDIwJzE0LjAyNVxcXCJFXCIsXG5leHBvcnRzLmJvZ290YSA9IC03NC4wODA5MTY2NjY2Njc7IC8vXCI3NGQwNCc1MS4zXFxcIldcIixcbmV4cG9ydHMubWFkcmlkID0gLTMuNjg3OTM4ODg4ODg5OyAvL1wiM2Q0MScxNi41OFxcXCJXXCIsXG5leHBvcnRzLnJvbWUgPSAxMi40NTIzMzMzMzMzMzM7IC8vXCIxMmQyNyc4LjRcXFwiRVwiLFxuZXhwb3J0cy5iZXJuID0gNy40Mzk1ODMzMzMzMzM7IC8vXCI3ZDI2JzIyLjVcXFwiRVwiLFxuZXhwb3J0cy5qYWthcnRhID0gMTA2LjgwNzcxOTQ0NDQ0NDsgLy9cIjEwNmQ0OCcyNy43OVxcXCJFXCIsXG5leHBvcnRzLmZlcnJvID0gLTE3LjY2NjY2NjY2NjY2NzsgLy9cIjE3ZDQwJ1dcIixcbmV4cG9ydHMuYnJ1c3NlbHMgPSA0LjM2Nzk3NTsgLy9cIjRkMjInNC43MVxcXCJFXCIsXG5leHBvcnRzLnN0b2NraG9sbSA9IDE4LjA1ODI3Nzc3Nzc3ODsgLy9cIjE4ZDMnMjkuOFxcXCJFXCIsXG5leHBvcnRzLmF0aGVucyA9IDIzLjcxNjMzNzU7IC8vXCIyM2Q0Mic1OC44MTVcXFwiRVwiLFxuZXhwb3J0cy5vc2xvID0gMTAuNzIyOTE2NjY2NjY3OyAvL1wiMTBkNDMnMjIuNVxcXCJFXCIiLCJleHBvcnRzLmZ0ID0ge3RvX21ldGVyOiAwLjMwNDh9O1xuZXhwb3J0c1sndXMtZnQnXSA9IHt0b19tZXRlcjogMTIwMCAvIDM5Mzd9O1xuIiwidmFyIHByb2ogPSByZXF1aXJlKCcuL1Byb2onKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpO1xudmFyIHdnczg0ID0gcHJvaignV0dTODQnKTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoZnJvbSwgdG8sIGNvb3Jkcykge1xuICB2YXIgdHJhbnNmb3JtZWRBcnJheTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xuICAgIHRyYW5zZm9ybWVkQXJyYXkgPSB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3Jkcyk7XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBbdHJhbnNmb3JtZWRBcnJheS54LCB0cmFuc2Zvcm1lZEFycmF5LnksIHRyYW5zZm9ybWVkQXJyYXkuel07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueV07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3Jkcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9qKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBwcm9qKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKGl0ZW0ub1Byb2opIHtcbiAgICByZXR1cm4gaXRlbS5vUHJvajtcbiAgfVxuICByZXR1cm4gcHJvaihpdGVtKTtcbn1cbmZ1bmN0aW9uIHByb2o0KGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKSB7XG4gIGZyb21Qcm9qID0gY2hlY2tQcm9qKGZyb21Qcm9qKTtcbiAgdmFyIHNpbmdsZSA9IGZhbHNlO1xuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIHRvUHJvaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIHRvUHJvai54ICE9PSAndW5kZWZpbmVkJyB8fCBBcnJheS5pc0FycmF5KHRvUHJvaikpIHtcbiAgICBjb29yZCA9IHRvUHJvajtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH1cbiAgdG9Qcm9qID0gY2hlY2tQcm9qKHRvUHJvaik7XG4gIGlmIChjb29yZCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgZm9yd2FyZDogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZHMpO1xuICAgICAgfSxcbiAgICAgIGludmVyc2U6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIodG9Qcm9qLCBmcm9tUHJvaiwgY29vcmRzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzaW5nbGUpIHtcbiAgICAgIG9iai5vUHJvaiA9IHRvUHJvajtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBwcm9qNDsiLCJ2YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgUEpEX1dHUzg0ID0gNDsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xuXG5mdW5jdGlvbiBkYXR1bShkYXR1bUNvZGUsIGRhdHVtX3BhcmFtcywgYSwgYiwgZXMsIGVwMikge1xuICB2YXIgb3V0ID0ge307XG4gIG91dC5kYXR1bV90eXBlID0gUEpEX1dHUzg0OyAvL2RlZmF1bHQgc2V0dGluZ1xuICBpZiAoZGF0dW1Db2RlICYmIGRhdHVtQ29kZSA9PT0gJ25vbmUnKSB7XG4gICAgb3V0LmRhdHVtX3R5cGUgPSBQSkRfTk9EQVRVTTtcbiAgfVxuXG4gIGlmIChkYXR1bV9wYXJhbXMpIHtcbiAgICBvdXQuZGF0dW1fcGFyYW1zID0gZGF0dW1fcGFyYW1zLm1hcChwYXJzZUZsb2F0KTtcbiAgICBpZiAob3V0LmRhdHVtX3BhcmFtc1swXSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzFdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbMl0gIT09IDApIHtcbiAgICAgIG91dC5kYXR1bV90eXBlID0gUEpEXzNQQVJBTTtcbiAgICB9XG4gICAgaWYgKG91dC5kYXR1bV9wYXJhbXMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKG91dC5kYXR1bV9wYXJhbXNbM10gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1s0XSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzVdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbNl0gIT09IDApIHtcbiAgICAgICAgb3V0LmRhdHVtX3R5cGUgPSBQSkRfN1BBUkFNO1xuICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzNdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIG91dC5kYXR1bV9wYXJhbXNbNF0gKj0gU0VDX1RPX1JBRDtcbiAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1s1XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzZdID0gKG91dC5kYXR1bV9wYXJhbXNbNl0gLyAxMDAwMDAwLjApICsgMS4wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgb3V0LmEgPSBhOyAvL2RhdHVtIG9iamVjdCBhbHNvIHVzZXMgdGhlc2UgdmFsdWVzXG4gIG91dC5iID0gYjtcbiAgb3V0LmVzID0gZXM7XG4gIG91dC5lcDIgPSBlcDI7XG4gIHJldHVybiBvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0dW07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblxuZXhwb3J0cy5jb21wYXJlRGF0dW1zID0gZnVuY3Rpb24oc291cmNlLCBkZXN0KSB7XG4gIGlmIChzb3VyY2UuZGF0dW1fdHlwZSAhPT0gZGVzdC5kYXR1bV90eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBmYWxzZSwgZGF0dW1zIGFyZSBub3QgZXF1YWxcbiAgfSBlbHNlIGlmIChzb3VyY2UuYSAhPT0gZGVzdC5hIHx8IE1hdGguYWJzKHRoaXMuZXMgLSBkZXN0LmVzKSA+IDAuMDAwMDAwMDAwMDUwKSB7XG4gICAgLy8gdGhlIHRvbGVyZW5jZSBmb3IgZXMgaXMgdG8gZW5zdXJlIHRoYXQgR1JTODAgYW5kIFdHUzg0XG4gICAgLy8gYXJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdHVtX3BhcmFtc1swXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMF0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1sxXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMV0gJiYgc291cmNlLmRhdHVtX3BhcmFtc1syXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMl0pO1xuICB9IGVsc2UgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgcmV0dXJuIChzb3VyY2UuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzNdID09PSBkZXN0LmRhdHVtX3BhcmFtc1szXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzRdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s0XSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzVdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s1XSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzZdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s2XSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7IC8vIGRhdHVtcyBhcmUgZXF1YWxcbiAgfVxufTsgLy8gY3NfY29tcGFyZV9kYXR1bXMoKVxuXG4vKlxuICogVGhlIGZ1bmN0aW9uIENvbnZlcnRfR2VvZGV0aWNfVG9fR2VvY2VudHJpYyBjb252ZXJ0cyBnZW9kZXRpYyBjb29yZGluYXRlc1xuICogKGxhdGl0dWRlLCBsb25naXR1ZGUsIGFuZCBoZWlnaHQpIHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKFgsIFksIFopLFxuICogYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGVsbGlwc29pZCBwYXJhbWV0ZXJzLlxuICpcbiAqICAgIExhdGl0dWRlICA6IEdlb2RldGljIGxhdGl0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gKiAgICBMb25naXR1ZGUgOiBHZW9kZXRpYyBsb25naXR1ZGUgaW4gcmFkaWFucyAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICogICAgSGVpZ2h0ICAgIDogR2VvZGV0aWMgaGVpZ2h0LCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAqICAgIFggICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBYIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICogICAgWSAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFkgY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gKiAgICBaICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWiBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAqXG4gKi9cbmV4cG9ydHMuZ2VvZGV0aWNUb0dlb2NlbnRyaWMgPSBmdW5jdGlvbihwLCBlcywgYSkge1xuICB2YXIgTG9uZ2l0dWRlID0gcC54O1xuICB2YXIgTGF0aXR1ZGUgPSBwLnk7XG4gIHZhciBIZWlnaHQgPSBwLnogPyBwLnogOiAwOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuXG4gIHZhciBSbjsgLyogIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAgKi9cbiAgdmFyIFNpbl9MYXQ7IC8qICBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gIHZhciBTaW4yX0xhdDsgLyogIFNxdWFyZSBvZiBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gIHZhciBDb3NfTGF0OyAvKiAgTWF0aC5jb3MoTGF0aXR1ZGUpICAqL1xuXG4gIC8qXG4gICAqKiBEb24ndCBibG93IHVwIGlmIExhdGl0dWRlIGlzIGp1c3QgYSBsaXR0bGUgb3V0IG9mIHRoZSB2YWx1ZVxuICAgKiogcmFuZ2UgYXMgaXQgbWF5IGp1c3QgYmUgYSByb3VuZGluZyBpc3N1ZS4gIEFsc28gcmVtb3ZlZCBsb25naXR1ZGVcbiAgICoqIHRlc3QsIGl0IHNob3VsZCBiZSB3cmFwcGVkIGJ5IE1hdGguY29zKCkgYW5kIE1hdGguc2luKCkuICBORlcgZm9yIFBST0ouNCwgU2VwLzIwMDEuXG4gICAqL1xuICBpZiAoTGF0aXR1ZGUgPCAtSEFMRl9QSSAmJiBMYXRpdHVkZSA+IC0xLjAwMSAqIEhBTEZfUEkpIHtcbiAgICBMYXRpdHVkZSA9IC1IQUxGX1BJO1xuICB9IGVsc2UgaWYgKExhdGl0dWRlID4gSEFMRl9QSSAmJiBMYXRpdHVkZSA8IDEuMDAxICogSEFMRl9QSSkge1xuICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgfSBlbHNlIGlmICgoTGF0aXR1ZGUgPCAtSEFMRl9QSSkgfHwgKExhdGl0dWRlID4gSEFMRl9QSSkpIHtcbiAgICAvKiBMYXRpdHVkZSBvdXQgb2YgcmFuZ2UgKi9cbiAgICAvLy4ucmVwb3J0RXJyb3IoJ2dlb2NlbnQ6bGF0IG91dCBvZiByYW5nZTonICsgTGF0aXR1ZGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKExvbmdpdHVkZSA+IE1hdGguUEkpIHtcbiAgICBMb25naXR1ZGUgLT0gKDIgKiBNYXRoLlBJKTtcbiAgfVxuICBTaW5fTGF0ID0gTWF0aC5zaW4oTGF0aXR1ZGUpO1xuICBDb3NfTGF0ID0gTWF0aC5jb3MoTGF0aXR1ZGUpO1xuICBTaW4yX0xhdCA9IFNpbl9MYXQgKiBTaW5fTGF0O1xuICBSbiA9IGEgLyAoTWF0aC5zcXJ0KDEuMGUwIC0gZXMgKiBTaW4yX0xhdCkpO1xuICByZXR1cm4ge1xuICAgIHg6IChSbiArIEhlaWdodCkgKiBDb3NfTGF0ICogTWF0aC5jb3MoTG9uZ2l0dWRlKSxcbiAgICB5OiAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguc2luKExvbmdpdHVkZSksXG4gICAgejogKChSbiAqICgxIC0gZXMpKSArIEhlaWdodCkgKiBTaW5fTGF0XG4gIH07XG59OyAvLyBjc19nZW9kZXRpY190b19nZW9jZW50cmljKClcblxuXG5leHBvcnRzLmdlb2NlbnRyaWNUb0dlb2RldGljID0gZnVuY3Rpb24ocCwgZXMsIGEsIGIpIHtcbiAgLyogbG9jYWwgZGVmaW50aW9ucyBhbmQgdmFyaWFibGVzICovXG4gIC8qIGVuZC1jcml0ZXJpdW0gb2YgbG9vcCwgYWNjdXJhY3kgb2Ygc2luKExhdGl0dWRlKSAqL1xuICB2YXIgZ2VuYXUgPSAxZS0xMjtcbiAgdmFyIGdlbmF1MiA9IChnZW5hdSAqIGdlbmF1KTtcbiAgdmFyIG1heGl0ZXIgPSAzMDtcblxuICB2YXIgUDsgLyogZGlzdGFuY2UgYmV0d2VlbiBzZW1pLW1pbm9yIGF4aXMgYW5kIGxvY2F0aW9uICovXG4gIHZhciBSUjsgLyogZGlzdGFuY2UgYmV0d2VlbiBjZW50ZXIgYW5kIGxvY2F0aW9uICovXG4gIHZhciBDVDsgLyogc2luIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cbiAgdmFyIFNUOyAvKiBjb3Mgb2YgZ2VvY2VudHJpYyBsYXRpdHVkZSAqL1xuICB2YXIgUlg7XG4gIHZhciBSSztcbiAgdmFyIFJOOyAvKiBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gKi9cbiAgdmFyIENQSEkwOyAvKiBjb3Mgb2Ygc3RhcnQgb3Igb2xkIGdlb2RldGljIGxhdGl0dWRlIGluIGl0ZXJhdGlvbnMgKi9cbiAgdmFyIFNQSEkwOyAvKiBzaW4gb2Ygc3RhcnQgb3Igb2xkIGdlb2RldGljIGxhdGl0dWRlIGluIGl0ZXJhdGlvbnMgKi9cbiAgdmFyIENQSEk7IC8qIGNvcyBvZiBzZWFyY2hlZCBnZW9kZXRpYyBsYXRpdHVkZSAqL1xuICB2YXIgU1BISTsgLyogc2luIG9mIHNlYXJjaGVkIGdlb2RldGljIGxhdGl0dWRlICovXG4gIHZhciBTRFBISTsgLyogZW5kLWNyaXRlcml1bTogYWRkaXRpb24tdGhlb3JlbSBvZiBzaW4oTGF0aXR1ZGUoaXRlciktTGF0aXR1ZGUoaXRlci0xKSkgKi9cbiAgdmFyIGl0ZXI7IC8qICMgb2YgY29udGlub3VzIGl0ZXJhdGlvbiwgbWF4LiAzMCBpcyBhbHdheXMgZW5vdWdoIChzLmEuKSAqL1xuXG4gIHZhciBYID0gcC54O1xuICB2YXIgWSA9IHAueTtcbiAgdmFyIFogPSBwLnogPyBwLnogOiAwLjA7IC8vWiB2YWx1ZSBub3QgYWx3YXlzIHN1cHBsaWVkXG4gIHZhciBMb25naXR1ZGU7XG4gIHZhciBMYXRpdHVkZTtcbiAgdmFyIEhlaWdodDtcblxuICBQID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkpO1xuICBSUiA9IE1hdGguc3FydChYICogWCArIFkgKiBZICsgWiAqIFopO1xuXG4gIC8qICAgICAgc3BlY2lhbCBjYXNlcyBmb3IgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAqL1xuICBpZiAoUCAvIGEgPCBnZW5hdSkge1xuXG4gICAgLyogIHNwZWNpYWwgY2FzZSwgaWYgUD0wLiAoWD0wLiwgWT0wLikgKi9cbiAgICBMb25naXR1ZGUgPSAwLjA7XG5cbiAgICAvKiAgaWYgKFgsWSxaKT0oMC4sMC4sMC4pIHRoZW4gSGVpZ2h0IGJlY29tZXMgc2VtaS1taW5vciBheGlzXG4gICAgICogIG9mIGVsbGlwc29pZCAoPWNlbnRlciBvZiBtYXNzKSwgTGF0aXR1ZGUgYmVjb21lcyBQSS8yICovXG4gICAgaWYgKFJSIC8gYSA8IGdlbmF1KSB7XG4gICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gICAgICBIZWlnaHQgPSAtYjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAueCxcbiAgICAgICAgeTogcC55LFxuICAgICAgICB6OiBwLnpcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8qICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGxvbmdpdHVkZVxuICAgICAqICBpbnRlcnZhbDogLVBJIDwgTG9uZ2l0dWRlIDw9ICtQSSAqL1xuICAgIExvbmdpdHVkZSA9IE1hdGguYXRhbjIoWSwgWCk7XG4gIH1cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBGb2xsb3dpbmcgaXRlcmF0aXZlIGFsZ29yaXRobSB3YXMgZGV2ZWxvcHBlZCBieVxuICAgKiBcIkluc3RpdHV0IGZvciBFcmRtZXNzdW5nXCIsIFVuaXZlcnNpdHkgb2YgSGFubm92ZXIsIEp1bHkgMTk4OC5cbiAgICogSW50ZXJuZXQ6IHd3dy5pZmUudW5pLWhhbm5vdmVyLmRlXG4gICAqIEl0ZXJhdGl2ZSBjb21wdXRhdGlvbiBvZiBDUEhJLFNQSEkgYW5kIEhlaWdodC5cbiAgICogSXRlcmF0aW9uIG9mIENQSEkgYW5kIFNQSEkgdG8gMTAqKi0xMiByYWRpYW4gcmVzcC5cbiAgICogMioxMCoqLTcgYXJjc2VjLlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgQ1QgPSBaIC8gUlI7XG4gIFNUID0gUCAvIFJSO1xuICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSBlcyAqICgyLjAgLSBlcykgKiBTVCAqIFNUKTtcbiAgQ1BISTAgPSBTVCAqICgxLjAgLSBlcykgKiBSWDtcbiAgU1BISTAgPSBDVCAqIFJYO1xuICBpdGVyID0gMDtcblxuICAvKiBsb29wIHRvIGZpbmQgc2luKExhdGl0dWRlKSByZXNwLiBMYXRpdHVkZVxuICAgKiB1bnRpbCB8c2luKExhdGl0dWRlKGl0ZXIpLUxhdGl0dWRlKGl0ZXItMSkpfCA8IGdlbmF1ICovXG4gIGRvIHtcbiAgICBpdGVyKys7XG4gICAgUk4gPSBhIC8gTWF0aC5zcXJ0KDEuMCAtIGVzICogU1BISTAgKiBTUEhJMCk7XG5cbiAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBoZWlnaHQgKi9cbiAgICBIZWlnaHQgPSBQICogQ1BISTAgKyBaICogU1BISTAgLSBSTiAqICgxLjAgLSBlcyAqIFNQSEkwICogU1BISTApO1xuXG4gICAgUksgPSBlcyAqIFJOIC8gKFJOICsgSGVpZ2h0KTtcbiAgICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSBSSyAqICgyLjAgLSBSSykgKiBTVCAqIFNUKTtcbiAgICBDUEhJID0gU1QgKiAoMS4wIC0gUkspICogUlg7XG4gICAgU1BISSA9IENUICogUlg7XG4gICAgU0RQSEkgPSBTUEhJICogQ1BISTAgLSBDUEhJICogU1BISTA7XG4gICAgQ1BISTAgPSBDUEhJO1xuICAgIFNQSEkwID0gU1BISTtcbiAgfVxuICB3aGlsZSAoU0RQSEkgKiBTRFBISSA+IGdlbmF1MiAmJiBpdGVyIDwgbWF4aXRlcik7XG5cbiAgLyogICAgICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGxhdGl0dWRlICovXG4gIExhdGl0dWRlID0gTWF0aC5hdGFuKFNQSEkgLyBNYXRoLmFicyhDUEhJKSk7XG4gIHJldHVybiB7XG4gICAgeDogTG9uZ2l0dWRlLFxuICAgIHk6IExhdGl0dWRlLFxuICAgIHo6IEhlaWdodFxuICB9O1xufTsgLy8gY3NfZ2VvY2VudHJpY190b19nZW9kZXRpYygpXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBwal9nZW9jZW50aWNfdG9fd2dzODQoIHAgKVxuLy8gIHAgPSBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG5cblxuLyoqIHBvaW50IG9iamVjdCwgbm90aGluZyBmYW5jeSwganVzdCBhbGxvd3MgdmFsdWVzIHRvIGJlXG4gICAgcGFzc2VkIGJhY2sgYW5kIGZvcnRoIGJ5IHJlZmVyZW5jZSByYXRoZXIgdGhhbiBieSB2YWx1ZS5cbiAgICBPdGhlciBwb2ludCBjbGFzc2VzIG1heSBiZSB1c2VkIGFzIGxvbmcgYXMgdGhleSBoYXZlXG4gICAgeCBhbmQgeSBwcm9wZXJ0aWVzLCB3aGljaCB3aWxsIGdldCBtb2RpZmllZCBpbiB0aGUgdHJhbnNmb3JtIG1ldGhvZC5cbiovXG5leHBvcnRzLmdlb2NlbnRyaWNUb1dnczg0ID0gZnVuY3Rpb24ocCwgZGF0dW1fdHlwZSwgZGF0dW1fcGFyYW1zKSB7XG5cbiAgaWYgKGRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcbiAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54ICsgZGF0dW1fcGFyYW1zWzBdLFxuICAgICAgeTogcC55ICsgZGF0dW1fcGFyYW1zWzFdLFxuICAgICAgejogcC56ICsgZGF0dW1fcGFyYW1zWzJdLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgIHZhciBEeF9CRiA9IGRhdHVtX3BhcmFtc1swXTtcbiAgICB2YXIgRHlfQkYgPSBkYXR1bV9wYXJhbXNbMV07XG4gICAgdmFyIER6X0JGID0gZGF0dW1fcGFyYW1zWzJdO1xuICAgIHZhciBSeF9CRiA9IGRhdHVtX3BhcmFtc1szXTtcbiAgICB2YXIgUnlfQkYgPSBkYXR1bV9wYXJhbXNbNF07XG4gICAgdmFyIFJ6X0JGID0gZGF0dW1fcGFyYW1zWzVdO1xuICAgIHZhciBNX0JGID0gZGF0dW1fcGFyYW1zWzZdO1xuICAgIC8vIGlmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgIC8vICAgIGNvbnRpbnVlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNX0JGICogKHAueCAtIFJ6X0JGICogcC55ICsgUnlfQkYgKiBwLnopICsgRHhfQkYsXG4gICAgICB5OiBNX0JGICogKFJ6X0JGICogcC54ICsgcC55IC0gUnhfQkYgKiBwLnopICsgRHlfQkYsXG4gICAgICB6OiBNX0JGICogKC1SeV9CRiAqIHAueCArIFJ4X0JGICogcC55ICsgcC56KSArIER6X0JGXG4gICAgfTtcbiAgfVxufTsgLy8gY3NfZ2VvY2VudHJpY190b193Z3M4NFxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vIHBqX2dlb2NlbnRpY19mcm9tX3dnczg0KClcbi8vICBjb29yZGluYXRlIHN5c3RlbSBkZWZpbml0aW9uLFxuLy8gIHBvaW50IHRvIHRyYW5zZm9ybSBpbiBnZW9jZW50cmljIGNvb3JkaW5hdGVzICh4LHkseilcbmV4cG9ydHMuZ2VvY2VudHJpY0Zyb21XZ3M4NCA9IGZ1bmN0aW9uKHAsIGRhdHVtX3R5cGUsIGRhdHVtX3BhcmFtcykge1xuXG4gIGlmIChkYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54IC0gZGF0dW1fcGFyYW1zWzBdLFxuICAgICAgeTogcC55IC0gZGF0dW1fcGFyYW1zWzFdLFxuICAgICAgejogcC56IC0gZGF0dW1fcGFyYW1zWzJdLFxuICAgIH07XG5cbiAgfSBlbHNlIGlmIChkYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgdmFyIER4X0JGID0gZGF0dW1fcGFyYW1zWzBdO1xuICAgIHZhciBEeV9CRiA9IGRhdHVtX3BhcmFtc1sxXTtcbiAgICB2YXIgRHpfQkYgPSBkYXR1bV9wYXJhbXNbMl07XG4gICAgdmFyIFJ4X0JGID0gZGF0dW1fcGFyYW1zWzNdO1xuICAgIHZhciBSeV9CRiA9IGRhdHVtX3BhcmFtc1s0XTtcbiAgICB2YXIgUnpfQkYgPSBkYXR1bV9wYXJhbXNbNV07XG4gICAgdmFyIE1fQkYgPSBkYXR1bV9wYXJhbXNbNl07XG4gICAgdmFyIHhfdG1wID0gKHAueCAtIER4X0JGKSAvIE1fQkY7XG4gICAgdmFyIHlfdG1wID0gKHAueSAtIER5X0JGKSAvIE1fQkY7XG4gICAgdmFyIHpfdG1wID0gKHAueiAtIER6X0JGKSAvIE1fQkY7XG4gICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAvLyAgICBjb250aW51ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4X3RtcCArIFJ6X0JGICogeV90bXAgLSBSeV9CRiAqIHpfdG1wLFxuICAgICAgeTogLVJ6X0JGICogeF90bXAgKyB5X3RtcCArIFJ4X0JGICogel90bXAsXG4gICAgICB6OiBSeV9CRiAqIHhfdG1wIC0gUnhfQkYgKiB5X3RtcCArIHpfdG1wXG4gICAgfTtcbiAgfSAvL2NzX2dlb2NlbnRyaWNfZnJvbV93Z3M4NCgpXG59O1xuIiwidmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIGRhdHVtID0gcmVxdWlyZSgnLi9kYXR1bVV0aWxzJyk7XG5mdW5jdGlvbiBjaGVja1BhcmFtcyh0eXBlKSB7XG4gIHJldHVybiAodHlwZSA9PT0gUEpEXzNQQVJBTSB8fCB0eXBlID09PSBQSkRfN1BBUkFNKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlLCBkZXN0LCBwb2ludCkge1xuICAvLyBTaG9ydCBjdXQgaWYgdGhlIGRhdHVtcyBhcmUgaWRlbnRpY2FsLlxuICBpZiAoZGF0dW0uY29tcGFyZURhdHVtcyhzb3VyY2UsIGRlc3QpKSB7XG4gICAgcmV0dXJuIHBvaW50OyAvLyBpbiB0aGlzIGNhc2UsIHplcm8gaXMgc3VjZXNzLFxuICAgIC8vIHdoZXJlYXMgY3NfY29tcGFyZV9kYXR1bXMgcmV0dXJucyAxIHRvIGluZGljYXRlIFRSVUVcbiAgICAvLyBjb25mdXNpbmcsIHNob3VsZCBmaXggdGhpc1xuICB9XG5cbiAgLy8gRXhwbGljaXRseSBza2lwIGRhdHVtIHRyYW5zZm9ybSBieSBzZXR0aW5nICdkYXR1bT1ub25lJyBhcyBwYXJhbWV0ZXIgZm9yIGVpdGhlciBzb3VyY2Ugb3IgZGVzdFxuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNIHx8IGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX05PREFUVU0pIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBJZiB0aGlzIGRhdHVtIHJlcXVpcmVzIGdyaWQgc2hpZnRzLCB0aGVuIGFwcGx5IGl0IHRvIGdlb2RldGljIGNvb3JkaW5hdGVzLlxuXG4gIC8vIERvIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBnZW9jZW50cmljIGNvb3JkaW5hdGVzP1xuICBpZiAoc291cmNlLmVzID09PSBkZXN0LmVzICYmIHNvdXJjZS5hID09PSBkZXN0LmEgJiYgIWNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSAmJiAgIWNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG4gIHBvaW50ID0gZGF0dW0uZ2VvZGV0aWNUb0dlb2NlbnRyaWMocG9pbnQsIHNvdXJjZS5lcywgc291cmNlLmEpO1xuICAvLyBDb252ZXJ0IGJldHdlZW4gZGF0dW1zXG4gIGlmIChjaGVja1BhcmFtcyhzb3VyY2UuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGRhdHVtLmdlb2NlbnRyaWNUb1dnczg0KHBvaW50LCBzb3VyY2UuZGF0dW1fdHlwZSwgc291cmNlLmRhdHVtX3BhcmFtcyk7XG4gIH1cbiAgaWYgKGNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcbiAgICBwb2ludCA9IGRhdHVtLmdlb2NlbnRyaWNGcm9tV2dzODQocG9pbnQsIGRlc3QuZGF0dW1fdHlwZSwgZGVzdC5kYXR1bV9wYXJhbXMpO1xuICB9XG4gIHJldHVybiBkYXR1bS5nZW9jZW50cmljVG9HZW9kZXRpYyhwb2ludCwgZGVzdC5lcywgZGVzdC5hLCBkZXN0LmIpO1xuXG59O1xuIiwidmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbCcpO1xudmFyIHBhcnNlUHJvaiA9IHJlcXVpcmUoJy4vcHJvalN0cmluZycpO1xudmFyIHdrdCA9IHJlcXVpcmUoJy4vd2t0Jyk7XG5cbmZ1bmN0aW9uIGRlZnMobmFtZSkge1xuICAvKmdsb2JhbCBjb25zb2xlKi9cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBkZWYgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZGVmLmNoYXJBdCgwKSA9PT0gJysnKSB7XG4gICAgICAgIGRlZnNbbmFtZV0gPSBwYXJzZVByb2ooYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWZzW25hbWVdID0gd2t0KGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZnNbbmFtZV0gPSBkZWY7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgcmV0dXJuIG5hbWUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICBkZWZzLmFwcGx5KHRoYXQsIHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlZnModik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChuYW1lIGluIGRlZnMpIHtcbiAgICAgICAgcmV0dXJuIGRlZnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdFUFNHJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydFUFNHOicgKyBuYW1lLkVQU0ddID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ0VTUkknIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0VTUkk6JyArIG5hbWUuRVNSSV0gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgnSUFVMjAwMCcgaW4gbmFtZSkge1xuICAgICAgZGVmc1snSUFVMjAwMDonICsgbmFtZS5JQVUyMDAwXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG5cbn1cbmdsb2JhbHMoZGVmcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGRlZnM7XG4iLCIvLyBlbGxpcG9pZCBwal9zZXRfZWxsLmNcbnZhciBTSVhUSCA9IDAuMTY2NjY2NjY2NjY2NjY2NjY2Nztcbi8qIDEvNiAqL1xudmFyIFJBNCA9IDAuMDQ3MjIyMjIyMjIyMjIyMjIyMjI7XG4vKiAxNy8zNjAgKi9cbnZhciBSQTYgPSAwLjAyMjE1NjA4NDY1NjA4NDY1NjA4O1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBFbGxpcHNvaWQgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9FbGxpcHNvaWQnKTtcblxuZXhwb3J0cy5lY2NlbnRyaWNpdHkgPSBmdW5jdGlvbihhLCBiLCByZiwgUl9BKSB7XG4gIHZhciBhMiA9IGEgKiBhOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAgdmFyIGIyID0gYiAqIGI7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICB2YXIgZXMgPSAoYTIgLSBiMikgLyBhMjsgLy8gZSBeIDJcbiAgdmFyIGUgPSAwO1xuICBpZiAoUl9BKSB7XG4gICAgYSAqPSAxIC0gZXMgKiAoU0lYVEggKyBlcyAqIChSQTQgKyBlcyAqIFJBNikpO1xuICAgIGEyID0gYSAqIGE7XG4gICAgZXMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLnNxcnQoZXMpOyAvLyBlY2NlbnRyaWNpdHlcbiAgfVxuICB2YXIgZXAyID0gKGEyIC0gYjIpIC8gYjI7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICByZXR1cm4ge1xuICAgIGVzOiBlcyxcbiAgICBlOiBlLFxuICAgIGVwMjogZXAyXG4gIH07XG59O1xuZXhwb3J0cy5zcGhlcmUgPSBmdW5jdGlvbiAoYSwgYiwgcmYsIGVsbHBzLCBzcGhlcmUpIHtcbiAgaWYgKCFhKSB7IC8vIGRvIHdlIGhhdmUgYW4gZWxsaXBzb2lkP1xuICAgIHZhciBlbGxpcHNlID0gRWxsaXBzb2lkW2VsbHBzXTtcbiAgICBpZiAoIWVsbGlwc2UpIHtcbiAgICAgIGVsbGlwc2UgPSBFbGxpcHNvaWQuV0dTODQ7XG4gICAgfVxuICAgIGEgPSBlbGxpcHNlLmE7XG4gICAgYiA9IGVsbGlwc2UuYjtcbiAgICByZiA9IGVsbGlwc2UucmY7XG4gIH1cblxuICBpZiAocmYgJiYgIWIpIHtcbiAgICBiID0gKDEuMCAtIDEuMCAvIHJmKSAqIGE7XG4gIH1cbiAgaWYgKHJmID09PSAwIHx8IE1hdGguYWJzKGEgLSBiKSA8IEVQU0xOKSB7XG4gICAgc3BoZXJlID0gdHJ1ZTtcbiAgICBiID0gYTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGE6IGEsXG4gICAgYjogYixcbiAgICByZjogcmYsXG4gICAgc3BoZXJlOiBzcGhlcmVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcbiAgdmFyIHZhbHVlLCBwcm9wZXJ0eTtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cbiAgZm9yIChwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZWZzKSB7XG4gIGRlZnMoJ0VQU0c6NDMyNicsIFwiK3RpdGxlPVdHUyA4NCAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzo0MjY5JywgXCIrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXNcIik7XG4gIGRlZnMoJ0VQU0c6Mzg1NycsIFwiK3RpdGxlPVdHUyA4NCAvIFBzZXVkby1NZXJjYXRvciArcHJvaj1tZXJjICthPTYzNzgxMzcgK2I9NjM3ODEzNyArbGF0X3RzPTAuMCArbG9uXzA9MC4wICt4XzA9MC4wICt5XzA9MCAraz0xLjAgK3VuaXRzPW0gK25hZGdyaWRzPUBudWxsICtub19kZWZzXCIpO1xuXG4gIGRlZnMuV0dTODQgPSBkZWZzWydFUFNHOjQzMjYnXTtcbiAgZGVmc1snRVBTRzozNzg1J10gPSBkZWZzWydFUFNHOjM4NTcnXTsgLy8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0LCBvZmZpY2lhbCBjb2RlIGlzIDM4NTdcbiAgZGVmcy5HT09HTEUgPSBkZWZzWydFUFNHOjM4NTcnXTtcbiAgZGVmc1snRVBTRzo5MDA5MTMnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjEwMjExMyddID0gZGVmc1snRVBTRzozODU3J107XG59O1xuIiwidmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciB3a3QgPSByZXF1aXJlKCcuL3drdCcpO1xudmFyIHByb2pTdHIgPSByZXF1aXJlKCcuL3Byb2pTdHJpbmcnKTtcbmZ1bmN0aW9uIHRlc3RPYmooY29kZSl7XG4gIHJldHVybiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiB0ZXN0RGVmKGNvZGUpe1xuICByZXR1cm4gY29kZSBpbiBkZWZzO1xufVxudmFyIGNvZGVXb3JkcyA9IFsnR0VPR0NTJywnR0VPQ0NTJywnUFJPSkNTJywnTE9DQUxfQ1MnXTtcblxuZnVuY3Rpb24gdGVzdFdLVChjb2RlKXtcbiAgcmV0dXJuIGNvZGVXb3Jkcy5zb21lKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIGNvZGUuaW5kZXhPZih3b3JkKSA+IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRlc3RQcm9qKGNvZGUpe1xuICByZXR1cm4gY29kZVswXSA9PT0gJysnO1xufVxuZnVuY3Rpb24gcGFyc2UoY29kZSl7XG4gIGlmICh0ZXN0T2JqKGNvZGUpKSB7XG4gICAgLy9jaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIFdLVCBzdHJpbmdcbiAgICBpZiAodGVzdERlZihjb2RlKSkge1xuICAgICAgcmV0dXJuIGRlZnNbY29kZV07XG4gICAgfVxuICAgIGlmICh0ZXN0V0tUKGNvZGUpKSB7XG4gICAgICByZXR1cm4gd2t0KGNvZGUpO1xuICAgIH1cbiAgICBpZiAodGVzdFByb2ooY29kZSkpIHtcbiAgICAgIHJldHVybiBwcm9qU3RyKGNvZGUpO1xuICAgIH1cbiAgfWVsc2V7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbiIsInZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xudmFyIFByaW1lTWVyaWRpYW4gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy91bml0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlZkRhdGEpIHtcbiAgdmFyIHNlbGYgPSB7fTtcbiAgdmFyIHBhcmFtT2JqID0gZGVmRGF0YS5zcGxpdCgnKycpLm1hcChmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYudHJpbSgpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24ocCwgYSkge1xuICAgIHZhciBzcGxpdCA9IGEuc3BsaXQoJz0nKTtcbiAgICBzcGxpdC5wdXNoKHRydWUpO1xuICAgIHBbc3BsaXRbMF0udG9Mb3dlckNhc2UoKV0gPSBzcGxpdFsxXTtcbiAgICByZXR1cm4gcDtcbiAgfSwge30pO1xuICB2YXIgcGFyYW1OYW1lLCBwYXJhbVZhbCwgcGFyYW1PdXRuYW1lO1xuICB2YXIgcGFyYW1zID0ge1xuICAgIHByb2o6ICdwcm9qTmFtZScsXG4gICAgZGF0dW06ICdkYXR1bUNvZGUnLFxuICAgIHJmOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnJmID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGxhdF8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0XzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MSA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfMjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQyID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF90czogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXRfdHMgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzAgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzEgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbG9uXzI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZzIgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYWxwaGEgPSBwYXJzZUZsb2F0KHYpICogRDJSO1xuICAgIH0sXG4gICAgbG9uYzogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nYyA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICB4XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYueDAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgeV8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnkwID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGtfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBrOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYSA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBiOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgcl9hOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuUl9BID0gdHJ1ZTtcbiAgICB9LFxuICAgIHpvbmU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuem9uZSA9IHBhcnNlSW50KHYsIDEwKTtcbiAgICB9LFxuICAgIHNvdXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYudXRtU291dGggPSB0cnVlO1xuICAgIH0sXG4gICAgdG93Z3M4NDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5kYXR1bV9wYXJhbXMgPSB2LnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9fbWV0ZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgdW5pdHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYudW5pdHMgPSB2O1xuICAgICAgaWYgKHVuaXRzW3ZdKSB7XG4gICAgICAgIHNlbGYudG9fbWV0ZXIgPSB1bml0c1t2XS50b19tZXRlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZyb21fZ3JlZW53aWNoOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHBtOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gKFByaW1lTWVyaWRpYW5bdl0gPyBQcmltZU1lcmlkaWFuW3ZdIDogcGFyc2VGbG9hdCh2KSkgKiBEMlI7XG4gICAgfSxcbiAgICBuYWRncmlkczogZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgPT09ICdAbnVsbCcpIHtcbiAgICAgICAgc2VsZi5kYXR1bUNvZGUgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi5uYWRncmlkcyA9IHY7XG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgbGVnYWxBeGlzID0gXCJld25zdWRcIjtcbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gMyAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigwLCAxKSkgIT09IC0xICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDEsIDEpKSAhPT0gLTEgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMiwgMSkpICE9PSAtMSkge1xuICAgICAgICBzZWxmLmF4aXMgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1PYmopIHtcbiAgICBwYXJhbVZhbCA9IHBhcmFtT2JqW3BhcmFtTmFtZV07XG4gICAgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtT3V0bmFtZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbU91dG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGFyYW1PdXRuYW1lKHBhcmFtVmFsKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmW3BhcmFtT3V0bmFtZV0gPSBwYXJhbVZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZWxmW3BhcmFtTmFtZV0gPSBwYXJhbVZhbDtcbiAgICB9XG4gIH1cbiAgaWYodHlwZW9mIHNlbGYuZGF0dW1Db2RlID09PSAnc3RyaW5nJyAmJiBzZWxmLmRhdHVtQ29kZSAhPT0gXCJXR1M4NFwiKXtcbiAgICBzZWxmLmRhdHVtQ29kZSA9IHNlbGYuZGF0dW1Db2RlLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuIiwidmFyIHByb2pzID0gW1xuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL21lcmMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9sb25nbGF0Jylcbl07XG52YXIgbmFtZXMgPSB7fTtcbnZhciBwcm9qU3RvcmUgPSBbXTtcblxuZnVuY3Rpb24gYWRkKHByb2osIGkpIHtcbiAgdmFyIGxlbiA9IHByb2pTdG9yZS5sZW5ndGg7XG4gIGlmICghcHJvai5uYW1lcykge1xuICAgIGNvbnNvbGUubG9nKGkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHByb2pTdG9yZVtsZW5dID0gcHJvajtcbiAgcHJvai5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBuYW1lc1tuLnRvTG93ZXJDYXNlKCldID0gbGVuO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydHMuYWRkID0gYWRkO1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodHlwZW9mIG5hbWVzW25dICE9PSAndW5kZWZpbmVkJyAmJiBwcm9qU3RvcmVbbmFtZXNbbl1dKSB7XG4gICAgcmV0dXJuIHByb2pTdG9yZVtuYW1lc1tuXV07XG4gIH1cbn07XG5leHBvcnRzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHByb2pzLmZvckVhY2goYWRkKTtcbn07XG4iLCJleHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy9uby1vcCBmb3IgbG9uZ2xhdFxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHkocHQpIHtcbiAgcmV0dXJuIHB0O1xufVxuZXhwb3J0cy5mb3J3YXJkID0gaWRlbnRpdHk7XG5leHBvcnRzLmludmVyc2UgPSBpZGVudGl0eTtcbmV4cG9ydHMubmFtZXMgPSBbXCJsb25nbGF0XCIsIFwiaWRlbnRpdHlcIl07XG4iLCJ2YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBGT1JUUEkgPSBNYXRoLlBJLzQ7XG52YXIgdHNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBwaGkyeiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9waGkyeicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb24gPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gY29uICogY29uO1xuICBpZighKCd4MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueDAgPSAwO1xuICB9XG4gIGlmKCEoJ3kwJyBpbiB0aGlzKSl7XG4gICAgdGhpcy55MCA9IDA7XG4gIH1cbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICBpZiAodGhpcy5sYXRfdHMpIHtcbiAgICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICAgIHRoaXMuazAgPSBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuazApIHtcbiAgICAgIGlmICh0aGlzLmspIHtcbiAgICAgICAgdGhpcy5rMCA9IHRoaXMuaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmswID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIE1lcmNhdG9yIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLy8gY29udmVydCB0byByYWRpYW5zXG4gIGlmIChsYXQgKiBSMkQgPiA5MCAmJiBsYXQgKiBSMkQgPCAtOTAgJiYgbG9uICogUjJEID4gMTgwICYmIGxvbiAqIFIyRCA8IC0xODApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB4LCB5O1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgMC41ICogbGF0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gICAgICB2YXIgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgc2lucGhpKTtcbiAgICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICB5ID0gdGhpcy55MCAtIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZyh0cyk7XG4gICAgfVxuICAgIHAueCA9IHg7XG4gICAgcC55ID0geTtcbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxuXG4vKiBNZXJjYXRvciBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciB4ID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgdHMgPSBNYXRoLmV4cCgteSAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB4IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiTWVyY2F0b3JcIiwgXCJQb3B1bGFyIFZpc3VhbGlzYXRpb24gUHNldWRvIE1lcmNhdG9yXCIsIFwiTWVyY2F0b3JfMVNQXCIsIFwiTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZVwiLCBcIm1lcmNcIl07XG4iLCJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbnZhciBQSkRfM1BBUkFNID0gMTtcbnZhciBQSkRfN1BBUkFNID0gMjtcbnZhciBkYXR1bV90cmFuc2Zvcm0gPSByZXF1aXJlKCcuL2RhdHVtX3RyYW5zZm9ybScpO1xudmFyIGFkanVzdF9heGlzID0gcmVxdWlyZSgnLi9hZGp1c3RfYXhpcycpO1xudmFyIHByb2ogPSByZXF1aXJlKCcuL1Byb2onKTtcbnZhciB0b1BvaW50ID0gcmVxdWlyZSgnLi9jb21tb24vdG9Qb2ludCcpO1xuZnVuY3Rpb24gY2hlY2tOb3RXR1Moc291cmNlLCBkZXN0KSB7XG4gIHJldHVybiAoKHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNIHx8IHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSAmJiBkZXN0LmRhdHVtQ29kZSAhPT0gJ1dHUzg0JykgfHwgKChkZXN0LmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0gfHwgZGVzdC5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSAmJiBzb3VyY2UuZGF0dW1Db2RlICE9PSAnV0dTODQnKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgdmFyIHdnczg0O1xuICBpZiAoQXJyYXkuaXNBcnJheShwb2ludCkpIHtcbiAgICBwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgZGF0dW0gc2hpZnRzIHRvd2dzODQsIGlmIGVpdGhlciBzb3VyY2Ugb3IgZGVzdGluYXRpb24gcHJvamVjdGlvbiBpcyBub3Qgd2dzODRcbiAgaWYgKHNvdXJjZS5kYXR1bSAmJiBkZXN0LmRhdHVtICYmIGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkpIHtcbiAgICB3Z3M4NCA9IG5ldyBwcm9qKCdXR1M4NCcpO1xuICAgIHBvaW50ID0gdHJhbnNmb3JtKHNvdXJjZSwgd2dzODQsIHBvaW50KTtcbiAgICBzb3VyY2UgPSB3Z3M4NDtcbiAgfVxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKHNvdXJjZS5heGlzICE9PSAnZW51Jykge1xuICAgIHBvaW50ID0gYWRqdXN0X2F4aXMoc291cmNlLCBmYWxzZSwgcG9pbnQpO1xuICB9XG4gIC8vIFRyYW5zZm9ybSBzb3VyY2UgcG9pbnRzIHRvIGxvbmcvbGF0LCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5LlxuICBpZiAoc291cmNlLnByb2pOYW1lID09PSAnbG9uZ2xhdCcpIHtcbiAgICBwb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggKiBEMlIsXG4gICAgICB5OiBwb2ludC55ICogRDJSXG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoc291cmNlLnRvX21ldGVyKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnQueCAqIHNvdXJjZS50b19tZXRlcixcbiAgICAgICAgeTogcG9pbnQueSAqIHNvdXJjZS50b19tZXRlclxuICAgICAgfTtcbiAgICB9XG4gICAgcG9pbnQgPSBzb3VyY2UuaW52ZXJzZShwb2ludCk7IC8vIENvbnZlcnQgQ2FydGVzaWFuIHRvIGxvbmdsYXRcbiAgfVxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKHNvdXJjZS5mcm9tX2dyZWVud2ljaCkge1xuICAgIHBvaW50LnggKz0gc291cmNlLmZyb21fZ3JlZW53aWNoO1xuICB9XG5cbiAgLy8gQ29udmVydCBkYXR1bXMgaWYgbmVlZGVkLCBhbmQgaWYgcG9zc2libGUuXG4gIHBvaW50ID0gZGF0dW1fdHJhbnNmb3JtKHNvdXJjZS5kYXR1bSwgZGVzdC5kYXR1bSwgcG9pbnQpO1xuXG4gIC8vIEFkanVzdCBmb3IgdGhlIHByaW1lIG1lcmlkaWFuIGlmIG5lY2Vzc2FyeVxuICBpZiAoZGVzdC5mcm9tX2dyZWVud2ljaCkge1xuICAgIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAtIGRlc3QuZ3JvbV9ncmVlbndpY2gsXG4gICAgICB5OiBwb2ludC55XG4gICAgfTtcbiAgfVxuXG4gIGlmIChkZXN0LnByb2pOYW1lID09PSAnbG9uZ2xhdCcpIHtcbiAgICAvLyBjb252ZXJ0IHJhZGlhbnMgdG8gZGVjaW1hbCBkZWdyZWVzXG4gICAgcG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54ICogUjJELFxuICAgICAgeTogcG9pbnQueSAqIFIyRFxuICAgIH07XG4gIH0gZWxzZSB7IC8vIGVsc2UgcHJvamVjdFxuICAgIHBvaW50ID0gZGVzdC5mb3J3YXJkKHBvaW50KTtcbiAgICBpZiAoZGVzdC50b19tZXRlcikge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50LnggLyBkZXN0LnRvX21ldGVyLFxuICAgICAgICB5OiBwb2ludC55IC8gZGVzdC50b19tZXRlclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKGRlc3QuYXhpcyAhPT0gJ2VudScpIHtcbiAgICByZXR1cm4gYWRqdXN0X2F4aXMoZGVzdCwgdHJ1ZSwgcG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufTtcbiIsInZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5cbmZ1bmN0aW9uIG1hcGl0KG9iaiwga2V5LCB2KSB7XG4gIG9ialtrZXldID0gdi5tYXAoZnVuY3Rpb24oYWEpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIHNFeHByKGFhLCBvKTtcbiAgICByZXR1cm4gbztcbiAgfSkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGEsIGIpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHNFeHByKHYsIG9iaikge1xuICB2YXIga2V5O1xuICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICBvYmpbdl0gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICBlbHNlIHtcbiAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gICAgaWYgKGtleSA9PT0gJ1BBUkFNRVRFUicpIHtcbiAgICAgIGtleSA9IHYuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKHYubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2WzBdKSkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICBzRXhwcih2WzBdLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2WzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghdi5sZW5ndGgpIHtcbiAgICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnVE9XR1M4NCcpIHtcbiAgICAgIG9ialtrZXldID0gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgaWYgKFsnVU5JVCcsICdQUklNRU0nLCAnVkVSVF9EQVRVTSddLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIG5hbWU6IHZbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBjb252ZXJ0OiB2WzFdXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIG9ialtrZXldLmF1dGggPSB2WzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdTUEhFUk9JRCcpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgbmFtZTogdlswXSxcbiAgICAgICAgICBhOiB2WzFdLFxuICAgICAgICAgIHJmOiB2WzJdXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIG9ialtrZXldLmF1dGggPSB2WzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChbJ0dFT0dDUycsICdHRU9DQ1MnLCAnREFUVU0nLCAnVkVSVF9DUycsICdDT01QRF9DUycsICdMT0NBTF9DUycsICdGSVRURURfQ1MnLCAnTE9DQUxfREFUVU0nXS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICB2WzBdID0gWyduYW1lJywgdlswXV07XG4gICAgICAgIG1hcGl0KG9iaiwga2V5LCB2KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYuZXZlcnkoZnVuY3Rpb24oYWEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYWEpO1xuICAgICAgfSkpIHtcbiAgICAgICAgbWFwaXQob2JqLCBrZXksIHYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNFeHByKHYsIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuYW1lKG9iaiwgcGFyYW1zKSB7XG4gIHZhciBvdXROYW1lID0gcGFyYW1zWzBdO1xuICB2YXIgaW5OYW1lID0gcGFyYW1zWzFdO1xuICBpZiAoIShvdXROYW1lIGluIG9iaikgJiYgKGluTmFtZSBpbiBvYmopKSB7XG4gICAgb2JqW291dE5hbWVdID0gb2JqW2luTmFtZV07XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIG9ialtvdXROYW1lXSA9IHBhcmFtc1syXShvYmpbb3V0TmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkMnIoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0ICogRDJSO1xufVxuXG5mdW5jdGlvbiBjbGVhbldLVCh3a3QpIHtcbiAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuICAgIHdrdC5wcm9qTmFtZSA9ICdsb25nbGF0JztcbiAgfVxuICBlbHNlIGlmICh3a3QudHlwZSA9PT0gJ0xPQ0FMX0NTJykge1xuICAgIHdrdC5wcm9qTmFtZSA9ICdpZGVudGl0eSc7XG4gICAgd2t0LmxvY2FsID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHdrdC5QUk9KRUNUSU9OID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB3a3QucHJvak5hbWUgPSBPYmplY3Qua2V5cyh3a3QuUFJPSkVDVElPTilbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2t0LnByb2pOYW1lID0gd2t0LlBST0pFQ1RJT047XG4gICAgfVxuICB9XG4gIGlmICh3a3QuVU5JVCkge1xuICAgIHdrdC51bml0cyA9IHdrdC5VTklULm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAod2t0LnVuaXRzID09PSAnbWV0cmUnKSB7XG4gICAgICB3a3QudW5pdHMgPSAnbWV0ZXInO1xuICAgIH1cbiAgICBpZiAod2t0LlVOSVQuY29udmVydCkge1xuICAgICAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuICAgICAgICBpZiAod2t0LkRBVFVNICYmIHdrdC5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgICAgIHdrdC50b19tZXRlciA9IHBhcnNlRmxvYXQod2t0LlVOSVQuY29udmVydCwgMTApKndrdC5EQVRVTS5TUEhFUk9JRC5hO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3a3QudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHdrdC5VTklULmNvbnZlcnQsIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAod2t0LkdFT0dDUykge1xuICAgIC8vaWYod2t0LkdFT0dDUy5QUklNRU0mJndrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQpe1xuICAgIC8vICB3a3QuZnJvbV9ncmVlbndpY2g9d2t0LkdFT0dDUy5QUklNRU0uY29udmVydCpEMlI7XG4gICAgLy99XG4gICAgaWYgKHdrdC5HRU9HQ1MuREFUVU0pIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuR0VPR0NTLkRBVFVNLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LkdFT0dDUy5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIDIpID09PSAnZF8nKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF9nZW9kZXRpY19kYXR1bV8xOTQ5JyB8fCB3a3QuZGF0dW1Db2RlID09PSAnbmV3X3plYWxhbmRfMTk0OScpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnbnpnZDQ5JztcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUgPT09IFwid2dzXzE5ODRcIikge1xuICAgICAgaWYgKHdrdC5QUk9KRUNUSU9OID09PSAnTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZScpIHtcbiAgICAgICAgd2t0LnNwaGVyZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ3dnczg0JztcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTYpID09PSAnX2ZlcnJvJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgLSA2KTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTgpID09PSAnX2pha2FydGEnKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDgpO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignYmVsZ2UnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IFwicm5iNzJcIjtcbiAgICB9XG4gICAgaWYgKHdrdC5HRU9HQ1MuREFUVU0gJiYgd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgd2t0LmVsbHBzID0gd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRC5uYW1lLnJlcGxhY2UoJ18xOScsICcnKS5yZXBsYWNlKC9bQ2NdbGFya2VcXF8xOC8sICdjbHJrJyk7XG4gICAgICBpZiAod2t0LmVsbHBzLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgMTMpID09PSBcImludGVybmF0aW9uYWxcIikge1xuICAgICAgICB3a3QuZWxscHMgPSAnaW50bCc7XG4gICAgICB9XG5cbiAgICAgIHdrdC5hID0gd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRC5hO1xuICAgICAgd2t0LnJmID0gcGFyc2VGbG9hdCh3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELnJmLCAxMCk7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdvc2diXzE5MzYnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IFwib3NnYjM2XCI7XG4gICAgfVxuICB9XG4gIGlmICh3a3QuYiAmJiAhaXNGaW5pdGUod2t0LmIpKSB7XG4gICAgd2t0LmIgPSB3a3QuYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvTWV0ZXIoaW5wdXQpIHtcbiAgICB2YXIgcmF0aW8gPSB3a3QudG9fbWV0ZXIgfHwgMTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChpbnB1dCwgMTApICogcmF0aW87XG4gIH1cbiAgdmFyIHJlbmFtZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHJlbmFtZSh3a3QsIGEpO1xuICB9O1xuICB2YXIgbGlzdCA9IFtcbiAgICBbJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCAnU3RhbmRhcmRfUGFyYWxsZWxfMSddLFxuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMicsICdTdGFuZGFyZF9QYXJhbGxlbF8yJ10sXG4gICAgWydmYWxzZV9lYXN0aW5nJywgJ0ZhbHNlX0Vhc3RpbmcnXSxcbiAgICBbJ2ZhbHNlX25vcnRoaW5nJywgJ0ZhbHNlX05vcnRoaW5nJ10sXG4gICAgWydjZW50cmFsX21lcmlkaWFuJywgJ0NlbnRyYWxfTWVyaWRpYW4nXSxcbiAgICBbJ2xhdGl0dWRlX29mX29yaWdpbicsICdMYXRpdHVkZV9PZl9PcmlnaW4nXSxcbiAgICBbJ2xhdGl0dWRlX29mX29yaWdpbicsICdDZW50cmFsX1BhcmFsbGVsJ10sXG4gICAgWydzY2FsZV9mYWN0b3InLCAnU2NhbGVfRmFjdG9yJ10sXG4gICAgWydrMCcsICdzY2FsZV9mYWN0b3InXSxcbiAgICBbJ2xhdGl0dWRlX29mX2NlbnRlcicsICdMYXRpdHVkZV9vZl9jZW50ZXInXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCAnTG9uZ2l0dWRlX09mX0NlbnRlciddLFxuICAgIFsnbG9uZ2MnLCAnbG9uZ2l0dWRlX29mX2NlbnRlcicsIGQycl0sXG4gICAgWyd4MCcsICdmYWxzZV9lYXN0aW5nJywgdG9NZXRlcl0sXG4gICAgWyd5MCcsICdmYWxzZV9ub3J0aGluZycsIHRvTWV0ZXJdLFxuICAgIFsnbG9uZzAnLCAnY2VudHJhbF9tZXJpZGlhbicsIGQycl0sXG4gICAgWydsYXQwJywgJ2xhdGl0dWRlX29mX29yaWdpbicsIGQycl0sXG4gICAgWydsYXQwJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCBkMnJdLFxuICAgIFsnbGF0MScsICdzdGFuZGFyZF9wYXJhbGxlbF8xJywgZDJyXSxcbiAgICBbJ2xhdDInLCAnc3RhbmRhcmRfcGFyYWxsZWxfMicsIGQycl0sXG4gICAgWydhbHBoYScsICdhemltdXRoJywgZDJyXSxcbiAgICBbJ3Nyc0NvZGUnLCAnbmFtZSddXG4gIF07XG4gIGxpc3QuZm9yRWFjaChyZW5hbWVyKTtcbiAgaWYgKCF3a3QubG9uZzAgJiYgd2t0LmxvbmdjICYmICh3a3QucHJvak5hbWUgPT09ICdBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYScgfHwgd2t0LnByb2pOYW1lID09PSBcIkxhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWFcIikpIHtcbiAgICB3a3QubG9uZzAgPSB3a3QubG9uZ2M7XG4gIH1cbiAgaWYgKCF3a3QubGF0X3RzICYmIHdrdC5sYXQxICYmICh3a3QucHJvak5hbWUgPT09ICdTdGVyZW9ncmFwaGljX1NvdXRoX1BvbGUnIHx8IHdrdC5wcm9qTmFtZSA9PT0gJ1BvbGFyIFN0ZXJlb2dyYXBoaWMgKHZhcmlhbnQgQiknKSkge1xuICAgIHdrdC5sYXQwID0gZDJyKHdrdC5sYXQxID4gMCA/IDkwIDogLTkwKTtcbiAgICB3a3QubGF0X3RzID0gd2t0LmxhdDE7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2t0LCBzZWxmKSB7XG4gIHZhciBsaXNwID0gSlNPTi5wYXJzZSgoXCIsXCIgKyB3a3QpLnJlcGxhY2UoL1xccypcXCxcXHMqKFtBLVpfMC05XSs/KShcXFspL2csICcsW1wiJDFcIiwnKS5zbGljZSgxKS5yZXBsYWNlKC9cXHMqXFwsXFxzKihbQS1aXzAtOV0rPylcXF0vZywgJyxcIiQxXCJdJykucmVwbGFjZSgvLFxcW1wiVkVSVENTXCIuKy8sJycpKTtcbiAgdmFyIHR5cGUgPSBsaXNwLnNoaWZ0KCk7XG4gIHZhciBuYW1lID0gbGlzcC5zaGlmdCgpO1xuICBsaXNwLnVuc2hpZnQoWyduYW1lJywgbmFtZV0pO1xuICBsaXNwLnVuc2hpZnQoWyd0eXBlJywgdHlwZV0pO1xuICBsaXNwLnVuc2hpZnQoJ291dHB1dCcpO1xuICB2YXIgb2JqID0ge307XG4gIHNFeHByKGxpc3AsIG9iaik7XG4gIGNsZWFuV0tUKG9iai5vdXRwdXQpO1xuICByZXR1cm4gZXh0ZW5kKHNlbGYsIG9iai5vdXRwdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJ0aWFsU29ydDtcblxuLy8gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06XG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xuLy8gVGhlIGstdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIChrIC0gbGVmdCArIDEpdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XVxuXG5mdW5jdGlvbiBwYXJ0aWFsU29ydChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICByaWdodCA9IHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSk7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmU7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcGFydGlhbFNvcnQoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXG4gICAgICAgICAgICAnLCBtaW5ZOiBhJyArIGZvcm1hdFsxXSArXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCIvKipcbnNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCAwLjctYmV0YTFcbmh0dHA6Ly93d3cuZGl2ZWludG9qYXZhc2NyaXB0LmNvbS9wcm9qZWN0cy9qYXZhc2NyaXB0LXNwcmludGZcblxuQ29weXJpZ2h0IChjKSBBbGV4YW5kcnUgTWFyYXN0ZWFudSA8YWxleGFob2xpYyBbYXQpIGdtYWlsIChkb3RdIGNvbT5cbkFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxubW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCBub3IgdGhlXG4gICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFsZXhhbmRydSBNYXJhc3RlYW51IEJFIExJQUJMRSBGT1IgQU5ZXG5ESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG5PTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5cbkNoYW5nZWxvZzpcbjIwMTAuMTEuMDcgLSAwLjctYmV0YTEtbm9kZVxuICAtIGNvbnZlcnRlZCBpdCB0byBhIG5vZGUuanMgY29tcGF0aWJsZSBtb2R1bGVcblxuMjAxMC4wOS4wNiAtIDAuNy1iZXRhMVxuICAtIGZlYXR1cmVzOiB2c3ByaW50Ziwgc3VwcG9ydCBmb3IgbmFtZWQgcGxhY2Vob2xkZXJzXG4gIC0gZW5oYW5jZW1lbnRzOiBmb3JtYXQgY2FjaGUsIHJlZHVjZWQgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cblxuMjAxMC4wNS4yMiAtIDAuNjpcbiAtIHJldmVydGVkIHRvIDAuNCBhbmQgZml4ZWQgdGhlIGJ1ZyByZWdhcmRpbmcgdGhlIHNpZ24gb2YgdGhlIG51bWJlciAwXG4gTm90ZTpcbiBUaGFua3MgdG8gUmFwaGFlbCBQaWd1bGxhIDxyYXBoIChhdF0gbjNyZCBbZG90KSBvcmc+IChodHRwOi8vd3d3Lm4zcmQub3JnLylcbiB3aG8gd2FybmVkIG1lIGFib3V0IGEgYnVnIGluIDAuNSwgSSBkaXNjb3ZlcmVkIHRoYXQgdGhlIGxhc3QgdXBkYXRlIHdhc1xuIGEgcmVncmVzcy4gSSBhcHBvbG9naXplIGZvciB0aGF0LlxuXG4yMDEwLjA1LjA5IC0gMC41OlxuIC0gYnVnIGZpeDogMCBpcyBub3cgcHJlY2VlZGVkIHdpdGggYSArIHNpZ25cbiAtIGJ1ZyBmaXg6IHRoZSBzaWduIHdhcyBub3QgYXQgdGhlIHJpZ2h0IHBvc2l0aW9uIG9uIHBhZGRlZCByZXN1bHRzIChLYW1hbCBBYmRhbGkpXG4gLSBzd2l0Y2hlZCBmcm9tIEdQTCB0byBCU0QgbGljZW5zZVxuXG4yMDA3LjEwLjIxIC0gMC40OlxuIC0gdW5pdCB0ZXN0IGFuZCBwYXRjaCAoRGF2aWQgQmFpcmQpXG5cbjIwMDcuMDkuMTcgLSAwLjM6XG4gLSBidWcgZml4OiBubyBsb25nZXIgdGhyb3dzIGV4Y2VwdGlvbiBvbiBlbXB0eSBwYXJhbWVudGVycyAoSGFucyBQdWZhbClcblxuMjAwNy4wOS4xMSAtIDAuMjpcbiAtIGZlYXR1cmU6IGFkZGVkIGFyZ3VtZW50IHN3YXBwaW5nXG5cbjIwMDcuMDQuMDMgLSAwLjE6XG4gLSBpbml0aWFsIHJlbGVhc2VcbioqL1xuXG52YXIgc3ByaW50ZiA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0X3R5cGUodmFyaWFibGUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRmdW5jdGlvbiBzdHJfcmVwZWF0KGlucHV0LCBtdWx0aXBsaWVyKSB7XG5cdFx0Zm9yICh2YXIgb3V0cHV0ID0gW107IG11bHRpcGxpZXIgPiAwOyBvdXRwdXRbLS1tdWx0aXBsaWVyXSA9IGlucHV0KSB7LyogZG8gbm90aGluZyAqL31cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0dmFyIHN0cl9mb3JtYXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuXHRcdFx0c3RyX2Zvcm1hdC5jYWNoZVthcmd1bWVudHNbMF1dID0gc3RyX2Zvcm1hdC5wYXJzZShhcmd1bWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyX2Zvcm1hdC5mb3JtYXQuY2FsbChudWxsLCBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0Ly8gY29udmVydCBvYmplY3QgdG8gc2ltcGxlIG9uZSBsaW5lIHN0cmluZyB3aXRob3V0IGluZGVudGF0aW9uIG9yXG5cdC8vIG5ld2xpbmVzLiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBwcmludCBhcnJheVxuXHQvLyB2YWx1ZXMgdG8gdGhlaXIgYWN0dWFsIHBsYWNlIGZvciBzcGFyc2UgYXJyYXlzLiBcblx0Ly9cblx0Ly8gRm9yIGV4YW1wbGUgc3BhcnNlIGFycmF5IGxpa2UgdGhpc1xuXHQvLyAgICBsID0gW11cblx0Ly8gICAgbFs0XSA9IDFcblx0Ly8gV291bGQgYmUgcHJpbnRlZCBhcyBcIlsxXVwiIGluc3RlYWQgb2YgXCJbLCAsICwgLCAxXVwiXG5cdC8vIFxuXHQvLyBJZiBhcmd1bWVudCAnc2VlbicgaXMgbm90IG51bGwgYW5kIGFycmF5IHRoZSBmdW5jdGlvbiB3aWxsIGNoZWNrIGZvciBcblx0Ly8gY2lyY3VsYXIgb2JqZWN0IHJlZmVyZW5jZXMgZnJvbSBhcmd1bWVudC5cblx0c3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBkZXB0aCwgbWF4ZGVwdGgsIHNlZW4pIHtcblx0XHR2YXIgc3RyID0gJyc7XG5cdFx0aWYgKG9iaiAhPSBudWxsKSB7XG5cdFx0XHRzd2l0Y2goIHR5cGVvZihvYmopICkge1xuXHRcdFx0Y2FzZSAnZnVuY3Rpb24nOiBcblx0XHRcdFx0cmV0dXJuICdbRnVuY3Rpb24nICsgKG9iai5uYW1lID8gJzogJytvYmoubmFtZSA6ICcnKSArICddJztcblx0XHRcdCAgICBicmVhaztcblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdGlmICggb2JqIGluc3RhbmNlb2YgRXJyb3IpIHsgcmV0dXJuICdbJyArIG9iai50b1N0cmluZygpICsgJ10nIH07XG5cdFx0XHRcdGlmIChkZXB0aCA+PSBtYXhkZXB0aCkgcmV0dXJuICdbT2JqZWN0XSdcblx0XHRcdFx0aWYgKHNlZW4pIHtcblx0XHRcdFx0XHQvLyBhZGQgb2JqZWN0IHRvIHNlZW4gbGlzdFxuXHRcdFx0XHRcdHNlZW4gPSBzZWVuLnNsaWNlKDApXG5cdFx0XHRcdFx0c2Vlbi5wdXNoKG9iaik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9iai5sZW5ndGggIT0gbnVsbCkgeyAvL2FycmF5XG5cdFx0XHRcdFx0c3RyICs9ICdbJztcblx0XHRcdFx0XHR2YXIgYXJyID0gW11cblx0XHRcdFx0XHRmb3IgKHZhciBpIGluIG9iaikge1xuXHRcdFx0XHRcdFx0aWYgKHNlZW4gJiYgc2Vlbi5pbmRleE9mKG9ialtpXSkgPj0gMCkgYXJyLnB1c2goJ1tDaXJjdWxhcl0nKTtcblx0XHRcdFx0XHRcdGVsc2UgYXJyLnB1c2goc3RyX2Zvcm1hdC5vYmplY3Rfc3RyaW5naWZ5KG9ialtpXSwgZGVwdGgrMSwgbWF4ZGVwdGgsIHNlZW4pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyICs9IGFyci5qb2luKCcsICcpICsgJ10nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCdnZXRNb250aCcgaW4gb2JqKSB7IC8vIGRhdGVcblx0XHRcdFx0XHRyZXR1cm4gJ0RhdGUoJyArIG9iaiArICcpJztcblx0XHRcdFx0fSBlbHNlIHsgLy8gb2JqZWN0XG5cdFx0XHRcdFx0c3RyICs9ICd7Jztcblx0XHRcdFx0XHR2YXIgYXJyID0gW11cblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIG9iaikgeyBcblx0XHRcdFx0XHRcdGlmKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2VlbiAmJiBzZWVuLmluZGV4T2Yob2JqW2tdKSA+PSAwKSBhcnIucHVzaChrICsgJzogW0NpcmN1bGFyXScpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGFyci5wdXNoKGsgKyc6ICcgK3N0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeShvYmpba10sIGRlcHRoKzEsIG1heGRlcHRoLCBzZWVuKSk7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHIgKz0gYXJyLmpvaW4oJywgJykgKyAnfSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAnXCInICsgb2JqICsgJ1wiJztcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICcnICsgb2JqO1xuXHR9XG5cblx0c3RyX2Zvcm1hdC5mb3JtYXQgPSBmdW5jdGlvbihwYXJzZV90cmVlLCBhcmd2KSB7XG5cdFx0dmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0cmVlX2xlbmd0aDsgaSsrKSB7XG5cdFx0XHRub2RlX3R5cGUgPSBnZXRfdHlwZShwYXJzZV90cmVlW2ldKTtcblx0XHRcdGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHBhcnNlX3RyZWVbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdG1hdGNoID0gcGFyc2VfdHJlZVtpXTsgLy8gY29udmVuaWVuY2UgcHVycG9zZXMgb25seVxuXHRcdFx0XHRpZiAobWF0Y2hbMl0pIHsgLy8ga2V5d29yZCBhcmd1bWVudFxuXHRcdFx0XHRcdGFyZyA9IGFyZ3ZbY3Vyc29yXTtcblx0XHRcdFx0XHRmb3IgKGsgPSAwOyBrIDwgbWF0Y2hbMl0ubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmICghYXJnLmhhc093blByb3BlcnR5KG1hdGNoWzJdW2tdKSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZignW3NwcmludGZdIHByb3BlcnR5IFwiJXNcIiBkb2VzIG5vdCBleGlzdCcsIG1hdGNoWzJdW2tdKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcblx0XHRcdFx0XHRhcmcgPSBhcmd2W21hdGNoWzFdXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoaW1wbGljaXQpXG5cdFx0XHRcdFx0YXJnID0gYXJndltjdXJzb3IrK107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoL1tec09dLy50ZXN0KG1hdGNoWzhdKSAmJiAoZ2V0X3R5cGUoYXJnKSAhPSAnbnVtYmVyJykpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzIFwiJyArIGFyZyArICdcIicsIGdldF90eXBlKGFyZykpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG1hdGNoWzhdKSB7XG5cdFx0XHRcdFx0Y2FzZSAnYic6IGFyZyA9IGFyZy50b1N0cmluZygyKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYyc6IGFyZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJnKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZCc6IGFyZyA9IHBhcnNlSW50KGFyZywgMTApOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdlJzogYXJnID0gbWF0Y2hbN10gPyBhcmcudG9FeHBvbmVudGlhbChtYXRjaFs3XSkgOiBhcmcudG9FeHBvbmVudGlhbCgpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdmJzogYXJnID0gbWF0Y2hbN10gPyBwYXJzZUZsb2F0KGFyZykudG9GaXhlZChtYXRjaFs3XSkgOiBwYXJzZUZsb2F0KGFyZyk7IGJyZWFrO1xuXHRcdFx0XHQgICAgY2FzZSAnTyc6IGFyZyA9IHN0cl9mb3JtYXQub2JqZWN0X3N0cmluZ2lmeShhcmcsIDAsIHBhcnNlSW50KG1hdGNoWzddKSB8fCA1KTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbyc6IGFyZyA9IGFyZy50b1N0cmluZyg4KTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAncyc6IGFyZyA9ICgoYXJnID0gU3RyaW5nKGFyZykpICYmIG1hdGNoWzddID8gYXJnLnN1YnN0cmluZygwLCBtYXRjaFs3XSkgOiBhcmcpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd1JzogYXJnID0gTWF0aC5hYnMoYXJnKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAneCc6IGFyZyA9IGFyZy50b1N0cmluZygxNik7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZyA9ICgvW2RlZl0vLnRlc3QobWF0Y2hbOF0pICYmIG1hdGNoWzNdICYmIGFyZyA+PSAwID8gJysnKyBhcmcgOiBhcmcpO1xuXHRcdFx0XHRwYWRfY2hhcmFjdGVyID0gbWF0Y2hbNF0gPyBtYXRjaFs0XSA9PSAnMCcgPyAnMCcgOiBtYXRjaFs0XS5jaGFyQXQoMSkgOiAnICc7XG5cdFx0XHRcdHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcblx0XHRcdFx0cGFkID0gbWF0Y2hbNl0gPyBzdHJfcmVwZWF0KHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGgpIDogJyc7XG5cdFx0XHRcdG91dHB1dC5wdXNoKG1hdGNoWzVdID8gYXJnICsgcGFkIDogcGFkICsgYXJnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fTtcblxuXHRzdHJfZm9ybWF0LmNhY2hlID0ge307XG5cblx0c3RyX2Zvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKGZtdCkge1xuXHRcdHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG5cdFx0d2hpbGUgKF9mbXQpIHtcblx0XHRcdGlmICgobWF0Y2ggPSAvXlteXFx4MjVdKy8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcblx0XHRcdFx0cGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjV7Mn0vLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhcnNlX3RyZWUucHVzaCgnJScpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKG1hdGNoID0gL15cXHgyNSg/OihbMS05XVxcZCopXFwkfFxcKChbXlxcKV0rKVxcKSk/KFxcKyk/KDB8J1teJF0pPygtKT8oXFxkKyk/KD86XFwuKFxcZCspKT8oW2ItZm9zT3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAobWF0Y2hbMl0pIHtcblx0XHRcdFx0XHRhcmdfbmFtZXMgfD0gMTtcblx0XHRcdFx0XHR2YXIgZmllbGRfbGlzdCA9IFtdLCByZXBsYWNlbWVudF9maWVsZCA9IG1hdGNoWzJdLCBmaWVsZF9tYXRjaCA9IFtdO1xuXHRcdFx0XHRcdGlmICgoZmllbGRfbWF0Y2ggPSAvXihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcblx0XHRcdFx0XHRcdHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcLihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoKGZpZWxkX21hdGNoID0gL15cXFsoXFxkKylcXF0vLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gJyArIHJlcGxhY2VtZW50X2ZpZWxkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3NwcmludGZdICcgKyByZXBsYWNlbWVudF9maWVsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hdGNoWzJdID0gZmllbGRfbGlzdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhcmdfbmFtZXMgfD0gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYXJnX25hbWVzID09PSAzKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdbc3ByaW50Zl0gbWl4aW5nIHBvc2l0aW9uYWwgYW5kIG5hbWVkIHBsYWNlaG9sZGVycyBpcyBub3QgKHlldCkgc3VwcG9ydGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VfdHJlZS5wdXNoKG1hdGNoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1tzcHJpbnRmXSAnICsgX2ZtdCk7XG5cdFx0XHR9XG5cdFx0XHRfZm10ID0gX2ZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlX3RyZWU7XG5cdH07XG5cblx0cmV0dXJuIHN0cl9mb3JtYXQ7XG59KSgpO1xuXG52YXIgdnNwcmludGYgPSBmdW5jdGlvbihmbXQsIGFyZ3YpIHtcblx0dmFyIGFyZ3ZDbG9uZSA9IGFyZ3Yuc2xpY2UoKTtcblx0YXJndkNsb25lLnVuc2hpZnQoZm10KTtcblx0cmV0dXJuIHNwcmludGYuYXBwbHkobnVsbCwgYXJndkNsb25lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3ByaW50ZjtcbnNwcmludGYuc3ByaW50ZiA9IHNwcmludGY7XG5zcHJpbnRmLnZzcHJpbnRmID0gdnNwcmludGY7XG4iLCIhZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiKSBkZWZpbmUoZGVmaW5pdGlvbik7XG4gIGVsc2UgdGhpcy50eiA9IGRlZmluaXRpb24oKTtcbn0gKGZ1bmN0aW9uICgpIHtcbi8qXG4gIGZ1bmN0aW9uIGRpZSAoKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXkgKCkgeyByZXR1cm4gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpIH1cbiovXG4gIGZ1bmN0aW9uIGFjdHVhbGl6ZSAoZW50cnksIHJ1bGUsIHllYXIpIHtcbiAgICB2YXIgYWN0dWFsaXplZCwgZGF0ZSA9IHJ1bGUuZGF5WzFdO1xuXG4gICAgZG8ge1xuICAgICAgYWN0dWFsaXplZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIHJ1bGUubW9udGgsIE1hdGguYWJzKGRhdGUrKykpKTtcbiAgICB9IHdoaWxlIChydWxlLmRheVswXSA8IDcgJiYgYWN0dWFsaXplZC5nZXRVVENEYXkoKSAhPSBydWxlLmRheVswXSlcblxuICAgIGFjdHVhbGl6ZWQgPSB7XG4gICAgICBjbG9jazogcnVsZS5jbG9jayxcbiAgICAgIHNvcnQ6IGFjdHVhbGl6ZWQuZ2V0VGltZSgpLFxuICAgICAgcnVsZTogcnVsZSxcbiAgICAgIHNhdmU6IHJ1bGUuc2F2ZSAqIDZlNCxcbiAgICAgIG9mZnNldDogZW50cnkub2Zmc2V0XG4gICAgfTtcblxuICAgIGFjdHVhbGl6ZWRbYWN0dWFsaXplZC5jbG9ja10gPSBhY3R1YWxpemVkLnNvcnQgKyBydWxlLnRpbWUgKiA2ZTQ7XG5cbiAgICBpZiAoYWN0dWFsaXplZC5wb3NpeCkge1xuICAgICAgYWN0dWFsaXplZC53YWxsY2xvY2sgPSBhY3R1YWxpemVkW2FjdHVhbGl6ZWQuY2xvY2tdICsgKGVudHJ5Lm9mZnNldCArIHJ1bGUuc2F2ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWxpemVkLnBvc2l4ID0gYWN0dWFsaXplZFthY3R1YWxpemVkLmNsb2NrXSAtIChlbnRyeS5vZmZzZXQgKyBydWxlLnNhdmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0dWFsaXplZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmQgKHJlcXVlc3QsIGNsb2NrLCB0aW1lKSB7XG4gICAgdmFyIGksIEksIGVudHJ5LCBmb3VuZCwgem9uZSA9IHJlcXVlc3RbcmVxdWVzdC56b25lXSwgYWN0dWFsaXplZCA9IFtdLCBhYmJyZXYsIHJ1bGVzXG4gICAgICAsIGosIHllYXIgPSBuZXcgRGF0ZSh0aW1lKS5nZXRVVENGdWxsWWVhcigpLCBvZmYgPSAxO1xuICAgIGZvciAoaSA9IDEsIEkgPSB6b25lLmxlbmd0aDsgaSA8IEk7IGkrKykgaWYgKHpvbmVbaV1bY2xvY2tdIDw9IHRpbWUpIGJyZWFrO1xuICAgIGVudHJ5ID0gem9uZVtpXTtcbiAgICBpZiAoZW50cnkucnVsZXMpIHtcbiAgICAgIHJ1bGVzID0gcmVxdWVzdFtlbnRyeS5ydWxlc107XG4gICAgICBmb3IgKGogPSB5ZWFyICsgMTsgaiA+PSB5ZWFyIC0gb2ZmOyAtLWopXG4gICAgICAgIGZvciAoaSA9IDAsIEkgPSBydWxlcy5sZW5ndGg7IGkgPCBJOyBpKyspXG4gICAgICAgICAgaWYgKHJ1bGVzW2ldLmZyb20gPD0gaiAmJiBqIDw9IHJ1bGVzW2ldLnRvKSBhY3R1YWxpemVkLnB1c2goYWN0dWFsaXplKGVudHJ5LCBydWxlc1tpXSwgaikpO1xuICAgICAgICAgIGVsc2UgaWYgKHJ1bGVzW2ldLnRvIDwgaiAmJiBvZmYgPT0gMSkgb2ZmID0gaiAtIHJ1bGVzW2ldLnRvO1xuICAgICAgYWN0dWFsaXplZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnNvcnQgLSBiLnNvcnQgfSk7XG4gICAgICBmb3IgKGkgPSAwLCBJID0gYWN0dWFsaXplZC5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICAgICAgaWYgKHRpbWUgPj0gYWN0dWFsaXplZFtpXVtjbG9ja10gJiYgYWN0dWFsaXplZFtpXVthY3R1YWxpemVkW2ldLmNsb2NrXSA+IGVudHJ5W2FjdHVhbGl6ZWRbaV0uY2xvY2tdKSBmb3VuZCA9IGFjdHVhbGl6ZWRbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZCkge1xuICAgICAgaWYgKGFiYnJldiA9IC9eKC4qKVxcLyguKikkLy5leGVjKGVudHJ5LmZvcm1hdCkpIHtcbiAgICAgICAgZm91bmQuYWJicmV2ID0gYWJicmV2W2ZvdW5kLnNhdmUgPyAyIDogMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZC5hYmJyZXYgPSBlbnRyeS5mb3JtYXQucmVwbGFjZSgvJXMvLCBmb3VuZC5ydWxlLmxldHRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCB8fCBlbnRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb1dhbGxjbG9jayAocmVxdWVzdCwgcG9zaXgpIHtcbiAgICBpZiAocmVxdWVzdC56b25lID09IFwiVVRDXCIpIHJldHVybiBwb3NpeDtcbiAgICByZXF1ZXN0LmVudHJ5ID0gZmluZChyZXF1ZXN0LCBcInBvc2l4XCIsIHBvc2l4KTtcbiAgICByZXR1cm4gcG9zaXggKyByZXF1ZXN0LmVudHJ5Lm9mZnNldCArIHJlcXVlc3QuZW50cnkuc2F2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb1BPU0lYIChyZXF1ZXN0LCB3YWxsY2xvY2spIHtcbiAgICBpZiAocmVxdWVzdC56b25lID09IFwiVVRDXCIpIHJldHVybiB3YWxsY2xvY2s7XG5cbiAgICB2YXIgZW50cnksIGRpZmY7XG4gICAgcmVxdWVzdC5lbnRyeSA9IGVudHJ5ID0gZmluZChyZXF1ZXN0LCBcIndhbGxjbG9ja1wiLCB3YWxsY2xvY2spO1xuICAgIGRpZmYgPSB3YWxsY2xvY2sgLSBlbnRyeS53YWxsY2xvY2s7XG5cbiAgICByZXR1cm4gMCA8IGRpZmYgJiYgZGlmZiA8IGVudHJ5LnNhdmUgPyBudWxsIDogd2FsbGNsb2NrIC0gZW50cnkub2Zmc2V0IC0gZW50cnkuc2F2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdCAocmVxdWVzdCwgcG9zaXgsIG1hdGNoKSB7XG4gICAgdmFyIGluY3JlbWVudCA9ICsobWF0Y2hbMV0gKyAxKSAvLyBjb252ZXJzaW9uIG5lY2Vzc2FyeSBmb3Igd2VlayBkYXkgYWRkaXRpb25cbiAgICAgICwgb2Zmc2V0ID0gbWF0Y2hbMl0gKiBpbmNyZW1lbnRcbiAgICAgICwgaW5kZXggPSBVTklUUy5pbmRleE9mKG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkpXG4gICAgICAsIGRhdGVcbiAgICAgIDtcbiAgICBpZiAoaW5kZXggPiA5KSB7XG4gICAgICBwb3NpeCArPSBvZmZzZXQgKiBUSU1FW2luZGV4IC0gMTBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUoY29udmVydFRvV2FsbGNsb2NrKHJlcXVlc3QsIHBvc2l4KSk7XG4gICAgICBpZiAoaW5kZXggPCA3KSB7XG4gICAgICAgIHdoaWxlIChvZmZzZXQpIHtcbiAgICAgICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBpbmNyZW1lbnQpO1xuICAgICAgICAgIGlmIChkYXRlLmdldFVUQ0RheSgpID09IGluZGV4KSBvZmZzZXQgLT0gaW5jcmVtZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09IDcpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSA4KSB7XG4gICAgICAgIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAoKHBvc2l4ID0gY29udmVydFRvUE9TSVgocmVxdWVzdCwgZGF0ZS5nZXRUaW1lKCkpKSA9PSBudWxsKSB7XG4gICAgICAgIHBvc2l4ID0gY29udmVydFRvUE9TSVgocmVxdWVzdCwgZGF0ZS5nZXRUaW1lKCkgKyA4NjRlNSAqIGluY3JlbWVudCkgLSA4NjRlNSAqIGluY3JlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvc2l4O1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydCAodmFyZ3MpIHtcbiAgICBpZiAoIXZhcmdzLmxlbmd0aCkgcmV0dXJuIFwiMS4wLjZcIjtcblxuICAgIHZhciByZXF1ZXN0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzKVxuICAgICAgLCBhZGp1c3RtZW50cyA9IFtdXG4gICAgICAsIGksIEksICQsIGFyZ3VtZW50LCBkYXRlXG4gICAgICA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFyZ3MubGVuZ3RoOyBpKyspIHsgLy8gbGVhdmUgdGhlIGZvciBsb29wIGFsb25lLCBpdCB3b3Jrcy5cbiAgICAgIGFyZ3VtZW50ID0gdmFyZ3NbaV07XG4gICAgICAvLyBodHRwczovL3R3aXR0ZXIuY29tL2JpZ2Vhc3kvc3RhdHVzLzIxNTExMjE4NjU3MjQzOTU1MlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnQpKSB7XG4gICAgICAgIGlmICghaSAmJiAhaXNOYU4oYXJndW1lbnRbMV0pKSB7XG4gICAgICAgICAgZGF0ZSA9IGFyZ3VtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3VtZW50LnNwbGljZS5hcHBseSh2YXJncywgWyBpLS0sIDEgXS5jb25jYXQoYXJndW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc05hTihhcmd1bWVudCkpIHtcbiAgICAgICAgJCA9IHR5cGVvZiBhcmd1bWVudDtcbiAgICAgICAgaWYgKCQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh+YXJndW1lbnQuaW5kZXhPZihcIiVcIikpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuZm9ybWF0ID0gYXJndW1lbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghaSAmJiBhcmd1bWVudCA9PSBcIipcIikge1xuICAgICAgICAgICAgZGF0ZSA9IGFyZ3VtZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWkgJiYgKCQgPSAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pKD86W1RcXHNdKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkKykpPyk/KFp8KChbKy1dKShcXGR7Mn0oOlxcZHsyfSl7MCwyfSkpKT8pPyQvLmV4ZWMoYXJndW1lbnQpKSkge1xuICAgICAgICAgICAgZGF0ZSA9IFtdO1xuICAgICAgICAgICAgZGF0ZS5wdXNoLmFwcGx5KGRhdGUsICQuc2xpY2UoMSwgOCkpO1xuICAgICAgICAgICAgaWYgKCRbOV0pIHtcbiAgICAgICAgICAgICAgZGF0ZS5wdXNoKCRbMTBdICsgMSk7XG4gICAgICAgICAgICAgIGRhdGUucHVzaC5hcHBseShkYXRlLCAkWzExXS5zcGxpdCgvOi8pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJFs4XSkge1xuICAgICAgICAgICAgICBkYXRlLnB1c2goMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgvXlxcd3syLDN9X1xcd3syfSQvLnRlc3QoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmxvY2FsZSA9IGFyZ3VtZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCA9IFVOSVRfUkUuZXhlYyhhcmd1bWVudCkpIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnRzLnB1c2goJCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3Quem9uZSA9IGFyZ3VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgkID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmICgkID0gYXJndW1lbnQuY2FsbChyZXF1ZXN0KSkgcmV0dXJuICQ7XG4gICAgICAgIH0gZWxzZSBpZiAoL15cXHd7MiwzfV9cXHd7Mn0kLy50ZXN0KGFyZ3VtZW50Lm5hbWUpKSB7XG4gICAgICAgICAgcmVxdWVzdFthcmd1bWVudC5uYW1lXSA9IGFyZ3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LnpvbmVzKSB7XG4gICAgICAgICAgZm9yICgkIGluIGFyZ3VtZW50LnpvbmVzKSByZXF1ZXN0WyRdID0gYXJndW1lbnQuem9uZXNbJF07XG4gICAgICAgICAgZm9yICgkIGluIGFyZ3VtZW50LnJ1bGVzKSByZXF1ZXN0WyRdID0gYXJndW1lbnQucnVsZXNbJF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgZGF0ZSA9IGFyZ3VtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdFtyZXF1ZXN0LmxvY2FsZV0pIGRlbGV0ZSByZXF1ZXN0LmxvY2FsZTtcbiAgICBpZiAoIXJlcXVlc3RbcmVxdWVzdC56b25lXSkgZGVsZXRlIHJlcXVlc3Quem9uZTtcblxuICAgIGlmIChkYXRlICE9IG51bGwpIHtcbiAgICAgIGlmIChkYXRlID09IFwiKlwiKSB7XG4gICAgICAgIGRhdGUgPSByZXF1ZXN0LmNsb2NrKCk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0ZSkpIHtcbiAgICAgICAgSSA9ICFkYXRlWzddO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTE7IGkrKykgZGF0ZVtpXSA9ICsoZGF0ZVtpXSB8fCAwKTsgLy8gY29udmVyc2lvbiBuZWNlc3NhcnkgZm9yIGRlY3JlbWVudFxuICAgICAgICAtLWRhdGVbMV07IC8vIEdyci4uXG4gICAgICAgIGRhdGUgPSBEYXRlLlVUQy5hcHBseShEYXRlLlVUQywgZGF0ZS5zbGljZSgwLCA4KSkgK1xuICAgICAgICAgIC1kYXRlWzddICogKGRhdGVbOF0gKiAzNmU1ICsgZGF0ZVs5XSAqIDZlNCArIGRhdGVbMTBdICogMWUzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSBNYXRoLmZsb29yKGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgICAgICBpZiAoSSkgZGF0ZSA9IGNvbnZlcnRUb1BPU0lYKHJlcXVlc3QsIGRhdGUpO1xuXG4gICAgICAgIGlmIChkYXRlID09IG51bGwpIHJldHVybiBkYXRlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIEkgPSBhZGp1c3RtZW50cy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICAgICAgICBkYXRlID0gYWRqdXN0KHJlcXVlc3QsIGRhdGUsIGFkanVzdG1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVxdWVzdC5mb3JtYXQpIHJldHVybiBkYXRlO1xuXG4gICAgICAgICQgPSBuZXcgRGF0ZShjb252ZXJ0VG9XYWxsY2xvY2socmVxdWVzdCwgZGF0ZSkpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5mb3JtYXQucmVwbGFjZSgvJShbLTBfXl0/KSg6ezAsM30pKFxcZCopKC4pL2csXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSwgZmxhZywgY29sb25zLCBwYWRkaW5nLCBzcGVjaWZpZXIpIHtcbiAgICAgICAgICB2YXIgZiwgZmlsbCA9IFwiMFwiLCBwYWQ7XG4gICAgICAgICAgaWYgKGYgPSByZXF1ZXN0W3NwZWNpZmllcl0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKGYuY2FsbChyZXF1ZXN0LCAkLCBkYXRlLCBmbGFnLCBjb2xvbnMubGVuZ3RoKSk7XG4gICAgICAgICAgICBpZiAoKGZsYWcgfHwgZi5zdHlsZSkgPT0gXCJfXCIpIGZpbGwgPSBcIiBcIjtcbiAgICAgICAgICAgIHBhZCA9IGZsYWcgPT0gXCItXCIgPyAwIDogZi5wYWQgfHwgMDtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBwYWQpIHZhbHVlID0gZmlsbCArIHZhbHVlO1xuICAgICAgICAgICAgcGFkID0gZmxhZyA9PSBcIi1cIiA/IDAgOiBwYWRkaW5nIHx8IGYucGFkO1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IHBhZCkgdmFsdWUgPSBmaWxsICsgdmFsdWU7XG4gICAgICAgICAgICBpZiAoc3BlY2lmaWVyID09IFwiTlwiICYmIHBhZCA8IHZhbHVlLmxlbmd0aCkgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwYWQpO1xuICAgICAgICAgICAgaWYgKGZsYWcgPT0gXCJeXCIpIHZhbHVlID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWVzdC5jb252ZXJ0KGFyZ3VtZW50cykgfTtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID1cbiAgICB7IGNsb2NrOiBmdW5jdGlvbiAoKSB7IHJldHVybiArKG5ldyBEYXRlKCkpIH1cbiAgICAsIHpvbmU6IFwiVVRDXCJcbiAgICAsIGVudHJ5OiB7IGFiYnJldjogXCJVVENcIiwgb2Zmc2V0OiAwLCBzYXZlOiAwIH1cbiAgICAsIFVUQzogMVxuICAgICwgejogZnVuY3Rpb24oZGF0ZSwgcG9zaXgsIGZsYWcsIGRlbGltaXRlcnMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZW50cnkub2Zmc2V0ICsgdGhpcy5lbnRyeS5zYXZlXG4gICAgICAgICAgLCBzZWNvbmRzID0gTWF0aC5hYnMob2Zmc2V0IC8gMTAwMCksIHBhcnRzID0gW10sIHBhcnQgPSAzNjAwLCBpLCB6O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgcGFydHMucHVzaCgoXCIwXCIgKyBNYXRoLmZsb29yKHNlY29uZHMgLyBwYXJ0KSkuc2xpY2UoLTIpKTtcbiAgICAgICAgICBzZWNvbmRzICU9IHBhcnQ7XG4gICAgICAgICAgcGFydCAvPSA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZyA9PSBcIl5cIiAmJiAhb2Zmc2V0KSByZXR1cm4gXCJaXCI7XG4gICAgICAgIGlmIChmbGFnID09IFwiXlwiKSBkZWxpbWl0ZXJzID0gMztcbiAgICAgICAgaWYgKGRlbGltaXRlcnMgPT0gMykge1xuICAgICAgICAgIHogPSBwYXJ0cy5qb2luKFwiOlwiKTtcbiAgICAgICAgICB6ID0gei5yZXBsYWNlKC86MDAkLywgXCJcIik7XG4gICAgICAgICAgaWYgKGZsYWcgIT0gXCJeXCIpIHogPSB6LnJlcGxhY2UoLzowMCQvLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgeiA9IHBhcnRzLnNsaWNlKDAsIGRlbGltaXRlcnMgKyAxKS5qb2luKFwiOlwiKTtcbiAgICAgICAgICBpZiAoZmxhZyA9PSBcIl5cIikgeiA9IHoucmVwbGFjZSgvOjAwJC8sIFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHogPSBwYXJ0cy5zbGljZSgwLCAyKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHogPSAob2Zmc2V0IDwgMCA/IFwiLVwiIDogXCIrXCIpICsgejtcbiAgICAgICAgeiA9IHoucmVwbGFjZSgvKFstK10pKDApLywgeyBcIl9cIjogXCIgJDFcIiwgXCItXCI6IFwiJDFcIiB9W2ZsYWddIHx8IFwiJDEkMlwiKTtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgICB9XG4gICAgLCBcIiVcIjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gXCIlXCIgfVxuICAgICwgbjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFwiXFxuXCIgfVxuICAgICwgdDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFwiXFx0XCIgfVxuICAgICwgVTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHdlZWtPZlllYXIoZGF0ZSwgMCkgfVxuICAgICwgVzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHdlZWtPZlllYXIoZGF0ZSwgMSkgfVxuICAgICwgVjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGlzb1dlZWsoZGF0ZSlbMF0gfVxuICAgICwgRzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGlzb1dlZWsoZGF0ZSlbMV0gfVxuICAgICwgZzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGlzb1dlZWsoZGF0ZSlbMV0gJSAxMDAgfVxuICAgICwgajogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gRGF0ZS5VVEMoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCAwKSkgLyA4NjRlNSkgKyAxIH1cbiAgICAsIHM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCkgfVxuICAgICwgQzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gMTAwKSB9XG4gICAgLCBOOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgJSAxMDAwICogMTAwMDAwMCB9XG4gICAgLCBtOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENNb250aCgpICsgMSB9XG4gICAgLCBZOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpIH1cbiAgICAsIHk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAgfVxuICAgICwgSDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKSB9XG4gICAgLCBNOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCkgfVxuICAgICwgUzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpIH1cbiAgICAsIGU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSB9XG4gICAgLCBkOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgfVxuICAgICwgdTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KCkgfHwgNyB9XG4gICAgLCB3OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENEYXkoKSB9XG4gICAgLCBsOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpICUgMTIgfHwgMTIgfVxuICAgICwgSTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyIH1cbiAgICAsIGs6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCkgfVxuICAgICwgWjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHRoaXMuZW50cnkuYWJicmV2IH1cbiAgICAsIGE6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5kYXkuYWJicmV2W2RhdGUuZ2V0VVRDRGF5KCldIH1cbiAgICAsIEE6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5kYXkuZnVsbFtkYXRlLmdldFVUQ0RheSgpXSB9XG4gICAgLCBoOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gdGhpc1t0aGlzLmxvY2FsZV0ubW9udGguYWJicmV2W2RhdGUuZ2V0VVRDTW9udGgoKV0gfVxuICAgICwgYjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHRoaXNbdGhpcy5sb2NhbGVdLm1vbnRoLmFiYnJldltkYXRlLmdldFVUQ01vbnRoKCldIH1cbiAgICAsIEI6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5tb250aC5mdWxsW2RhdGUuZ2V0VVRDTW9udGgoKV0gfVxuICAgICwgUDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHRoaXNbdGhpcy5sb2NhbGVdLm1lcmlkaWVtW01hdGguZmxvb3IoZGF0ZS5nZXRVVENIb3VycygpIC8gMTIpXS50b0xvd2VyQ2FzZSgpIH1cbiAgICAsIHA6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiB0aGlzW3RoaXMubG9jYWxlXS5tZXJpZGllbVtNYXRoLmZsb29yKGRhdGUuZ2V0VVRDSG91cnMoKSAvIDEyKV0gfVxuICAgICwgUjogZnVuY3Rpb24gKGRhdGUsIHBvc2l4KSB7IHJldHVybiB0aGlzLmNvbnZlcnQoWyBwb3NpeCwgXCIlSDolTVwiIF0pIH1cbiAgICAsIFQ6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIFwiJUg6JU06JVNcIiBdKSB9XG4gICAgLCBEOiBmdW5jdGlvbiAoZGF0ZSwgcG9zaXgpIHsgcmV0dXJuIHRoaXMuY29udmVydChbIHBvc2l4LCBcIiVtLyVkLyV5XCIgXSkgfVxuICAgICwgRjogZnVuY3Rpb24gKGRhdGUsIHBvc2l4KSB7IHJldHVybiB0aGlzLmNvbnZlcnQoWyBwb3NpeCwgXCIlWS0lbS0lZFwiIF0pIH1cbiAgICAsIHg6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIHRoaXNbdGhpcy5sb2NhbGVdLmRhdGUgXSkgfVxuICAgICwgcjogZnVuY3Rpb24gKGRhdGUsIHBvc2l4KSB7IHJldHVybiB0aGlzLmNvbnZlcnQoWyBwb3NpeCwgdGhpc1t0aGlzLmxvY2FsZV0udGltZTEyIHx8ICclSTolTTolUycgXSkgfVxuICAgICwgWDogZnVuY3Rpb24gKGRhdGUsIHBvc2l4KSB7IHJldHVybiB0aGlzLmNvbnZlcnQoWyBwb3NpeCwgdGhpc1t0aGlzLmxvY2FsZV0udGltZTI0IF0pIH1cbiAgICAsIGM6IGZ1bmN0aW9uIChkYXRlLCBwb3NpeCkgeyByZXR1cm4gdGhpcy5jb252ZXJ0KFsgcG9zaXgsIHRoaXNbdGhpcy5sb2NhbGVdLmRhdGVUaW1lIF0pIH1cbiAgICAsIGNvbnZlcnQ6IGNvbnZlcnRcbiAgICAsIGxvY2FsZTogXCJlbl9VU1wiXG4gICAgLCBlbl9VUzoge1xuICAgICAgICBkYXRlOiBcIiVtLyVkLyVZXCIsXG4gICAgICAgIHRpbWUyNDogXCIlSTolTTolUyAlcFwiLFxuICAgICAgICB0aW1lMTI6IFwiJUk6JU06JVMgJXBcIixcbiAgICAgICAgZGF0ZVRpbWU6IFwiJWEgJWQgJWIgJVkgJUk6JU06JVMgJXAgJVpcIixcbiAgICAgICAgbWVyaWRpZW06IFsgXCJBTVwiLCBcIlBNXCIgXSxcbiAgICAgICAgbW9udGg6IHtcbiAgICAgICAgICBhYmJyZXY6IFwiSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWNcIi5zcGxpdChcInxcIiksXG4gICAgICAgICAgZnVsbDogXCJKYW51YXJ5fEZlYnJ1YXJ5fE1hcmNofEFwcmlsfE1heXxKdW5lfEp1bHl8QXVndXN0fFNlcHRlbWJlcnxPY3RvYmVyfE5vdmVtYmVyfERlY2VtYmVyXCIuc3BsaXQoXCJ8XCIpXG4gICAgICAgIH0sXG4gICAgICAgIGRheToge1xuICAgICAgICAgIGFiYnJldjogXCJTdW58TW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXRcIi5zcGxpdChcInxcIiksXG4gICAgICAgICAgZnVsbDogXCJTdW5kYXl8TW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheVwiLnNwbGl0KFwifFwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgdmFyIFVOSVRTID0gXCJTdW5kYXl8TW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXx5ZWFyfG1vbnRofGRheXxob3VyfG1pbnV0ZXxzZWNvbmR8bWlsbGlzZWNvbmRcIlxuICAgICwgVU5JVF9SRSA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqKFsrLV0pKFxcXFxkKylcXFxccysoXCIgKyBVTklUUyArIFwiKXM/XFxcXHMqJFwiLCBcImlcIilcbiAgICAsIFRJTUUgPSBbIDM2ZTUsIDZlNCwgMWUzLCAxIF1cbiAgICA7XG4gIFVOSVRTID0gVU5JVFMudG9Mb3dlckNhc2UoKS5zcGxpdChcInxcIik7XG5cbiAgXCJkZWxtSE1TVVdWZ0NJa3lcIi5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uIChlKSB7IGNvbnRleHRbZV0ucGFkID0gMiB9KTtcblxuICBjb250ZXh0Lk4ucGFkID0gOTtcbiAgY29udGV4dC5qLnBhZCA9IDM7XG5cbiAgY29udGV4dC5rLnN0eWxlID0gXCJfXCI7XG4gIGNvbnRleHQubC5zdHlsZSA9IFwiX1wiO1xuICBjb250ZXh0LmUuc3R5bGUgPSBcIl9cIjtcblxuICBmdW5jdGlvbiB3ZWVrT2ZZZWFyIChkYXRlLCBzdGFydE9mV2Vlaykge1xuICAgIHZhciBkaWZmLCBueWQsIHdlZWtTdGFydDtcbiAgICBueWQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDApKTtcbiAgICBkaWZmID0gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBueWQuZ2V0VGltZSgpKSAvIDg2NGU1KTtcbiAgICBpZiAobnlkLmdldFVUQ0RheSgpID09IHN0YXJ0T2ZXZWVrKSB7XG4gICAgICB3ZWVrU3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ZWVrU3RhcnQgPSA3IC0gbnlkLmdldFVUQ0RheSgpICsgc3RhcnRPZldlZWs7XG4gICAgICBpZiAod2Vla1N0YXJ0ID09IDgpIHtcbiAgICAgICAgd2Vla1N0YXJ0ID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmYgPj0gd2Vla1N0YXJ0ID8gTWF0aC5mbG9vcigoZGlmZiAtIHdlZWtTdGFydCkgLyA3KSArIDEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNvV2VlayAoZGF0ZSkge1xuICAgIHZhciBueWQsIG55eSwgd2VlaztcbiAgICBueXkgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgbnlkID0gbmV3IERhdGUoRGF0ZS5VVEMobnl5LCAwKSkuZ2V0VVRDRGF5KCk7XG4gICAgd2VlayA9IHdlZWtPZlllYXIoZGF0ZSwgMSkgKyAobnlkID4gMSAmJiBueWQgPD0gNCA/IDEgOiAwKTtcbiAgICBpZiAoIXdlZWspIHtcbiAgICAgIG55eSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAtIDE7XG4gICAgICBueWQgPSBuZXcgRGF0ZShEYXRlLlVUQyhueXksIDApKS5nZXRVVENEYXkoKTtcbiAgICAgIHdlZWsgPSBueWQgPT0gNCB8fCAobnlkID09IDMgJiYgbmV3IERhdGUobnl5LCAxLCAyOSkuZ2V0RGF0ZSgpID09IDI5KSA/IDUzIDogNTI7XG4gICAgICByZXR1cm4gW3dlZWssIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAtIDFdO1xuICAgIH0gZWxzZSBpZiAod2VlayA9PSA1MyAmJiAhKG55ZCA9PSA0IHx8IChueWQgPT0gMyAmJiBuZXcgRGF0ZShueXksIDEsIDI5KS5nZXREYXRlKCkgPT0gMjkpKSkge1xuICAgICAgcmV0dXJuIFsxLCBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt3ZWVrLCBkYXRlLmdldFVUQ0Z1bGxZZWFyKCldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LmNvbnZlcnQoYXJndW1lbnRzKSB9O1xufSk7XG4iXX0="}